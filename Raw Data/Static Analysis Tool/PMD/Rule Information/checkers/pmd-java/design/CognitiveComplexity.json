{
  "name": "CognitiveComplexity",
  "language": "java",
  "description": "\n            Methods that are highly complex are difficult to read and more costly to maintain. If you include too much decisional\n            logic within a single method, you make its behavior hard to understand and more difficult to modify.\n\n            Cognitive complexity is a measure of how difficult it is for humans to read and understand a method. Code that contains\n            a break in the control flow is more complex, whereas the use of language shorthands doesn't increase the level of\n            complexity. Nested control flows can make a method more difficult to understand, with each additional nesting of the\n            control flow leading to an increase in cognitive complexity.\n\n            Information about Cognitive complexity can be found in the original paper here:\n            <https://www.sonarsource.com/docs/CognitiveComplexity.pdf>\n\n            By default, this rule reports methods with a complexity of 15 or more. Reported methods should be broken down into less\n            complex components.\n        ",
  "example": "public class Foo {\n  // Has a cognitive complexity of 0\n  public void createAccount() {\n    Account account = new Account(\"PMD\");\n    // save account\n  }\n\n  // Has a cognitive complexity of 1\n  public Boolean setPhoneNumberIfNotExisting(Account a, String phone) {\n    if (a.phone == null) {                          // +1\n      a.phone = phone;\n      return true;\n    }\n\n    return false;\n  }\n\n  // Has a cognitive complexity of 4\n  public void updateContacts(List<Contact> contacts) {\n    List<Contact> contactsToUpdate = new ArrayList<Contact>();\n\n    for (Contact contact : contacts) {                           // +1\n      if (contact.department.equals(\"Finance\")) {                // +2 (nesting = 1)\n        contact.title = \"Finance Specialist\";\n        contactsToUpdate.add(contact);\n      } else if (contact.department.equals(\"Sales\")) {           // +1\n        contact.title = \"Sales Specialist\";\n        contactsToUpdate.add(contact);\n      }\n    }\n    // save contacts\n  }\n}",
  "cwe": null,
  "cwe-description": null,
  "checker-language": "java",
  "loc": 68,
  "branches": 8,
  "apis": 9,
  "test": [
    {
      "description": "SonarSource example 1",
      "expected-problems": 1,
      "expected-linenumbers": [],
      "code": "import java.util.List;\n\npublic class Foo {\n\n    private JavaSymbol overriddenSymbolFrom(JavaSymbol classType) {\n        if (classType.isUnknown()) { // +1\n            return null;\n        }\n        boolean unknownFound = false;\n        List<JavaSymbol> symbols = classType.members();\n        for (JavaSymbol overrideSymbol : symbols) { // +1\n            if (overrideSymbol.isMethod() // +2 (nesting = 1)\n                && !overrideSymbol.isStatic()) { // +1\n\n                if (canOverride(overrideSymbol)) { // +3 (nesting = 2)\n                    Boolean overriding = checkOverridingParameters(overrideSymbol, classType);\n                    if (overriding == null) { // +4 (nesting = 3)\n                        if (!unknownFound) { // +5 (nesting = 4)\n                            unknownFound = true;\n                        }\n                    } else if (overriding) { // +1\n                        return null;\n                    }\n                }\n            }\n        }\n        if (unknownFound) { // +1\n            return null;\n        }\n        return null;\n    } // total complexity = 19\n\n\n    boolean canOverride(JavaSymbol s) {}\n\n    Boolean checkOverridingParameters(JavaSymbol s, JavaSymbol s2) {}\n}\n\nclass JavaSymbol {\n\n    boolean isUnknown() {}\n\n    boolean isMethod() {}\n\n    boolean isStatic() {}\n\n    List<JavaSymbol> members() {}\n}\n\n            "
    },
    {
      "description": "SonarSource example 2",
      "expected-problems": 1,
      "expected-linenumbers": [],
      "code": "\npublic class Foo {\n\n    private void addVersion(final Entry entry, final Transaction txn, Entry frst) throws Exception {\n        final int ti = getTransactionIndex();\n        while (true) { // +1\n            try {\n                synchronized (this) {\n                    if (frst != null) { // +2 (nesting = 1)\n                        if (frst.hashCode() > entry.hashCode()) { // +3 (nesting = 2)\n                            throw new Exception();\n                        }\n                        if (txn.isActive()) { // +3 (nesting = 2)\n                            for // +4 (nesting = 3)\n                            (Entry e = frst; e != null; e = e.getPrevious()) {\n                                final long version = e.getVersion();\n                                final long depends = ti.wwDependency(version,\n                                                                     txn.getTransactionStatus(), 0);\n                                if (depends == 1) { // +5 (nesting = 4)\n                                    throw new Exception(\"\"+version);\n                                }\n                                if (depends != 0 // +5 (nesting = 4)\n                                    && depends != 5) { // +1\n                                    throw new Exception();\n                                }\n                            }\n                        }\n                    }\n                    entry.setPrevious(frst);\n                    frst = entry;\n                    break;\n                }\n            } catch (final Exception re) { // +2 (nesting = 1)\n                try {\n                    final long depends = getTransactionIndex()\n                                                   .wwDependency(re.getVersionHandle(), txn.getTransactionStatus(),\n                                                                 0);\n                    if (depends != 0 // +3 (nesting = 2)\n                        && depends != 5) { // +1\n                        throw new Exception();\n                    }\n                } catch (final InterruptedException ie) { // +3 (nesting = 2)\n                    throw new Exception(ie);\n                }\n            } catch (final InterruptedException ie) { // +2 (nesting = 1)\n                throw new Exception(ie);\n            }\n        }\n    } // total complexity = 35\n}\n\nclass Entry { }\ninterface Transaction {\nboolean isActive() ;\n}"
    },
    {
      "description": "SonarSource example 3",
      "expected-problems": 1,
      "expected-linenumbers": [],
      "code": "\n            \n            public class Foo {\n              private static String toRegexp(String antPattern,\n                  String directorySeparator) {\n                final String escapedDirectorySeparator = '\\\\' + directorySeparator;\n                final StringBuilder sb = new StringBuilder(antPattern.length());\n                sb.append('^');\n                int i = antPattern.startsWith(\"/\") || // +1\n                    antPattern.startsWith(\"\\\\\") ? 1 : 0; // +1\n                while (i < antPattern.length()) { // +1\n                  final char ch = antPattern.charAt(i);\n                  if (\"SPECIAL_CHARS\".indexOf(ch) != -1) { // +2 (nesting = 1)\n                    sb.append('\\\\').append(ch);\n                  } else if (ch == '*') { // +1\n                    if (i + 1 < antPattern.length() // +3 (nesting = 2)\n                        && antPattern.charAt(i + 1) == '*') { // +1\n                      if (i + 2 < antPattern.length() // +4 (nesting = 3)\n                          && isSlash(antPattern.charAt(i + 2))) { // +1\n                        sb.append(\"(?:.*\")\n                            .append(escapedDirectorySeparator).append(\"|)\");\n                        i += 2;\n                      } else { // +1\n                        sb.append(\".*\");\n                        i += 1;\n                      }\n                    } else { // +1\n                      sb.append(\"[^\").append(escapedDirectorySeparator).append(\"]*?\");\n                    }\n                  } else if (ch == '?') { // +1\n                    sb.append(\"[^\").append(escapedDirectorySeparator).append(\"]\");\n                  } else if (isSlash(ch)) { // +1\n                    sb.append(escapedDirectorySeparator);\n                  } else { // +1\n                    sb.append(ch);\n                  }\n                  i++;\n                }\n                sb.append('$');\n                return sb.toString();\n              } // total complexity = 20\n            }\n            \n        "
    },
    {
      "description": "Rule Doc Example",
      "expected-problems": 2,
      "expected-linenumbers": [
        9,
        19
      ],
      "code": "\n            \npublic class Foo {\n  // Has a cognitive complexity of 0\n  public void createAccount() {\n    Account account = new Account(\"PMD\");\n    // save account\n  }\n\n  // Has a cognitive complexity of 1\n  public Boolean setPhoneNumberIfNotExisting(Account a, String phone) {\n    if (a.phone == null) {                          // +1\n      a.phone = phone;\n      return true;\n    }\n\n    return false;\n  }\n\n  // Has a cognitive complexity of 4\n  public void updateContacts(List<Contact> contacts) {\n    List<Contact> contactsToUpdate = new ArrayList<Contact>();\n\n    for (Contact contact : contacts) {                           // +1\n      if (contact.department.equals(\"Finance\")) {                // +2 (nesting = 1)\n        contact.title = \"Finance Specialist\";\n        contactsToUpdate.add(contact);\n      } else if (contact.department.equals(\"Sales\")) {           // +1\n        contact.title = \"Sales Specialist\";\n        contactsToUpdate.add(contact);\n      }\n    }\n    // save contacts\n  }\n}            \n        "
    },
    {
      "description": "[java] CognitiveComplexity: Exception when using Map.of() #5084",
      "expected-problems": 0,
      "expected-linenumbers": [],
      "code": "\npackage net.sourceforge.pmd.lang.java.rule.design.cognitivecomplexity;\n\nimport java.util.Map;\n\npublic class ReproducerFor5084 {\n    private Map<Class, Serializer> serializers;\n\n    public ReproducerFor5084() {\n        this.serializers = Map.of(\n                HttpRequest.class, new HttpRequestSerializer(),\n                HttpResponse.class, new HttpResponseSerializer()\n        );\n    }\n\n    public abstract static class Body<T> { }\n\n    public abstract static class BodyWithContentType<T> extends Body<T> { }\n\n    public interface HttpMessage<T extends HttpMessage, B extends Body> { }\n\n    public static class HttpRequest implements HttpMessage<HttpRequest, Body> { }\n\n    public static class HttpResponse implements HttpMessage<HttpResponse, BodyWithContentType> { }\n\n    public interface Serializer<T> {\n        String serialize(T t);\n    }\n\n    public class HttpRequestSerializer implements Serializer<HttpRequest> {\n        @Override\n        public String serialize(HttpRequest s) {\n            return String.valueOf(s);\n        }\n    }\n\n    public class HttpResponseSerializer implements Serializer<HttpResponse> {\n        @Override\n        public String serialize(HttpResponse s) {\n            return String.valueOf(s);\n        }\n    }\n}\n"
    }
  ]
}