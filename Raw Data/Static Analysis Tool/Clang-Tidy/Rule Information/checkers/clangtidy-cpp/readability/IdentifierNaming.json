{
  "name": "IdentifierNaming",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-identifier-naming",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 1563,
  "branches": 276,
  "apis": 958,
  "test": [
    {
      "description": null,
      "expected-problems": 102,
      "expected-linenumbers": [
        98,
        101,
        105,
        115,
        119,
        146,
        152,
        159,
        163,
        166,
        169,
        172,
        178,
        181,
        184,
        189,
        193,
        210,
        213,
        216,
        221,
        226,
        231,
        235,
        238,
        255,
        267,
        274,
        277,
        302,
        306,
        345,
        349,
        363,
        381,
        407,
        417,
        420,
        424,
        427,
        432,
        436,
        439,
        443,
        444,
        445,
        448,
        451,
        454,
        457,
        461,
        469,
        472,
        473,
        483,
        484,
        485,
        488,
        493,
        498,
        501,
        506,
        510,
        515,
        519,
        523,
        528,
        532,
        538,
        543,
        554,
        559,
        563,
        575,
        579,
        583,
        587,
        591,
        595,
        599,
        603,
        608,
        612,
        628,
        633,
        637,
        646,
        650,
        654,
        659,
        662,
        666,
        670,
        695,
        730,
        736,
        743,
        748,
        755,
        769,
        773,
        790
      ],
      "code": "\n// Remove UNSUPPORTED for powerpc64le when the problem introduced by\n// r288563 is resolved.\n// UNSUPPORTED: target=powerpc64le{{.*}}\n// RUN: %check_clang_tidy -std=c++20 %s readability-identifier-naming %t -- \\\n// RUN:   -config='{CheckOptions: { \\\n// RUN:     readability-identifier-naming.AbstractClassCase: CamelCase, \\\n// RUN:     readability-identifier-naming.AbstractClassPrefix: 'A', \\\n// RUN:     readability-identifier-naming.ClassCase: CamelCase, \\\n// RUN:     readability-identifier-naming.ClassPrefix: 'C', \\\n// RUN:     readability-identifier-naming.ClassConstantCase: CamelCase, \\\n// RUN:     readability-identifier-naming.ClassConstantPrefix: 'k', \\\n// RUN:     readability-identifier-naming.ClassMemberCase: CamelCase, \\\n// RUN:     readability-identifier-naming.ClassMethodCase: camelBack, \\\n// RUN:     readability-identifier-naming.ConceptCase: CamelCase, \\\n// RUN:     readability-identifier-naming.ConstantCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.ConstantSuffix: '_CST', \\\n// RUN:     readability-identifier-naming.ConstexprFunctionCase: lower_case, \\\n// RUN:     readability-identifier-naming.ConstexprMethodCase: lower_case, \\\n// RUN:     readability-identifier-naming.ConstexprVariableCase: lower_case, \\\n// RUN:     readability-identifier-naming.EnumCase: CamelCase, \\\n// RUN:     readability-identifier-naming.EnumPrefix: 'E', \\\n// RUN:     readability-identifier-naming.ScopedEnumConstantCase: CamelCase, \\\n// RUN:     readability-identifier-naming.EnumConstantCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.FunctionCase: camelBack, \\\n// RUN:     readability-identifier-naming.GlobalConstantCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.GlobalFunctionCase: CamelCase, \\\n// RUN:     readability-identifier-naming.GlobalVariableCase: lower_case, \\\n// RUN:     readability-identifier-naming.GlobalVariablePrefix: 'g_', \\\n// RUN:     readability-identifier-naming.InlineNamespaceCase: lower_case, \\\n// RUN:     readability-identifier-naming.LocalConstantCase: CamelCase, \\\n// RUN:     readability-identifier-naming.LocalConstantPrefix: 'k', \\\n// RUN:     readability-identifier-naming.LocalVariableCase: lower_case, \\\n// RUN:     readability-identifier-naming.MemberCase: CamelCase, \\\n// RUN:     readability-identifier-naming.MemberPrefix: 'm_', \\\n// RUN:     readability-identifier-naming.ConstantMemberCase: lower_case, \\\n// RUN:     readability-identifier-naming.PrivateMemberPrefix: '__', \\\n// RUN:     readability-identifier-naming.ProtectedMemberPrefix: '_', \\\n// RUN:     readability-identifier-naming.PublicMemberCase: lower_case, \\\n// RUN:     readability-identifier-naming.MethodCase: camelBack, \\\n// RUN:     readability-identifier-naming.PrivateMethodPrefix: '__', \\\n// RUN:     readability-identifier-naming.ProtectedMethodPrefix: '_', \\\n// RUN:     readability-identifier-naming.NamespaceCase: lower_case, \\\n// RUN:     readability-identifier-naming.ParameterCase: camelBack, \\\n// RUN:     readability-identifier-naming.ParameterPrefix: 'a_', \\\n// RUN:     readability-identifier-naming.ConstantParameterCase: camelBack, \\\n// RUN:     readability-identifier-naming.ConstantParameterPrefix: 'i_', \\\n// RUN:     readability-identifier-naming.ParameterPackCase: camelBack, \\\n// RUN:     readability-identifier-naming.PureFunctionCase: lower_case, \\\n// RUN:     readability-identifier-naming.PureMethodCase: camelBack, \\\n// RUN:     readability-identifier-naming.StaticConstantCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.StaticVariableCase: camelBack, \\\n// RUN:     readability-identifier-naming.StaticVariablePrefix: 's_', \\\n// RUN:     readability-identifier-naming.StructCase: Leading_upper_snake_case, \\\n// RUN:     readability-identifier-naming.TemplateParameterCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.TemplateTemplateParameterCase: CamelCase, \\\n// RUN:     readability-identifier-naming.TemplateUsingCase: lower_case, \\\n// RUN:     readability-identifier-naming.TemplateUsingPrefix: 'u_', \\\n// RUN:     readability-identifier-naming.TypeTemplateParameterCase: camelBack, \\\n// RUN:     readability-identifier-naming.TypeTemplateParameterSuffix: '_t', \\\n// RUN:     readability-identifier-naming.TypedefCase: lower_case, \\\n// RUN:     readability-identifier-naming.TypedefSuffix: '_t', \\\n// RUN:     readability-identifier-naming.UnionCase: CamelCase, \\\n// RUN:     readability-identifier-naming.UnionPrefix: 'U', \\\n// RUN:     readability-identifier-naming.UsingCase: lower_case, \\\n// RUN:     readability-identifier-naming.ValueTemplateParameterCase: camelBack, \\\n// RUN:     readability-identifier-naming.VariableCase: lower_case, \\\n// RUN:     readability-identifier-naming.VirtualMethodCase: Camel_Snake_Case, \\\n// RUN:     readability-identifier-naming.VirtualMethodPrefix: 'v_', \\\n// RUN:     readability-identifier-naming.MacroDefinitionCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.TypeAliasCase: camel_Snake_Back, \\\n// RUN:     readability-identifier-naming.TypeAliasSuffix: '_t', \\\n// RUN:     readability-identifier-naming.IgnoreFailedSplit: false, \\\n// RUN:     readability-identifier-naming.GlobalPointerCase: CamelCase, \\\n// RUN:     readability-identifier-naming.GlobalPointerSuffix: '_Ptr', \\\n// RUN:     readability-identifier-naming.GlobalConstantPointerCase: UPPER_CASE, \\\n// RUN:     readability-identifier-naming.GlobalConstantPointerSuffix: '_Ptr', \\\n// RUN:     readability-identifier-naming.PointerParameterCase: lower_case, \\\n// RUN:     readability-identifier-naming.PointerParameterPrefix: 'p_', \\\n// RUN:     readability-identifier-naming.ConstantPointerParameterCase: CamelCase, \\\n// RUN:     readability-identifier-naming.ConstantPointerParameterPrefix: 'cp_', \\\n// RUN:     readability-identifier-naming.LocalPointerCase: CamelCase, \\\n// RUN:     readability-identifier-naming.LocalPointerPrefix: 'l_', \\\n// RUN:     readability-identifier-naming.LocalConstantPointerCase: CamelCase, \\\n// RUN:     readability-identifier-naming.LocalConstantPointerPrefix: 'lc_', \\\n// RUN:   }}' -- -fno-delayed-template-parsing -Dbad_macro \\\n// RUN:   -I%S/Inputs/identifier-naming \\\n// RUN:   -isystem %S/Inputs/identifier-naming/system\n\n// clang-format off\n\n#include <system-header.h>\n#include <coroutines.h>\n#include \"user-header.h\"\n// NO warnings or fixes expected from declarations within header files without\n// the -header-filter= option\n\nnamespace FOO_NS {\n// CHECK-MESSAGES: :[[@LINE-1]]:11: warning: invalid case style for namespace 'FOO_NS' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}namespace foo_ns {{{$}}\ninline namespace InlineNamespace {\n// CHECK-MESSAGES: :[[@LINE-1]]:18: warning: invalid case style for inline namespace 'InlineNamespace'\n// CHECK-FIXES: {{^}}inline namespace inline_namespace {{{$}}\n\nnamespace FOO_ALIAS = FOO_NS;\n// CHECK-MESSAGES: :[[@LINE-1]]:11: warning: invalid case style for namespace 'FOO_ALIAS' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}namespace foo_alias = FOO_NS;{{$}}\n\nSYSTEM_NS::structure g_s1;\n// NO warnings or fixes expected as SYSTEM_NS and structure are declared in a header file\n\nUSER_NS::object g_s2;\n// NO warnings or fixes expected as USER_NS and object are declared in a header file\n\nSYSTEM_MACRO(var1);\n// CHECK-MESSAGES: :[[@LINE-1]]:14: warning: invalid case style for global variable 'var1' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}SYSTEM_MACRO(g_var1);\n\nUSER_MACRO(var2);\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: invalid case style for global variable 'var2' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}USER_MACRO(g_var2);\n\n#define BLA int FOO_bar\nBLA;\n// NO warnings or fixes expected as FOO_bar is from macro expansion\n\nint global0;\n#define USE_NUMBERED_GLOBAL(number) auto use_global##number = global##number\nUSE_NUMBERED_GLOBAL(0);\n// NO warnings or fixes expected as global0 is pieced together in a macro\n// expansion.\n\nint global1;\n#define USE_NUMBERED_BAL(prefix, number) \\\n  auto use_##prefix##bal##number = prefix##bal##number\nUSE_NUMBERED_BAL(glo, 1);\n// NO warnings or fixes expected as global1 is pieced together in a macro\n// expansion.\n\nint global2;\n#define USE_RECONSTRUCTED(glo, bal) auto use_##glo##bal = glo##bal\nUSE_RECONSTRUCTED(glo, bal2);\n// NO warnings or fixes expected as global2 is pieced together in a macro\n// expansion.\n\nint global;\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for global variable 'global'\n// CHECK-FIXES: {{^}}int g_global;{{$}}\n#define USE_IN_MACRO(m) auto use_##m = m\nUSE_IN_MACRO(global);\n\nint global3;\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for global variable 'global3'\n// CHECK-FIXES: {{^}}int g_global3;{{$}}\n#define ADD_TO_SELF(m) (m) + (m)\nint g_twice_global3 = ADD_TO_SELF(global3);\n// CHECK-FIXES: {{^}}int g_twice_global3 = ADD_TO_SELF(g_global3);{{$}}\n\nint g_Global4;\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for global variable 'g_Global4'\n// CHECK-FIXES: {{^}}int g_global4;{{$}}\n\nenum my_enumeration {\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: invalid case style for enum 'my_enumeration'\n// CHECK-FIXES: {{^}}enum EMyEnumeration {{{$}}\n    MyConstant = 1,\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for enum constant 'MyConstant'\n// CHECK-FIXES: {{^}}    MY_CONSTANT = 1,{{$}}\n    your_CONST = 1,\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for enum constant 'your_CONST'\n// CHECK-FIXES: {{^}}    YOUR_CONST = 1,{{$}}\n    THIS_ConstValue = 1,\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for enum constant 'THIS_ConstValue'\n// CHECK-FIXES: {{^}}    THIS_CONST_VALUE = 1,{{$}}\n};\n\nenum class EMyEnumeration {\n    myConstant = 1,\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for scoped enum constant 'myConstant'\n// CHECK-FIXES: {{^}}    MyConstant = 1,{{$}}\n    your_CONST = 1,\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for scoped enum constant 'your_CONST'\n// CHECK-FIXES: {{^}}    YourConst = 1,{{$}}\n    THIS_ConstValue = 1,\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for scoped enum constant 'THIS_ConstValue'\n// CHECK-FIXES: {{^}}    ThisConstValue = 1,{{$}}\n};\n\nconstexpr int ConstExpr_variable = MyConstant;\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: invalid case style for constexpr variable 'ConstExpr_variable'\n// CHECK-FIXES: {{^}}constexpr int const_expr_variable = MY_CONSTANT;{{$}}\n\nclass my_class {\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for class 'my_class'\n// CHECK-FIXES: {{^}}class CMyClass {{{$}}\npublic:\n    my_class();\n// CHECK-FIXES: {{^}}    CMyClass();{{$}}\n\n    my_class(void*) : my_class() {}\n// CHECK-FIXES: {{^}}    CMyClass(void*) : CMyClass() {}{{$}}\n\n    ~\n      my_class();\n// (space in destructor token test, we could check trigraph but they will be deprecated)\n// CHECK-FIXES: {{^}}    ~{{$}}\n// CHECK-FIXES: {{^}}      CMyClass();{{$}}\n\nprivate:\n  const int MEMBER_one_1 = ConstExpr_variable;\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: invalid case style for constant member 'MEMBER_one_1'\n// CHECK-FIXES: {{^}}  const int member_one_1 = const_expr_variable;{{$}}\n  int member2 = 2;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for private member 'member2'\n// CHECK-FIXES: {{^}}  int __member2 = 2;{{$}}\n  int _memberWithExtraUnderscores_ = 42;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for private member '_memberWithExtraUnderscores_'\n// CHECK-FIXES: {{^}}  int __memberWithExtraUnderscores = 42;{{$}}\n\nprivate:\n    int private_member = 3;\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for private member 'private_member'\n// CHECK-FIXES: {{^}}    int __private_member = 3;{{$}}\n\nprotected:\n    int ProtMember;\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for protected member 'ProtMember'\n// CHECK-FIXES: {{^}}    int _ProtMember;{{$}}\n\npublic:\n    int PubMem;\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for public member 'PubMem'\n// CHECK-FIXES: {{^}}    int pub_mem;{{$}}\n\n    static const int classConstant;\n// CHECK-MESSAGES: :[[@LINE-1]]:22: warning: invalid case style for class constant 'classConstant'\n// CHECK-FIXES: {{^}}    static const int kClassConstant;{{$}}\n    static int ClassMember_2;\n// CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for class member 'ClassMember_2'\n// CHECK-FIXES: {{^}}    static int ClassMember2;{{$}}\n};\nclass my_class;\n// No warning needed here as this is tied to the previous declaration.\n// Just make sure the fix is applied.\n// CHECK-FIXES: {{^}}class CMyClass;{{$}}\n\nclass my_forward_declared_class; // No warning should be triggered.\n\nconst int my_class::classConstant = 4;\n// CHECK-FIXES: {{^}}const int CMyClass::kClassConstant = 4;{{$}}\n\nint my_class::ClassMember_2 = 5;\n// CHECK-FIXES: {{^}}int CMyClass::ClassMember2 = 5;{{$}}\n\nclass my_derived_class : public virtual my_class {};\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for class 'my_derived_class'\n// CHECK-FIXES: {{^}}class CMyDerivedClass : public virtual CMyClass {};{{$}}\n\nclass CMyWellNamedClass {};\n// No warning expected as this class is well named.\n\ntemplate<typename t_t>\nconcept MyConcept = requires (t_t a_t) { {a_t++}; };\n// No warning expected as this concept is well named.\n\ntemplate<typename t_t>\nconcept my_concept_2 = requires (t_t a_t) { {a_t++}; };\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for concept 'my_concept_2'\n// CHECK-FIXES: {{^}}concept MyConcept2 = requires (t_t a_t) { {a_t++}; };{{$}}\n\ntemplate <typename t_t>\nclass CMyWellNamedClass2 : public my_class {\n  // CHECK-FIXES: {{^}}class CMyWellNamedClass2 : public CMyClass {{{$}}\n  t_t my_Bad_Member;\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for private member 'my_Bad_Member'\n  // CHECK-FIXES: {{^}}  t_t __my_Bad_Member;{{$}}\n  int my_Other_Bad_Member = 42;\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for private member 'my_Other_Bad_Member'\n  // CHECK-FIXES: {{^}}  int __my_Other_Bad_Member = 42;{{$}}\npublic:\n  CMyWellNamedClass2() = default;\n  CMyWellNamedClass2(CMyWellNamedClass2 const&) = default;\n  CMyWellNamedClass2(CMyWellNamedClass2 &&) = default;\n  CMyWellNamedClass2(t_t a_v, void *p_p) : my_class(p_p), my_Bad_Member(a_v) {}\n  // CHECK-FIXES: {{^}}  CMyWellNamedClass2(t_t a_v, void *p_p) : CMyClass(p_p), __my_Bad_Member(a_v) {}{{$}}\n\n  CMyWellNamedClass2(t_t a_v) : my_class(), my_Bad_Member(a_v), my_Other_Bad_Member(11) {}\n  // CHECK-FIXES: {{^}}  CMyWellNamedClass2(t_t a_v) : CMyClass(), __my_Bad_Member(a_v), __my_Other_Bad_Member(11) {}{{$}}\n};\nvoid InstantiateClassMethods() {\n  // Ensure we trigger the instantiation of each constructor\n  CMyWellNamedClass2<int> x;\n  CMyWellNamedClass2<int> x2 = x;\n  CMyWellNamedClass2<int> x3 = static_cast<CMyWellNamedClass2<int>&&>(x2);\n  CMyWellNamedClass2<int> x4(42);\n  CMyWellNamedClass2<int> x5(42, nullptr);\n}\n\nclass AOverridden {\npublic:\n  virtual ~AOverridden() = default;\n  virtual void BadBaseMethod() = 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for virtual method 'BadBaseMethod'\n  // CHECK-FIXES: {{^}}  virtual void v_Bad_Base_Method() = 0;\n\n  virtual void BadBaseMethodNoAttr() = 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for virtual method 'BadBaseMethodNoAttr'\n  // CHECK-FIXES: {{^}}  virtual void v_Bad_Base_Method_No_Attr() = 0;\n};\n\nclass COverriding : public AOverridden {\npublic:\n  // Overriding a badly-named base isn't a new violation.\n  void BadBaseMethod() override {}\n  // CHECK-FIXES: {{^}}  void v_Bad_Base_Method() override {}\n\n  void BadBaseMethodNoAttr() /* override */ {}\n  // CHECK-FIXES: {{^}}  void v_Bad_Base_Method_No_Attr() /* override */ {}\n\n  void foo() {\n    BadBaseMethod();\n    // CHECK-FIXES: {{^}}    v_Bad_Base_Method();\n    this->BadBaseMethod();\n    // CHECK-FIXES: {{^}}    this->v_Bad_Base_Method();\n    AOverridden::BadBaseMethod();\n    // CHECK-FIXES: {{^}}    AOverridden::v_Bad_Base_Method();\n    COverriding::BadBaseMethod();\n    // CHECK-FIXES: {{^}}    COverriding::v_Bad_Base_Method();\n\n    BadBaseMethodNoAttr();\n    // CHECK-FIXES: {{^}}    v_Bad_Base_Method_No_Attr();\n    this->BadBaseMethodNoAttr();\n    // CHECK-FIXES: {{^}}    this->v_Bad_Base_Method_No_Attr();\n    AOverridden::BadBaseMethodNoAttr();\n    // CHECK-FIXES: {{^}}    AOverridden::v_Bad_Base_Method_No_Attr();\n    COverriding::BadBaseMethodNoAttr();\n    // CHECK-FIXES: {{^}}    COverriding::v_Bad_Base_Method_No_Attr();\n  }\n};\n\n// Same test as above, now with a dependent base class.\ntemplate<typename some_t>\nclass ATOverridden {\npublic:\n  virtual void BadBaseMethod() = 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for virtual method 'BadBaseMethod'\n  // CHECK-FIXES: {{^}}  virtual void v_Bad_Base_Method() = 0;\n\n  virtual void BadBaseMethodNoAttr() = 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for virtual method 'BadBaseMethodNoAttr'\n  // CHECK-FIXES: {{^}}  virtual void v_Bad_Base_Method_No_Attr() = 0;\n};\n\ntemplate<typename some_t>\nclass CTOverriding : public ATOverridden<some_t> {\n  // Overriding a badly-named base isn't a new violation.\n  // FIXME: The fixes from the base class should be propagated to the derived class here\n  //        (note that there could be specializations of the template base class, though)\n  void BadBaseMethod() override {}\n\n  // Without the \"override\" attribute, and due to the dependent base class, it is not\n  // known whether this method overrides anything, so we get the warning here.\n  virtual void BadBaseMethodNoAttr() {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for virtual method 'BadBaseMethodNoAttr'\n  // CHECK-FIXES: {{^}}  virtual void v_Bad_Base_Method_No_Attr() {};\n};\n\ntemplate<typename some_t>\nvoid VirtualCall(AOverridden &a_vItem, ATOverridden<some_t> &a_vTitem) {\n  a_vItem.BadBaseMethod();\n  // CHECK-FIXES: {{^}}  a_vItem.v_Bad_Base_Method();\n\n  // FIXME: The fixes from ATOverridden should be propagated to the following call\n  a_vTitem.BadBaseMethod();\n}\n\n// Same test as above, now with a dependent base class that is instantiated below.\ntemplate<typename some_t>\nclass ATIOverridden {\npublic:\n  virtual void BadBaseMethod() = 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for virtual method 'BadBaseMethod'\n  // CHECK-FIXES: {{^}}  virtual void v_Bad_Base_Method() = 0;\n};\n\ntemplate<typename some_t>\nclass CTIOverriding : public ATIOverridden<some_t> {\npublic:\n  // Overriding a badly-named base isn't a new violation.\n  void BadBaseMethod() override {}\n  // CHECK-FIXES: {{^}}  void v_Bad_Base_Method() override {}\n};\n\ntemplate class CTIOverriding<int>;\n\nvoid VirtualCallI(ATIOverridden<int>& a_vItem, CTIOverriding<int>& a_vCitem) {\n  a_vItem.BadBaseMethod();\n  // CHECK-FIXES: {{^}}  a_vItem.v_Bad_Base_Method();\n\n  a_vCitem.BadBaseMethod();\n  // CHECK-FIXES: {{^}}  a_vCitem.v_Bad_Base_Method();\n}\n\ntemplate <typename derived_t>\nclass CRTPBase {\npublic:\n  void BadBaseMethod(int) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: invalid case style for method 'BadBaseMethod'\n};\n\nclass CRTPDerived : CRTPBase<CRTPDerived> {\npublic:\n  // Hiding a badly-named base isn't a new violation.\n  double BadBaseMethod(double) { return 0; }\n};\n\ntemplate<typename T>\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: invalid case style for type template parameter 'T'\n// CHECK-FIXES: {{^}}template<typename t_t>{{$}}\nclass my_templated_class : CMyWellNamedClass {};\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for class 'my_templated_class'\n// CHECK-FIXES: {{^}}class CMyTemplatedClass : CMyWellNamedClass {};{{$}}\n\ntemplate<typename T>\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: invalid case style for type template parameter 'T'\n// CHECK-FIXES: {{^}}template<typename t_t>{{$}}\nclass my_other_templated_class : my_templated_class<  my_class>, private my_derived_class {};\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for class 'my_other_templated_class'\n// CHECK-FIXES: {{^}}class CMyOtherTemplatedClass : CMyTemplatedClass<  CMyClass>, private CMyDerivedClass {};{{$}}\n\ntemplate<typename t_t>\nusing mysuper_tpl_t = my_other_templated_class  <:: FOO_NS  ::my_class>;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for type alias 'mysuper_tpl_t'\n// CHECK-FIXES: {{^}}using mysuper_Tpl_t = CMyOtherTemplatedClass  <:: foo_ns  ::CMyClass>;{{$}}\n\nconst int global_Constant = 6;\n// CHECK-MESSAGES: :[[@LINE-1]]:11: warning: invalid case style for global constant 'global_Constant'\n// CHECK-FIXES: {{^}}const int GLOBAL_CONSTANT = 6;{{$}}\nint Global_variable = 7;\n// CHECK-MESSAGES: :[[@LINE-1]]:5: warning: invalid case style for global variable 'Global_variable'\n// CHECK-FIXES: {{^}}int g_global_variable = 7;{{$}}\n\nvoid global_function(int PARAMETER_1, int const CONST_parameter) {\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: invalid case style for global function 'global_function'\n// CHECK-MESSAGES: :[[@LINE-2]]:26: warning: invalid case style for parameter 'PARAMETER_1'\n// CHECK-MESSAGES: :[[@LINE-3]]:49: warning: invalid case style for constant parameter 'CONST_parameter'\n// CHECK-FIXES: {{^}}void GlobalFunction(int a_parameter1, int const i_constParameter) {{{$}}\n    static const int THIS_static_ConsTant = 4;\n// CHECK-MESSAGES: :[[@LINE-1]]:22: warning: invalid case style for static constant 'THIS_static_ConsTant'\n// CHECK-FIXES: {{^}}    static const int THIS_STATIC_CONS_TANT = 4;{{$}}\n    static int THIS_static_variable;\n// CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for static variable 'THIS_static_variable'\n// CHECK-FIXES: {{^}}    static int s_thisStaticVariable;{{$}}\n    int const local_Constant = 3;\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: invalid case style for local constant 'local_Constant'\n// CHECK-FIXES: {{^}}    int const kLocalConstant = 3;{{$}}\n    int LOCAL_VARIABLE;\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for local variable 'LOCAL_VARIABLE'\n// CHECK-FIXES: {{^}}    int local_variable;{{$}}\n\n    int LOCAL_Array__[] = {0, 1, 2};\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for local variable 'LOCAL_Array__'\n// CHECK-FIXES: {{^}}    int local_array[] = {0, 1, 2};{{$}}\n\n    for (auto _ : LOCAL_Array__) {\n    }\n}\n\ntemplate<typename ... TYPE_parameters>\n// CHECK-MESSAGES: :[[@LINE-1]]:23: warning: invalid case style for type template parameter 'TYPE_parameters'\n// CHECK-FIXES: {{^}}template<typename ... typeParameters_t>{{$}}\nvoid Global_Fun(TYPE_parameters... PARAMETER_PACK) {\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: invalid case style for global function 'Global_Fun'\n// CHECK-MESSAGES: :[[@LINE-2]]:36: warning: invalid case style for parameter pack 'PARAMETER_PACK'\n// CHECK-FIXES: {{^}}void GlobalFun(typeParameters_t... parameterPack) {{{$}}\n    global_function(1, 2);\n// CHECK-FIXES: {{^}}    GlobalFunction(1, 2);{{$}}\n    FOO_bar = Global_variable;\n// CHECK-FIXES: {{^}}    FOO_bar = g_global_variable;{{$}}\n// NO fix expected for FOO_bar declared in macro expansion\n}\n\ntemplate<template<typename> class TPL_parameter, int COUNT_params, typename ... TYPE_parameters>\n// CHECK-MESSAGES: :[[@LINE-1]]:35: warning: invalid case style for template template parameter 'TPL_parameter'\n// CHECK-MESSAGES: :[[@LINE-2]]:54: warning: invalid case style for value template parameter 'COUNT_params'\n// CHECK-MESSAGES: :[[@LINE-3]]:81: warning: invalid case style for type template parameter 'TYPE_parameters'\n// CHECK-FIXES: {{^}}template<template<typename> class TplParameter, int countParams, typename ... typeParameters_t>{{$}}\nclass test_CLASS {\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for class 'test_CLASS'\n// CHECK-FIXES: {{^}}class CTestClass {{{$}}\n};\n\nclass abstract_class {\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for abstract class 'abstract_class'\n// CHECK-FIXES: {{^}}class AAbstractClass {{{$}}\n    virtual ~abstract_class() = 0;\n// CHECK-FIXES: {{^}}    virtual ~AAbstractClass() = 0;{{$}}\n    virtual void VIRTUAL_METHOD();\n// CHECK-MESSAGES: :[[@LINE-1]]:18: warning: invalid case style for virtual method 'VIRTUAL_METHOD'\n// CHECK-FIXES: {{^}}    virtual void v_Virtual_Method();{{$}}\n    void non_Virtual_METHOD() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:10: warning: invalid case style for private method 'non_Virtual_METHOD'\n// CHECK-FIXES: {{^}}    void __non_Virtual_METHOD() {}{{$}}\n\npublic:\n    static void CLASS_METHOD() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:17: warning: invalid case style for class method 'CLASS_METHOD'\n// CHECK-FIXES: {{^}}    static void classMethod() {}{{$}}\n\n    constexpr int CST_expr_Method() { return 2; }\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: invalid case style for constexpr method 'CST_expr_Method'\n// CHECK-FIXES: {{^}}    constexpr int cst_expr_method() { return 2; }{{$}}\n\nprivate:\n    void PRIVate_Method();\n// CHECK-MESSAGES: :[[@LINE-1]]:10: warning: invalid case style for private method 'PRIVate_Method'\n// CHECK-FIXES: {{^}}    void __PRIVate_Method();{{$}}\nprotected:\n    void protected_Method();\n// CHECK-MESSAGES: :[[@LINE-1]]:10: warning: invalid case style for protected method 'protected_Method'\n// CHECK-FIXES: {{^}}    void _protected_Method();{{$}}\npublic:\n    void public_Method();\n// CHECK-MESSAGES: :[[@LINE-1]]:10: warning: invalid case style for method 'public_Method'\n// CHECK-FIXES: {{^}}    void publicMethod();{{$}}\n};\n\nconstexpr int CE_function() { return 3; }\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: invalid case style for constexpr function 'CE_function'\n// CHECK-FIXES: {{^}}constexpr int ce_function() { return 3; }{{$}}\n\nstruct THIS___Structure {\n// CHECK-MESSAGES: :[[@LINE-1]]:8: warning: invalid case style for struct 'THIS___Structure'\n// CHECK-FIXES: {{^}}struct This_structure {{{$}}\n    THIS___Structure();\n// CHECK-FIXES: {{^}}    This_structure();{{$}}\n\n  union __MyUnion_is_wonderful__ {};\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for union '__MyUnion_is_wonderful__'\n// CHECK-FIXES: {{^}}  union UMyUnionIsWonderful {};{{$}}\n};\n\ntypedef THIS___Structure struct_type;\n// CHECK-MESSAGES: :[[@LINE-1]]:26: warning: invalid case style for typedef 'struct_type'\n// CHECK-FIXES: {{^}}typedef This_structure struct_type_t;{{$}}\n\nstruct_type GlobalTypedefTestFunction(struct_type a_argument1) {\n// CHECK-FIXES: {{^}}struct_type_t GlobalTypedefTestFunction(struct_type_t a_argument1) {\n    struct_type typedef_test_1;\n// CHECK-FIXES: {{^}}    struct_type_t typedef_test_1;\n  return {};\n}\n\nusing my_struct_type = THIS___Structure;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for type alias 'my_struct_type'\n// CHECK-FIXES: {{^}}using my_Struct_Type_t = This_structure;{{$}}\n\ntemplate<typename t_t>\nusing SomeOtherTemplate = my_other_templated_class  <:: FOO_NS  ::my_class>;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for type alias 'SomeOtherTemplate'\n// CHECK-FIXES: {{^}}using some_Other_Template_t = CMyOtherTemplatedClass  <:: foo_ns  ::CMyClass>;{{$}}\n\nstatic void static_Function() {\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: invalid case style for function 'static_Function'\n// CHECK-FIXES: {{^}}static void staticFunction() {{{$}}\n\n  ::FOO_NS::InlineNamespace::abstract_class::CLASS_METHOD();\n// CHECK-FIXES: {{^}}  ::foo_ns::inline_namespace::AAbstractClass::classMethod();{{$}}\n  ::FOO_NS::InlineNamespace::static_Function();\n// CHECK-FIXES: {{^}}  ::foo_ns::inline_namespace::staticFunction();{{$}}\n\n  using ::FOO_NS::InlineNamespace::CE_function;\n// CHECK-FIXES: {{^}}  using ::foo_ns::inline_namespace::ce_function;{{$}}\n\n  unsigned MY_LOCAL_array[] = {1,2,3};\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: invalid case style for local variable 'MY_LOCAL_array'\n// CHECK-FIXES: {{^}}  unsigned my_local_array[] = {1,2,3};{{$}}\n\n  unsigned const MyConstLocal_array[] = {1,2,3};\n// CHECK-MESSAGES: :[[@LINE-1]]:18: warning: invalid case style for local constant 'MyConstLocal_array'\n// CHECK-FIXES: {{^}}  unsigned const kMyConstLocalArray[] = {1,2,3};{{$}}\n\n  static unsigned MY_STATIC_array[] = {1,2,3};\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: invalid case style for static variable 'MY_STATIC_array'\n// CHECK-FIXES: {{^}}  static unsigned s_myStaticArray[] = {1,2,3};{{$}}\n\n  static unsigned const MyConstStatic_array[] = {1,2,3};\n// CHECK-MESSAGES: :[[@LINE-1]]:25: warning: invalid case style for static constant 'MyConstStatic_array'\n// CHECK-FIXES: {{^}}  static unsigned const MY_CONST_STATIC_ARRAY[] = {1,2,3};{{$}}\n\n  char MY_LOCAL_string[] = \"123\";\n// CHECK-MESSAGES: :[[@LINE-1]]:8: warning: invalid case style for local variable 'MY_LOCAL_string'\n// CHECK-FIXES: {{^}}  char my_local_string[] = \"123\";{{$}}\n\n  char const MyConstLocal_string[] = \"123\";\n// CHECK-MESSAGES: :[[@LINE-1]]:14: warning: invalid case style for local constant 'MyConstLocal_string'\n// CHECK-FIXES: {{^}}  char const kMyConstLocalString[] = \"123\";{{$}}\n\n  static char MY_STATIC_string[] = \"123\";\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: invalid case style for static variable 'MY_STATIC_string'\n// CHECK-FIXES: {{^}}  static char s_myStaticString[] = \"123\";{{$}}\n\n  static char const MyConstStatic_string[] = \"123\";\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: invalid case style for static constant 'MyConstStatic_string'\n// CHECK-FIXES: {{^}}  static char const MY_CONST_STATIC_STRING[] = \"123\";{{$}}\n}\n\n#define MY_TEST_Macro(X) X()\n// CHECK-MESSAGES: :[[@LINE-1]]:9: warning: invalid case style for macro definition 'MY_TEST_Macro'\n// CHECK-FIXES: {{^}}#define MY_TEST_MACRO(X) X()\n\nvoid MY_TEST_Macro(function) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:20: warning: invalid case style for global function 'function' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}void MY_TEST_MACRO(Function) {}\n\n#define MY_CAT_IMPL(l, r) l ## r\n#define MY_CAT(l, r) MY_CAT_IMPL(l, r)\n#define MY_MACRO2(foo) int MY_CAT(awesome_, MY_CAT(foo, __COUNTER__)) = 0\n#define MY_MACRO3(foo) int MY_CAT(awesome_, foo) = 0\nMY_MACRO2(myglob);\nMY_MACRO3(myglob);\n// No suggestions should occur even though the resulting decl of awesome_myglob#\n// or awesome_myglob are not entirely within a macro argument.\n\n} // namespace InlineNamespace\n} // namespace FOO_NS\n\ntemplate <typename t_t> struct a {\n// CHECK-MESSAGES: :[[@LINE-1]]:32: warning: invalid case style for struct 'a'\n// CHECK-FIXES: {{^}}template <typename t_t> struct A {{{$}}\n  typename t_t::template b<> c;\n\n  char const MY_ConstMember_string[4] = \"123\";\n// CHECK-MESSAGES: :[[@LINE-1]]:14: warning: invalid case style for constant member 'MY_ConstMember_string'\n// CHECK-FIXES: {{^}}  char const my_const_member_string[4] = \"123\";{{$}}\n\n  static char const MyConstClass_string[];\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: invalid case style for class constant 'MyConstClass_string'\n// CHECK-FIXES: {{^}}  static char const kMyConstClassString[];{{$}}\n};\n\ntemplate<typename t_t>\nchar const a<t_t>::MyConstClass_string[] = \"123\";\n// CHECK-FIXES: {{^}}char const A<t_t>::kMyConstClassString[] = \"123\";{{$}}\n\ntemplate <template <typename> class A> struct b { A<int> c; };\n// CHECK-MESSAGES: :[[@LINE-1]]:47: warning: invalid case style for struct 'b'\n// CHECK-FIXES:template <template <typename> class A> struct B { A<int> c; };{{$}}\n\nunsigned MY_GLOBAL_array[] = {1,2,3};\n// CHECK-MESSAGES: :[[@LINE-1]]:10: warning: invalid case style for global variable 'MY_GLOBAL_array'\n// CHECK-FIXES: {{^}}unsigned g_my_global_array[] = {1,2,3};{{$}}\n\nunsigned const MyConstGlobal_array[] = {1,2,3};\n// CHECK-MESSAGES: :[[@LINE-1]]:16: warning: invalid case style for global constant 'MyConstGlobal_array'\n// CHECK-FIXES: {{^}}unsigned const MY_CONST_GLOBAL_ARRAY[] = {1,2,3};{{$}}\n\nint * MyGlobal_Ptr;// -> ok\nint * my_second_global_Ptr;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for global pointer 'my_second_global_Ptr'\n// CHECK-FIXES: {{^}}int * MySecondGlobal_Ptr;{{$}}\nint * const MyConstantGlobalPointer = nullptr;\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: invalid case style for global constant pointer 'MyConstantGlobalPointer'\n// CHECK-FIXES: {{^}}int * const MY_CONSTANT_GLOBAL_POINTER_Ptr = nullptr;{{$}}\n\nvoid MyPoiterFunction(int * p_normal_pointer, int * const constant_ptr){\n// CHECK-MESSAGES: :[[@LINE-1]]:59: warning: invalid case style for constant pointer parameter 'constant_ptr'\n// CHECK-FIXES: {{^}}void MyPoiterFunction(int * p_normal_pointer, int * const cp_ConstantPtr){{{$}}\n    int * l_PointerA;\n    int * const pointer_b = nullptr;\n// CHECK-MESSAGES: :[[@LINE-1]]:17: warning: invalid case style for local constant pointer 'pointer_b'\n// CHECK-FIXES: {{^}}    int * const lc_PointerB = nullptr;{{$}}\n}\n\nusing namespace FOO_NS;\n// CHECK-FIXES: {{^}}using namespace foo_ns;\n\nusing namespace FOO_NS::InlineNamespace;\n// CHECK-FIXES: {{^}}using namespace foo_ns::inline_namespace;\n\nvoid QualifiedTypeLocTest(THIS___Structure);\n// CHECK-FIXES: {{^}}void QualifiedTypeLocTest(This_structure);{{$}}\nvoid QualifiedTypeLocTest(THIS___Structure &);\n// CHECK-FIXES: {{^}}void QualifiedTypeLocTest(This_structure &);{{$}}\nvoid QualifiedTypeLocTest(THIS___Structure &&);\n// CHECK-FIXES: {{^}}void QualifiedTypeLocTest(This_structure &&);{{$}}\nvoid QualifiedTypeLocTest(const THIS___Structure);\n// CHECK-FIXES: {{^}}void QualifiedTypeLocTest(const This_structure);{{$}}\nvoid QualifiedTypeLocTest(const THIS___Structure &);\n// CHECK-FIXES: {{^}}void QualifiedTypeLocTest(const This_structure &);{{$}}\nvoid QualifiedTypeLocTest(volatile THIS___Structure &);\n// CHECK-FIXES: {{^}}void QualifiedTypeLocTest(volatile This_structure &);{{$}}\n\nnamespace redecls {\n// We only want the warning to show up once here for the first decl.\n// CHECK-MESSAGES: :[[@LINE+1]]:6: warning: invalid case style for global function 'badNamedFunction'\nvoid badNamedFunction();\nvoid badNamedFunction();\nvoid badNamedFunction(){}\n//      CHECK-FIXES: {{^}}void BadNamedFunction();\n// CHECK-FIXES-NEXT: {{^}}void BadNamedFunction();\n// CHECK-FIXES-NEXT: {{^}}void BadNamedFunction(){}\nvoid ReferenceBadNamedFunction() {\n  auto l_Ptr = badNamedFunction;\n  // CHECK-FIXES: {{^}}  auto l_Ptr = BadNamedFunction;\n  l_Ptr();\n  badNamedFunction();\n  // CHECK-FIXES: {{^}}  BadNamedFunction();\n}\n\n} // namespace redecls\n\nnamespace scratchspace {\n#define DUP(Tok) Tok\n#define M1(Tok) DUP(badName##Tok())\n\n// We don't want a warning here as the call to this in Foo is in a scratch\n// buffer so its fix-it wouldn't be applied, resulting in invalid code.\nvoid badNameWarn();\n\nvoid Foo() {\n  M1(Warn);\n}\n\n#undef M1\n#undef DUP\n} // namespace scratchspace\n\ntemplate<typename type_t>\nauto GetRes(type_t& Param) -> decltype(Param.res());\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: invalid case style for parameter 'Param'\n// CHECK-FIXES: auto GetRes(type_t& a_param) -> decltype(a_param.res());\n\n// Check implicit declarations in coroutines\n\nstruct async_obj {\n// CHECK-MESSAGES: :[[@LINE-1]]:8: warning: invalid case style for struct 'async_obj'\n// CHECK-FIXES: {{^}}struct Async_obj {{{$}}\npublic:\n  never_suspend operator co_await() const noexcept;\n};\n\ntask ImplicitDeclTest(async_obj &a_object) {\n  co_await a_object;  // CHECK-MESSAGES-NOT: warning: invalid case style for local variable\n}\n\n// Test scenario when canonical declaration will be a forward declaration\nstruct ForwardDeclStruct;\n// CHECK-MESSAGES: :[[@LINE-1]]:8: warning: invalid case style for struct 'ForwardDeclStruct' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}struct Forward_decl_struct;\n// CHECK-FIXES: {{^}}struct Forward_decl_struct {\nstruct ForwardDeclStruct {\n};\n\nstruct forward_declared_as_struct;\n// CHECK-MESSAGES: :[[@LINE-1]]:8: warning: invalid case style for class 'forward_declared_as_struct' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}struct CForwardDeclaredAsStruct;\n// CHECK-FIXES: {{^}}class CForwardDeclaredAsStruct {\nclass forward_declared_as_struct {\n};\n\nnamespace pr55156 {\n\ntemplate<typename> struct Wrap;\n\ntypedef enum {\n  VALUE0,\n  VALUE1,\n} ValueType;\n// CHECK-MESSAGES: :[[@LINE-1]]:3: warning: invalid case style for typedef 'ValueType' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}} value_type_t;\n\ntypedef ValueType (*MyFunPtr)(const ValueType&, Wrap<ValueType>*);\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: invalid case style for typedef 'MyFunPtr' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}typedef value_type_t (*my_fun_ptr_t)(const value_type_t&, Wrap<value_type_t>*);\n\n#define STATIC_MACRO static\nSTATIC_MACRO void someFunc(ValueType a_v1, const ValueType& a_v2) {}\n// CHECK-FIXES: {{^}}STATIC_MACRO void someFunc(value_type_t a_v1, const value_type_t& a_v2) {}\nSTATIC_MACRO void someFunc(const ValueType** p_a_v1, ValueType (*p_a_v2)()) {}\n// CHECK-FIXES: {{^}}STATIC_MACRO void someFunc(const value_type_t** p_a_v1, value_type_t (*p_a_v2)()) {}\nSTATIC_MACRO ValueType someFunc() { return {}; }\n// CHECK-FIXES: {{^}}STATIC_MACRO value_type_t someFunc() { return {}; }\nSTATIC_MACRO void someFunc(MyFunPtr, const MyFunPtr****) {}\n// CHECK-FIXES: {{^}}STATIC_MACRO void someFunc(my_fun_ptr_t, const my_fun_ptr_t****) {}\n#undef STATIC_MACRO\n}\n\nstruct Some_struct {\n  int SomeMember;\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: invalid case style for public member 'SomeMember' [readability-identifier-naming]\n// CHECK-FIXES: {{^}}  int some_member;\n};\nSome_struct g_s1{ .SomeMember = 1 };\n// CHECK-FIXES: {{^}}Some_struct g_s1{ .some_member = 1 };\nSome_struct g_s2{.SomeMember=1};\n// CHECK-FIXES: {{^}}Some_struct g_s2{.some_member=1};"
    }
  ]
}