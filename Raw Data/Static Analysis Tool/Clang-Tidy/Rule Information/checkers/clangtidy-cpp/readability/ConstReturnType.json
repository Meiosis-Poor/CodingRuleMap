{
  "name": "ConstReturnType",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-const-return-type",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 146,
  "branches": 18,
  "apis": 71,
  "test": [
    {
      "description": null,
      "expected-problems": 39,
      "expected-linenumbers": [
        16,
        26,
        32,
        52,
        61,
        70,
        79,
        89,
        93,
        101,
        107,
        111,
        118,
        125,
        131,
        135,
        139,
        143,
        147,
        151,
        155,
        159,
        163,
        167,
        171,
        179,
        187,
        191,
        231,
        235,
        239,
        245,
        247,
        255,
        259,
        284,
        321,
        350,
        351
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes -std=c++14-or-later %s readability-const-return-type %t -- -- -Wno-error=return-type\n\n//  p# = positive test\n//  n# = negative test\n\nnamespace std {\ntemplate< class T >\nstruct add_cv { typedef const volatile T type; };\n\ntemplate< class T> struct add_const { typedef const T type; };\n\ntemplate< class T> struct add_volatile { typedef volatile T type; };\n}\n\nconst int p1() {\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int' is 'const'-qualified at the top level, which may reduce code readability without improving const correctness\n// CHECK-FIXES: int p1() {\n  return 1;\n}\n\nconst int p15();\n// CHECK-FIXES: int p15();\n\ntemplate <typename T>\nconst int p31(T v) { return 2; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int' is 'const'-qu\n// CHECK-FIXES: int p31(T v) { return 2; }\n\n// We detect const-ness even without instantiating T.\ntemplate <typename T>\nconst T p32(T t) { return t; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const T' is 'const'-qual\n// CHECK-FIXES: T p32(T t) { return t; }\n\n// However, if the return type is itself a template instantiation, Clang does\n// not consider it const-qualified without knowing `T`.\ntemplate <typename T>\ntypename std::add_const<T>::type n15(T v) { return v; }\n\ntemplate <bool B>\nstruct MyStruct {};\n\ntemplate <typename A>\nclass Klazz {\npublic:\n  Klazz(A) {}\n};\n\nclass Clazz {\n public:\n  Clazz *const p2() {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'Clazz *const' is 'co\n    // CHECK-FIXES: Clazz *p2() {\n    return this;\n  }\n\n  Clazz *const p3();\n  // CHECK-FIXES: Clazz *p3();\n\n  const int p4() const {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const int' is 'const\n    // CHECK-FIXES: int p4() const {\n    return 4;\n  }\n\n  const Klazz<const int>* const p5() const;\n  // CHECK-FIXES: const Klazz<const int>* p5() const;\n\n  const Clazz operator++(int x) {  //  p12\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const Clazz' is 'const\n  // CHECK-FIXES: Clazz operator++(int x) {\n  }\n\n  struct Strukt {\n    int i;\n  };\n\n  const Strukt p6() {}\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const Strukt' i\n  // CHECK-FIXES: Strukt p6() {}\n\n  // No warning is emitted here, because this is only the declaration.  The\n  // warning will be associated with the definition, below.\n  const Strukt* const p7();\n  // CHECK-FIXES: const Strukt* p7();\n\n  // const-qualifier is the first `const` token, but not the first token.\n  static const int p8() {}\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const int' is 'const'-\n  // CHECK-FIXES: static int p8() {}\n\n  static const Strukt p9() {}\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const Strukt' i\n  // CHECK-FIXES: static Strukt p9() {}\n\n  int n0() const { return 0; }\n  const Klazz<const int>& n11(const Klazz<const int>) const;\n};\n\nClazz *const Clazz::p3() {\n  // CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'Clazz *const' is 'cons\n  // CHECK-FIXES: Clazz *Clazz::p3() {\n  return this;\n}\n\nconst Klazz<const int>* const Clazz::p5() const {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const int> *\n// CHECK-FIXES: const Klazz<const int>* Clazz::p5() const {}\n\nconst Clazz::Strukt* const Clazz::p7() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Clazz::Strukt *con\n// CHECK-FIXES: const Clazz::Strukt* Clazz::p7() {}\n\nClazz *const p10();\n// CHECK-FIXES: Clazz *p10();\n\nClazz *const p10() {\n  // CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'Clazz *const' is 'cons\n  // CHECK-FIXES: Clazz *p10() {\n  return new Clazz();\n}\n\nconst Clazz bar;\nconst Clazz *const p11() {\n  // CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Clazz *const' is\n  // CHECK-FIXES: const Clazz *p11() {\n  return &bar;\n}\n\nconst Klazz<const int> p12() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const int>'\n// CHECK-FIXES: Klazz<const int> p12() {}\n\nconst Klazz<const Klazz<const int>> p33() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<\n// CHECK-FIXES: Klazz<const Klazz<const int>> p33() {}\n\nconst Klazz<const int>* const p13() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const int> *\n// CHECK-FIXES: const Klazz<const int>* p13() {}\n\nconst Klazz<const int>* const volatile p14() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const int> *\n// CHECK-FIXES: const Klazz<const int>* volatile p14() {}\n\nconst MyStruct<0 < 1> p34() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const MyStruct<0 < 1>'\n// CHECK-FIXES: MyStruct<0 < 1> p34() {}\n\nMyStruct<0 < 1> const p35() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const MyStruct<0 < 1>'\n// CHECK-FIXES: MyStruct<0 < 1> p35() {}\n\nKlazz<MyStruct<0 < 1> const> const p36() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const MyStru\n// CHECK-FIXES: Klazz<MyStruct<0 < 1> const> p36() {}\n\nconst Klazz<MyStruct<0 < 1> const> *const p37() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const MyStru\n// CHECK-FIXES: const Klazz<MyStruct<0 < 1> const> *p37() {}\n\nKlazz<const MyStruct<0 < 1>> const p38() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const MyStru\n// CHECK-FIXES: Klazz<const MyStruct<0 < 1>> p38() {}\n\nconst Klazz<const MyStruct<0 < 1>> p39() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<\n// CHECK-FIXES: Klazz<const MyStruct<0 < 1>> p39() {}\n\nconst Klazz<const MyStruct<(0 > 1)>> p40() {}\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const MyStru\n// CHECK-FIXES: Klazz<const MyStruct<(0 > 1)>> p40() {}\n\n// re-declaration of p15.\nconst int p15();\n// CHECK-FIXES: int p15();\n\nconst int p15() {\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning:\n// CHECK-FIXES: int p15() {\n  return 0;\n}\n\n// Exercise the lexer.\n\nconst /* comment */ /* another comment*/ int p16() { return 0; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning:\n// CHECK-FIXES: /* comment */ /* another comment*/ int p16() { return 0; }\n\n/* comment */ const\n// CHECK-MESSAGES: [[@LINE-1]]:15: warning:\n// CHECK-FIXES: /* comment */\n// more\n/* another comment*/ int p17() { return 0; }\n\n// Test cases where the `const` token lexically is hidden behind some form of\n// indirection.\n\n// Regression tests involving macros, which are ignored by default because\n// IgnoreMacros defaults to true.\n#define CONCAT(a, b) a##b\nCONCAT(cons, t) int n22(){}\n\n#define CONSTINT const int\nCONSTINT n23() {}\n\n#define CONST const\nCONST int n24() {}\n\n#define CREATE_FUNCTION()                    \\\nconst int n_inside_macro() { \\\n  return 1; \\\n}\nCREATE_FUNCTION();\n\nusing ty = const int;\nty p21() {}\n\ntypedef const int ty2;\nty2 p22() {}\n\n// Declaration uses a macro, while definition doesn't.  In this case, we won't\n// fix the declaration, and will instead issue a warning.\nCONST int p23();\n// CHECK-NOTE: [[@LINE-1]]:1: note: could not transform this declaration\n\nconst int p23();\n// CHECK-FIXES: int p23();\n\nconst int p23() { return 3; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int' is 'const'-qu\n// CHECK-FIXES: int p23() { return 3; }\n\nint const p24() { return 3; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int' is 'const'-qu\n// CHECK-FIXES: int p24() { return 3; }\n\nint const * const p25(const int* p) { return p; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int *const' is 'co\n// CHECK-FIXES: int const * p25(const int* p) { return p; }\n\n// We cannot (yet) fix instances that use trailing return types, but we can\n// warn.\nauto p26() -> const int { return 3; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int' is 'const'-qu\nauto p27() -> int const { return 3; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const int' is 'const'-qu\n\nstd::add_const<int>::type p28() { return 3; }\n\n// p29, p30 are based on\n// llvm/projects/test-suite/SingleSource/Benchmarks/Misc-C++-EH/spirit.cpp:\ntemplate <class T>\nKlazz<T const> const p29(T const &t) { return {}; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const T>' is\n// CHECK-FIXES: Klazz<T const> p29(T const &t) { return {}; }\n\nKlazz<char const *> const p30(char const *s) { return s; }\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const Klazz<const char *\n// CHECK-FIXES: Klazz<char const *> p30(char const *s) { return s; }\n\nconst int n1 = 1;\nconst Clazz n2 = Clazz();\nconst Clazz* n3 = new Clazz();\nClazz *const n4 = new Clazz();\nconst Clazz *const n5 = new Clazz();\nconstexpr int n6 = 6;\nconstexpr int n7() { return 8; }\nconst int eight = 8;\nconstexpr const int* n8() { return &eight; }\nKlazz<const int> n9();\nconst Klazz<const int>* n10();\nconst Klazz<const int>& Clazz::n11(const Klazz<const int>) const {}\n\n// Declaration only.\nconst int n14();\n\nint **const * n_multiple_ptr();\nint *const & n_pointer_ref();\n\nclass PVBase {\npublic:\n  virtual const int getC() = 0;\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const int' is 'const'-qualified at the top level, which may reduce code readability without improving const correctness\n  // CHECK-NOT-FIXES: virtual int getC() = 0;\n};\n\nclass NVDerive : public PVBase {\npublic:\n  // Don't warn about overridden methods, because it may be impossible to make\n  // them non-const as the user may not be able to change the base class.\n  const int getC() override { return 1; }\n};\n\nclass NVDeriveOutOfLine : public PVBase {\npublic:\n  // Don't warn about overridden methods, because it may be impossible to make\n  // them non-const as one may not be able to change the base class\n  const int getC();\n};\n\nconst int NVDeriveOutOfLine::getC() { return 1; }\n\n// Don't warn about const auto types, because it may be impossible to make them non-const\n// without a significant semantics change. Since `auto` drops cv-qualifiers,\n// tests check `decltype(auto)`.\ndecltype(auto) n16() {\n  static const int i = 42;\n  return i;\n}\n\n// Don't warn about `decltype(<expr>)` types\nconst int n17i = 1;\ndecltype(n17i) n17() {\n  return 17;\n}\n\n// Do warn when on decltype types with the local const qualifier\n// `const decltype(auto)` won't compile, so check only `const decltype(<expr>)`\nconst decltype(n17i) n18() {\n  // CHECK-MESSAGES: [[@LINE-1]]:1: warning: return type 'const decltype(n17i)\n  // CHECK-FIXES: decltype(n17i) n18() {\n  return 18;\n}\n\n// `volatile` modifier doesn't affect the checker\nvolatile decltype(n17i) n19() {\n  return 19;\n}\n\n// Don't warn about `__typeof__(<expr>)` types\n__typeof__(n17i) n20() {\n  return 20;\n}\n\n// Don't warn about `__typeof__(type)` types\n__typeof__(const int) n21() {\n  return 21;\n}\n\ntemplate <typename T>\nstruct n25 {\n  T foo() const { return 2; }\n};\ntemplate struct n25<const int>;\n\ntemplate <typename T>\nstruct p41 {\n  const T foo() const { return 2; }\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: return type 'const\n  // CHECK-MESSAGES: [[@LINE-2]]:3: warning: return type 'const\n  // CHECK-FIXES: T foo() const { return 2; }\n};\ntemplate struct p41<int>;\n\nnamespace PR73270 {\n  template<typename K, typename V>\n  struct Pair {\n    using first_type = const K;\n    using second_type = V;\n  };\n\n  template<typename PairType>\n  typename PairType::first_type getFirst() {\n    return {};\n  }\n\n  void test() {\n    getFirst<Pair<int, int>>();\n  }\n}"
    }
  ]
}