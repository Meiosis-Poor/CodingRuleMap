{
  "name": "StaticAccessedThroughInstance",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-static-accessed-through-instance",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 114,
  "branches": 10,
  "apis": 57,
  "test": [
    {
      "description": null,
      "expected-problems": 43,
      "expected-linenumbers": [
        49,
        50,
        62,
        63,
        68,
        69,
        77,
        78,
        98,
        103,
        108,
        114,
        136,
        150,
        157,
        160,
        163,
        166,
        169,
        176,
        184,
        187,
        192,
        195,
        212,
        215,
        232,
        244,
        270,
        271,
        284,
        299,
        307,
        309,
        311,
        313,
        358,
        361,
        365,
        368,
        386,
        402,
        403
      ],
      "code": "\n// RUN: %check_clang_tidy %s readability-static-accessed-through-instance %t -- --fix-notes -- -isystem %S/Inputs/static-accessed-through-instance\n#include <__clang_cuda_builtin_vars.h>\n\nenum OutEnum {\n  E0,\n};\n\nstruct C {\n  static void foo();\n  static int x;\n  int nsx;\n  enum {\n    Anonymous,\n  };\n  enum E {\n    E1,\n  };\n  using enum OutEnum;\n  void mf() {\n    (void)&x;    // OK, x is accessed inside the struct.\n    (void)&C::x; // OK, x is accessed using a qualified-id.\n    foo();       // OK, foo() is accessed inside the struct.\n  }\n  void ns() const;\n};\n\nint C::x = 0;\n\nstruct CC {\n  void foo();\n  int x;\n};\n\ntemplate <typename T> struct CT {\n  static T foo();\n  static T x;\n  int nsx;\n  void mf() {\n    (void)&x;    // OK, x is accessed inside the struct.\n    (void)&C::x; // OK, x is accessed using a qualified-id.\n    foo();       // OK, foo() is accessed inside the struct.\n  }\n};\n\n// Expressions with side effects\nC &f(int, int, int, int);\nvoid g() {\n  f(1, 2, 3, 4).x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member accessed through instance  [readability-static-accessed-through-instance]\n  // CHECK-MESSAGES: :[[@LINE-2]]:3: note: member base expression may carry some side effects\n  // CHECK-FIXES: {{^}}  C::x;{{$}}\n}\n\nint i(int &);\nvoid j(int);\nC h();\nbool a();\nint k(bool);\n\nvoid f(C c) {\n  j(i(h().x));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: static member\n  // CHECK-MESSAGES: :[[@LINE-2]]:7: note: member base expression may carry some side effects\n  // CHECK-FIXES: {{^}}  j(i(C::x));{{$}}\n\n  // The execution of h() depends on the return value of a().\n  j(k(a() && h().x));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: static member\n  // CHECK-MESSAGES: :[[@LINE-2]]:14: note: member base expression may carry some side effects\n  // CHECK-FIXES: {{^}}  j(k(a() && C::x));{{$}}\n\n  if ([c]() {\n        c.ns();\n        return c;\n      }().x == 15)\n    ;\n  // CHECK-MESSAGES: :[[@LINE-5]]:7: warning: static member\n  // CHECK-MESSAGES: :[[@LINE-6]]:7: note: member base expression may carry some side effects\n  // CHECK-FIXES: {{^}}  if (C::x == 15){{$}}\n}\n\n// Nested specifiers\nnamespace N {\nstruct V {\n  static int v;\n  struct T {\n    static int t;\n    struct U {\n      static int u;\n    };\n  };\n};\n}\n\nvoid f(N::V::T::U u) {\n  N::V v;\n  v.v = 12;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  N::V::v = 12;{{$}}\n\n  N::V::T w;\n  w.t = 12;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  N::V::T::t = 12;{{$}}\n\n  // u.u is not changed to N::V::T::U::u; because the nesting level is over 3.\n  u.u = 12;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  u.u = 12;{{$}}\n\n  using B = N::V::T::U;\n  B b;\n  b.u;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  B::u;{{$}}\n}\n\n// Templates\ntemplate <typename T> T CT<T>::x;\n\ntemplate <typename T> struct CCT {\n  T foo();\n  T x;\n};\n\ntypedef C D;\n\nusing E = D;\n\n#define FOO(c) c.foo()\n#define X(c) c.x\n\ntemplate <typename T> void f(T t, C c) {\n  t.x; // OK, t is a template parameter.\n  c.x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::x;{{$}}\n}\n\ntemplate <int N> struct S { static int x; };\n\ntemplate <> struct S<0> { int x; };\n\ntemplate <int N> void h() {\n  S<N> sN;\n  sN.x; // OK, value of N affects whether x is static or not.\n\n  S<2> s2;\n  s2.x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  S<2>::x;{{$}}\n}\n\nvoid static_through_instance() {\n  C *c1 = new C();\n  c1->foo(); // 1\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::foo(); // 1{{$}}\n  c1->x; // 2\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::x; // 2{{$}}\n  c1->Anonymous; // 3\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::Anonymous; // 3{{$}}\n  c1->E1; // 4\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::E1; // 4{{$}}\n  c1->E0; // 5\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::E0; // 5{{$}}\n\n  c1->nsx; // OK, nsx is a non-static member.\n\n  const C *c2 = new C();\n  c2->foo(); // 2\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  C::foo(); // 2{{$}}\n\n  C::foo(); // OK, foo() is accessed using a qualified-id.\n  C::x;     // OK, x is accessed using a qualified-id.\n\n  D d;\n  d.foo();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  D::foo();{{$}}\n  d.x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  D::x;{{$}}\n\n  E e;\n  e.foo();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  E::foo();{{$}}\n  e.x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  E::x;{{$}}\n\n  CC *cc = new CC;\n\n  f(*c1, *c1);\n  f(*cc, *c1);\n\n  // Macros: OK, macros are not checked.\n  FOO((*c1));\n  X((*c1));\n  FOO((*cc));\n  X((*cc));\n\n  // Templates\n  CT<int> ct;\n  ct.foo();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  CT<int>::foo();{{$}}\n  ct.x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  CT<int>::x;{{$}}\n  ct.nsx; // OK, nsx is a non-static member\n\n  CCT<int> cct;\n  cct.foo(); // OK, CCT has no static members.\n  cct.x;     // OK, CCT has no static members.\n\n  h<4>();\n}\n\nstruct SP {\n  static int I;\n} P;\n\nvoid usep() {\n  P.I;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  SP::I;{{$}}\n}\n\nnamespace NSP {\nstruct SP {\n  static int I;\n} P;\n} // namespace NSP\n\nvoid usensp() {\n  NSP::P.I;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  NSP::SP::I;{{$}}\n}\n\n// Overloaded member access operator\nstruct Q {\n  static int K;\n  int y = 0;\n};\n\nint Q::K = 0;\n\nstruct Qptr {\n  Q *q;\n\n  explicit Qptr(Q *qq) : q(qq) {}\n\n  Q *operator->() {\n    ++q->y;\n    return q;\n  }\n};\n\nvoid func(Qptr qp) {\n  qp->y = 10;\n  qp->K = 10;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member accessed through instance [readability-static-accessed-through-instance]\n  // CHECK-MESSAGES: :[[@LINE-2]]:3: note: member base expression may carry some side effects\n  // CHECK-FIXES: {{^}}  Q::K = 10;\n}\n\nnamespace {\n  struct Anonymous {\n    static int I;\n  };\n}\n\nvoid use_anonymous() {\n  Anonymous Anon;\n  Anon.I;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  Anonymous::I;{{$}}\n}\n\nnamespace Outer {\n  inline namespace Inline {\n  struct S {\n    static int I;\n  };\n  }\n}\n\nvoid use_inline() {\n  Outer::S V;\n  V.I;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member\n  // CHECK-FIXES: {{^}}  Outer::S::I;{{$}}\n}\n\n// https://bugs.llvm.org/show_bug.cgi?id=48758\nnamespace Bugzilla_48758 {\n\nunsigned int x1 = threadIdx.x;\n// CHECK-MESSAGES-NOT: :[[@LINE-1]]:10: warning: static member\nunsigned int x2 = blockIdx.x;\n// CHECK-MESSAGES-NOT: :[[@LINE-1]]:10: warning: static member\nunsigned int x3 = blockDim.x;\n// CHECK-MESSAGES-NOT: :[[@LINE-1]]:10: warning: static member\nunsigned int x4 = gridDim.x;\n// CHECK-MESSAGES-NOT: :[[@LINE-1]]:10: warning: static member\n\n} // namespace Bugzilla_48758\n\n// https://github.com/llvm/llvm-project/issues/61736\nnamespace llvm_issue_61736\n{\n\nstruct {\n  static void f() {}\n} AnonStruct, *AnonStructPointer;\n\nclass {\n  public:\n  static void f() {}\n} AnonClass, *AnonClassPointer;\n\nvoid testAnonymousStructAndClass() {\n  AnonStruct.f();\n  AnonStructPointer->f();\n\n  AnonClass.f();\n  AnonClassPointer->f();\n}\n\nstruct Embedded {\n  struct {\n    static void f() {}\n  } static EmbeddedStruct, *EmbeddedStructPointer;\n\n  class {\n    public:\n      static void f() {}\n  } static EmbeddedClass, *EmbeddedClassPointer;\n};\n\nvoid testEmbeddedAnonymousStructAndClass() {\n  Embedded::EmbeddedStruct.f();\n  Embedded::EmbeddedStructPointer->f();\n\n  Embedded::EmbeddedClass.f();\n  Embedded::EmbeddedClassPointer->f();\n\n  Embedded E;\n  E.EmbeddedStruct.f();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member accessed through instance [readability-static-accessed-through-instance]\n  // CHECK-FIXES: {{^}}  llvm_issue_61736::Embedded::EmbeddedStruct.f();{{$}}\n  E.EmbeddedStructPointer->f();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member accessed through instance [readability-static-accessed-through-instance]\n  // CHECK-FIXES: {{^}}  llvm_issue_61736::Embedded::EmbeddedStructPointer->f();{{$}}\n\n  E.EmbeddedClass.f();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member accessed through instance [readability-static-accessed-through-instance]\n  // CHECK-FIXES: {{^}}  llvm_issue_61736::Embedded::EmbeddedClass.f();{{$}}\n  E.EmbeddedClassPointer->f();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: static member accessed through instance [readability-static-accessed-through-instance]\n  // CHECK-FIXES: {{^}}  llvm_issue_61736::Embedded::EmbeddedClassPointer->f();{{$}}\n}\n\n} // namespace llvm_issue_61736\n\nnamespace PR51861 {\n  class Foo {\n    public:\n      static Foo& getInstance();\n      static int getBar();\n  };\n\n  inline int Foo::getBar() { return 42; }\n\n  void test() {\n    auto& params = Foo::getInstance();\n    params.getBar();\n    // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: static member accessed through instance [readability-static-accessed-through-instance]\n    // CHECK-FIXES: {{^}}    PR51861::Foo::getBar();{{$}}\n  }\n}\n\nnamespace PR75163 {\n  struct Static {\n    static void call();\n  };\n\n  struct Ptr {\n    Static* operator->();\n  };\n\n  void test(Ptr& ptr) {\n    ptr->call();\n    // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: static member accessed through instance [readability-static-accessed-through-instance]\n    // CHECK-MESSAGES: :[[@LINE-2]]:5: note: member base expression may carry some side effects\n    // CHECK-FIXES: {{^}}    PR75163::Static::call();{{$}}\n  }\n}"
    }
  ]
}