{
  "name": "RedundantCasting",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-redundant-casting",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 257,
  "branches": 31,
  "apis": 192,
  "test": [
    {
      "description": null,
      "expected-problems": 35,
      "expected-linenumbers": [
        23,
        24,
        30,
        31,
        37,
        38,
        44,
        45,
        51,
        52,
        58,
        59,
        60,
        77,
        78,
        85,
        86,
        93,
        94,
        102,
        103,
        125,
        132,
        150,
        156,
        162,
        191,
        192,
        201,
        207,
        214,
        221,
        222,
        234,
        235
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++11,c++14,c++17 %s readability-redundant-casting %t -- -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -std=c++11,c++14,c++17 -check-suffix=,MACROS %s readability-redundant-casting %t -- \\\n// RUN:   -config='{CheckOptions: { readability-redundant-casting.IgnoreMacros: false }}' \\\n// RUN:   -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -std=c++11,c++14,c++17 -check-suffix=,ALIASES %s readability-redundant-casting %t -- \\\n// RUN:   -config='{CheckOptions: { readability-redundant-casting.IgnoreTypeAliases: true }}' \\\n// RUN:   -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -std=c++20 %s readability-redundant-casting %t -- \\\n// RUN:   -- -fno-delayed-template-parsing -D CXX_20=1\n// RUN: %check_clang_tidy -std=c++20 -check-suffix=,MACROS %s readability-redundant-casting %t -- \\\n// RUN:   -config='{CheckOptions: { readability-redundant-casting.IgnoreMacros: false }}' \\\n// RUN:   -- -fno-delayed-template-parsing -D CXX_20=1\n// RUN: %check_clang_tidy -std=c++20 -check-suffix=,ALIASES %s readability-redundant-casting %t -- \\\n// RUN:   -config='{CheckOptions: { readability-redundant-casting.IgnoreTypeAliases: true }}' \\\n// RUN:   -- -fno-delayed-template-parsing -D CXX_20=1\n\nstruct A {};\nstruct B : A {};\nA getA();\n\nvoid testRedundantStaticCasting(A& value) {\n  A& a1 = static_cast<A&>(value);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:36: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  A& a1 = value;\n}\n\nvoid testRedundantConstCasting1(A& value) {\n  A& a2 = const_cast<A&>(value);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:36: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  A& a2 = value;\n}\n\nvoid testRedundantConstCasting2(const A& value) {\n  const A& a3 = const_cast<const A&>(value);\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: redundant explicit casting to the same type 'const A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:42: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  const A& a3 = value;\n}\n\nvoid testRedundantReinterpretCasting(A& value) {\n  A& a4 = reinterpret_cast<A&>(value);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:41: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  A& a4 = value;\n}\n\nvoid testRedundantCCasting(A& value) {\n  A& a5 = (A&)(value);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:31: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  A& a5 = value;\n}\n\nvoid testDoubleCasting(A& value) {\n  A& a6 = static_cast<A&>(reinterpret_cast<A&>(value));\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-2]]:27: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-4]]:27: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  A& a6 = value;\n}\n\nvoid testDiffrentTypesCast(B& value) {\n  A& a7 = static_cast<A&>(value);\n}\n\n#ifdef CXX_20\nvoid testParenListInitExpr(A value) {\n  B b = static_cast<B>(value);\n}\n#endif\n\nvoid testCastingWithAuto() {\n  auto a = getA();\n  A& a8 = static_cast<A&>(a);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:8: note: source type originates from referencing this variable\n  // CHECK-FIXES: {{^}}  A& a8 = a;\n}\n\nvoid testCastingWithConstAuto() {\n  const auto a = getA();\n  const A& a9 = static_cast<const A&>(a);\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: redundant explicit casting to the same type 'const A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:14: note: source type originates from referencing this variable\n  // CHECK-FIXES: {{^}}  const A& a9 = a;\n}\n\nvoid testCastingWithAutoPtr(A& ptr) {\n  auto* a = &ptr;\n  A* a10 = static_cast<A*>(a);\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: redundant explicit casting to the same type 'A *' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-3]]:9: note: source type originates from referencing this variable\n  // CHECK-FIXES: {{^}}  A* a10 = a;\n}\n\ntemplate<typename T>\nvoid testRedundantTemplateCasting(T& value) {\n  A& a = static_cast<A&>(value);\n  T& t = static_cast<T&>(value);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: redundant explicit casting to the same type 'T' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-4]]:38: note: source type originates from referencing this parameter\n  // CHECK-FIXES: {{^}}  T& t = value;\n}\n\nvoid testTemplate() {\n  A value;\n  testRedundantTemplateCasting(value);\n}\n\nvoid testValidRefConstCast() {\n  const auto a = getA();\n  A& a11 = const_cast<A&>(a);\n}\n\nvoid testValidPtrConstCast(const A* ptr) {\n  A* a12 = const_cast<A*>(ptr);\n}\n\n#define CAST(X) static_cast<int>(X)\n\nvoid testMacroCasting(int value) {\n  int a = CAST(value);\n  // CHECK-MESSAGES-MACROS: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'int' as the sub-expression, remove this casting [readability-redundant-casting]\n}\n\n#define PTR_NAME name\n\nvoid testMacroCasting(A* PTR_NAME) {\n  A* a13 = static_cast<A*>(PTR_NAME);\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: redundant explicit casting to the same type 'A *' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-FIXES: {{^}}  A* a13 = PTR_NAME;\n}\n\nstruct CastBool {\n  operator bool() const {\n    return true;\n  }\n};\n\nvoid testUserOperatorCast(const CastBool& value) {\n  bool b = static_cast<bool>(value);\n}\n\nusing TypeA = A;\n\nvoid testTypedefCast(A& value) {\n  TypeA& a = static_cast<TypeA&>(value);\n  // CHECK-MESSAGES-ALIASES: :[[@LINE-1]]:14: warning: redundant explicit casting to the same type 'TypeA' (aka 'A') as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-FIXES-ALIASES: {{^}}  TypeA& a = value;\n}\n\nvoid testTypedefCast2(TypeA& value) {\n  A& a = static_cast<A&>(value);\n  // CHECK-MESSAGES-ALIASES: :[[@LINE-1]]:10: warning: redundant explicit casting to the same type 'A' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-FIXES-ALIASES: {{^}}  A& a = value;\n}\n\nvoid testFunctionalCastWithPrimitive(int a) {\n  int b = int(a);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'int' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-FIXES: {{^}}  int b = a;\n}\n\nvoid testFunctionalCastWithInitExpr(unsigned a) {\n  unsigned b = ~unsigned{!a};\n  unsigned c = unsigned{0};\n}\n\nvoid testBinaryOperator(char c) {\n  int a = int(c - 'C');\n}\n\nstruct BIT {\n  bool b:1;\n};\n\ntemplate<typename ...Args>\nvoid make(Args&& ...);\n\nvoid testBinaryOperator(BIT b) {\n  make((bool)b.b);\n}\n\nstruct Class {\n  using Iterator = const char*;\n\n  Iterator begin() {\n    return static_cast<Iterator>(first());\n// CHECK-MESSAGES-ALIASES: :[[@LINE-1]]:12: warning: redundant explicit casting to the same type 'Iterator' (aka 'const char *') as the sub-expression, remove this casting [readability-redundant-casting]\n// CHECK-MESSAGES-ALIASES: :[[@LINE+4]]:15: note: source type originates from the invocation of this method\n// CHECK-FIXES-ALIASES: {{^}}    return first();\n  }\n\n  const char* first();\n};\n\nvoid testAddOperation(int aa, int bb) {\n  int c = static_cast<int>(aa + bb) * aa;\n // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'int' as the sub-expression, remove this casting [readability-redundant-casting]\n // CHECK-FIXES: {{^}}  int c = (aa + bb) * aa;\n}\n\nvoid testAddOperationWithParen(int a, int b) {\n  int c = static_cast<int>((a+b))*a;\n // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'int' as the sub-expression, remove this casting [readability-redundant-casting]\n // CHECK-FIXES: {{^}}  int c = (a+b)*a;\n}\n\nvoid testRValueCast(int&& a) {\n  int&& b = static_cast<int&&>(a);\n  int&& c = static_cast<int&&>(10);\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: redundant explicit casting to the same type 'int' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-FIXES: {{^}}  int&& c = 10;\n}\n\ntemplate <int V>\nvoid testRedundantNTTPCasting() {\n  int a = static_cast<int>(V);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: redundant explicit casting to the same type 'int' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-4]]:15: note: source type originates from referencing this non-type template parameter\n  // CHECK-FIXES: {{^}}  int a = V;\n}\n\ntemplate <typename T, T V>\nvoid testValidNTTPCasting() {\n  int a = static_cast<int>(V);\n}\n\ntemplate <typename T, T V>\nvoid testRedundantDependentNTTPCasting() {\n  T a = static_cast<T>(V);\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: redundant explicit casting to the same type 'T' as the sub-expression, remove this casting [readability-redundant-casting]\n  // CHECK-MESSAGES: :[[@LINE-4]]:25: note: source type originates from referencing this non-type template parameter\n  // CHECK-FIXES: {{^}}  T a = V;\n}"
    }
  ]
}