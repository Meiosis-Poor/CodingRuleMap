{
  "name": "MakeMemberFunctionConst",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-make-member-function-const",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 271,
  "branches": 27,
  "apis": 143,
  "test": [
    {
      "description": null,
      "expected-problems": 17,
      "expected-linenumbers": [
        26,
        32,
        38,
        44,
        50,
        56,
        62,
        68,
        74,
        80,
        86,
        92,
        98,
        104,
        110,
        116,
        126
      ],
      "code": "\n// RUN: %check_clang_tidy %s readability-make-member-function-const %t\n\nstruct Str {\n  void const_method() const;\n  void non_const_method();\n};\n\nnamespace Diagnose {\nstruct A;\n\nvoid free_const_use(const A *);\nvoid free_const_use(const A &);\n\nstruct A {\n  int M;\n  const int ConstM;\n  struct {\n    int M;\n  } Struct;\n  Str S;\n  Str &Sref;\n\n  void already_const() const;\n\n  int read_field() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'read_field' can be made const\n    // CHECK-FIXES: {{^}}  int read_field() const {\n    return M;\n  }\n\n  int read_struct_field() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'read_struct_field' can be made const\n    // CHECK-FIXES: {{^}}  int read_struct_field() const {\n    return Struct.M;\n  }\n\n  int read_const_field() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'read_const_field' can be made const\n    // CHECK-FIXES: {{^}}  int read_const_field() const {\n    return ConstM;\n  }\n\n  int read_fields_in_parentheses() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'read_fields_in_parentheses' can be made const\n    // CHECK-FIXES: {{^}}  int read_fields_in_parentheses() const {\n    return (this)->M + (((((Struct.M))))) + ((this->ConstM));\n  }\n\n  void call_const_member() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: method 'call_const_member' can be made const\n    // CHECK-FIXES: {{^}}  void call_const_member() const {\n    already_const();\n  }\n\n  void call_const_member_on_public_field() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: method 'call_const_member_on_public_field' can be made const\n    // CHECK-FIXES: {{^}}  void call_const_member_on_public_field() const {\n    S.const_method();\n  }\n\n  void call_const_member_on_public_field_ref() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: method 'call_const_member_on_public_field_ref' can be made const\n    // CHECK-FIXES: {{^}}  void call_const_member_on_public_field_ref() const {\n    Sref.const_method();\n  }\n\n  const Str &return_public_field_ref() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: method 'return_public_field_ref' can be made const\n    // CHECK-FIXES: {{^}}  const Str &return_public_field_ref() const {\n    return S;\n  }\n\n  const A *return_this_const() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: method 'return_this_const' can be made const\n    // CHECK-FIXES: {{^}}  const A *return_this_const() const {\n    return this;\n  }\n\n  const A &return_this_const_ref() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: method 'return_this_const_ref' can be made const\n    // CHECK-FIXES: {{^}}  const A &return_this_const_ref() const {\n    return *this;\n  }\n\n  void const_use() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: method 'const_use' can be made const\n    // CHECK-FIXES: {{^}}  void const_use() const {\n    free_const_use(this);\n  }\n\n  void const_use_ref() {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: method 'const_use_ref' can be made const\n    // CHECK-FIXES: {{^}}  void const_use_ref() const {\n    free_const_use(*this);\n  }\n\n  auto trailingReturn() -> int {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: method 'trailingReturn' can be made const\n    // CHECK-FIXES: {{^}}  auto trailingReturn() const -> int {\n    return M;\n  }\n\n  int volatileFunction() volatile {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'volatileFunction' can be made const\n    // CHECK-FIXES: {{^}}  int volatileFunction() const volatile {\n    return M;\n  }\n\n  int restrictFunction() __restrict {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'restrictFunction' can be made const\n    // CHECK-FIXES: {{^}}  int restrictFunction() const __restrict {\n    return M;\n  }\n\n  int refFunction() & {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: method 'refFunction' can be made const\n    // CHECK-FIXES: {{^}}  int refFunction() const & {\n    return M;\n  }\n\n  void out_of_line_call_const();\n  // CHECK-FIXES: {{^}}  void out_of_line_call_const() const;\n};\n\nvoid A::out_of_line_call_const() {\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: method 'out_of_line_call_const' can be made const\n  // CHECK-FIXES: {{^}}void A::out_of_line_call_const() const {\n  already_const();\n}\n} // namespace Diagnose\n\nnamespace Keep {\nstruct Keep;\nvoid free_non_const_use(Keep *);\nvoid free_non_const_use(Keep &);\n\nstruct Keep {\nprivate:\n  void private_const_method() const;\n  Str PrivateS;\n  Str *Sptr;\n  Str &Sref;\n\npublic:\n  int M;\n  Str S;\n\n  void keepTrivial() {}\n\n  // See readability-convert-member-functions-to-static instead.\n  void keepStatic() { int I = 0; }\n\n  const int *keepConstCast() const;\n  int *keepConstCast() { // Needs to stay non-const.\n    return const_cast<int *>(static_cast<const Keep *>(this)->keepConstCast());\n  }\n\n  void non_const_use() { free_non_const_use(this); }\n  void non_const_use_ref() { free_non_const_use(*this); }\n\n  Keep *return_this() {\n    return this;\n  }\n\n  Keep &return_this_ref() {\n    return *this;\n  }\n\n  void escape_this() {\n    Keep *Escaped = this;\n  }\n\n  void call_private_const_method() {\n    private_const_method();\n  }\n\n  int keepConst() const { return M; }\n\n  virtual int keepVirtual() { return M; }\n\n  void writeField() {\n    M = 1;\n  }\n\n  void callNonConstMember() { writeField(); }\n\n  void call_non_const_member_on_field() { S.non_const_method(); }\n\n  void call_const_member_on_private_field() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    PrivateS.const_method();\n  }\n\n  const Str &return_private_field_ref() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    return PrivateS;\n  }\n\n  void call_non_const_member_on_pointee() {\n    Sptr->non_const_method();\n  }\n\n  void call_const_member_on_pointee() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    Sptr->const_method();\n  }\n\n  Str *return_pointer() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    return Sptr;\n  }\n\n  const Str *return_const_pointer() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    return Sptr;\n  }\n\n  void call_non_const_member_on_ref() {\n    Sref.non_const_method();\n  }\n\n  void escaped_private_field() {\n    const auto &Escaped = Sref;\n  }\n\n  Str &return_field_ref() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    return Sref;\n  }\n\n  const Str &return_field_const_ref() {\n    // Technically, this method could be const-qualified,\n    // but it might not be logically const.\n    return Sref;\n  }\n};\n\nstruct KeepVirtualDerived : public Keep {\n  int keepVirtual() { return M; }\n};\n\nvoid KeepLambdas() {\n  auto F = +[]() { return 0; };\n  auto F2 = []() { return 0; };\n}\n\ntemplate <class Base>\nstruct KeepWithDependentBase : public Base {\n  int M;\n  // We cannot make this method const because it might need to override\n  // a function from Base.\n  int const_f() { return M; }\n};\n\ntemplate <class T>\nstruct KeepClassTemplate {\n  int M;\n  // We cannot make this method const because a specialization\n  // might use *this differently.\n  int const_f() { return M; }\n};\n\nstruct KeepMemberFunctionTemplate {\n  int M;\n  // We cannot make this method const because a specialization\n  // might use *this differently.\n  template <class T>\n  int const_f() { return M; }\n};\n\nvoid instantiate() {\n  struct S {};\n  KeepWithDependentBase<S> I1;\n  I1.const_f();\n\n  KeepClassTemplate<int> I2;\n  I2.const_f();\n\n  KeepMemberFunctionTemplate I3;\n  I3.const_f<int>();\n}\n\nstruct NoFixitInMacro {\n  int M;\n\n#define FUN const_use_macro()\n  int FUN {\n    return M;\n  }\n\n#define T(FunctionName, Keyword) \\\n  int FunctionName() Keyword { return M; }\n#define EMPTY\n  T(A, EMPTY)\n  T(B, const)\n\n#define T2(FunctionName) \\\n  int FunctionName() { return M; }\n  T2(A2)\n};\n\n// Real-world code, see clang::ObjCInterfaceDecl.\nclass DataPattern {\n  int &data() const;\n\npublic:\n  const int &get() const {\n    return const_cast<DataPattern *>(this)->get();\n  }\n\n  // This member function must stay non-const, even though\n  // it only calls other private const member functions.\n  int &get() {\n    return data();\n  }\n\n  void set() {\n    data() = 42;\n  }\n};\n\nstruct MemberFunctionPointer {\n  void call_non_const(void (MemberFunctionPointer::*FP)()) {\n    (this->*FP)();\n  }\n\n  void call_const(void (MemberFunctionPointer::*FP)() const) {\n    (this->*FP)();\n  }\n};\n\n} // namespace Keep"
    }
  ]
}