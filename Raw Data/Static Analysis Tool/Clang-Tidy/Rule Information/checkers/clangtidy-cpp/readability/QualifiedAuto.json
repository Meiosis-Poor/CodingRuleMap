{
  "name": "QualifiedAuto",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-qualified-auto",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 303,
  "branches": 36,
  "apis": 245,
  "test": [
    {
      "description": null,
      "expected-problems": 50,
      "expected-linenumbers": [
        19,
        24,
        27,
        47,
        52,
        55,
        78,
        81,
        85,
        88,
        92,
        95,
        100,
        103,
        106,
        112,
        117,
        154,
        162,
        167,
        176,
        182,
        193,
        199,
        224,
        227,
        231,
        235,
        239,
        293,
        300,
        304,
        308,
        312,
        316,
        320,
        324,
        328,
        332,
        336,
        340,
        344,
        348,
        352,
        356,
        360,
        367,
        371,
        375,
        381
      ],
      "code": "\n// RUN: %check_clang_tidy %s readability-qualified-auto %t \\\n// RUN: -config='{CheckOptions: { \\\n// RUN:   readability-qualified-auto.AllowedTypes: \"[iI]terator$;my::ns::Ignored1;std::array<.*>::Ignored2;MyIgnoredPtr\" \\\n// RUN: }}'\n\nnamespace typedefs {\ntypedef int *MyPtr;\ntypedef int &MyRef;\ntypedef const int *CMyPtr;\ntypedef const int &CMyRef;\n\nMyPtr getPtr();\nMyRef getRef();\nCMyPtr getCPtr();\nCMyRef getCRef();\n\nvoid foo() {\n  auto TdNakedPtr = getPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto TdNakedPtr' can be declared as 'auto *TdNakedPtr'\n  // CHECK-FIXES: {{^}}  auto *TdNakedPtr = getPtr();\n  auto &TdNakedRef = getRef();\n  auto TdNakedRefDeref = getRef();\n  auto TdNakedCPtr = getCPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto TdNakedCPtr' can be declared as 'const auto *TdNakedCPtr'\n  // CHECK-FIXES: {{^}}  const auto *TdNakedCPtr = getCPtr();\n  auto &TdNakedCRef = getCRef();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto &TdNakedCRef' can be declared as 'const auto &TdNakedCRef'\n  // CHECK-FIXES: {{^}}  const auto &TdNakedCRef = getCRef();\n  auto TdNakedCRefDeref = getCRef();\n}\n\n}; // namespace typedefs\n\nnamespace usings {\nusing MyPtr = int *;\nusing MyRef = int &;\nusing CMyPtr = const int *;\nusing CMyRef = const int &;\n\nMyPtr getPtr();\nMyRef getRef();\nCMyPtr getCPtr();\nCMyRef getCRef();\n\nvoid foo() {\n  auto UNakedPtr = getPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto UNakedPtr' can be declared as 'auto *UNakedPtr'\n  // CHECK-FIXES: {{^}}  auto *UNakedPtr = getPtr();\n  auto &UNakedRef = getRef();\n  auto UNakedRefDeref = getRef();\n  auto UNakedCPtr = getCPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto UNakedCPtr' can be declared as 'const auto *UNakedCPtr'\n  // CHECK-FIXES: {{^}}  const auto *UNakedCPtr = getCPtr();\n  auto &UNakedCRef = getCRef();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto &UNakedCRef' can be declared as 'const auto &UNakedCRef'\n  // CHECK-FIXES: {{^}}  const auto &UNakedCRef = getCRef();\n  auto UNakedCRefDeref = getCRef();\n}\n\n}; // namespace usings\n\nint getInt();\nint *getIntPtr();\nconst int *getCIntPtr();\n\nvoid foo() {\n  // make sure check disregards named types\n  int TypedInt = getInt();\n  int *TypedPtr = getIntPtr();\n  const int *TypedConstPtr = getCIntPtr();\n  int &TypedRef = *getIntPtr();\n  const int &TypedConstRef = *getCIntPtr();\n\n  // make sure check disregards auto types that aren't pointers or references\n  auto AutoInt = getInt();\n\n  auto NakedPtr = getIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto NakedPtr' can be declared as 'auto *NakedPtr'\n  // CHECK-FIXES: {{^}}  auto *NakedPtr = getIntPtr();\n  auto NakedCPtr = getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto NakedCPtr' can be declared as 'const auto *NakedCPtr'\n  // CHECK-FIXES: {{^}}  const auto *NakedCPtr = getCIntPtr();\n\n  const auto ConstPtr = getIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'const auto ConstPtr' can be declared as 'auto *const ConstPtr'\n  // CHECK-FIXES: {{^}}  auto *const ConstPtr = getIntPtr();\n  const auto ConstCPtr = getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'const auto ConstCPtr' can be declared as 'const auto *const ConstCPtr'\n  // CHECK-FIXES: {{^}}  const auto *const ConstCPtr = getCIntPtr();\n\n  volatile auto VolatilePtr = getIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'volatile auto VolatilePtr' can be declared as 'auto *volatile VolatilePtr'\n  // CHECK-FIXES: {{^}}  auto *volatile VolatilePtr = getIntPtr();\n  volatile auto VolatileCPtr = getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'volatile auto VolatileCPtr' can be declared as 'const auto *volatile VolatileCPtr'\n  // CHECK-FIXES: {{^}}  const auto *volatile VolatileCPtr = getCIntPtr();\n\n  auto *QualPtr = getIntPtr();\n  auto *QualCPtr = getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto *QualCPtr' can be declared as 'const auto *QualCPtr'\n  // CHECK-FIXES: {{^}}  const auto *QualCPtr = getCIntPtr();\n  auto *const ConstantQualCPtr = getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto *const ConstantQualCPtr' can be declared as 'const auto *const ConstantQualCPtr'\n  // CHECK-FIXES: {{^}}  const auto *const ConstantQualCPtr = getCIntPtr();\n  auto *volatile VolatileQualCPtr = getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto *volatile VolatileQualCPtr' can be declared as 'const auto *volatile VolatileQualCPtr'\n  // CHECK-FIXES: {{^}}  const auto *volatile VolatileQualCPtr = getCIntPtr();\n  const auto *ConstQualCPtr = getCIntPtr();\n\n  auto &Ref = *getIntPtr();\n  auto &CRef = *getCIntPtr();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto &CRef' can be declared as 'const auto &CRef'\n  // CHECK-FIXES: {{^}}  const auto &CRef = *getCIntPtr();\n  const auto &ConstCRef = *getCIntPtr();\n\n  if (auto X = getCIntPtr()) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'auto X' can be declared as 'const auto *X'\n    // CHECK-FIXES: {{^}}  if (const auto *X = getCIntPtr()) {\n  }\n}\n\nvoid macroTest() {\n#define _AUTO auto\n#define _CONST const\n  _AUTO AutoMACROPtr = getIntPtr();\n  const _AUTO ConstAutoMacroPtr = getIntPtr();\n  _CONST _AUTO ConstMacroAutoMacroPtr = getIntPtr();\n  _CONST auto ConstMacroAutoPtr = getIntPtr();\n#undef _AUTO\n#undef _CONST\n}\n\nnamespace std {\ntemplate <typename T>\nclass vector { // dummy impl\n  T _data[1];\n\npublic:\n  T *begin() { return _data; }\n  const T *begin() const { return _data; }\n  T *end() { return &_data[1]; }\n  const T *end() const { return &_data[1]; }\n};\n} // namespace std\n\nvoid change(int &);\nvoid observe(const int &);\n\nvoid loopRef(std::vector<int> &Mutate, const std::vector<int> &Constant) {\n  for (auto &Data : Mutate) {\n    change(Data);\n  }\n  for (auto &Data : Constant) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: 'auto &Data' can be declared as 'const auto &Data'\n    // CHECK-FIXES: {{^}}  for (const auto &Data : Constant) {\n    observe(Data);\n  }\n}\n\nvoid loopPtr(const std::vector<int *> &Mutate, const std::vector<const int *> &Constant) {\n  for (auto Data : Mutate) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: 'auto Data' can be declared as 'auto *Data'\n    // CHECK-FIXES: {{^}}  for (auto *Data : Mutate) {\n    change(*Data);\n  }\n  for (auto Data : Constant) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: 'auto Data' can be declared as 'const auto *Data'\n    // CHECK-FIXES: {{^}}  for (const auto *Data : Constant) {\n    observe(*Data);\n  }\n}\n\ntemplate <typename T>\nvoid tempLoopPtr(std::vector<T *> &MutateTemplate, std::vector<const T *> &ConstantTemplate) {\n  for (auto Data : MutateTemplate) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: 'auto Data' can be declared as 'auto *Data'\n    // CHECK-FIXES: {{^}}  for (auto *Data : MutateTemplate) {\n    change(*Data);\n  }\n  //FixMe\n  for (auto Data : ConstantTemplate) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: 'auto Data' can be declared as 'const auto *Data'\n    // CHECK-FIXES: {{^}}  for (const auto *Data : ConstantTemplate) {\n    observe(*Data);\n  }\n}\n\ntemplate <typename T>\nclass TemplateLoopPtr {\npublic:\n  void operator()(const std::vector<T *> &MClassTemplate, const std::vector<const T *> &CClassTemplate) {\n    for (auto Data : MClassTemplate) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: 'auto Data' can be declared as 'auto *Data'\n      // CHECK-FIXES: {{^}}    for (auto *Data : MClassTemplate) {\n      change(*Data);\n    }\n    //FixMe\n    for (auto Data : CClassTemplate) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: 'auto Data' can be declared as 'const auto *Data'\n      // CHECK-FIXES: {{^}}    for (const auto *Data : CClassTemplate) {\n      observe(*Data);\n    }\n  }\n};\n\nvoid bar() {\n  std::vector<int> Vec;\n  std::vector<int *> PtrVec;\n  std::vector<const int *> CPtrVec;\n  loopRef(Vec, Vec);\n  loopPtr(PtrVec, CPtrVec);\n  tempLoopPtr(PtrVec, CPtrVec);\n  TemplateLoopPtr<int>()(PtrVec, CPtrVec);\n}\n\ntypedef int *(*functionRetPtr)();\ntypedef int (*functionRetVal)();\n\nfunctionRetPtr getPtrFunction();\nfunctionRetVal getValFunction();\n\nvoid baz() {\n  auto MyFunctionPtr = getPtrFunction();\n  // CHECK-MESSAGES-NOT: :[[@LINE-1]]:3: warning: 'auto MyFunctionPtr' can be declared as 'auto *MyFunctionPtr'\n  // CHECK-FIXES-NOT: {{^}}  auto *MyFunctionPtr = getPtrFunction();\n  auto MyFunctionVal = getValFunction();\n  // CHECK-MESSAGES-NOT: :[[@LINE-1]]:3: warning: 'auto MyFunctionVal' can be declared as 'auto *MyFunctionVal'\n  // CHECK-FIXES-NOT: {{^}}  auto *MyFunctionVal = getValFunction();\n\n  auto LambdaTest = [] { return 0; };\n  // CHECK-MESSAGES-NOT: :[[@LINE-1]]:3: warning: 'auto LambdaTest' can be declared as 'auto *LambdaTest'\n  // CHECK-FIXES-NOT: {{^}}  auto *LambdaTest = [] { return 0; };\n\n  auto LambdaTest2 = +[] { return 0; };\n  // CHECK-MESSAGES-NOT: :[[@LINE-1]]:3: warning: 'auto LambdaTest2' can be declared as 'auto *LambdaTest2'\n  // CHECK-FIXES-NOT: {{^}}  auto *LambdaTest2 = +[] { return 0; };\n\n  auto MyFunctionRef = *getPtrFunction();\n  // CHECK-MESSAGES-NOT: :[[@LINE-1]]:3: warning: 'auto MyFunctionRef' can be declared as 'auto *MyFunctionRef'\n  // CHECK-FIXES-NOT: {{^}}  auto *MyFunctionRef = *getPtrFunction();\n\n  auto &MyFunctionRef2 = *getPtrFunction();\n}\n\nnamespace std {\n\ntemplate<typename T, int N>\nstruct array {\n  typedef T value_type;\n\n  typedef value_type* iterator;\n  typedef value_type* Iterator;\n  using using_iterator = T*;\n  typedef const value_type* const_iterator;\n  typedef const value_type* constIterator;\n\n  struct Ignored2 {};\n  using NotIgnored2 = Ignored2;\n\n  iterator begin() { return nullptr; }\n  const_iterator begin() const { return nullptr; }\n  iterator end() { return nullptr; }\n  const_iterator end() const { return nullptr; }\n};\n\nstruct Iterator {};\n\nstruct Ignored2 {}; // should not be ignored\n\n} // namespace std\n\ntypedef std::Iterator iterator;\n\nnamespace my {\nnamespace ns {\n\nstruct Ignored1 {};\n\nusing NotIgnored1 = Ignored1;\ntypedef Ignored1 NotIgnored2;\n\n} // namespace ns\n\nstruct Ignored1 {}; // should not be ignored\n\n} // namespace my\n\ntypedef int *MyIgnoredPtr;\nMyIgnoredPtr getIgnoredPtr();\n\nvoid ignored_types() {\n  auto ignored_ptr = getIgnoredPtr();\n  // CHECK-MESSAGES-NOT: warning: 'auto ignored_ptr' can be declared as 'auto *ignored_ptr'\n  // CHECK-FIXES-NOT: auto *ignored_ptr = getIgnoredPtr();\n\n  std::array<int, 4> arr;\n  std::array<int, 4> carr;\n\n  auto it1 = arr.begin();\n  // CHECK-MESSAGES-NOT: warning: 'auto it' can be declared as 'auto *it'\n  // CHECK-FIXES-NOT: auto *it = vec.it_begin();\n  \n  auto it2 = carr.begin();\n  // CHECK-MESSAGES-NOT: warning: 'auto it2' can be declared as 'auto *it2'\n  // CHECK-FIXES-NOT: auto *it2 = carr.begin();\n\n  auto it3 = std::array<int, 4>::iterator{};\n  // CHECK-MESSAGES-NOT: warning: 'auto it3' can be declared as 'auto *it3'\n  // CHECK-FIXES-NOT: auto *it3 = std::array<int, 4>::iterator{};\n\n  auto it4 = std::array<int, 4>::Iterator{};\n  // CHECK-MESSAGES-NOT: warning: 'auto it4' can be declared as 'auto *it4'\n  // CHECK-FIXES-NOT: auto *it4 = std::array<int, 4>::Iterator{};\n\n  auto it5 = std::array<int, 4>::using_iterator{};\n  // CHECK-MESSAGES-NOT: warning: 'auto it5' can be declared as 'auto *it5'\n  // CHECK-FIXES-NOT: auto *it5 = std::array<int, 4>::using_iterator{};\n\n  auto it6 = std::array<int, 4>::const_iterator{};\n  // CHECK-MESSAGES-NOT: warning: 'auto it6' can be declared as 'auto *it6'\n  // CHECK-FIXES-NOT: auto *it6 = std::array<int, 4>::const_iterator{};\n\n  auto it7 = std::array<int, 4>::constIterator{};\n  // CHECK-MESSAGES-NOT: warning: 'auto it7' can be declared as 'auto *it7'\n  // CHECK-FIXES-NOT: auto *it7 = std::array<int, 4>::constIterator{};\n\n  auto it8 = new std::Iterator();\n  // CHECK-MESSAGES-NOT: warning: 'auto it8' can be declared as 'auto *it8'\n  // CHECK-FIXES-NOT: auto *it8 = new std::Iterator();\n\n  auto it9 = new iterator();\n  // CHECK-MESSAGES-NOT: warning: 'auto it9' can be declared as 'auto *it9'\n  // CHECK-FIXES-NOT: auto *it9 = new iterator();\n\n  auto arr_ignored2 = new std::array<int, 4>::Ignored2();\n  // CHECK-MESSAGES-NOT: warning: 'auto arr_ignored2' can be declared as 'auto *arr_ignored2'\n  // CHECK-FIXES-NOT: auto *arr_ignored2 = new std::array<int, 4>::Ignored2();\n\n  auto arr_not_ignored2 = new std::array<int, 4>::NotIgnored2();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto arr_not_ignored2' can be declared as 'auto *arr_not_ignored2'\n  // CHECK-FIXES: auto *arr_not_ignored2 = new std::array<int, 4>::NotIgnored2();\n\n  auto not_ignored2 = new std::Ignored2();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto not_ignored2' can be declared as 'auto *not_ignored2'\n  // CHECK-FIXES: auto *not_ignored2 = new std::Ignored2();\n\n  auto ignored1 = new my::ns::Ignored1();\n  // CHECK-MESSAGES-NOT: warning: 'auto ignored1' can be declared as 'auto *ignored1'\n  // CHECK-FIXES-NOT: auto *ignored1 = new my::ns::Ignored1();\n\n  auto not_ignored1 = new my::ns::NotIgnored1();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto not_ignored1' can be declared as 'auto *not_ignored1'\n  // CHECK-FIXES: auto *not_ignored1 = new my::ns::NotIgnored1();\n\n  auto not2_ignored1 = new my::ns::NotIgnored2();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto not2_ignored1' can be declared as 'auto *not2_ignored1'\n  // CHECK-FIXES: auto *not2_ignored1 = new my::ns::NotIgnored2();\n\n  auto not3_ignored1 = new my::Ignored1();\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 'auto not3_ignored1' can be declared as 'auto *not3_ignored1'\n  // CHECK-FIXES: auto *not3_ignored1 = new my::Ignored1();\n}\n\ntemplate <typename T>\nvoid ignored_types_template(std::array<T, 4> arr, const std::array<T, 4>& carr) {\n  auto it1 = arr.begin();\n  // CHECK-MESSAGES-NOT: warning: 'auto it' can be declared as 'auto *it'\n  // CHECK-FIXES-NOT: auto *it = arr.it_begin();\n  \n  auto it2 = carr.begin();\n  // CHECK-MESSAGES-NOT: warning: 'auto it2' can be declared as 'auto *it2'\n  // CHECK-FIXES-NOT: auto *it2 = carr.begin();\n\n  for (auto Data : arr) {\n    // CHECK-MESSAGES-NOT: warning: 'auto Data' can be declared as 'auto *Data'\n    // CHECK-FIXES-NOT: {{^}}    for (auto *Data : MClassTemplate) {\n    change(*Data);\n  }\n\n  for (auto Data : carr) {\n    // CHECK-MESSAGES-NOT: warning: 'auto Data' can be declared as 'const auto *Data'\n    // CHECK-FIXES-NOT: {{^}}    for (const auto *Data : MClassTemplate) {\n    change(*Data);\n  }\n}"
    }
  ]
}