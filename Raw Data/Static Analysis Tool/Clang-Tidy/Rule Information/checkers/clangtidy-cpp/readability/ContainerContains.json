{
  "name": "ContainerContains",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-container-contains",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 142,
  "branches": 4,
  "apis": 158,
  "test": [
    {
      "description": null,
      "expected-problems": 57,
      "expected-linenumbers": [
        42,
        46,
        49,
        52,
        55,
        58,
        61,
        69,
        72,
        75,
        78,
        81,
        89,
        92,
        95,
        98,
        106,
        109,
        112,
        115,
        124,
        140,
        151,
        187,
        190,
        193,
        196,
        199,
        202,
        205,
        208,
        221,
        222,
        231,
        232,
        240,
        259,
        263,
        271,
        281,
        359,
        362,
        365,
        374,
        389,
        406,
        411,
        415,
        431,
        437,
        440,
        443,
        446,
        449,
        452,
        455,
        458
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++11-or-later %s readability-container-contains %t\n\n// Some *very* simplified versions of `map` etc.\nnamespace std {\n\ntemplate <class Key, class T>\nstruct map {\n  struct iterator {\n    bool operator==(const iterator &Other) const;\n    bool operator!=(const iterator &Other) const;\n  };\n\n  unsigned count(const Key &K) const;\n  bool contains(const Key &K) const;\n  iterator find(const Key &K);\n  iterator end();\n};\n\ntemplate <class Key>\nstruct set {\n  unsigned count(const Key &K) const;\n  bool contains(const Key &K) const;\n};\n\ntemplate <class Key>\nstruct unordered_set {\n  unsigned count(const Key &K) const;\n  bool contains(const Key &K) const;\n};\n\ntemplate <class Key, class T>\nstruct multimap {\n  unsigned count(const Key &K) const;\n  bool contains(const Key &K) const;\n};\n\n} // namespace std\n\n// Check that we detect various common ways to check for membership\nint testDifferentCheckTypes(std::map<int, int> &MyMap) {\n  if (MyMap.count(0))\n    // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use 'contains' to check for membership [readability-container-contains]\n    // CHECK-FIXES: if (MyMap.contains(0))\n    return 1;\n  bool C1 = MyMap.count(1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C1 = MyMap.contains(1);\n  auto C2 = static_cast<bool>(MyMap.count(1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:37: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C2 = static_cast<bool>(MyMap.contains(1));\n  auto C3 = MyMap.count(2) != 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C3 = MyMap.contains(2);\n  auto C4 = MyMap.count(3) > 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C4 = MyMap.contains(3);\n  auto C5 = MyMap.count(4) >= 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C5 = MyMap.contains(4);\n  auto C6 = MyMap.find(5) != MyMap.end();\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C6 = MyMap.contains(5);\n  return C1 + C2 + C3 + C4 + C5 + C6;\n}\n\n// Check that we detect various common ways to check for non-membership\nint testNegativeChecks(std::map<int, int> &MyMap) {\n  bool C1 = !MyMap.count(-1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C1 = !MyMap.contains(-1);\n  auto C2 = MyMap.count(-2) == 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C2 = !MyMap.contains(-2);\n  auto C3 = MyMap.count(-3) <= 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C3 = !MyMap.contains(-3);\n  auto C4 = MyMap.count(-4) < 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C4 = !MyMap.contains(-4);\n  auto C5 = MyMap.find(-5) == MyMap.end();\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C5 = !MyMap.contains(-5);\n  return C1 + C2 + C3 + C4 + C5;\n}\n\n// Check for various types\nint testDifferentTypes(std::map<int, int> &M, std::unordered_set<int> &US, std::set<int> &S, std::multimap<int, int> &MM) {\n  bool C1 = M.count(1001);\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C1 = M.contains(1001);\n  bool C2 = US.count(1002);\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C2 = US.contains(1002);\n  bool C3 = S.count(1003);\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C3 = S.contains(1003);\n  bool C4 = MM.count(1004);\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C4 = MM.contains(1004);\n  return C1 + C2 + C3 + C4;\n}\n\n// The check detects all kind of `const`, reference, rvalue-reference and value types.\nint testQualifiedTypes(std::map<int, int> ValueM, std::map<int, int> &RefM, const std::map<int, int> &ConstRefM, std::map<int, int> &&RValueM) {\n  bool C1 = ValueM.count(2001);\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C1 = ValueM.contains(2001);\n  bool C2 = RefM.count(2002);\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C2 = RefM.contains(2002);\n  bool C3 = ConstRefM.count(2003);\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C3 = ConstRefM.contains(2003);\n  bool C4 = RValueM.count(2004);\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C4 = RValueM.contains(2004);\n  return C1 + C2 + C3 + C4;\n}\n\n// This is effectively a membership check, as the result is implicitly casted\n// to `bool`.\nbool returnContains(std::map<int, int> &M) {\n  return M.count(42);\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: return M.contains(42);\n}\n\n// This returns the actual count and should not be rewritten\nint actualCount(std::multimap<int, int> &M) {\n  return M.count(21);\n  // NO-WARNING.\n  // CHECK-FIXES: return M.count(21);\n}\n\n// Check that we are not confused by aliases\nnamespace s2 = std;\nusing MyMapT = s2::map<int, int>;\nint typeAliases(MyMapT &MyMap) {\n  bool C1 = MyMap.count(99);\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: bool C1 = MyMap.contains(99);\n  return C1;\n}\n\n// Check that the tests also trigger for a local variable and not only for\n// function arguments.\nbool localVar() {\n  using namespace std;\n  map<int, int> LocalM;\n  return LocalM.count(42);\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: return LocalM.contains(42);\n}\n\n// Check various usages of an actual `count` which isn't rewritten\nint nonRewrittenCount(std::multimap<int, int> &MyMap) {\n  // This is an actual test if we have at least 2 usages. Shouldn't be rewritten.\n  bool C1 = MyMap.count(1) >= 2;\n  // NO-WARNING.\n  // CHECK-FIXES: bool C1 = MyMap.count(1) >= 2;\n\n  // \"< 0\" makes little sense and is always `false`. Still, let's ensure we\n  // don't accidentally rewrite it to 'contains'.\n  bool C2 = MyMap.count(2) < 0;\n  // NO-WARNING.\n  // CHECK-FIXES: bool C2 = MyMap.count(2) < 0;\n\n  // The `count` is used in some more complicated formula.\n  bool C3 = MyMap.count(1) + MyMap.count(2) * 2 + MyMap.count(3) / 3 >= 20;\n  // NO-WARNING.\n  // CHECK-FIXES: bool C3 = MyMap.count(1) + MyMap.count(2) * 2 + MyMap.count(3) / 3 >= 20;\n\n  // This could theoretically be rewritten into a 'contains' after removig the\n  // `4` on both sides of the comparison. For the time being, we don't detect\n  // this case.\n  bool C4 = MyMap.count(1) + 4 > 4;\n  // NO-WARNING.\n  // CHECK-FIXES: bool C4 = MyMap.count(1) + 4 > 4;\n\n  return C1 + C2 + C3 + C4;\n}\n\n// Check different integer literal suffixes\nint testDifferentIntegerLiteralSuffixes(std::map<int, int> &MyMap) {\n\n  auto C1 = MyMap.count(2) != 0U;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C1 = MyMap.contains(2);\n  auto C2 = MyMap.count(2) != 0UL;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C2 = MyMap.contains(2);\n  auto C3 = 0U != MyMap.count(2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C3 = MyMap.contains(2);\n  auto C4 = 0UL != MyMap.count(2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C4 = MyMap.contains(2);\n  auto C5 = MyMap.count(2) < 1U;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C5 = !MyMap.contains(2);\n  auto C6 = MyMap.count(2) < 1UL;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C6 = !MyMap.contains(2);\n  auto C7 = 1U > MyMap.count(2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:24: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C7 = !MyMap.contains(2);\n  auto C8 = 1UL > MyMap.count(2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: auto C8 = !MyMap.contains(2);\n\n  return C1 + C2 + C3 + C4 + C5 + C6 + C7 + C8;\n}\n\n// We don't want to rewrite if the `contains` call is from a macro expansion\nint testMacroExpansion(std::unordered_set<int> &MySet) {\n#define COUNT_ONES(SET) SET.count(1)\n  // Rewriting the macro would break the code\n  // CHECK-FIXES: #define COUNT_ONES(SET) SET.count(1)\n  // We still want to warn the user even if we don't offer a fixit\n  if (COUNT_ONES(MySet)) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use 'contains' to check for membership [readability-container-contains]\n    // CHECK-MESSAGES: note: expanded from macro 'COUNT_ONES'\n    return COUNT_ONES(MySet);\n  }\n#undef COUNT_ONES\n#define COUNT_ONES count(1)\n  // Rewriting the macro would break the code\n  // CHECK-FIXES: #define COUNT_ONES count(1)\n  // We still want to warn the user even if we don't offer a fixit\n  if (MySet.COUNT_ONES) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use 'contains' to check for membership [readability-container-contains]\n    // CHECK-MESSAGES: note: expanded from macro 'COUNT_ONES'\n    return MySet.COUNT_ONES;\n  }\n#undef COUNT_ONES\n#define MY_SET MySet\n  // CHECK-FIXES: #define MY_SET MySet\n  // We still want to rewrite one of the two calls to `count`\n  if (MY_SET.count(1)) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: use 'contains' to check for membership [readability-container-contains]\n    // CHECK-FIXES: if (MY_SET.contains(1)) {\n    return MY_SET.count(1);\n  }\n#undef MY_SET\n  return 0;\n}\n\n// The following map has the same interface as `std::map`.\ntemplate <class Key, class T>\nstruct CustomMap {\n  unsigned count(const Key &K) const;\n  bool contains(const Key &K) const;\n  void *find(const Key &K);\n  void *end();\n};\n\nvoid testDifferentCheckTypes(CustomMap<int, int> &MyMap) {\n  if (MyMap.count(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MyMap.contains(0)) {};\n\n  MyMap.find(0) != MyMap.end();\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: MyMap.contains(0);\n}\n\nstruct MySubmap : public CustomMap<int, int> {};\n\nvoid testSubclass(MySubmap& MyMap) {\n  if (MyMap.count(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MyMap.contains(0)) {};\n}\n\nusing UsingMap = CustomMap<int, int>;\nstruct MySubmap2 : public UsingMap {};\nusing UsingMap2 = MySubmap2;\n\nvoid testUsing(UsingMap2& MyMap) {\n  if (MyMap.count(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MyMap.contains(0)) {};\n}\n\ntemplate <class Key, class T>\nstruct CustomMapContainsDeleted {\n  unsigned count(const Key &K) const;\n  bool contains(const Key &K) const = delete;\n  void *find(const Key &K);\n  void *end();\n};\n\nstruct SubmapContainsDeleted : public CustomMapContainsDeleted<int, int> {};\n\nvoid testContainsDeleted(CustomMapContainsDeleted<int, int> &MyMap,\n                         SubmapContainsDeleted &MyMap2) {\n  // No warning if the `contains` method is deleted.\n  if (MyMap.count(0)) {};\n  if (MyMap2.count(0)) {};\n}\n\ntemplate <class Key, class T>\nstruct CustomMapPrivateContains {\n  unsigned count(const Key &K) const;\n  void *find(const Key &K);\n  void *end();\n\nprivate:\n  bool contains(const Key &K) const;\n};\n\nstruct SubmapPrivateContains : public CustomMapPrivateContains<int, int> {};\n\nvoid testPrivateContains(CustomMapPrivateContains<int, int> &MyMap,\n                         SubmapPrivateContains &MyMap2) {\n  // No warning if the `contains` method is not public.\n  if (MyMap.count(0)) {};\n  if (MyMap2.count(0)) {};\n}\n\nstruct MyString {};\n\nstruct WeirdNonMatchingContains {\n  unsigned count(char) const;\n  bool contains(const MyString&) const;\n};\n\nvoid testWeirdNonMatchingContains(WeirdNonMatchingContains &MyMap) {\n  // No warning if there is no `contains` method with the right type.\n  if (MyMap.count('a')) {};\n}\n\ntemplate <class T>\nstruct SmallPtrSet {\n  using ConstPtrType = const T*;\n  unsigned count(ConstPtrType Ptr) const;\n  bool contains(ConstPtrType Ptr) const;\n};\n\ntemplate <class T>\nstruct SmallPtrPtrSet {\n  using ConstPtrType = const T**;\n  unsigned count(ConstPtrType Ptr) const;\n  bool contains(ConstPtrType Ptr) const;\n};\n\ntemplate <class T>\nstruct SmallPtrPtrPtrSet {\n  using ConstPtrType = const T***;\n  unsigned count(ConstPtrType Ptr) const;\n  bool contains(ConstPtrType Ptr) const;\n};\n\nvoid testSmallPtrSet(const int ***Ptr,\n                     SmallPtrSet<int> &MySet,\n                     SmallPtrPtrSet<int> &MySet2,\n                     SmallPtrPtrPtrSet<int> &MySet3) {\n  if (MySet.count(**Ptr)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MySet.contains(**Ptr)) {};\n  if (MySet2.count(*Ptr)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MySet2.contains(*Ptr)) {};\n  if (MySet3.count(Ptr)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MySet3.contains(Ptr)) {};\n}\n\nstruct X {};\nstruct Y : public X {};\n\nvoid testSubclassEntry(SmallPtrSet<X>& Set, Y* Entry) {\n  if (Set.count(Entry)) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (Set.contains(Entry)) {}\n}\n\nstruct WeirdPointerApi {\n  unsigned count(int** Ptr) const;\n  bool contains(int* Ptr) const;\n};\n\nvoid testWeirdApi(WeirdPointerApi& Set, int* E) {\n  if (Set.count(&E)) {}\n}\n\nvoid testIntUnsigned(std::set<int>& S, unsigned U) {\n  if (S.count(U)) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (S.contains(U)) {}\n}\n\ntemplate <class T>\nstruct CustomSetConvertible {\n  unsigned count(const T &K) const;\n  bool contains(const T &K) const;\n};\n\nstruct A {};\nstruct B { B() = default; B(const A&) {} };\nstruct C { operator A() const; };\n\nvoid testConvertibleTypes() {\n  CustomSetConvertible<B> MyMap;\n  if (MyMap.count(A())) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MyMap.contains(A())) {};\n\n  CustomSetConvertible<A> MyMap2;\n  if (MyMap2.count(C())) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MyMap2.contains(C())) {};\n\n  if (MyMap2.count(C()) != 0) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (MyMap2.contains(C())) {};\n}\n\ntemplate<class U>\nusing Box = const U& ;\n\ntemplate <class T>\nstruct CustomBoxedSet {\n  unsigned count(Box<T> K) const;\n  bool contains(Box<T> K) const;\n};\n\nvoid testBox() {\n  CustomBoxedSet<int> Set;\n  if (Set.count(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (Set.contains(0)) {};\n}\n\nvoid testOperandPermutations(std::map<int, int>& Map) {\n  if (Map.count(0) != 0) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (Map.contains(0)) {};\n  if (0 != Map.count(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (Map.contains(0)) {};\n  if (Map.count(0) == 0) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (!Map.contains(0)) {};\n  if (0 == Map.count(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (!Map.contains(0)) {};\n  if (Map.find(0) != Map.end()) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (Map.contains(0)) {};\n  if (Map.end() != Map.find(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (Map.contains(0)) {};\n  if (Map.find(0) == Map.end()) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (!Map.contains(0)) {};\n  if (Map.end() == Map.find(0)) {};\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: use 'contains' to check for membership [readability-container-contains]\n  // CHECK-FIXES: if (!Map.contains(0)) {};\n}"
    }
  ]
}