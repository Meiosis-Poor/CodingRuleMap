{
  "name": "SuspiciousCallArgument",
  "language": "cpp",
  "description": ".. title:: clang-tidy - readability-suspicious-call-argument",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 810,
  "branches": 118,
  "apis": 409,
  "test": [
    {
      "description": null,
      "expected-problems": 35,
      "expected-linenumbers": [
        33,
        34,
        60,
        76,
        88,
        109,
        114,
        119,
        167,
        193,
        212,
        226,
        233,
        242,
        249,
        281,
        302,
        314,
        401,
        405,
        410,
        415,
        420,
        425,
        430,
        435,
        440,
        446,
        450,
        453,
        460,
        470,
        472,
        512,
        513
      ],
      "code": "\n// RUN: %check_clang_tidy %s readability-suspicious-call-argument %t -- -- -std=c++11\n\nvoid foo_1(int aaaaaa, int bbbbbb) {}\n\nvoid foo_2(int source, int aaaaaa) {}\n\nvoid foo_3(int valToRet, int aaaaaa) {}\n\nvoid foo_4(int pointer, int aaaaaa) {}\n\nvoid foo_5(int aaaaaa, int bbbbbb, int cccccc, ...) {}\n\nvoid foo_6(const int dddddd, bool &eeeeee) {}\n\nvoid foo_7(int aaaaaa, int bbbbbb, int cccccc, int ffffff = 7) {}\n\nvoid foo_8(int frobble1, int frobble2) {}\n\n// Test functions for convertible argument--parameter types.\nvoid fun(const int &m);\nvoid fun2() {\n  int m = 3;\n  fun(m);\n}\n\n// Test cases for parameters of const reference and value.\nvoid value_const_reference(int llllll, const int &kkkkkk);\n\nvoid const_ref_value_swapped() {\n  const int &kkkkkk = 42;\n  const int &llllll = 42;\n  value_const_reference(kkkkkk, llllll);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'kkkkkk' (passed to 'llllll') looks like it might be swapped with the 2nd, 'llllll' (passed to 'kkkkkk') [readability-suspicious-call-argument]\n  // CHECK-MESSAGES: :[[@LINE-7]]:6: note: in the call to 'value_const_reference', declared here\n}\n\n// Const, non const references.\nvoid const_nonconst_parameters(const int &mmmmmm, int &nnnnnn);\n\nvoid const_nonconst_swap1() {\n  const int &nnnnnn = 42;\n  int mmmmmm;\n  // Do not check, because non-const reference parameter cannot bind to const reference argument.\n  const_nonconst_parameters(nnnnnn, mmmmmm);\n}\n\nvoid const_nonconst_swap3() {\n  const int nnnnnn = 42;\n  int m = 42;\n  int &mmmmmm = m;\n  // Do not check, const int does not bind to non const reference.\n  const_nonconst_parameters(nnnnnn, mmmmmm);\n}\n\nvoid const_nonconst_swap2() {\n  int nnnnnn;\n  int mmmmmm;\n  // Check for swapped arguments. (Both arguments are non-const.)\n  const_nonconst_parameters(nnnnnn, mmmmmm);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'nnnnnn' (passed to 'mmmmmm') looks like it might be swapped with the 2nd, 'mmmmmm' (passed to 'nnnnnn')\n}\n\nvoid const_nonconst_pointers(const int *mmmmmm, int *nnnnnn);\nvoid const_nonconst_pointers2(const int *mmmmmm, const int *nnnnnn);\n\nvoid const_nonconst_pointers_swapped() {\n  int *mmmmmm;\n  const int *nnnnnn;\n  const_nonconst_pointers(nnnnnn, mmmmmm);\n}\n\nvoid const_nonconst_pointers_swapped2() {\n  const int *mmmmmm;\n  int *nnnnnn;\n  const_nonconst_pointers2(nnnnnn, mmmmmm);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'nnnnnn' (passed to 'mmmmmm') looks like it might be swapped with the 2nd, 'mmmmmm' (passed to 'nnnnnn')\n}\n\n// Test cases for pointers and arrays.\nvoid pointer_array_parameters(\n    int *pppppp, int qqqqqq[4]);\n\nvoid pointer_array_swap() {\n  int qqqqqq[5];\n  int *pppppp;\n  // Check for swapped arguments. An array implicitly converts to a pointer.\n  pointer_array_parameters(qqqqqq, pppppp);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'qqqqqq' (passed to 'pppppp') looks like it might be swapped with the 2nd, 'pppppp' (passed to 'qqqqqq')\n}\n\n// Test cases for multilevel pointers.\nvoid multilevel_pointer_parameters(int *const **pppppp,\n                                   const int *const *volatile const *qqqqqq);\nvoid multilevel_pointer_parameters2(\n    char *****nnnnnn, char *volatile *const *const *const *const &mmmmmm);\n\ntypedef float T;\ntypedef T *S;\ntypedef S *const volatile R;\ntypedef R *Q;\ntypedef Q *P;\ntypedef P *O;\nvoid multilevel_pointer_parameters3(float **const volatile ***rrrrrr, O &ssssss);\n\nvoid multilevel_pointer_swap() {\n  int *const **qqqqqq;\n  int *const **pppppp;\n  multilevel_pointer_parameters(qqqqqq, pppppp);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'qqqqqq' (passed to 'pppppp') looks like it might be swapped with the 2nd, 'pppppp' (passed to 'qqqqqq')\n\n  char *****mmmmmm;\n  char *****nnnnnn;\n  multilevel_pointer_parameters2(mmmmmm, nnnnnn);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'mmmmmm' (passed to 'nnnnnn') looks like it might be swapped with the 2nd, 'nnnnnn' (passed to 'mmmmmm')\n\n  float **const volatile ***rrrrrr;\n  float **const volatile ***ssssss;\n  multilevel_pointer_parameters3(ssssss, rrrrrr);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'ssssss' (passed to 'rrrrrr') looks like it might be swapped with the 2nd, 'rrrrrr' (passed to 'ssssss')\n}\n\nvoid multilevel_pointer_parameters4(char ****pppppp,\n                                    char *const volatile **const *qqqqqq);\nvoid multilevel_pointer_parameters5(\n    bool *****nnnnnn, bool *volatile *const *const *const *&mmmmmm);\nvoid multilevel_pointer_parameters6(double **llllll, char **&kkkkkk);\nvoid multilevel_pointer_parameters7(const volatile int ***iiiiii,\n                                    const int *const *const *jjjjjj);\n\nvoid multilevel_pointer_swap3() {\n  char ****qqqqqq;\n  char *const volatile **const *pppppp;\n  // Do not check.\n  multilevel_pointer_parameters4(qqqqqq, pppppp);\n\n  bool *****mmmmmm;\n  bool *volatile *const *const *const *nnnnnn;\n  // Do not check.\n  multilevel_pointer_parameters5(mmmmmm, nnnnnn);\n\n  double **kkkkkk;\n  char **llllll;\n  multilevel_pointer_parameters6(kkkkkk, llllll);\n\n  const volatile int ***jjjjjj;\n  const int *const *const *iiiiii;\n  multilevel_pointer_parameters7(jjjjjj, iiiiii);\n}\n\n// Test cases for multidimesional arrays.\nvoid multilevel_array_parameters(int pppppp[2][2][2], const int qqqqqq[][2][2]);\n\nvoid multilevel_array_parameters2(int (*mmmmmm)[2][2], int nnnnnn[9][2][23]);\n\nvoid multilevel_array_parameters3(int (*eeeeee)[2][2], int (&ffffff)[1][2][2]);\n\nvoid multilevel_array_parameters4(int (*llllll)[2][2], int kkkkkk[2][2]);\n\nvoid multilevel_array_parameters5(int iiiiii[2][2], char jjjjjj[2][2]);\n\nvoid multilevel_array_parameters6(int (*bbbbbb)[2][2], int cccccc[1][2][2]);\n\nvoid multilevel_array_swap() {\n  int qqqqqq[1][2][2];\n  int pppppp[][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}}; // int [2][2][2]\n  multilevel_array_parameters(qqqqqq, pppppp);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'qqqqqq' (passed to 'pppppp') looks like it might be swapped with the 2nd, 'pppppp' (passed to 'qqqqqq')\n\n  int(*nnnnnn)[2][2];\n  int mmmmmm[9][2][23];\n  // Do not check, array sizes has to match in every dimension, except the first.\n  multilevel_array_parameters2(nnnnnn, mmmmmm);\n\n  int ffffff[][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}}; // int [2][2][2]\n  int eeeeee[1][2][2] = {{{1, 2}, {1, 2}}};                  // int [1][2][2]\n  // Do not check, for array references, size has to match in every dimension.\n  multilevel_array_parameters3(ffffff, eeeeee);\n\n  int kkkkkk[2][2][2];\n  int(*llllll)[2];\n  // Do not check, argument dimensions differ.\n  multilevel_array_parameters4(kkkkkk, llllll);\n\n  int jjjjjj[2][2];\n  char iiiiii[2][2];\n  // Do not check, array element types differ.\n  multilevel_array_parameters5(jjjjjj, iiiiii);\n\n  int t[][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}}; // int [2][2][2]\n  int(*cccccc)[2][2] = t;                               // int (*)[2][2]\n  int bbbbbb[][2][2] = {{{1, 2}, {1, 2}}};              // int [1][2][2]\n  multilevel_array_parameters6(cccccc, bbbbbb);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'bbbbbb') looks like it might be swapped with the 2nd, 'bbbbbb' (passed to 'cccccc')\n}\n\nvoid multilevel_array_swap2() {\n  int qqqqqq[2][2][2];\n  const int pppppp[][2][2] = {{{1, 2}, {1, 2}}, {{1, 2}, {1, 2}}};\n  // Do not check, pppppp is const and cannot bind to an array with nonconst elements.\n  multilevel_array_parameters(qqqqqq, pppppp);\n}\n\n// Complex test case.\nvoid multilevel_pointer_array_parameters(const int(*const (*volatile const (*const (*const (*const &aaaaaa)[1])[32])[4])[3][2][2]), const int(*const (*volatile const (*const (*const (*&bbbbbb)[1])[32])[4])[3][2][2]));\n\nvoid multilevel_pointer_array_swap() {\n  const int(\n          *const(*volatile const(*const(*const(*aaaaaa)[1])[32])[4])[3][2][2]);\n  const int(\n          *const(*volatile const(*const(*const(*bbbbbb)[1])[32])[4])[3][2][2]);\n  multilevel_pointer_array_parameters(bbbbbb, aaaaaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'bbbbbb' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaaaa' (passed to 'bbbbbb')\n}\n\nenum class numbers_scoped { one,\n                            two };\n\n// Test cases for arithmetic types.\nvoid arithmetic_type_parameters(float vvvvvv, int wwwwww);\nvoid arithmetic_type_parameters2(numbers_scoped vvvvvv, int wwwwww);\n\nvoid arithmetic_types_swap1() {\n  bool wwwwww;\n  float vvvvvv;\n  arithmetic_type_parameters(wwwwww, vvvvvv);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'wwwwww' (passed to 'vvvvvv') looks like it might be swapped with the 2nd, 'vvvvvv' (passed to 'wwwwww')\n}\n\nvoid arithmetic_types_swap3() {\n  char wwwwww;\n  unsigned long long int vvvvvv;\n  arithmetic_type_parameters(wwwwww, vvvvvv);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'wwwwww' (passed to 'vvvvvv') looks like it might be swapped with the 2nd, 'vvvvvv' (passed to 'wwwwww')\n}\n\nvoid arithmetic_types_swap4() {\n  enum numbers { one,\n                 two };\n  numbers wwwwww = numbers::one;\n  int vvvvvv;\n  arithmetic_type_parameters(wwwwww, vvvvvv);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'wwwwww' (passed to 'vvvvvv') looks like it might be swapped with the 2nd, 'vvvvvv' (passed to 'wwwwww')\n}\n\nvoid arithmetic_types_swap5() {\n  wchar_t vvvvvv;\n  float wwwwww;\n  arithmetic_type_parameters(wwwwww, vvvvvv);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'wwwwww' (passed to 'vvvvvv') looks like it might be swapped with the 2nd, 'vvvvvv' (passed to 'wwwwww')\n}\n\nvoid arithmetic_types_swap6() {\n  wchar_t vvvvvv;\n  numbers_scoped wwwwww = numbers_scoped::one;\n  // Do not check, numers is a scoped enum type.\n  arithmetic_type_parameters2(wwwwww, vvvvvv);\n}\n\n// Base, derived\nclass TestClass {\npublic:\n  void thisFunction(int integerParam, int thisIsPARAM) {}\n};\n\nclass DerivedTestClass : public TestClass {};\n\nvoid base_derived_pointer_parameters(TestClass *aaaaaa,\n                                     DerivedTestClass *bbbbbb);\n\nvoid base_derived_swap1() {\n  TestClass *bbbbbb;\n  DerivedTestClass *aaaaaa;\n  // Do not check, because TestClass does not convert implicitly to DerivedTestClass.\n  base_derived_pointer_parameters(bbbbbb, aaaaaa);\n}\n\nvoid base_derived_swap2() {\n  DerivedTestClass *bbbbbb, *aaaaaa;\n  // Check for swapped arguments, DerivedTestClass converts to TestClass implicitly.\n  base_derived_pointer_parameters(bbbbbb, aaaaaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'bbbbbb' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaaaa' (passed to 'bbbbbb')\n}\n\nclass PrivateDerivedClass : private TestClass {};\n\nvoid private_derived_pointer_parameters(TestClass *aaaaaa, PrivateDerivedClass *bbbbbb);\n\nvoid private_base_swap1() {\n  TestClass *bbbbbb;\n  PrivateDerivedClass *aaaaaa;\n  private_derived_pointer_parameters(bbbbbb, aaaaaa);\n}\n\n// Multilevel inheritance\nclass DerivedOfDerivedTestClass : public DerivedTestClass {};\n\nvoid multi_level_inheritance_swap() {\n  DerivedOfDerivedTestClass *aaaaaa, *bbbbbb;\n  // Check for swapped arguments. Derived classes implicitly convert to their base.\n  base_derived_pointer_parameters(\n      bbbbbb, aaaaaa);\n  // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: 1st argument 'bbbbbb' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaaaa' (passed to 'bbbbbb')\n}\n\n// Tests for function pointer swaps\nvoid funct_ptr_params(double (*ffffff)(int, int), double (*gggggg)(int, int));\nvoid funct_ptr_params(double (*ffffff)(int, int), int (*gggggg)(int, int));\n\ndouble ffffff(int a, int b) { return 0; }\ndouble gggggg(int a, int b) { return 0; }\n\nvoid funtionc_ptr_params_swap() {\n  funct_ptr_params(gggggg, ffffff);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'gggggg' (passed to 'ffffff') looks like it might be swapped with the 2nd, 'ffffff' (passed to 'gggggg')\n}\n\nint fffff(int a, int b) { return 0; }\n\nvoid function_ptr_swap2() {\n  // Do not check, because the function `ffffff` cannot convert to a function\n  // with prototype: double(int,int).\n  funct_ptr_params(gggggg, fffff);\n}\n\n// Paraphrased example from Z3 (src/qe/qe_arrays.cpp) which originally produced\n// a false positive. Operator() calls should ignore the called object\n// \"argument\".\nstruct type1;\nstruct type2;\nstruct type3;\n\nstruct callable1 {\n  void operator()(type1 &mdl, type2 &arr_vars, type3 &fml, type2 &aux_vars) const {}\n};\n\nstruct callable2 {\n  void operator()(type1 &mdl, type2 &arr_vars, type3 &fml, type2 &aux_vars,\n                  bool reduce_all_selects) const {\n    (void)reduce_all_selects;\n    callable1 pe;\n    pe(mdl, arr_vars, fml, aux_vars);\n    // NO-WARN: Argument and parameter names match perfectly, \"pe\" should be\n    // ignored!\n  }\n};\n\nstruct binop_t {};\n\nbinop_t operator+(const binop_t &lhs, const binop_t &rhs) { return lhs; }\nbool operator<(const binop_t &lhs, const binop_t &rhs) { return true; }\nbool operator>(const binop_t &aaaaaa, const binop_t &bbbbbb) { return false; }\n\nvoid binop_test() {\n  // NO-WARN: Binary operators are ignored.\n  binop_t lhs, rhs;\n  if (lhs + rhs < rhs)\n    return;\n\n  if (operator<(rhs, lhs))\n    return;\n\n  binop_t aaaaaa, cccccc;\n  if (operator>(cccccc, aaaaaa))\n    return;\n}\n\nint recursion(int aaaa, int bbbb) {\n  if (aaaa)\n    return 0;\n\n  int cccc = 0;\n  return recursion(bbbb, cccc);\n  // NO-WARN: Recursive calls usually shuffle with arguments and we ignore those.\n}\n\nvoid pass_by_copy(binop_t xxxx, binop_t yyyy) {}\n\n// Paraphrased example from LLVM's code (lib/Analysis/InstructionSimplify.cpp)\n// that generated a false positive.\nstruct value;\nenum opcode { Foo,\n              Bar };\nstatic value *SimplifyRightShift(\n    opcode Opcode, value *Op0, value *Op1, bool isExact,\n    const type1 &Q, unsigned MaxRecurse) { return nullptr; }\nstatic value *SimplifyLShrInst(value *Op0, value *Op1, bool isExact,\n                               const type1 &Q, unsigned MaxRecurse) {\n  if (value *V = SimplifyRightShift(Foo, Op0, Op1, isExact, Q, MaxRecurse))\n    return V;\n  // NO-WARN: Argument names perfectly match parameter names, sans the enum.\n\n  return nullptr;\n}\n\nvoid has_unnamed(int aaaaaa, int) {}\n\nint main() {\n  // Equality test.\n  int aaaaaa, cccccc = 0;\n  foo_1(cccccc, aaaaaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaaaa' (passed to 'bbbbbb')\n\n  binop_t xxxx, yyyy;\n  pass_by_copy(yyyy, xxxx);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'yyyy' (passed to 'xxxx') looks like it might be swapped with the 2nd, 'xxxx' (passed to 'yyyy')\n\n  // Abbreviation test.\n  int src = 0;\n  foo_2(aaaaaa, src);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'aaaaaa' (passed to 'source') looks like it might be swapped with the 2nd, 'src' (passed to 'aaaaaa')\n\n  // Levenshtein test.\n  int aaaabb = 0;\n  foo_1(cccccc, aaaabb);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaabb' (passed to 'bbbbbb')\n\n  // Prefix test.\n  int aaaa = 0;\n  foo_1(cccccc, aaaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaa' (passed to 'bbbbbb')\n\n  // Suffix test.\n  int urce = 0;\n  foo_2(cccccc, urce);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'source') looks like it might be swapped with the 2nd, 'urce' (passed to 'aaaaaa')\n\n  // Substring test.\n  int ourc = 0;\n  foo_2(cccccc, ourc);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'source') looks like it might be swapped with the 2nd, 'ourc' (passed to 'aaaaaa')\n\n  // Jaro-Winkler test.\n  int iPonter = 0;\n  foo_4(cccccc, iPonter);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'pointer') looks like it might be swapped with the 2nd, 'iPonter' (passed to 'aaaaaa')\n\n  // Dice test.\n  int aaabaa = 0;\n  foo_1(cccccc, aaabaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaabaa' (passed to 'bbbbbb')\n\n  // Variadic function test.\n  int bbbbbb = 0;\n  foo_5(src, bbbbbb, cccccc, aaaaaa); // Should pass.\n  foo_5(cccccc, bbbbbb, aaaaaa, src);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'aaaaaa') looks like it might be swapped with the 3rd, 'aaaaaa' (passed to 'cccccc')\n\n  // Test function with default argument.\n  foo_7(src, bbbbbb, cccccc, aaaaaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'src' (passed to 'aaaaaa') looks like it might be swapped with the 4th, 'aaaaaa' (passed to 'ffffff')\n\n  foo_7(cccccc, bbbbbb, aaaaaa, src);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'cccccc' (passed to 'aaaaaa') looks like it might be swapped with the 3rd, 'aaaaaa' (passed to 'cccccc')\n\n  int ffffff = 0;\n  foo_7(ffffff, bbbbbb, cccccc); // NO-WARN: Even though 'ffffff' is passed to 'aaaaaa' and there is a 4th parameter 'ffffff', there isn't a **swap** here.\n\n  int frobble1 = 1, frobble2 = 2;\n  foo_8(frobble2, frobble1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'frobble2' (passed to 'frobble1') looks like it might be swapped with the 2nd, 'frobble1' (passed to 'frobble2')\n\n  int bar1 = 1, bar2 = 2;\n  foo_8(bar2, bar1); // NO-WARN.\n\n  // Type match\n  bool dddddd = false;\n  int eeeeee = 0;\n  auto szam = 0;\n  foo_6(eeeeee, dddddd);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'eeeeee' (passed to 'dddddd') looks like it might be swapped with the 2nd, 'dddddd' (passed to 'eeeeee')\n  foo_1(szam, aaaaaa);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'szam' (passed to 'aaaaaa') looks like it might be swapped with the 2nd, 'aaaaaa' (passed to 'bbbbbb')\n\n  // Test lambda.\n  auto testMethod = [&](int method, int randomParam) { return 0; };\n  int method = 0;\n  testMethod(method, 0); // Should pass.\n\n  // Member function test.\n  TestClass test;\n  int integ, thisIsAnArg = 0;\n  test.thisFunction(integ, thisIsAnArg); // Should pass.\n\n  has_unnamed(1, bbbbbb);\n\n  return 0;\n}\n\nnamespace Issue_54074 {\n\nclass T {};\nusing OperatorTy = int(const T &, const T &);\nint operator-(const T &, const T &);\n\ntemplate <typename U>\nstruct Wrap {\n  Wrap(U);\n};\n\ntemplate <typename V>\nvoid wrapTaker(V, Wrap<OperatorTy>);\n\ntemplate <typename V>\nvoid wrapTaker(V aaaaa, V bbbbb, Wrap<OperatorTy>);\n\nvoid test() {\n  wrapTaker(0, operator-);\n  // NO-WARN. No crash!\n\n  int aaaaa = 4, bbbbb = 8;\n  wrapTaker(bbbbb, aaaaa, operator-);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: 1st argument 'bbbbb' (passed to 'aaaaa') looks like it might be swapped with the 2nd, 'aaaaa' (passed to 'bbbbb')\n  // CHECK-MESSAGES: :[[@LINE-9]]:6: note: in the call to 'wrapTaker<int>', declared here\n}\n\n} // namespace Issue_54074"
    }
  ]
}