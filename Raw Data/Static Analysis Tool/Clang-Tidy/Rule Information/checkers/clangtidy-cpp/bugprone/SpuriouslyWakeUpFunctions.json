{
  "name": "SpuriouslyWakeUpFunctions",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-spuriously-wake-up-functions",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 86,
  "branches": 6,
  "apis": 97,
  "test": [
    {
      "description": null,
      "expected-problems": 3,
      "expected-linenumbers": [
        123,
        159,
        177
      ],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-spuriously-wake-up-functions %t -- --\n#define NULL 0\n\nnamespace std {\nusing intmax_t = int;\n\ntemplate <intmax_t N, intmax_t D = 1>\nclass ratio {\npublic:\n  static constexpr intmax_t num = 0;\n  static constexpr intmax_t den = 0;\n  typedef ratio<num, den> type;\n};\ntypedef ratio<1, 1000> milli;\nnamespace chrono {\n\ntemplate <class Rep, class Period = ratio<1>>\nclass duration {\npublic:\n  using rep = Rep;\n  using period = Period;\n\npublic:\n  constexpr duration() = default;\n  template <class Rep2>\n  constexpr explicit duration(const Rep2 &r);\n  template <class Rep2, class Period2>\n  constexpr duration(const duration<Rep2, Period2> &d);\n  ~duration() = default;\n  duration(const duration &) = default;\n};\n\ntemplate <class Clock, class Duration = typename Clock::duration>\nclass time_point {\npublic:\n  using clock = Clock;\n  using duration = Duration;\n\npublic:\n  constexpr time_point();\n  constexpr explicit time_point(const duration &d);\n  template <class Duration2>\n  constexpr time_point(const time_point<clock, Duration2> &t);\n};\n\nusing milliseconds = duration<int, milli>;\n\nclass system_clock {\npublic:\n  typedef milliseconds duration;\n  typedef duration::rep rep;\n  typedef duration::period period;\n  typedef chrono::time_point<system_clock> time_point;\n\n  static time_point now() noexcept;\n};\n} // namespace chrono\n\nclass mutex;\ntemplate <class Mutex>\nclass unique_lock {\npublic:\n  typedef Mutex mutex_type;\n\n  unique_lock() noexcept;\n  explicit unique_lock(mutex_type &m);\n};\n\nclass mutex {\npublic:\n  constexpr mutex() noexcept;\n  ~mutex();\n  mutex(const mutex &) = delete;\n  mutex &operator=(const mutex &) = delete;\n};\n\nenum class cv_status {\n  no_timeout,\n  timeout\n};\n\nclass condition_variable {\npublic:\n  condition_variable();\n  ~condition_variable();\n  condition_variable(const condition_variable &) = delete;\n\n  void wait(unique_lock<mutex> &lock);\n  template <class Predicate>\n  void wait(unique_lock<mutex> &lock, Predicate pred);\n  template <class Clock, class Duration>\n  cv_status wait_until(unique_lock<mutex> &lock,\n                       const chrono::time_point<Clock, Duration> &abs_time){ return cv_status::no_timeout; };\n  template <class Clock, class Duration, class Predicate>\n  bool wait_until(unique_lock<mutex> &lock,\n                  const chrono::time_point<Clock, Duration> &abs_time,\n                  Predicate pred){ return false; };\n  template <class Rep, class Period>\n  cv_status wait_for(unique_lock<mutex> &lock,\n                     const chrono::duration<Rep, Period> &rel_time){ return cv_status::no_timeout; };\n  template <class Rep, class Period, class Predicate>\n  bool wait_for(unique_lock<mutex> &lock,\n                const chrono::duration<Rep, Period> &rel_time,\n                Predicate pred){ return false; };\n};\n\n} // namespace std\n\nstruct Node1 {\n  void *Node1;\n  struct Node1 *next;\n};\n\nstatic Node1 list;\nstatic std::mutex m;\nstatic std::condition_variable condition;\n\nvoid consume_list_element(std::condition_variable &condition) {\n  std::unique_lock<std::mutex> lk(m);\n\n  if (list.next == nullptr) {\n    condition.wait(lk);\n    // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: 'wait' should be placed inside a while statement or used with a conditional parameter [bugprone-spuriously-wake-up-functions]\n  }\n\n  while (list.next == nullptr) {\n    condition.wait(lk);\n  }\n\n  do {\n    condition.wait(lk);\n  } while (list.next == nullptr);\n\n  for (;; list.next == nullptr) {\n    condition.wait(lk);\n  }\n\n  if (list.next == nullptr) {\n    while (list.next == nullptr) {\n      condition.wait(lk);\n    }\n  }\n\n  if (list.next == nullptr) {\n    do {\n      condition.wait(lk);\n    } while (list.next == nullptr);\n  }\n\n  if (list.next == nullptr) {\n    for (;; list.next == nullptr) {\n      condition.wait(lk);\n    }\n  }\n  using durtype = std::chrono::duration<int, std::milli>;\n  durtype dur = std::chrono::duration<int, std::milli>();\n  if (list.next == nullptr) {\n    condition.wait_for(lk, dur);\n    // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: 'wait_for' should be placed inside a while statement or used with a conditional parameter [bugprone-spuriously-wake-up-functions]\n  }\n  if (list.next == nullptr) {\n    condition.wait_for(lk, dur, [] { return 1; });\n  }\n  while (list.next == nullptr) {\n    condition.wait_for(lk, dur);\n  }\n  do {\n    condition.wait_for(lk, dur);\n  } while (list.next == nullptr);\n  for (;; list.next == nullptr) {\n    condition.wait_for(lk, dur);\n  }\n\n  auto now = std::chrono::system_clock::now();\n  if (list.next == nullptr) {\n    condition.wait_until(lk, now);\n    // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: 'wait_until' should be placed inside a while statement or used with a conditional parameter [bugprone-spuriously-wake-up-functions]\n  }\n  if (list.next == nullptr) {\n    condition.wait_until(lk, now, [] { return 1; });\n  }\n  while (list.next == nullptr) {\n    condition.wait_until(lk, now);\n  }\n  do {\n    condition.wait_until(lk, now);\n  } while (list.next == nullptr);\n  for (;; list.next == nullptr) {\n    condition.wait_until(lk, now);\n  }\n}"
    }
  ]
}