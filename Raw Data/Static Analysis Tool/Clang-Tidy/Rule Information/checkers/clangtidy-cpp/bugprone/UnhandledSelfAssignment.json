{
  "name": "UnhandledSelfAssignment",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-unhandled-self-assignment",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 110,
  "branches": 7,
  "apis": 108,
  "test": [
    {
      "description": null,
      "expected-problems": 17,
      "expected-linenumbers": [
        47,
        56,
        68,
        80,
        92,
        104,
        117,
        131,
        147,
        161,
        180,
        193,
        207,
        223,
        568,
        581,
        601
      ],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-unhandled-self-assignment %t -- -- -fno-delayed-template-parsing\n\nnamespace std {\n\ntemplate <class T>\nvoid swap(T &x, T &y) {\n}\n\ntemplate <class T>\nT &&move(T &x) {\n}\n\ntemplate <typename T> class default_delete {};\n\ntemplate <class T, typename Deleter = std::default_delete<T>>\nclass unique_ptr {\n};\n\ntemplate <class T>\nclass shared_ptr {\n};\n\ntemplate <class T>\nclass weak_ptr {\n};\n\ntemplate <class T>\nclass auto_ptr {\n};\n\n} // namespace std\n\nvoid assert(int expression){};\n\n///////////////////////////////////////////////////////////////////\n/// Test cases correctly caught by the check.\n\nclass PtrField {\npublic:\n  PtrField &operator=(const PtrField &object);\n\nprivate:\n  int *p;\n};\n\nPtrField &PtrField::operator=(const PtrField &object) {\n  // CHECK-MESSAGES: [[@LINE-1]]:21: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n  // ...\n  return *this;\n}\n\n// Class with an inline operator definition.\nclass InlineDefinition {\npublic:\n  InlineDefinition &operator=(const InlineDefinition &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:21: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\nclass UniquePtrField {\npublic:\n  UniquePtrField &operator=(const UniquePtrField &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:19: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  std::unique_ptr<int> p;\n};\n\nclass SharedPtrField {\npublic:\n  SharedPtrField &operator=(const SharedPtrField &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:19: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  std::shared_ptr<int> p;\n};\n\nclass WeakPtrField {\npublic:\n  WeakPtrField &operator=(const WeakPtrField &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:17: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  std::weak_ptr<int> p;\n};\n\nclass AutoPtrField {\npublic:\n  AutoPtrField &operator=(const AutoPtrField &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:17: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  std::auto_ptr<int> p;\n};\n\n// Class with C array field.\nclass CArrayField {\npublic:\n  CArrayField &operator=(const CArrayField &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:16: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  int array[256];\n};\n\n// Make sure to not ignore cases when the operator definition calls\n// a copy constructor of another class.\nclass CopyConstruct {\npublic:\n  CopyConstruct &operator=(const CopyConstruct &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:18: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    WeakPtrField a;\n    WeakPtrField b(a);\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// Make sure to not ignore cases when the operator definition calls\n// a copy assignment operator of another class.\nclass AssignOperator {\npublic:\n  AssignOperator &operator=(const AssignOperator &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:19: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    a.operator=(object.a);\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n  WeakPtrField a;\n};\n\nclass NotSelfCheck {\npublic:\n  NotSelfCheck &operator=(const NotSelfCheck &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:17: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    if (&object == this->doSomething()) {\n      // ...\n    }\n    return *this;\n  }\n\n  void *doSomething() {\n    return p;\n  }\n\nprivate:\n  int *p;\n};\n\ntemplate <class T>\nclass TemplatePtrField {\npublic:\n  TemplatePtrField<T> &operator=(const TemplatePtrField<T> &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:24: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  T *p;\n};\n\ntemplate <class T>\nclass TemplateCArrayField {\npublic:\n  TemplateCArrayField<T> &operator=(const TemplateCArrayField<T> &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:27: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    // ...\n    return *this;\n  }\n\nprivate:\n  T p[256];\n};\n\n// Other template class's constructor is called inside a declaration.\ntemplate <class T>\nclass WrongTemplateCopyAndMove {\npublic:\n  WrongTemplateCopyAndMove<T> &operator=(const WrongTemplateCopyAndMove<T> &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:32: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    TemplatePtrField<T> temp;\n    TemplatePtrField<T> temp2(temp);\n    return *this;\n  }\n\nprivate:\n  T *p;\n};\n\n// https://bugs.llvm.org/show_bug.cgi?id=44499\nclass Foo2;\ntemplate <int a>\nbool operator!=(Foo2 &, Foo2 &) {\n  class Bar2 {\n    Bar2 &operator=(const Bar2 &other) {\n      // CHECK-MESSAGES: [[@LINE-1]]:11: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n      p = other.p;\n      return *this;\n    }\n\n    int *p;\n  };\n}\n\n///////////////////////////////////////////////////////////////////\n/// Test cases correctly ignored by the check.\n\n// Self-assignment is checked using the equality operator.\nclass SelfCheck1 {\npublic:\n  SelfCheck1 &operator=(const SelfCheck1 &object) {\n    if (this == &object)\n      return *this;\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\nclass SelfCheck2 {\npublic:\n  SelfCheck2 &operator=(const SelfCheck2 &object) {\n    if (&object == this)\n      return *this;\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// Self-assignment is checked using the inequality operator.\nclass SelfCheck3 {\npublic:\n  SelfCheck3 &operator=(const SelfCheck3 &object) {\n    if (this != &object) {\n      // ...\n    }\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\nclass SelfCheck4 {\npublic:\n  SelfCheck4 &operator=(const SelfCheck4 &object) {\n    if (&object != this) {\n      // ...\n    }\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\ntemplate <class T>\nclass TemplateSelfCheck {\npublic:\n  TemplateSelfCheck<T> &operator=(const TemplateSelfCheck<T> &object) {\n    if (&object != this) {\n      // ...\n    }\n    return *this;\n  }\n\nprivate:\n  T *p;\n};\n\n// https://bugs.llvm.org/show_bug.cgi?id=44499\nclass Foo;\ntemplate <int a>\nbool operator!=(Foo &, Foo &) {\n  class Bar {\n    Bar &operator=(const Bar &other) {\n      if (this != &other) {\n      }\n      return *this;\n    }\n\n    int *p;\n  };\n}\n\n// There is no warning if the copy assignment operator gets the object by value.\nclass PassedByValue {\npublic:\n  PassedByValue &operator=(PassedByValue object) {\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// User-defined swap method calling std::swap inside.\nclass CopyAndSwap1 {\npublic:\n  CopyAndSwap1 &operator=(const CopyAndSwap1 &object) {\n    CopyAndSwap1 temp(object);\n    doSwap(temp);\n    return *this;\n  }\n\nprivate:\n  int *p;\n\n  void doSwap(CopyAndSwap1 &object) {\n    using std::swap;\n    swap(p, object.p);\n  }\n};\n\n// User-defined swap method used with passed-by-value parameter.\nclass CopyAndSwap2 {\npublic:\n  CopyAndSwap2 &operator=(CopyAndSwap2 object) {\n    doSwap(object);\n    return *this;\n  }\n\nprivate:\n  int *p;\n\n  void doSwap(CopyAndSwap2 &object) {\n    using std::swap;\n    swap(p, object.p);\n  }\n};\n\n// Copy-and-swap method is used but without creating a separate method for it.\nclass CopyAndSwap3 {\npublic:\n  CopyAndSwap3 &operator=(const CopyAndSwap3 &object) {\n    CopyAndSwap3 temp(object);\n    std::swap(p, temp.p);\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\ntemplate <class T>\nclass TemplateCopyAndSwap {\npublic:\n  TemplateCopyAndSwap<T> &operator=(const TemplateCopyAndSwap<T> &object) {\n    TemplateCopyAndSwap<T> temp(object);\n    std::swap(p, temp.p);\n    return *this;\n  }\n\nprivate:\n  T *p;\n};\n\n// Move semantics is used on a temporary copy of the object.\nclass CopyAndMove1 {\npublic:\n  CopyAndMove1 &operator=(const CopyAndMove1 &object) {\n    CopyAndMove1 temp(object);\n    *this = std::move(temp);\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// There is no local variable for the temporary copy.\nclass CopyAndMove2 {\npublic:\n  CopyAndMove2 &operator=(const CopyAndMove2 &object) {\n    *this = CopyAndMove2(object);\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\ntemplate <class T>\nclass TemplateCopyAndMove {\npublic:\n  TemplateCopyAndMove<T> &operator=(const TemplateCopyAndMove<T> &object) {\n    TemplateCopyAndMove<T> temp(object);\n    *this = std::move(temp);\n    return *this;\n  }\n\nprivate:\n  T *p;\n};\n\n// There is no local variable for the temporary copy.\ntemplate <class T>\nclass TemplateCopyAndMove2 {\npublic:\n  TemplateCopyAndMove2<T> &operator=(const TemplateCopyAndMove2<T> &object) {\n    *this = std::move(TemplateCopyAndMove2<T>(object));\n    return *this;\n  }\n\nprivate:\n  T *p;\n};\n\n// We should not catch move assignment operators.\nclass MoveAssignOperator {\npublic:\n  MoveAssignOperator &operator=(MoveAssignOperator &&object) {\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// We ignore copy assignment operators without user-defined implementation.\nclass DefaultOperator {\npublic:\n  DefaultOperator &operator=(const DefaultOperator &object) = default;\n\nprivate:\n  int *p;\n};\n\nclass DeletedOperator {\npublic:\n  DeletedOperator &operator=(const DefaultOperator &object) = delete;\n\nprivate:\n  int *p;\n};\n\nclass ImplicitOperator {\nprivate:\n  int *p;\n};\n\n// Check ignores those classes which has no any pointer or array field.\nclass TrivialFields {\npublic:\n  TrivialFields &operator=(const TrivialFields &object) {\n    // ...\n    return *this;\n  }\n\nprivate:\n  int m;\n  float f;\n  double d;\n  bool b;\n};\n\n// There is no warning when the class calls another assignment operator on 'this'\n// inside the copy assignment operator's definition.\nclass AssignIsForwarded {\npublic:\n  AssignIsForwarded &operator=(const AssignIsForwarded &object) {\n    operator=(object.p);\n    return *this;\n  }\n\n  AssignIsForwarded &operator=(int *pp) {\n    if (p != pp) {\n      delete p;\n      p = new int(*pp);\n    }\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// Assertion is a valid way to say that self-assignment is not expected to happen.\nclass AssertGuard {\npublic:\n  AssertGuard &operator=(const AssertGuard &object) {\n    assert(this != &object);\n    // ...\n    return *this;\n  }\n\nprivate:\n  int *p;\n};\n\n// Make sure we don't catch this operator=() as a copy assignment operator.\n// Note that RHS has swapped template arguments.\ntemplate <typename Ty, typename Uy>\nclass NotACopyAssignmentOperator {\n  Ty *Ptr1;\n  Uy *Ptr2;\n\npublic:\n  NotACopyAssignmentOperator& operator=(const NotACopyAssignmentOperator<Uy, Ty> &RHS) {\n    Ptr1 = RHS.getUy();\n    Ptr2 = RHS.getTy();\n    return *this;\n  }\n\n  Ty *getTy() const { return Ptr1; }\n  Uy *getUy() const { return Ptr2; }\n};\n\n///////////////////////////////////////////////////////////////////\n/// Test cases which should be caught by the check.\n\n// TODO: handle custom pointers.\ntemplate <class T>\nclass custom_ptr {\n};\n\nclass CustomPtrField {\npublic:\n  CustomPtrField &operator=(const CustomPtrField &object) {\n    // ...\n    return *this;\n  }\n\nprivate:\n  custom_ptr<int> p;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n/// False positives: These are self-assignment safe, but they don't use any of the three patterns.\n\nclass ArrayCopy {\npublic:\n  ArrayCopy &operator=(const ArrayCopy &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:14: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    for (int i = 0; i < 256; i++)\n      array[i] = object.array[i];\n    return *this;\n  }\n\nprivate:\n  int array[256];\n};\n\nclass GetterSetter {\npublic:\n  GetterSetter &operator=(const GetterSetter &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:17: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    setValue(object.getValue());\n    return *this;\n  }\n\n  int *getValue() const { return value; }\n\n  void setValue(int *newPtr) {\n    int *pTmp(newPtr ? new int(*newPtr) : nullptr);\n    std::swap(value, pTmp);\n    delete pTmp;\n  }\n\nprivate:\n  int *value;\n};\n\nclass CustomSelfCheck {\npublic:\n  CustomSelfCheck &operator=(const CustomSelfCheck &object) {\n    // CHECK-MESSAGES: [[@LINE-1]]:20: warning: operator=() does not handle self-assignment properly [bugprone-unhandled-self-assignment]\n    if (index != object.index) {\n      // ...\n    }\n    return *this;\n  }\n\nprivate:\n  int *value;\n  int index;\n};"
    }
  ]
}