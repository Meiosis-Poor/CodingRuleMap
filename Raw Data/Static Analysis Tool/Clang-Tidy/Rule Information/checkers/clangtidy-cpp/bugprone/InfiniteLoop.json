{
  "name": "InfiniteLoop",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-infinite-loop",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 329,
  "branches": 72,
  "apis": 218,
  "test": [
    {
      "description": null,
      "expected-problems": 24,
      "expected-linenumbers": [
        8,
        13,
        18,
        23,
        28,
        37,
        42,
        47,
        52,
        57,
        362,
        412,
        444,
        466,
        478,
        514,
        526,
        591,
        598,
        622,
        641,
        646,
        703,
        709
      ],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-infinite-loop %t \\\n// RUN:                   -- -- -fexceptions -fblocks -fno-delayed-template-parsing\n\nvoid simple_infinite_loop1() {\n  int i = 0;\n  int j = 0;\n  while (i < 10) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i) are updated in the loop body [bugprone-infinite-loop]\n    j++;\n  }\n\n  while (int k = 10) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; it does not check any variables in the condition [bugprone-infinite-loop]\n    j--;\n  }\n\n  while (int k = 10) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; it does not check any variables in the condition [bugprone-infinite-loop]\n    k--;\n  }\n\n  do {\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i) are updated in the loop body [bugprone-infinite-loop]\n    j++;\n  } while (i < 10);\n\n  for (i = 0; i < 10; ++j) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i) are updated in the loop body [bugprone-infinite-loop]\n  }\n}\n\nvoid simple_infinite_loop2() {\n  int i = 0;\n  int j = 0;\n  int Limit = 10;\n  while (i < Limit) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i, Limit) are updated in the loop body [bugprone-infinite-loop]\n    j++;\n  }\n\n  while (int k = Limit) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (Limit) are updated in the loop body [bugprone-infinite-loop]\n    j--;\n  }\n\n  while (int k = Limit) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (Limit) are updated in the loop body [bugprone-infinite-loop]\n    k--;\n  }\n\n  do {\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i, Limit) are updated in the loop body [bugprone-infinite-loop]\n    j++;\n  } while (i < Limit);\n\n  for (i = 0; i < Limit; ++j) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i, Limit) are updated in the loop body [bugprone-infinite-loop]\n  }\n}\n\nvoid simple_not_infinite1() {\n  int i = 0;\n  int Limit = 100;\n  while (i < Limit) {\n    // Not an error since 'Limit' is updated.\n    Limit--;\n  }\n\n  while (Limit--) {\n    // Not an error since 'Limit' is updated.\n    i++;\n  }\n\n  while ((Limit)--) {\n    // Not an error since 'Limit' is updated.\n    i++;\n  }\n\n  while ((Limit) -= 1) {\n    // Not an error since 'Limit' is updated.\n  }\n\n  while (int k = Limit) {\n    // Not an error since 'Limit' is updated.\n    Limit--;\n  }\n\n  while (int k = Limit) {\n    // Not an error since 'Limit' is updated\n    (Limit)--;\n  }\n\n  while (int k = Limit--) {\n    // Not an error since 'Limit' is updated.\n    i++;\n  }\n\n  do {\n    Limit--;\n  } while (i < Limit);\n\n  for (i = 0; i < Limit; Limit--) {\n  }\n\n  for (i = 0; i < Limit; (Limit) = Limit - 1) {\n  }\n\n  for (i = 0; i < Limit; (Limit) -= 1) {\n  }\n\n  for (i = 0; i < Limit; --(Limit)) {\n  }\n}\n\nvoid simple_not_infinite2() {\n  for (int i = 10; i-- > 0;) {\n    // Not an error, since loop variable is modified in its condition part.\n  }\n}\n\nint unknown_function();\n\nvoid function_call() {\n  int i = 0;\n  while (i < unknown_function()) {\n    // Not an error, since the function may return different values.\n  }\n\n  do {\n    // Not an error, since the function may return different values.\n  } while (i < unknown_function());\n\n  for (i = 0; i < unknown_function();) {\n    // Not an error, since the function may return different values.\n  }\n}\n\nvoid escape_before1() {\n  int i = 0;\n  int Limit = 100;\n  int *p = &i;\n  while (i < Limit) {\n    // Not an error, since *p is alias of i.\n    (*p)++;\n  }\n\n  do {\n    (*p)++;\n  } while (i < Limit);\n\n  for (i = 0; i < Limit; ++(*p)) {\n  }\n}\n\nvoid escape_before2() {\n  int i = 0;\n  int Limit = 100;\n  int &ii = i;\n  while (i < Limit) {\n    // Not an error, since ii is alias of i.\n    ii++;\n  }\n\n  do {\n    ii++;\n  } while (i < Limit);\n\n  for (i = 0; i < Limit; ++ii) {\n  }\n}\n\nvoid escape_inside1() {\n  int i = 0;\n  int Limit = 100;\n  int *p = &i;\n  while (i < Limit) {\n    // Not an error, since *p is alias of i.\n    int *p = &i;\n    (*p)++;\n  }\n\n  do {\n    int *p = &i;\n    (*p)++;\n  } while (i < Limit);\n}\n\nvoid escape_inside2() {\n  int i = 0;\n  int Limit = 100;\n  while (i < Limit) {\n    // Not an error, since ii is alias of i.\n    int &ii = i;\n    ii++;\n  }\n\n  do {\n    int &ii = i;\n    ii++;\n  } while (i < Limit);\n}\n\nvoid escape_after1() {\n  int i = 0;\n  int j = 0;\n  int Limit = 10;\n\n  while (i < Limit) {\n    // False negative, but difficult to detect without CFG-based analysis\n  }\n  int *p = &i;\n}\n\nvoid escape_after2() {\n  int i = 0;\n  int j = 0;\n  int Limit = 10;\n\n  while (i < Limit) {\n    // False negative, but difficult to detect without CFG-based analysis\n  }\n  int &ii = i;\n}\n\nint glob;\n\nvoid global1(int &x) {\n  int i = 0, Limit = 100;\n  while (x < Limit) {\n    // Not an error since 'x' can be an alias of 'glob'.\n    glob++;\n  }\n}\n\nvoid global2() {\n  int i = 0, Limit = 100;\n  while (glob < Limit) {\n    // Since 'glob' is declared out of the function we do not warn.\n    i++;\n  }\n}\n\nstruct X {\n  int m;\n\n  void change_m();\n\n  void member_expr1(int i) {\n    while (i < m) {\n      // False negative: No warning, since skipping the case where a struct or\n      // class can be found in its condition.\n      ;\n    }\n  }\n\n  void member_expr2(int i) {\n    while (i < m) {\n      --m;\n    }\n  }\n\n  void member_expr3(int i) {\n    while (i < m) {\n      change_m();\n    }\n  }\n};\n\nvoid array_index() {\n  int i = 0;\n  int v[10];\n  while (i < 10) {\n    v[i++] = 0;\n  }\n\n  i = 0;\n  do {\n    v[i++] = 0;\n  } while (i < 9);\n\n  for (i = 0; i < 10;) {\n    v[i++] = 0;\n  }\n\n  for (i = 0; i < 10; v[i++] = 0) {\n  }\n}\n\nvoid no_loop_variable() {\n  while (0)\n    ;\n}\n\nvoid volatile_in_condition() {\n  volatile int cond = 0;\n  while (!cond) {\n  }\n}\n\nnamespace std {\ntemplate<typename T> class atomic {\n  T val;\npublic:\n  atomic(T v): val(v) {};\n  operator T() { return val; };\n};\n}\n\nvoid atomic_in_condition() {\n  std::atomic<int> cond = 0;\n  while (!cond) {\n  }\n}\n\nvoid loop_exit1() {\n  int i = 0;\n  while (i) {\n    if (unknown_function())\n      break;\n  }\n}\n\nvoid loop_exit2() {\n  int i = 0;\n  while (i) {\n    if (unknown_function())\n      return;\n  }\n}\n\nvoid loop_exit3() {\n  int i = 0;\n  while (i) {\n    if (unknown_function())\n      goto end;\n  }\n end:\n  ;\n}\n\nvoid loop_exit4() {\n  int i = 0;\n  while (i) {\n    if (unknown_function())\n      throw 1;\n  }\n}\n\n[[noreturn]] void exit(int);\n\nvoid loop_exit5() {\n  int i = 0;\n  while (i) {\n    if (unknown_function())\n      exit(1);\n  }\n}\n\nvoid loop_exit_in_lambda() {\n  int i = 0;\n  while (i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i) are updated in the loop body [bugprone-infinite-loop]\n    auto l = []() { return 0; };\n  }\n}\n\nvoid lambda_capture() {\n  int i = 0;\n  int Limit = 100;\n  int *p = &i;\n  while (i < Limit) {\n    // Not an error, since i is captured by reference in a lambda.\n    auto l = [&i]() { ++i; };\n  }\n\n  do {\n    int *p = &i;\n    (*p)++;\n  } while (i < Limit);\n}\n\ntemplate <typename T> void accept_callback(T t) {\n  // Potentially call the callback.\n  // Possibly on a background thread or something.\n}\n\nvoid accept_block(void (^)(void)) {\n  // Potentially call the callback.\n  // Possibly on a background thread or something.\n}\n\nvoid wait(void) {\n  // Wait for the previously passed callback to be called.\n}\n\nvoid lambda_capture_from_outside() {\n  bool finished = false;\n  accept_callback([&]() {\n    finished = true;\n  });\n  while (!finished) {\n    wait();\n  }\n}\n\nvoid lambda_capture_from_outside_by_value() {\n  bool finished = false;\n  accept_callback([finished]() {\n    if (finished) {}\n  });\n  while (!finished) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (finished) are updated in the loop body [bugprone-infinite-loop]\n    wait();\n  }\n}\n\nvoid lambda_capture_from_outside_but_unchanged() {\n  bool finished = false;\n  accept_callback([&finished]() {\n    if (finished) {}\n  });\n  while (!finished) {\n    // FIXME: Should warn.\n    wait();\n  }\n}\n\nvoid block_capture_from_outside() {\n  __block bool finished = false;\n  accept_block(^{\n    finished = true;\n  });\n  while (!finished) {\n    wait();\n  }\n}\n\nvoid block_capture_from_outside_by_value() {\n  bool finished = false;\n  accept_block(^{\n    if (finished) {}\n  });\n  while (!finished) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (finished) are updated in the loop body [bugprone-infinite-loop]\n    wait();\n  }\n}\n\nvoid block_capture_from_outside_but_unchanged() {\n  __block bool finished = false;\n  accept_block(^{\n    if (finished) {}\n  });\n  while (!finished) {\n    // FIXME: Should warn.\n    wait();\n  }\n}\n\nvoid finish_at_any_time(bool *finished);\n\nvoid lambda_capture_with_loop_inside_lambda_bad() {\n  bool finished = false;\n  auto lambda = [=]() {\n    while (!finished) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: this loop is infinite; none of its condition variables (finished) are updated in the loop body [bugprone-infinite-loop]\n      wait();\n    }\n  };\n  finish_at_any_time(&finished);\n  lambda();\n}\n\nvoid lambda_capture_with_loop_inside_lambda_bad_init_capture() {\n  bool finished = false;\n  auto lambda = [captured_finished=finished]() {\n    while (!captured_finished) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: this loop is infinite; none of its condition variables (captured_finished) are updated in the loop body [bugprone-infinite-loop]\n      wait();\n    }\n  };\n  finish_at_any_time(&finished);\n  lambda();\n}\n\nvoid lambda_capture_with_loop_inside_lambda_good() {\n  bool finished = false;\n  auto lambda = [&]() {\n    while (!finished) {\n      wait(); // No warning: the variable may be updated\n              // from outside the lambda.\n    }\n  };\n  finish_at_any_time(&finished);\n  lambda();\n}\n\nvoid lambda_capture_with_loop_inside_lambda_good_init_capture() {\n  bool finished = false;\n  auto lambda = [&captured_finished=finished]() {\n    while (!captured_finished) {\n      wait(); // No warning: the variable may be updated\n              // from outside the lambda.\n    }\n  };\n  finish_at_any_time(&finished);\n  lambda();\n}\n\nvoid block_capture_with_loop_inside_block_bad() {\n  bool finished = false;\n  auto block = ^() {\n    while (!finished) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: this loop is infinite; none of its condition variables (finished) are updated in the loop body [bugprone-infinite-loop]\n      wait();\n    }\n  };\n  finish_at_any_time(&finished);\n  block();\n}\n\nvoid block_capture_with_loop_inside_block_bad_simpler() {\n  bool finished = false;\n  auto block = ^() {\n    while (!finished) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: this loop is infinite; none of its condition variables (finished) are updated in the loop body [bugprone-infinite-loop]\n      wait();\n    }\n  };\n  block();\n}\n\nvoid block_capture_with_loop_inside_block_good() {\n  __block bool finished = false;\n  auto block = ^() {\n    while (!finished) {\n      wait(); // No warning: the variable may be updated\n              // from outside the block.\n    }\n  };\n  finish_at_any_time(&finished);\n  block();\n}\n\nvoid evaluatable(bool CondVar) {\n  for (; false && CondVar;) {\n  }\n  while (false && CondVar) {\n  }\n  do {\n  } while (false && CondVar);\n}\n\nstruct logger {\n  void (*debug)(struct logger *, const char *, ...);\n};\n\nint foo(void) {\n  struct logger *pl = 0;\n  int iterator = 0;\n  while (iterator < 10) {\n    char *l_tmp_msg = 0;\n    pl->debug(pl, \"%d: %s\\n\", iterator, l_tmp_msg);\n    iterator++;\n  }\n  return 0;\n}\n\nstruct AggregateWithReference {\n  int &y;\n};\n\nvoid test_structured_bindings_good() {\n  int x = 0;\n  AggregateWithReference ref { x };\n  auto &[y] = ref;\n  for (; x < 10; ++y) {\n    // No warning. The loop is finite because 'y' is a reference to 'x'.\n  }\n}\n\nstruct AggregateWithValue {\n  int y;\n};\n\nvoid test_structured_bindings_bad() {\n  int x = 0;\n  AggregateWithValue val { x };\n  auto &[y] = val;\n  for (; x < 10; ++y) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (x) are updated in the loop body [bugprone-infinite-loop]\n  }\n}\n\nvoid test_volatile_cast() {\n  // This is a no-op cast. Clang ignores the qualifier, we should too.\n  for (int i = 0; (volatile int)i < 10;) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i) are updated in the loop body [bugprone-infinite-loop]\n  }\n}\n\nvoid test_volatile_concrete_address(int i, int size) {\n  // No warning. The value behind the volatile concrete address\n  // is beyond our control. It may change at any time.\n  for (; *((volatile int *)0x1234) < size;) {\n  }\n\n  for (; *((volatile int *)(0x1234 + i)) < size;) {\n  }\n\n  for (; **((volatile int **)0x1234) < size;) {\n  }\n\n  volatile int *x = (volatile int *)0x1234;\n  for (; *x < 10;) {\n  }\n\n  // FIXME: This one should probably also be suppressed.\n  // Whatever the developer is doing here, they can do that again anywhere else\n  // which basically makes it a global.\n  for (; *(int *)0x1234 < size;) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (size) are updated in the loop body [bugprone-infinite-loop]\n  }\n}\n\ntemplate <typename T>\nint some_template_fn() { return 1; }\n\ntemplate <typename T>\nvoid test_dependent_condition() {\n  const int error = some_template_fn<T>();\n  do {\n  } while (false && error == 0);\n\n  const int val = some_template_fn<T>();\n  for (; !(val == 0 || true);) {\n  }\n\n  const int val2 = some_template_fn<T>();\n  for (; !(val2 == 0 || false);) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (val2) are updated in the loop body [bugprone-infinite-loop]\n  }\n\n  const int val3 = some_template_fn<T>();\n  do {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (val3) are updated in the loop body [bugprone-infinite-loop]\n  } while (1, (true) && val3 == 1);\n\n  const int val4 = some_template_fn<T>();\n  do {\n  } while (1, (false) && val4 == 1);\n}\n\nvoid test_typeof() {\n  __typeof__({\n    for (int i = 0; i < 10; ++i) {\n    }\n    0;\n  }) x;\n}\n\nvoid test_typeof_infinite() {\n  __typeof__({\n    for (int i = 0; i < 10;) {\n    }\n    0;\n  }) x;\n}\n\nvoid test_typeof_while_infinite() {\n  __typeof__({\n    int i = 0;\n    while (i < 10) {\n    }\n    0;\n  }) x;\n}\n\nvoid test_typeof_dowhile_infinite() {\n  __typeof__({\n    int i = 0;\n    do {\n\n    } while (i < 10);\n    0;\n  }) x;\n}\n\nvoid test_local_static_recursion() {\n  static int i = 10;\n  int j = 0;\n\n  i--;\n  while (i >= 0)\n    test_local_static_recursion(); // no warning, recursively decrement i\n  for (; i >= 0;)\n    test_local_static_recursion(); // no warning, recursively decrement i\n  for (; i + j >= 0;)\n    test_local_static_recursion(); // no warning, recursively decrement i\n  for (; i >= 0; i--)\n    ; // no warning, i decrements\n  while (j >= 0)\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (j) are updated in the loop body [bugprone-infinite-loop]\n    test_local_static_recursion();\n\n  int (*p)(int) = 0;\n\n  while (i >= 0)\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: this loop is infinite; none of its condition variables (i) are updated in the loop body [bugprone-infinite-loop]\n    p = 0;\n  while (i >= 0)\n    p(0); // we don't know what p points to so no warning\n}"
    }
  ]
}