{
  "name": "ArgumentComment",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-argument-comment",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 369,
  "branches": 54,
  "apis": 278,
  "test": [
    {
      "description": null,
      "expected-problems": 0,
      "expected-linenumbers": [],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-argument-comment %t -- -- -I %S/Inputs/argument-comment\n\n// FIXME: clang-tidy should provide a -verify mode to make writing these checks\n// easier and more accurate.\n\nvoid ffff(int xxxx, int yyyy);\n\nvoid f(int x, int y);\nvoid g() {\n  // CHECK-NOTES: [[@LINE+4]]:5: warning: argument name 'y' in comment does not match parameter name 'x'\n  // CHECK-NOTES: [[@LINE-3]]:12: note: 'x' declared here\n  // CHECK-NOTES: [[@LINE+2]]:14: warning: argument name 'z' in comment does not match parameter name 'y'\n  // CHECK-NOTES: [[@LINE-5]]:19: note: 'y' declared here\n  f(/*y=*/0, /*z=*/0);\n  // CHECK-FIXES: {{^}}  f(/*y=*/0, /*z=*/0);\n\n  f(/*x=*/1, /*y=*/1);\n\n  ffff(0 /*aaaa=*/, /*bbbb*/ 0); // Unsupported formats.\n}\n\nstruct C {\n  C(int x, int y);\n};\nC c(/*x=*/0, /*y=*/0);\n\nstruct Closure {};\n\ntemplate <typename T1, typename T2>\nClosure *NewCallback(void (*f)(T1, T2), T1 arg1, T2 arg2) { return nullptr; }\n\ntemplate <typename T1, typename T2>\nClosure *NewPermanentCallback(void (*f)(T1, T2), T1 arg1, T2 arg2) { return nullptr; }\n\nvoid h() {\n  (void)NewCallback(&ffff, /*xxxx=*/11, /*yyyy=*/22);\n  (void)NewPermanentCallback(&ffff, /*xxxx=*/11, /*yyyy=*/22);\n}\n\ntemplate<typename... Args>\nvoid variadic(Args&&... args);\n\ntemplate<typename... Args>\nvoid variadic2(int zzz, Args&&... args);\n\nvoid templates() {\n  variadic(/*xxx=*/0, /*yyy=*/1);\n  variadic2(/*zzU=*/0, /*xxx=*/1, /*yyy=*/2);\n  // CHECK-NOTES: [[@LINE-1]]:13: warning: argument name 'zzU' in comment does not match parameter name 'zzz'\n  // CHECK-NOTES: :[[@LINE-6]]:20: note: 'zzz' declared here\n  // CHECK-FIXES: variadic2(/*zzz=*/0, /*xxx=*/1, /*yyy=*/2);\n}\n\n#define FALSE 0\nvoid qqq(bool aaa);\nvoid f2() { qqq(/*bbb=*/FALSE); }\n// CHECK-NOTES: [[@LINE-1]]:17: warning: argument name 'bbb' in comment does not match parameter name 'aaa'\n// CHECK-NOTES: [[@LINE-3]]:15: note: 'aaa' declared here\n// CHECK-FIXES: void f2() { qqq(/*bbb=*/FALSE); }\n\nvoid f3(bool _with_underscores_);\nvoid ignores_underscores() {\n  f3(/*With_Underscores=*/false);\n}\n\nnamespace IgnoresImplicit {\nstruct S {\n  S(int x);\n  int x;\n};\n\nstruct T {\n  // Use two arguments (one defaulted) because simplistic check for implicit\n  // constructor looks for only one argument. We need to default the argument so\n  // that it will still be triggered implicitly.  This is not contrived -- it\n  // comes up in real code, for example std::set(std::initializer_list...).\n  T(S s, int y = 0);\n};\n\nvoid k(T arg1);\n\nvoid mynewtest() {\n  int foo = 3;\n  k(/*arg1=*/S(foo));\n}\n} // namespace IgnoresImplicit\n\nnamespace ThisEditDistanceAboveThreshold {\nvoid f4(int xxx);\nvoid g() { f4(/*xyz=*/0); }\n// CHECK-NOTES: [[@LINE-1]]:15: warning: argument name 'xyz' in comment does not match parameter name 'xxx'\n// CHECK-NOTES: [[@LINE-3]]:13: note: 'xxx' declared here\n// CHECK-FIXES: void g() { f4(/*xyz=*/0); }\n}\n\nnamespace OtherEditDistanceAboveThreshold {\nvoid f5(int xxx, int yyy);\nvoid g() { f5(/*Zxx=*/0, 0); }\n// CHECK-NOTES: [[@LINE-1]]:15: warning: argument name 'Zxx' in comment does not match parameter name 'xxx'\n// CHECK-NOTES: [[@LINE-3]]:13: note: 'xxx' declared here\n// CHECK-FIXES: void g() { f5(/*xxx=*/0, 0); }\nstruct C2 {\n  C2(int xxx, int yyy);\n};\nC2 c2(/*Zxx=*/0, 0);\n// CHECK-NOTES: [[@LINE-1]]:7: warning: argument name 'Zxx' in comment does not match parameter name 'xxx'\n// CHECK-NOTES: [[@LINE-4]]:10: note: 'xxx' declared here\n// CHECK-FIXES: C2 c2(/*xxx=*/0, 0);\n}\n\nnamespace OtherEditDistanceBelowThreshold {\nvoid f6(int xxx, int yyy);\nvoid g() { f6(/*xxy=*/0, 0); }\n// CHECK-NOTES: [[@LINE-1]]:15: warning: argument name 'xxy' in comment does not match parameter name 'xxx'\n// CHECK-NOTES: [[@LINE-3]]:13: note: 'xxx' declared here\n// CHECK-FIXES: void g() { f6(/*xxy=*/0, 0); }\n}\n\n\nnamespace std {\ntemplate <typename T>\nclass vector {\npublic:\n  void assign(int __n, const T &__val);\n};\ntemplate<typename T>\nvoid swap(T& __a, T& __b);\n} // namespace std\nnamespace ignore_std_functions {\nvoid test(int a, int b) {\n  std::vector<int> s;\n  // verify the check is not fired on std functions.\n  s.assign(1, /*value=*/2);\n  std::swap(a, /*num=*/b);\n}\n} // namespace ignore_std_functions\n\nnamespace regular_header {\n#include \"header-with-decl.h\"\nvoid test() {\n  my_header_function(/*not_arg=*/1);\n// CHECK-NOTES: [[@LINE-1]]:22: warning: argument name 'not_arg' in comment does not match parameter name 'arg'\n// CHECK-NOTES: header-with-decl.h:1:29: note: 'arg' declared here\n// CHECK-FIXES: my_header_function(/*not_arg=*/1);\n}\n} // namespace regular_header\n\nnamespace system_header {\n#include \"system-header-with-decl.h\"\nvoid test() {\n  my_system_header_function(/*not_arg=*/1);\n}\n} // namespace system_header\n\nvoid testInvalidSlocCxxConstructExpr() {\n  __builtin_va_list __args;\n  // __builtin_va_list has no defination in any source file\n} "
    }
  ]
}