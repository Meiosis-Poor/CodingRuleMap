{
  "name": "UnusedReturnValue",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-unused-return-value",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 233,
  "branches": 3,
  "apis": 94,
  "test": [
    {
      "description": null,
      "expected-problems": 50,
      "expected-linenumbers": [
        90,
        91,
        94,
        95,
        99,
        100,
        103,
        104,
        107,
        108,
        111,
        112,
        116,
        117,
        121,
        122,
        125,
        126,
        130,
        131,
        136,
        137,
        141,
        142,
        145,
        146,
        149,
        150,
        154,
        155,
        159,
        160,
        165,
        166,
        169,
        170,
        174,
        175,
        180,
        181,
        186,
        187,
        191,
        192,
        198,
        199,
        202,
        203,
        207,
        208
      ],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-unused-return-value %t -- \\\n// RUN:   --config=\"{CheckOptions: {bugprone-unused-return-value.AllowCastToVoid: true}}\" -- -fexceptions\n\nnamespace std {\n\nstruct future {};\n\nenum class launch {\n  async,\n  deferred\n};\n\ntemplate <typename Function, typename... Args>\nfuture async(Function &&, Args &&...);\n\ntemplate <typename Function, typename... Args>\nfuture async(launch, Function &&, Args &&...);\n\ntemplate <typename ForwardIt, typename T>\nForwardIt remove(ForwardIt, ForwardIt, const T &);\n\ntemplate <typename ForwardIt, typename UnaryPredicate>\nForwardIt remove_if(ForwardIt, ForwardIt, UnaryPredicate);\n\ntemplate <typename ForwardIt>\nForwardIt unique(ForwardIt, ForwardIt);\n\ntemplate <typename T>\nstruct default_delete;\n\ntemplate <typename T, typename Deleter = std::default_delete<T>>\nstruct unique_ptr {\n  unique_ptr();\n  unique_ptr(unique_ptr const&);\n  unique_ptr(unique_ptr &&);\n  unique_ptr& operator=(unique_ptr const&);\n  unique_ptr& operator=(unique_ptr &&);\n  T *release() noexcept;\n};\n\ntemplate <typename T>\nstruct char_traits;\n\ntemplate <typename T>\nstruct allocator;\n\ntemplate <typename CharT,\n          typename Traits = char_traits<CharT>,\n          typename Allocator = allocator<CharT>>\nstruct basic_string {\n  bool empty() const;\n};\n\ntypedef basic_string<char> string;\n\ntemplate <typename T, typename Allocator = std::allocator<T>>\nstruct vector {\n  bool empty() const noexcept;\n};\n\nclass error_code {\n};\n\n// the check should be able to match std lib calls even if the functions are\n// declared inside inline namespaces\ninline namespace v1 {\n\ntemplate <typename T>\nT *launder(T *);\n\n} // namespace v1\n} // namespace std\n\nstruct Foo {\n  void f();\n};\n\nint increment(int i) {\n  return i + 1;\n}\n\nvoid useFuture(const std::future &fut);\n\nstd::error_code errorFunc() {\n    return std::error_code();\n}\n\nvoid warning() {\n  std::async(increment, 42);\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  std::async(std::launch::async, increment, 42);\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  Foo F;\n  std::launder(&F);\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  std::remove_if(nullptr, nullptr, nullptr);\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  std::unique(nullptr, nullptr);\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  std::unique_ptr<Foo> UPtr;\n  UPtr.release();\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  std::string Str;\n  Str.empty();\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  (int)Str.empty();\n  // CHECK-MESSAGES: [[@LINE-1]]:8: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:8: note: cast the expression to void to silence this warning\n\n  std::vector<Foo> Vec;\n  Vec.empty();\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n\n  // test discarding return values inside different kinds of statements\n\n  auto Lambda = [] { std::remove(nullptr, nullptr, 1); };\n  // CHECK-MESSAGES: [[@LINE-1]]:22: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:22: note: cast the expression to void to silence this warning\n\n  if (true)\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n  else if (true)\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n  else\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n\n  while (true)\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n\n  do\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n  while (true);\n\n  for (;;)\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n\n  for (std::remove(nullptr, nullptr, 1);;)\n    // CHECK-MESSAGES: [[@LINE-1]]:8: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n    // CHECK-MESSAGES: [[@LINE-2]]:8: note: cast the expression to void to silence this warning\n    ;\n\n  for (;; std::remove(nullptr, nullptr, 1))\n    // CHECK-MESSAGES: [[@LINE-1]]:11: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n    // CHECK-MESSAGES: [[@LINE-2]]:11: note: cast the expression to void to silence this warning\n    ;\n\n  for (auto C : \"foo\")\n    std::remove(nullptr, nullptr, 1);\n  // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n\n  switch (1) {\n  case 1:\n    std::remove(nullptr, nullptr, 1);\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n    // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n    break;\n  default:\n    std::remove(nullptr, nullptr, 1);\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n    // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n    break;\n  }\n\n  try {\n    std::remove(nullptr, nullptr, 1);\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n    // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n  } catch (...) {\n    std::remove(nullptr, nullptr, 1);\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n    // CHECK-MESSAGES: [[@LINE-2]]:5: note: cast the expression to void to silence this warning\n  }\n\n  errorFunc();\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: the value returned by this function should not be disregarded; neglecting it may lead to errors\n  // CHECK-MESSAGES: [[@LINE-2]]:3: note: cast the expression to void to silence this warning\n}\n\nvoid noWarning() {\n  auto AsyncRetval1 = std::async(increment, 42);\n  auto AsyncRetval2 = std::async(std::launch::async, increment, 42);\n\n  Foo FNoWarning;\n  auto LaunderRetval = std::launder(&FNoWarning);\n\n  auto RemoveRetval = std::remove(nullptr, nullptr, 1);\n\n  auto RemoveIfRetval = std::remove_if(nullptr, nullptr, nullptr);\n\n  auto UniqueRetval = std::unique(nullptr, nullptr);\n\n  std::unique_ptr<Foo> UPtrNoWarning;\n  auto ReleaseRetval = UPtrNoWarning.release();\n\n  std::string StrNoWarning;\n  auto StrEmptyRetval = StrNoWarning.empty();\n\n  std::vector<Foo> VecNoWarning;\n  auto VecEmptyRetval = VecNoWarning.empty();\n\n  (void) errorFunc();\n\n  // test using the return value in different kinds of expressions\n  useFuture(std::async(increment, 42));\n  std::launder(&FNoWarning)->f();\n  delete std::launder(&FNoWarning);\n\n  if (std::launder(&FNoWarning))\n    ;\n  for (; std::launder(&FNoWarning);)\n    ;\n  while (std::launder(&FNoWarning))\n    ;\n  do\n    ;\n  while (std::launder(&FNoWarning));\n  switch (std::unique(1, 1))\n    ;\n\n  // cast to void should allow ignoring the return value\n  (void)std::async(increment, 42);\n\n  // test discarding return value of functions that are not configured to be checked\n  increment(1);\n\n  // test that the check is disabled inside GNU statement expressions\n  ({ std::async(increment, 42); });\n  auto StmtExprRetval = ({ std::async(increment, 42); });\n}\n\nnamespace gh84314 {\n\nextern std::unique_ptr<int> alloc();\nvoid f1(std::unique_ptr<int> &foo) {\n    foo = alloc();\n}\n\n} // namespace gh84314"
    }
  ]
}