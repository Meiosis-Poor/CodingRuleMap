{
  "name": "TooSmallLoopVariable",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-too-small-loop-variable",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 224,
  "branches": 14,
  "apis": 141,
  "test": [
    {
      "description": null,
      "expected-problems": 21,
      "expected-linenumbers": [
        13,
        19,
        25,
        31,
        37,
        44,
        54,
        61,
        69,
        77,
        92,
        104,
        164,
        172,
        180,
        327,
        339,
        349,
        360,
        371,
        383
      ],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-too-small-loop-variable %t -- \\\n// RUN:   -config=\"{CheckOptions: \\\n// RUN:             {bugprone-too-small-loop-variable.MagnitudeBitsUpperLimit: 1024}}\" \\\n// RUN:   -- --target=x86_64-linux\n\nlong size() { return 294967296l; }\n\n////////////////////////////////////////////////////////////////////////////////\n/// Test cases correctly caught by bugprone-too-small-loop-variable.\n\nvoid voidBadForLoop() {\n  for (int i = 0; i < size(); ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidBadForLoop2() {\n  for (int i = 0; i < size() + 10; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidBadForLoop3() {\n  for (int i = 0; i <= size() - 1; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidBadForLoop4() {\n  for (int i = 0; size() > i; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidBadForLoop5() {\n  for (int i = 0; size() - 1 >= i; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:33: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidBadForLoop6() {\n  int i = 0;\n  for (; i < size(); ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidBadForLoop7() {\n    struct Int  {\n        int value;\n    } i;\n\n  for (i.value = 0; i.value < size(); ++i.value) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: loop variable has narrower type 'int' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidForLoopUnsignedBound() {\n  unsigned size = 3147483647;\n  for (int i = 0; i < size; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: loop variable has narrower type 'int' than iteration's upper bound 'unsigned int' [bugprone-too-small-loop-variable]\n  }\n}\n\n// The iteration's upper bound has a template dependent value.\ntemplate <long size>\nvoid doSomething() {\n  for (short i = 0; i < size; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: loop variable has narrower type 'short' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\n// The iteration's upper bound has a template dependent type.\ntemplate <class T>\nvoid doSomething() {\n  for (T i = 0; i < size(); ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: loop variable has narrower type 'short' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidForLoopInstantiation() {\n  // This line does not trigger the warning.\n  doSomething<long>();\n  // This one triggers the warning.\n  doSomething<short>();\n}\n\n// A suspicious function used in a macro.\n#define SUSPICIOUS_SIZE (size())\nvoid voidBadForLoopWithMacroBound() {\n  for (short i = 0; i < SUSPICIOUS_SIZE; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: loop variable has narrower type 'short' than iteration's upper bound 'long' [bugprone-too-small-loop-variable]\n  }\n}\n\nunsigned int getVal() {\n    return 300;\n}\n\n// The iteration's upper bound has a function declaration.\nvoid voidBadForLoop8() {\n  const unsigned int l = getVal();\n  for (unsigned char i = 0; i < l; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: loop variable has narrower type 'unsigned char' than iteration's upper bound 'const unsigned int' [bugprone-too-small-loop-variable]\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Correct loops: we should not warn here.\n\n// A simple use case when both expressions have the same type.\nvoid voidGoodForLoop() {\n  for (long i = 0; i < size(); ++i) { // no warning\n  }\n}\n\n// Other use case where both expressions have the same type,\n// but short expressions are converted to int by the compare operator.\nvoid voidGoodForLoop2() {\n  short loopCond = 10;\n  for (short i = 0; i < loopCond; ++i) { // no warning\n  }\n}\n\n// Because of the integer literal, the iteration's upper bound is int, but we suppress the warning here.\nvoid voidForLoopShortPlusLiteral() {\n  short size = 30000;\n  for (short i = 0; i <= (size - 1); ++i) { // no warning\n  }\n}\n\n// Addition of two short variables results in an int value, but we suppress this to avoid false positives.\nvoid voidForLoopShortPlusShort() {\n  short size = 256;\n  short increment = 14;\n  for (short i = 0; i < size + increment; ++i) { // no warning\n  }\n}\n\n// In this test case we have different integer types, but here the loop variable has the bigger type.\n// The iteration's bound is cast implicitly, not the loop variable.\nvoid voidForLoopBoundImplicitCast() {\n  short start = 256;\n  short end = 14;\n  for (int i = start; i >= end; --i) { // no warning\n  }\n}\n\n// Range based loop and other iterator based loops are ignored by this check.\nvoid voidRangeBasedForLoop() {\n  int array[] = {1, 2, 3, 4, 5};\n  for (const int &i : array) { // no warning\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Future possibilites to improve the check.\n\n// False positive: because of the int literal, iteration's upper bound has int type.\nvoid voidForLoopFalsePositive() {\n  short size = 30000;\n  bool cond = false;\n  for (short i = 0; i < (cond ? 0 : size); ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: loop variable has narrower type 'short' than iteration's upper bound 'int' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid voidForLoopFalsePositive2() {\n  short size = 30000;\n  bool cond = false;\n  for (short i = 0; i < (!cond ? size : 0); ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: loop variable has narrower type 'short' than iteration's upper bound 'int' [bugprone-too-small-loop-variable]\n  }\n}\n\n// False positive: The loop bound expression contains nested binary operators.\nvoid voidForLoopFalsePositive3() {\n  short number = 30000;\n  for (short i = 0; i < ((number & 0x7f) + 1); ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: loop variable has narrower type 'short' than iteration's upper bound 'int' [bugprone-too-small-loop-variable]\n  }\n}\n\n// TODO: handle while loop.\nvoid voidBadWhileLoop() {\n  short i = 0;\n  while (i < size()) { // missing warning\n    ++i;\n  }\n}\n\n// TODO: handle do-while loop.\nvoid voidBadDoWhileLoop() {\n  short i = 0;\n  do {\n    ++i;\n  } while (i < size()); // missing warning\n}\n\n// TODO: handle complex loop conditions.\nvoid voidComplexForCond() {\n  bool additionalCond = true;\n  for (int i = 0; i < size() && additionalCond; ++i) { // missing warning\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// Suspicious test cases ingored by this check.\n\n// Test case with a reverse iteration.\n// This is caught by -Wimplicit-int-conversion.\nvoid voidReverseForLoop() {\n  for (short i = size() - 1; i >= 0; --i) { // no warning\n  }\n}\n\n// Macro defined literals are used inside the loop condition.\n#define SIZE 125\n#define SIZE2 (SIZE + 1)\nvoid voidForLoopWithMacroBound() {\n  for (short i = 0; i < SIZE2; ++i) { // no warning\n  }\n}\n\n// A suspicious loop is not caught if the iteration's upper bound is a literal.\nvoid voidForLoopWithLiteralBound() {\n  for (short i = 0; i < 125; ++i) { // no warning\n  }\n}\n\n// The used literal leads to an infinite loop.\n// This is caught by -Wtautological-constant-out-of-range-compare.\nvoid voidForLoopWithBigLiteralBound() {\n  for (short i = 0; i < 294967296l; ++i) { // no warning\n  }\n}\n\nenum eSizeType {\n  START,\n  Y,\n  END\n};\n\n// A suspicious loop is not caught if the iteration's upper bound is an enum value.\nvoid voidForLoopWithEnumBound() {\n  for (short i = eSizeType::START; i < eSizeType::END; ++i) { // no warning\n  }\n}\n\nenum eSizeType2 : long {\n  START2 = 294967296l,\n  Y2,\n  END2\n};\n\n// The used enum value leads to an infinite loop.\n// This is caught by -Wtautological-constant-out-of-range-compare.\nvoid voidForLoopWithBigEnumBound() {\n  for (short i = eSizeType2::START2; i < eSizeType2::END2; ++i) { // no warning\n  }\n}\n\n// A suspicious loop is not caught if the iteration's upper bound is a constant variable.\nvoid voidForLoopWithConstBound() {\n  const long size = 252l;\n  for (short i = 0; i < size; ++i) { // no warning\n  }\n}\n\n// The used constant variable leads to an infinite loop.\n// This is caught by -Wtautological-constant-out-of-range-compare.\nvoid voidForLoopWithBigConstBound() {\n  const long size = 294967296l;\n  for (short i = 0; i < size; ++i) { // no warning\n  }\n}\n\n// Should detect proper size of upper bound bitfield\nvoid voidForLoopWithBitfieldOnUpperBound() {\n  struct StructWithBitField {\n      unsigned bitfield : 5;\n  } value = {};\n\n  for(unsigned char i = 0U; i < value.bitfield; ++i) { // no warning\n  }\n}\n\n// Should detect proper size of loop variable bitfield\nvoid voidForLoopWithBitfieldOnLoopVar() {\n  struct StructWithBitField {\n      unsigned bitfield : 9;\n  } value = {};\n\n  unsigned char upperLimit = 100U;\n\n  for(value.bitfield = 0U; value.bitfield < upperLimit; ++value.bitfield) {\n  }\n}\n\n// Should detect proper size of loop variable and upper bound\nvoid voidForLoopWithBitfieldOnLoopVarAndUpperBound() {\n  struct StructWithBitField {\n      unsigned var : 5, limit : 4;\n  } value = {};\n\n  for(value.var = 0U; value.var < value.limit; ++value.var) {\n  }\n}\n\n// Should detect proper size of loop variable and upper bound on integers\nvoid voidForLoopWithBitfieldOnLoopVarAndUpperBoundOnInt() {\n  struct StructWithBitField {\n      unsigned var : 5;\n      int limit : 6;\n  } value = {};\n\n  for(value.var = 0U; value.var < value.limit; ++value.var) {\n  }\n}\n\nvoid badForLoopWithBitfieldOnUpperBound() {\n  struct StructWithBitField {\n      unsigned bitfield : 9;\n  } value = {};\n\n  for(unsigned char i = 0U; i < value.bitfield; ++i) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: loop variable has narrower type 'unsigned char' than iteration's upper bound 'unsigned int:9' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid badForLoopWithBitfieldOnLoopVar() {\n  struct StructWithBitField {\n      unsigned bitfield : 7;\n  } value = {};\n\n  unsigned char upperLimit = 100U;\n\n  for(value.bitfield = 0U; value.bitfield < upperLimit; ++value.bitfield) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: loop variable has narrower type 'unsigned int:7' than iteration's upper bound 'unsigned char' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid badForLoopWithBitfieldOnLoopVarAndUpperBound() {\n  struct StructWithBitField {\n      unsigned var : 5, limit : 6;\n  } value = {};\n\n  for(value.var = 0U; value.var < value.limit; ++value.var) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: loop variable has narrower type 'unsigned int:5' than iteration's upper bound 'unsigned int:6' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid badForLoopWithBitfieldOnLoopVarOnIntAndUpperBound() {\n  struct StructWithBitField {\n      int var : 5;\n      unsigned limit : 5;\n  } value = {};\n\n  for(value.var = 0U; value.var < value.limit; ++value.var) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: loop variable has narrower type 'int:5' than iteration's upper bound 'unsigned int:5' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid badForLoopWithBitfieldOnLoopVarAndUpperBoundOnInt() {\n  struct StructWithBitField {\n      unsigned var : 5;\n      int limit : 7;\n  } value = {};\n\n  for(value.var = 0U; value.var < value.limit; ++value.var) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: loop variable has narrower type 'unsigned int:5' than iteration's upper bound 'int:7' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid badForLoopWithBitfieldOnLoopVarAndUpperBoundOnPtr() {\n  struct StructWithBitField {\n      unsigned var : 5, limit : 6;\n  } value = {};\n\n  StructWithBitField* ptr = &value;\n\n  for(ptr->var = 0U; ptr->var < ptr->limit; ++ptr->var) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: loop variable has narrower type 'unsigned int:5' than iteration's upper bound 'unsigned int:6' [bugprone-too-small-loop-variable]\n  }\n}\n\nvoid goodForLoopWithBitfieldOnUpperBoundOnly() {\n  struct S {\n    int x : 4;\n  } s;\n\n  for (int i = 10; i > s.x; --i) {\n  }\n}\n\nvoid goodForLoopWithIntegersOnUpperBoundOnly() {\n  struct S {\n    short x;\n  } s;\n\n  for (int i = 10; i > s.x; --i) {\n  }\n}"
    }
  ]
}