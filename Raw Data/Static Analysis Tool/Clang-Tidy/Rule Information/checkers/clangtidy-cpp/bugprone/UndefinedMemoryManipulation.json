{
  "name": "UndefinedMemoryManipulation",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-undefined-memory-manipulation",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 71,
  "branches": 5,
  "apis": 52,
  "test": [
    {
      "description": null,
      "expected-problems": 31,
      "expected-linenumbers": [
        68,
        74,
        80,
        97,
        99,
        101,
        103,
        105,
        108,
        110,
        112,
        114,
        116,
        119,
        121,
        123,
        125,
        127,
        131,
        133,
        137,
        140,
        143,
        152,
        154,
        163,
        165,
        167,
        171,
        173,
        178
      ],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-undefined-memory-manipulation %t\n\nvoid *memset(void *, int, __SIZE_TYPE__);\nvoid *memcpy(void *, const void *, __SIZE_TYPE__);\nvoid *memmove(void *, const void *, __SIZE_TYPE__);\n\nnamespace std {\nusing ::memcpy;\nusing ::memmove;\nusing ::memset;\n}\n\nnamespace types {\n// TriviallyCopyable types:\nstruct Plain {\n  int n;\n};\n\nenum E {\n  X,\n  Y,\n  Z\n};\n\nstruct Base {\n  float b;\n};\n\nstruct Derived : Base {\n  bool d;\n};\n\n// not TriviallyCopyable types:\nstruct Destruct {\n  ~Destruct() {}\n};\n\nstruct Copy {\n  Copy() {}\n  Copy(const Copy &) {}\n};\n\nstruct Move {\n  Move() {}\n  Move(Move &&) {}\n};\n\nstruct VirtualFunc {\n  virtual void f() {}\n};\n\nstruct VirtualBase : virtual Base {\n  int vb;\n};\n\n// Incomplete type, assume it is TriviallyCopyable.\nstruct NoDef;\n\n} // end namespace types\n\nvoid f(types::NoDef *s) {\n  memset(s, 0, 5);\n}\n\ntemplate <typename T>\nvoid memset_temp(T *b) {\n  memset(b, 0, sizeof(T));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::VirtualFunc' is not TriviallyCopyable [bugprone-undefined-memory-manipulation]\n}\n\ntemplate <typename S, typename T>\nvoid memcpy_temp(S *a, T *b) {\n  memcpy(a, b, sizeof(T));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::VirtualFunc'\n}\n\ntemplate <typename S, typename T>\nvoid memmove_temp(S *a, T *b) {\n  memmove(a, b, sizeof(T));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::VirtualFunc'\n}\n\nnamespace aliases {\nusing Copy2 = types::Copy;\ntypedef types::Move Move2;\n}\n\nvoid notTriviallyCopyable() {\n  types::Plain p; // TriviallyCopyable for variety\n  types::Destruct d;\n  types::Copy c;\n  types::Move m;\n  types::VirtualFunc vf;\n  types::VirtualBase vb;\n\n  memset(&vf, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::VirtualFunc'\n  memset(&d, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Destruct'\n  memset(&c, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Copy'\n  std::memset(&m, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Move'\n  ::memset(&vb, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::VirtualBase'\n\n  memcpy(&p, &vf, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::VirtualFunc'\n  memcpy(&p, &d, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::Destruct'\n  memcpy(&c, &p, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Copy'\n  std::memcpy(&m, &p, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Move'\n  ::memcpy(&vb, &p, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::VirtualBase'\n\n  memmove(&vf, &p, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::VirtualFunc'\n  memmove(&d, &p, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Destruct'\n  memmove(&p, &c, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::Copy'\n  std::memmove(&p, &m, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::Move'\n  ::memmove(&p, &vb, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::VirtualBase'\n\n  types::Copy ca[10];\n  memset(ca, 0, sizeof(ca));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Copy[10]'\n  memset(&ca, 0, sizeof(ca));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Copy[10]'\n\n#define MEMSET memset(&vf, 0, sizeof(int));\n  MEMSET\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::VirtualFunc'\n#define MEMCPY memcpy(&d, &p, sizeof(int));\n  MEMCPY\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'types::Destruct'\n#define MEMMOVE memmove(&p, &c, sizeof(int));\n  MEMMOVE\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, source object type 'types::Copy'\n\n  memset_temp<types::VirtualFunc>(&vf);\n  memcpy_temp<types::Plain, types::VirtualFunc>(&p, &vf);\n  memmove_temp<types::Plain, types::VirtualFunc>(&p, &vf);\n\n  aliases::Copy2 c2;\n  aliases::Move2 m2;\n  memset(&c2, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'aliases::Copy2'\n  memset(&m2, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'aliases::Move2'\n\n  typedef aliases::Copy2 Copy3;\n  typedef aliases::Copy2 *PCopy2;\n  typedef Copy3 *PCopy3;\n  Copy3 c3;\n  PCopy2 pc2;\n  PCopy3 pc3;\n  memset(&c3, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'Copy3'\n  memset(pc2, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'aliases::Copy2'\n  memset(pc3, 0, sizeof(int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'Copy3'\n  using Copy3Arr = Copy3[5];\n  Copy3Arr c3a;\n  memset(c3a, 0, sizeof(c3a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'Copy3Arr'\n  memset(&c3a, 0, sizeof(c3a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'Copy3Arr'\n\n  typedef Copy3 Copy3Arr2[5];\n  Copy3Arr2 c3a2;\n  memset(c3a2, 0, sizeof(c3a2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: undefined behavior, destination object type 'Copy3Arr2'\n}\n\nvoid triviallyCopyable() {\n  types::Plain p;\n  types::Base base;\n  types::Derived derived;\n\n  int i = 5;\n  int ia[3] = {1, 2, 3};\n  float f = 3.14;\n  float fa[3] = {1.1, 2.2, 3.3};\n  bool b = false;\n  bool ba[2] = {true, false};\n  types::E e = types::X;\n  p.n = 2;\n\n  memset(&p, 0, sizeof(int));\n  memset(&base, 0, sizeof(float));\n  memset(&derived, 0, sizeof(bool));\n  memset(&i, 0, sizeof(int));\n  memset(ia, 0, sizeof(int));\n  memset(&f, 0, sizeof(float));\n  memset(fa, 0, sizeof(float));\n  memset(&b, 0, sizeof(bool));\n  memset(ba, 0, sizeof(bool));\n  memset(&e, 0, sizeof(int));\n  memset(&p.n, 0, sizeof(int));\n\n  memcpy(&p, &p, sizeof(int));\n  memcpy(&base, &base, sizeof(float));\n  memcpy(&derived, &derived, sizeof(bool));\n  memcpy(&i, &i, sizeof(int));\n  memcpy(ia, ia, sizeof(int));\n  memcpy(&f, &f, sizeof(float));\n  memcpy(fa, fa, sizeof(float));\n  memcpy(&b, &b, sizeof(bool));\n  memcpy(ba, ba, sizeof(bool));\n  memcpy(&e, &e, sizeof(int));\n  memcpy(&p.n, &p.n, sizeof(int));\n\n  memmove(&p, &p, sizeof(int));\n  memmove(&base, &base, sizeof(float));\n  memmove(&derived, &derived, sizeof(bool));\n  memmove(&i, &i, sizeof(int));\n  memmove(ia, ia, sizeof(int));\n  memmove(&f, &f, sizeof(float));\n  memmove(fa, fa, sizeof(float));\n  memmove(&b, &b, sizeof(bool));\n  memmove(ba, ba, sizeof(bool));\n  memmove(&e, &e, sizeof(int));\n  memmove(&p.n, &p.n, sizeof(int));\n}"
    }
  ]
}