{
  "name": "MultipleNewInOneExpression",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-multiple-new-in-one-expression",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 155,
  "branches": 23,
  "apis": 123,
  "test": [
    {
      "description": null,
      "expected-problems": 38,
      "expected-linenumbers": [
        54,
        56,
        58,
        60,
        62,
        65,
        68,
        70,
        72,
        81,
        83,
        85,
        87,
        89,
        92,
        95,
        97,
        102,
        111,
        113,
        115,
        118,
        119,
        122,
        123,
        125,
        126,
        128,
        129,
        139,
        141,
        143,
        146,
        148,
        171,
        174,
        182,
        194
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++11 -check-suffixes=ALL,CPP11 %s bugprone-multiple-new-in-one-expression %t -- -- -target x86_64-unknown-unknown\n// RUN: %check_clang_tidy -std=c++17 -check-suffixes=ALL,CPP17 %s bugprone-multiple-new-in-one-expression %t -- -- -target x86_64-unknown-unknown\n\nnamespace std {\ntypedef __typeof__(sizeof(0)) size_t;\nenum class align_val_t : std::size_t {};\nclass exception {};\nclass bad_alloc : public exception {};\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\n} // namespace std\n\nvoid *operator new(std::size_t, const std::nothrow_t &) noexcept;\nvoid *operator new(std::size_t, std::align_val_t, const std::nothrow_t &) noexcept;\nvoid *operator new(std::size_t, void *) noexcept;\nvoid *operator new(std::size_t, char);\n\nstruct B;\n\nstruct A { int VarI; int *PtrI; B *PtrB; };\n\nstruct B { int VarI; };\n\nstruct G {\n  G(A*, B*) {}\n  int operator+=(A *) { return 3; };\n};\n\nstruct H {\n  int *a;\n  int *b;\n};\n\nint f(int);\nint f(A*);\nint f(A*, B*);\nint f(int, B*);\nint f(G, G);\nint f(B*);\nint f(const H &);\nvoid f1(void *, void *);\nA *g(A *);\n\nG operator+(const G&, const G&);\n\nvoid test_function_parameter(A *XA, B *XB) {\n  (void)f(new A, new B);\n  try {\n    (void)f(new A, new B);\n  }\n  catch (A) {};\n  try {\n    (void)f(new A, new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:13: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception; order of these allocations is undefined [\n    (void)f(f(new A, new B));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    int X = f(new A, new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    X = f(new A, new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:11: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    X = 1 + f(new A, new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)f(g(new A), new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)f(1 + f(new A), new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:19: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (void)f(XA = new A, new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:18: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (void)f(1 + f(new A), XB = new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:19: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n  }\n  catch (std::exception) {}\n}\n\nvoid test_operator(G *G1) {\n  (void)(f(new A) + f(new B));\n  try {\n    (void)(f(new A) + f(new B));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:14: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (void)f(f(new A) + f(new B));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    int X = f(new A) + f(new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    X = f(new A) + f(new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:11: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    X = 1 + f(new A) + 1 + f(new B);\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:15: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)(f(g(new A)) + f(new B));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:16: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)(f(1 + f(new A)) + f(new B));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:20: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (void)(f(1 + f(new A)) + f(1 + f(new B)));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:20: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)((new A)->VarI + (new A)->VarI);\n\n    (void)(f(new A) + ((*G1) += new A));\n     // CHECK-MESSAGES-ALL: :[[@LINE-1]]:14: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n  }\n  catch (std::bad_alloc) {}\n}\n\nvoid test_construct() {\n  (void)(G(new A, new B));\n  try {\n    (void)(G(new A, new B));\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:14: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (void)(G(new A, nullptr) + G(nullptr, new B));\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:14: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    f(G(new A, nullptr), G(new A, nullptr));\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:9: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)new G(new A, nullptr);\n    // CHECK-MESSAGES-CPP11: :[[@LINE-1]]:11: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    // CHECK-MESSAGES-CPP17: :[[@LINE-2]]:11: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception [\n    (void)new G(nullptr, (new A)->PtrB);\n    G *Z = new G(new A, nullptr);\n    // CHECK-MESSAGES-CPP11: :[[@LINE-1]]:12: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    // CHECK-MESSAGES-CPP17: :[[@LINE-2]]:12: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception [\n    Z = new G(g(new A), nullptr);\n    // CHECK-MESSAGES-CPP11: :[[@LINE-1]]:9: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    // CHECK-MESSAGES-CPP17: :[[@LINE-2]]:9: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception [\n    G *Z1, *Z2 = new G(nullptr, (new A)->PtrB), *Z3;\n    // CHECK-MESSAGES-CPP11: :[[@LINE-1]]:18: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    // CHECK-MESSAGES-CPP17: :[[@LINE-2]]:18: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception [\n }\n  catch (const std::bad_alloc &) {}\n}\n\nvoid test_new_assign() {\n  A *X, *Y;\n  (X = new A)->VarI = (Y = new A)->VarI;\n  try {\n    (X = new A)->VarI = (Y = new A)->VarI;\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:10: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (new A)->VarI = (Y = new A)->VarI;\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:6: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (X = new A)->VarI = (new A)->VarI;\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:10: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (new A)->VarI = (new A)->VarI;\n    (new A)->PtrI = new int;\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:6: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n    (X = new A)->VarI += (new A)->VarI;\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:10: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n  }\n  catch (...) {}\n}\n\nvoid test_operator_fixed_order(unsigned int L) {\n  (void)(f((f(new A) || f(0)) + f(new B[L])));\n  try {\n    (void)(f(new A) || f(new B));\n    (void)(f(new A) && f(new B));\n    (void)(f(new A) || f(new B) || f(new A));\n\n    (void)(f(new A), f(new B));\n\n    int Y = f(0, new B) ? f(new A) : f(new B);\n    Y = f(new A) ? 1 : f(new B);\n    Y = f(new A) ? f(new B) : 1;\n\n    G g{new A, new B};\n    H h{new int, new int};\n    f({new int, new int});\n    (void)f({new A, new B}, {nullptr, nullptr});\n    (void)f({new A, new B}, {new A, nullptr});\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:14: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n\n    (void)(f((f(new A) || f(0)) + f(new B[L])));\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:17: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n  }\n  catch (std::bad_alloc) {}\n}\n\nvoid test_cast() {\n  try {\n    f1(static_cast<void *>(new A), new B);\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:28: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n  }\n  catch (std::bad_alloc &) {}\n}\n\nvoid test_nothrow(void *P) {\n  try {\n    (void)f(new(std::nothrow) A, new B);\n    (void)f(new A, new(std::nothrow) B);\n    (void)f(new(static_cast<std::align_val_t>(8), std::nothrow) A, new B);\n    (void)f(new(P) A, new B);\n    (void)f(new('a') A, new B);\n    // CHECK-MESSAGES-ALL: :[[@LINE-1]]:13: warning: memory allocation may leak if an other allocation is sequenced after it and throws an exception;\n  }\n  catch (std::exception) {}\n}"
    }
  ]
}