{
  "name": "ForwardingReferenceOverload",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-forwarding-reference-overload",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 153,
  "branches": 23,
  "apis": 118,
  "test": [
    {
      "description": null,
      "expected-problems": 0,
      "expected-linenumbers": [],
      "code": "\n// RUN: %check_clang_tidy %s bugprone-forwarding-reference-overload %t\n\nnamespace std {\ntemplate <bool B, class T = void> struct enable_if { typedef T type; };\n\ntemplate <class T> struct enable_if<true, T> { typedef T type; };\n\ntemplate <bool B, class T = void>\nusing enable_if_t = typename enable_if<B, T>::type;\n\ntemplate <class T> struct enable_if_nice { typedef T type; };\n} // namespace std\n\nnamespace foo {\ntemplate <class T> struct enable_if { typedef T type; };\n} // namespace foo\n\ntemplate <typename T> constexpr bool just_true = true;\n\nclass Test1 {\npublic:\n  template <typename T> Test1(T &&n);\n  // CHECK-NOTES: [[@LINE-1]]:25: warning: constructor accepting a forwarding reference can hide the copy and move constructors [bugprone-forwarding-reference-overload]\n  // CHECK-NOTES: 48:3: note: copy constructor declared here\n  // CHECK-NOTES: 49:3: note: copy constructor declared here\n  // CHECK-NOTES: 50:3: note: move constructor declared here\n\n  template <typename T> Test1(T &&n, int i = 5, ...);\n  // CHECK-NOTES: :[[@LINE-1]]:25: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 48:3: note: copy constructor declared here\n  // CHECK-NOTES: 49:3: note: copy constructor declared here\n  // CHECK-NOTES: 50:3: note: move constructor declared here\n\n  template <typename T, typename U = typename std::enable_if_nice<T>::type>\n  Test1(T &&n);\n  // CHECK-NOTES: :[[@LINE-1]]:3: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 48:3: note: copy constructor declared here\n  // CHECK-NOTES: 49:3: note: copy constructor declared here\n  // CHECK-NOTES: 50:3: note: move constructor declared here\n\n  template <typename T>\n  Test1(T &&n, typename foo::enable_if<long>::type i = 5, ...);\n  // CHECK-NOTES: :[[@LINE-1]]:3: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 48:3: note: copy constructor declared here\n  // CHECK-NOTES: 49:3: note: copy constructor declared here\n  // CHECK-NOTES: 50:3: note: move constructor declared here\n\n  Test1(const Test1 &other) {}\n  Test1(Test1 &other) {}\n  Test1(Test1 &&other) {}\n};\n\ntemplate <typename U> class Test2 {\npublic:\n  // Two parameters without default value, can't act as copy / move constructor.\n  template <typename T, class V> Test2(T &&n, V &&m, int i = 5, ...);\n\n  // Guarded with enable_if.\n  template <typename T>\n  Test2(T &&n, int i = 5,\n        std::enable_if_t<sizeof(int) < sizeof(long), int> a = 5, ...);\n\n  // Guarded with enable_if.\n  template <typename T, typename X = typename std::enable_if<\n                            sizeof(int) < sizeof(long), double>::type &>\n  Test2(T &&n);\n\n  // Guarded with enable_if.\n  template <typename T>\n  Test2(T &&n, typename std::enable_if<just_true<T>>::type **a = nullptr);\n\n  // Guarded with enable_if.\n  template <typename T, typename X = std::enable_if_t<just_true<T>> *&&>\n  Test2(T &&n, double d = 0.0);\n\n  // Not a forwarding reference parameter.\n  template <typename T> Test2(const T &&n);\n\n  // Not a forwarding reference parameter.\n  Test2(int &&x);\n\n  // Two parameters without default value, can't act as copy / move constructor.\n  template <typename T> Test2(T &&n, int x);\n\n  // Not a forwarding reference parameter.\n  template <typename T> Test2(U &&n);\n};\n\n// The copy and move constructors are both disabled.\nclass Test3 {\npublic:\n  template <typename T> Test3(T &&n);\n\n  template <typename T> Test3(T &&n, int I = 5, ...);\n\n  Test3(const Test3 &rhs) = delete;\n\nprivate:\n  Test3(Test3 &&rhs);\n};\n\n// Both the copy and the (compiler generated) move constructors can be hidden.\nclass Test4 {\npublic:\n  template <typename T> Test4(T &&n);\n  // CHECK-NOTES: :[[@LINE-1]]:25: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n\n  Test4(const Test4 &rhs);\n  // CHECK-NOTES: :[[@LINE-1]]:3: note: copy constructor declared here\n};\n\n// Nothing can be hidden, the copy constructor is implicitly deleted.\nclass Test5 {\npublic:\n  template <typename T> Test5(T &&n);\n\n  Test5(Test5 &&rhs) = delete;\n};\n\n// Only the move constructor can be hidden.\nclass Test6 {\npublic:\n  template <typename T> Test6(T &&n);\n  // CHECK-NOTES: :[[@LINE-1]]:25: warning: constructor accepting a forwarding reference can hide the move constructor\n\n  Test6(Test6 &&rhs);\n  // CHECK-NOTES: :[[@LINE-1]]:3: note: move constructor declared here\nprivate:\n  Test6(const Test6 &rhs);\n};\n\n// Do not dereference a null BaseType.\ntemplate <class _Callable> class result_of;\ntemplate <class _Fp, class ..._Args> class result_of<_Fp(_Args...)> { };\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n\ntemplate <class... _Types> struct __overload;\ntemplate <class _Tp, class... _Types>\nstruct __overload<_Tp, _Types...> : __overload<_Types...> {\n  using __overload<_Types...>::operator();\n};\n\ntemplate <class _Tp, class... _Types>\nusing __best_match_t = typename result_of_t<__overload<_Types...>(_Tp&&)>::type;\n\ntemplate <class... _Types>\nclass variant {\npublic:\n  template <class _Arg, class _Tp = __best_match_t<_Arg, _Types...> >\n  constexpr variant(_Arg&& __arg) {}\n  // CHECK-NOTES: :[[@LINE-1]]:13: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n};\n\nnamespace std {\ntemplate <class T, class U> struct is_same { static constexpr bool value = false; };\ntemplate <class T> struct is_same<T, T> { static constexpr bool value = true; };\ntemplate <class T, class U> constexpr bool is_same_v = is_same<T, U>::value;\ntemplate <class T> struct remove_reference { using type = T; };\ntemplate <class T> struct remove_reference<T&> { using type = T; };\ntemplate <class T> struct remove_reference<T&&> { using type = T; };\ntemplate <class T> using remove_reference_t = typename remove_reference<T>::type;\ntemplate <class T> struct remove_cv { using type = T; };\ntemplate <class T> struct remove_cv<const T> { using type = T; };\ntemplate <class T> struct remove_cv<volatile T> { using type = T; };\ntemplate <class T> struct remove_cv<const volatile T> { using type = T; };\ntemplate <class T> using remove_cv_t = typename remove_cv<T>::type;\ntemplate <class T> struct remove_cvref { using type = remove_cv_t<remove_reference_t<T>>; };\ntemplate <class T> using remove_cvref_t = typename remove_cvref<T>::type;\n} // namespace std\n\n// Handle enable_if when used as a non-type template parameter.\nclass Test7 {\npublic:\n  // Guarded with enable_if.\n  template <class T,\n    typename std::enable_if_t<std::is_same_v<std::remove_cvref_t<T>, int>, int>::type = 0>\n  Test7(T &&t);\n\n  // Guarded with enable_if.\n  template <class T,\n    std::enable_if_t<\n      !std::is_same_v<std::remove_cvref_t<T>, Test7>\n      && !std::is_same_v<std::remove_cvref_t<T>, bool>, int> = true>\n  Test7(T &&t);\n\n  Test7(const Test7 &other) = default;\n  Test7(Test7 &&other) = default;\n};\n\n// Handle enable_if when used as a non-type template parameter following\n// a variadic template parameter pack.\nclass Test8 {\npublic:\n  // Guarded with enable_if.\n  template <class T, class... A,\n    std::enable_if_t<\n      !std::is_same_v<std::remove_cvref_t<T>, Test8>\n      || (sizeof...(A) > 0)>* = nullptr>\n  Test8(T &&t, A &&... a);\n\n  Test8(const Test8 &other) = default;\n  Test8(Test8 &&other) = default;\n};\n\n// Non-type template parameter failure cases.\nclass Test9 {\npublic:\n  // Requires a default argument (such as a literal, implicit cast expression, etc.)\n  template <class T,\n    std::enable_if_t<std::is_same_v<std::remove_cvref_t<T>, bool>, int>>\n  Test9(T &&t);\n  // CHECK-NOTES: :[[@LINE-1]]:3: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 240:3: note: copy constructor declared here\n  // CHECK-NOTES: 241:3: note: move constructor declared here\n\n  // Requires a default argument (such as a literal, implicit cast expression, etc.)\n  template <class T,\n    std::enable_if_t<std::is_same_v<std::remove_cvref_t<T>, long>>*>\n  Test9(T &&t);\n  // CHECK-NOTES: :[[@LINE-1]]:3: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 240:3: note: copy constructor declared here\n  // CHECK-NOTES: 241:3: note: move constructor declared here\n\n  // Only std::enable_if or std::enable_if_t are supported\n  template <class T,\n    typename std::enable_if_nice<T>::type* = nullptr>\n  Test9(T &&t);\n  // CHECK-NOTES: :[[@LINE-1]]:3: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 240:3: note: copy constructor declared here\n  // CHECK-NOTES: 241:3: note: move constructor declared here\n\n  // Only std::enable_if or std::enable_if_t are supported\n  template <class T,\n    typename foo::enable_if<T>::type = 0>\n  Test9(T &&t);\n  // CHECK-NOTES: :[[@LINE-1]]:3: warning: constructor accepting a forwarding reference can hide the copy and move constructors\n  // CHECK-NOTES: 240:3: note: copy constructor declared here\n  // CHECK-NOTES: 241:3: note: move constructor declared here\n\n  Test9(const Test9 &other) = default;\n  Test9(Test9 &&other) = default;\n};\n\n\ntemplate <typename T>\nclass Test10 {\npublic:\n  enum E {};\n  E e;\n\n  Test10(T &&Item, E e)\n      : e(e){}\n};\n\n// A deleted ctor cannot hide anything\nclass Test11 {\npublic:\n  template <typename T>\n  Test11(T&&) = delete;\n\n  Test11(const Test11 &) = default;\n  Test11(Test11 &&) = default;\n};\n\ntemplate <template <class> typename T, typename U>\nstruct gh106333\n{\n    gh106333(U && arg1, T<int> arg2) {}\n};"
    }
  ]
}