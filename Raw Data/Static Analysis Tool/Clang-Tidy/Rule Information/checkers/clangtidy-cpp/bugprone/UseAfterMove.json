{
  "name": "UseAfterMove",
  "language": "cpp",
  "description": ".. title:: clang-tidy - bugprone-use-after-move",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 531,
  "branches": 70,
  "apis": 320,
  "test": [
    {
      "description": null,
      "expected-problems": 0,
      "expected-linenumbers": [],
      "code": "\n// RUN: %check_clang_tidy -std=c++11 -check-suffixes=,CXX11 %s bugprone-use-after-move %t -- -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -std=c++17-or-later %s bugprone-use-after-move %t -- -- -fno-delayed-template-parsing\n\ntypedef decltype(nullptr) nullptr_t;\n\nnamespace std {\ntypedef unsigned size_t;\n\ntemplate <typename T>\nstruct unique_ptr {\n  unique_ptr();\n  T *get() const;\n  explicit operator bool() const;\n  void reset(T *ptr);\n  T &operator*() const;\n  T *operator->() const;\n  T& operator[](size_t i) const;\n};\n\ntemplate <typename T>\nstruct shared_ptr {\n  shared_ptr();\n  T *get() const;\n  explicit operator bool() const;\n  void reset(T *ptr);\n  T &operator*() const;\n  T *operator->() const;\n};\n\ntemplate <typename T>\nstruct weak_ptr {\n  weak_ptr();\n  bool expired() const;\n};\n\ntemplate <typename T>\nstruct optional {\n  optional();\n  T& operator*();\n  const T& operator*() const;\n  void reset();\n};\n\nstruct any {\n  any();\n  void reset();\n};\n\ntemplate <typename T1, typename T2>\nstruct pair {};\n\ntemplate <typename Key, typename T>\nstruct map {\n  struct iterator {};\n\n  map();\n  void clear();\n  bool empty();\n  template <class... Args>\n  pair<iterator, bool> try_emplace(const Key &key, Args &&...args);\n};\n\ntemplate <typename Key, typename T>\nstruct unordered_map {\n  struct iterator {};\n\n  unordered_map();\n  void clear();\n  bool empty();\n  template <class... Args>\n  pair<iterator, bool> try_emplace(const Key &key, Args &&...args);\n};\n\n#define DECLARE_STANDARD_CONTAINER(name) \\\n  template <typename T>                  \\\n  struct name {                          \\\n    name();                              \\\n    void clear();                        \\\n    bool empty();                        \\\n  }\n\n#define DECLARE_STANDARD_CONTAINER_WITH_ASSIGN(name) \\\n  template <typename T>                              \\\n  struct name {                                      \\\n    name();                                          \\\n    void clear();                                    \\\n    bool empty();                                    \\\n    void assign(size_t, const T &);                  \\\n  }\n\nDECLARE_STANDARD_CONTAINER_WITH_ASSIGN(basic_string);\nDECLARE_STANDARD_CONTAINER_WITH_ASSIGN(vector);\nDECLARE_STANDARD_CONTAINER_WITH_ASSIGN(deque);\nDECLARE_STANDARD_CONTAINER_WITH_ASSIGN(forward_list);\nDECLARE_STANDARD_CONTAINER_WITH_ASSIGN(list);\nDECLARE_STANDARD_CONTAINER(set);\nDECLARE_STANDARD_CONTAINER(multiset);\nDECLARE_STANDARD_CONTAINER(multimap);\nDECLARE_STANDARD_CONTAINER(unordered_set);\nDECLARE_STANDARD_CONTAINER(unordered_multiset);\nDECLARE_STANDARD_CONTAINER(unordered_multimap);\n\ntypedef basic_string<char> string;\n\ntemplate <typename>\nstruct remove_reference;\n\ntemplate <typename _Tp>\nstruct remove_reference {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_reference<_Tp &> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_reference<_Tp &&> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nconstexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept {\n  return static_cast<typename remove_reference<_Tp>::type &&>(__t);\n}\n\ntemplate <class _Tp>\nconstexpr _Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) noexcept {\n  return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\nconstexpr _Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) noexcept {\n  return static_cast<_Tp&&>(__t);\n}\n\n} // namespace std\n\nclass A {\npublic:\n  A();\n  A(const A &);\n  A(A &&);\n\n  A &operator=(const A &);\n  A &operator=(A &&);\n\n  void foo() const;\n  void bar(int i) const;\n  int getInt() const;\n\n  operator bool() const;\n\n  int i;\n};\n\ntemplate <class T>\nclass AnnotatedContainer {\npublic:\n  AnnotatedContainer();\n\n  void foo() const;\n  [[clang::reinitializes]] void clear();\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// General tests.\n\n// Simple case.\nvoid simple() {\n  A a;\n  a.foo();\n  A other_a = std::move(a);\n  a.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:15: note: move occurred here\n}\n\n// Don't flag a move-to-self.\nvoid selfMove() {\n  A a;\n  a = std::move(a);\n  a.foo();\n}\n\n// A warning should only be emitted for one use-after-move.\nvoid onlyFlagOneUseAfterMove() {\n  A a;\n  a.foo();\n  A other_a = std::move(a);\n  a.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:15: note: move occurred here\n  a.foo();\n}\n\nvoid moveAfterMove() {\n  // Move-after-move also counts as a use.\n  {\n    A a;\n    std::move(a);\n    std::move(a);\n    // CHECK-NOTES: [[@LINE-1]]:15: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // This is also true if the move itself turns into the use on the second loop\n  // iteration.\n  {\n    A a;\n    for (int i = 0; i < 10; ++i) {\n      std::move(a);\n      // CHECK-NOTES: [[@LINE-1]]:17: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-2]]:7: note: move occurred here\n      // CHECK-NOTES: [[@LINE-3]]:17: note: the use happens in a later loop\n    }\n  }\n}\n\n// Checks also works on function parameters that have a use-after move.\nvoid parameters(A a) {\n  std::move(a);\n  a.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:3: note: move occurred here\n}\n\nvoid standardSmartPtr() {\n  // std::unique_ptr<>, std::shared_ptr<> and std::weak_ptr<> are guaranteed to\n  // be null after a std::move. So the check only flags accesses that would\n  // dereference the pointer.\n  {\n    std::unique_ptr<A> ptr;\n    std::move(ptr);\n    ptr.get();\n    static_cast<bool>(ptr);\n    *ptr;\n    // CHECK-NOTES: [[@LINE-1]]:6: warning: 'ptr' used after it was moved\n    // CHECK-NOTES: [[@LINE-5]]:5: note: move occurred here\n  }\n  {\n    std::unique_ptr<A> ptr;\n    std::move(ptr);\n    ptr->foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'ptr' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  {\n    std::unique_ptr<A> ptr;\n    std::move(ptr);\n    ptr[0];\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'ptr' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  {\n    std::shared_ptr<A> ptr;\n    std::move(ptr);\n    ptr.get();\n    static_cast<bool>(ptr);\n    *ptr;\n    // CHECK-NOTES: [[@LINE-1]]:6: warning: 'ptr' used after it was moved\n    // CHECK-NOTES: [[@LINE-5]]:5: note: move occurred here\n  }\n  {\n    std::shared_ptr<A> ptr;\n    std::move(ptr);\n    ptr->foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'ptr' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  {\n    std::optional<A> opt;\n    std::move(opt);\n    A val = *opt;\n    (void)val;\n    // CHECK-NOTES: [[@LINE-2]]:14: warning: 'opt' used after it was moved\n    // CHECK-NOTES: [[@LINE-4]]:5: note: move occurred here\n  }\n  {\n    // std::weak_ptr<> cannot be dereferenced directly, so we only check that\n    // member functions may be called on it after a move.\n    std::weak_ptr<A> ptr;\n    std::move(ptr);\n    ptr.expired();\n  }\n  // Make sure we recognize std::unique_ptr<> or std::shared_ptr<> if they're\n  // wrapped in a typedef.\n  {\n    typedef std::unique_ptr<A> PtrToA;\n    PtrToA ptr;\n    std::move(ptr);\n    ptr.get();\n  }\n  {\n    typedef std::shared_ptr<A> PtrToA;\n    PtrToA ptr;\n    std::move(ptr);\n    ptr.get();\n  }\n  // And we don't get confused if the template argument is a little more\n  // involved.\n  {\n    struct B {\n      typedef A AnotherNameForA;\n    };\n    std::unique_ptr<B::AnotherNameForA> ptr;\n    std::move(ptr);\n    ptr.get();\n  }\n  // Make sure we treat references to smart pointers correctly.\n  {\n    std::unique_ptr<A> ptr;\n    std::unique_ptr<A>& ref_to_ptr = ptr;\n    std::move(ref_to_ptr);\n    ref_to_ptr.get();\n  }\n  {\n    std::unique_ptr<A> ptr;\n    std::unique_ptr<A>&& rvalue_ref_to_ptr = std::move(ptr);\n    std::move(rvalue_ref_to_ptr);\n    rvalue_ref_to_ptr.get();\n  }\n  // We don't give any special treatment to types that are called \"unique_ptr\"\n  // or \"shared_ptr\" but are not in the \"::std\" namespace.\n  {\n    struct unique_ptr {\n      void get();\n    } ptr;\n    std::move(ptr);\n    ptr.get();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'ptr' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n}\n\n// The check also works in member functions.\nclass Container {\n  void useAfterMoveInMemberFunction() {\n    A a;\n    std::move(a);\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n};\n\n// We see the std::move() if it's inside a declaration.\nvoid moveInDeclaration() {\n  A a;\n  A another_a(std::move(a));\n  a.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n}\n\n// We see the std::move if it's inside an initializer list. Initializer lists\n// are a special case because they cause ASTContext::getParents() to return\n// multiple parents for certain nodes in their subtree. This is because\n// RecursiveASTVisitor visits both the syntactic and semantic forms of\n// InitListExpr, and the parent-child relationships are different between the\n// two forms.\nvoid moveInInitList() {\n  struct S {\n    A a;\n  };\n  A a;\n  S s{std::move(a)};\n  a.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:7: note: move occurred here\n}\n\nvoid lambdas() {\n  // Use-after-moves inside a lambda should be detected.\n  {\n    A a;\n    auto lambda = [a] {\n      std::move(a);\n      a.foo();\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-3]]:7: note: move occurred here\n    };\n  }\n  // This is just as true if the variable was declared inside the lambda.\n  {\n    auto lambda = [] {\n      A a;\n      std::move(a);\n      a.foo();\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-3]]:7: note: move occurred here\n    };\n  }\n  // But don't warn if the move happened inside the lambda but the use happened\n  // outside -- because\n  // - the 'a' inside the lambda is a copy, and\n  // - we don't know when the lambda will get called anyway\n  {\n    A a;\n    auto lambda = [a] {\n      std::move(a);\n    };\n    a.foo();\n  }\n  // Don't warn if 'a' is a copy inside a synchronous lambda\n  {\n    A a;\n    A copied{[a] mutable { return std::move(a); }()};\n    a.foo();\n  }\n  // False negative (should warn if 'a' is a ref inside a synchronous lambda)\n  {\n    A a;\n    A moved{[&a] mutable { return std::move(a); }()};\n    a.foo();\n  }\n  // Warn if the use consists of a capture that happens after a move.\n  {\n    A a;\n    std::move(a);\n    auto lambda = [a]() { a.foo(); };\n    // CHECK-NOTES: [[@LINE-1]]:20: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // ...even if the capture was implicit.\n  {\n    A a;\n    std::move(a);\n    auto lambda = [=]() { a.foo(); };\n    // CHECK-NOTES: [[@LINE-1]]:20: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // Same tests but for capture by reference.\n  {\n    A a;\n    std::move(a);\n    auto lambda = [&a]() { a.foo(); };\n    // CHECK-NOTES: [[@LINE-1]]:21: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  {\n    A a;\n    std::move(a);\n    auto lambda = [&]() { a.foo(); };\n    // CHECK-NOTES: [[@LINE-1]]:20: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // But don't warn if the move happened after the capture.\n  {\n    A a;\n    auto lambda = [a]() { a.foo(); };\n    std::move(a);\n  }\n  // ...and again, same thing with an implicit move.\n  {\n    A a;\n    auto lambda = [=]() { a.foo(); };\n    std::move(a);\n  }\n  // Same tests but for capture by reference.\n  {\n    A a;\n    auto lambda = [&a]() { a.foo(); };\n    std::move(a);\n  }\n  {\n    A a;\n    auto lambda = [&]() { a.foo(); };\n    std::move(a);\n  }\n  {\n    A a;\n    auto lambda = [a = std::move(a)] { a.foo(); };\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:24: note: move occurred here\n  }\n}\n\n// Use-after-moves are detected in uninstantiated templates if the moved type\n// is not a dependent type.\ntemplate <class T>\nvoid movedTypeIsNotDependentType() {\n  T t;\n  A a;\n  std::move(a);\n  a.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:3: note: move occurred here\n}\n\n// And if the moved type is a dependent type, the use-after-move is detected if\n// the template is instantiated.\ntemplate <class T>\nvoid movedTypeIsDependentType() {\n  T t;\n  std::move(t);\n  t.foo();\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 't' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:3: note: move occurred here\n}\ntemplate void movedTypeIsDependentType<A>();\n\n// We handle the case correctly where the move consists of an implicit call\n// to a conversion operator.\nvoid implicitConversionOperator() {\n  struct Convertible {\n    operator A() && { return A(); }\n  };\n  void takeA(A a);\n\n  Convertible convertible;\n  takeA(std::move(convertible));\n  convertible;\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: 'convertible' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:9: note: move occurred here\n}\n\n// Using decltype on an expression is not a use.\nvoid decltypeIsNotUse() {\n  A a;\n  std::move(a);\n  decltype(a) other_a;\n}\n\n// Ignore moves or uses that occur as part of template arguments.\ntemplate <int>\nclass ClassTemplate {\npublic:\n  void foo(A a);\n};\ntemplate <int>\nvoid functionTemplate(A a);\nvoid templateArgIsNotUse() {\n  {\n    // A pattern like this occurs in the EXPECT_EQ and ASSERT_EQ macros in\n    // Google Test.\n    A a;\n    ClassTemplate<sizeof(A(std::move(a)))>().foo(std::move(a));\n  }\n  {\n    A a;\n    functionTemplate<sizeof(A(std::move(a)))>(std::move(a));\n  }\n}\n\n// Ignore moves of global variables.\nA global_a;\nvoid ignoreGlobalVariables() {\n  std::move(global_a);\n  global_a.foo();\n}\n\n// Ignore moves of member variables.\nclass IgnoreMemberVariables {\n  A a;\n  static A static_a;\n\n  void f() {\n    std::move(a);\n    a.foo();\n\n    std::move(static_a);\n    static_a.foo();\n  }\n};\n\n// Ignore moves that happen in a try_emplace.\nvoid ignoreMoveInTryEmplace() {\n  {\n    std::map<int, A> amap;\n    A a;\n    amap.try_emplace(1, std::move(a));\n    a.foo();\n  }\n  {\n    std::unordered_map<int, A> amap;\n    A a;\n    amap.try_emplace(1, std::move(a));\n    a.foo();\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Tests involving control flow.\n\nvoid useAndMoveInLoop() {\n  // Warn about use-after-moves if they happen in a later loop iteration than\n  // the std::move().\n  {\n    A a;\n    for (int i = 0; i < 10; ++i) {\n      a.foo();\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE+2]]:7: note: move occurred here\n      // CHECK-NOTES: [[@LINE-3]]:7: note: the use happens in a later loop\n      std::move(a);\n    }\n  }\n  // Same as above, but the use and the move are in different CFG blocks.\n  {\n    A a;\n    for (int i = 0; i < 10; ++i) {\n      if (i < 10)\n        a.foo();\n      // CHECK-NOTES: [[@LINE-1]]:9: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE+3]]:9: note: move occurred here\n      // CHECK-NOTES: [[@LINE-3]]:9: note: the use happens in a later loop\n      if (i < 10)\n        std::move(a);\n    }\n  }\n  // However, this case shouldn't be flagged -- the scope of the declaration of\n  // 'a' is important.\n  {\n    for (int i = 0; i < 10; ++i) {\n      A a;\n      a.foo();\n      std::move(a);\n    }\n  }\n  // Same as above, except that we have an unrelated variable being declared in\n  // the same declaration as 'a'. This case is interesting because it tests that\n  // the synthetic DeclStmts generated by the CFG are sequenced correctly\n  // relative to the other statements.\n  {\n    for (int i = 0; i < 10; ++i) {\n      A a, other;\n      a.foo();\n      std::move(a);\n    }\n  }\n  // Don't warn if we return after the move.\n  {\n    A a;\n    for (int i = 0; i < 10; ++i) {\n      a.foo();\n      if (a.getInt() > 0) {\n        std::move(a);\n        return;\n      }\n    }\n  }\n}\n\nvoid differentBranches(int i) {\n  // Don't warn if the use is in a different branch from the move.\n  {\n    A a;\n    if (i > 0) {\n      std::move(a);\n    } else {\n      a.foo();\n    }\n  }\n  // Same thing, but with a ternary operator.\n  {\n    A a;\n    i > 0 ? (void)std::move(a) : a.foo();\n  }\n  // A variation on the theme above.\n  {\n    A a;\n    a.getInt() > 0 ? a.getInt() : A(std::move(a)).getInt();\n  }\n  // Same thing, but with a switch statement.\n  {\n    A a;\n    switch (i) {\n    case 1:\n      std::move(a);\n      break;\n    case 2:\n      a.foo();\n      break;\n    }\n  }\n  // However, if there's a fallthrough, we do warn.\n  {\n    A a;\n    switch (i) {\n    case 1:\n      std::move(a);\n    case 2:\n      a.foo();\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-4]]:7: note: move occurred here\n      break;\n    }\n  }\n}\n\n// False positive: A use-after-move is flagged even though the \"if (b)\" and\n// \"if (!b)\" are mutually exclusive.\nvoid mutuallyExclusiveBranchesFalsePositive(bool b) {\n  A a;\n  if (b) {\n    std::move(a);\n  }\n  if (!b) {\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-5]]:5: note: move occurred here\n  }\n}\n\n// Destructors marked [[noreturn]] are handled correctly in the control flow\n// analysis. (These are used in some styles of assertion macros.)\nclass FailureLogger {\npublic:\n  FailureLogger();\n  [[noreturn]] ~FailureLogger();\n  void log(const char *);\n};\n#define ASSERT(x) \\\n  while (x)       \\\n  FailureLogger().log(#x)\nbool operationOnA(A);\nvoid noreturnDestructor() {\n  A a;\n  // The while loop in the ASSERT() would ordinarily have the potential to cause\n  // a use-after-move because the second iteration of the loop would be using a\n  // variable that had been moved from in the first iteration. Check that the\n  // CFG knows that the second iteration of the loop is never reached because\n  // the FailureLogger destructor is marked [[noreturn]].\n  ASSERT(operationOnA(std::move(a)));\n}\n#undef ASSERT\n\n////////////////////////////////////////////////////////////////////////////////\n// Tests for reinitializations\n\ntemplate <class T>\nvoid swap(T &a, T &b) {\n  T tmp = std::move(a);\n  a = std::move(b);\n  b = std::move(tmp);\n}\nvoid assignments(int i) {\n  // Don't report a use-after-move if the variable was assigned to in the\n  // meantime.\n  {\n    A a;\n    std::move(a);\n    a = A();\n    a.foo();\n  }\n  // The assignment should also be recognized if move, assignment and use don't\n  // all happen in the same block (but the assignment is still guaranteed to\n  // prevent a use-after-move).\n  {\n    A a;\n    if (i == 1) {\n      std::move(a);\n      a = A();\n    }\n    if (i == 2) {\n      a.foo();\n    }\n  }\n  {\n    A a;\n    if (i == 1) {\n      std::move(a);\n    }\n    if (i == 2) {\n      a = A();\n      a.foo();\n    }\n  }\n  // The built-in assignment operator should also be recognized as a\n  // reinitialization. (std::move() may be called on built-in types in template\n  // code.)\n  {\n    int a1 = 1, a2 = 2;\n    swap(a1, a2);\n  }\n  // A std::move() after the assignment makes the variable invalid again.\n  {\n    A a;\n    std::move(a);\n    a = A();\n    std::move(a);\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // Report a use-after-move if we can't be sure that the variable was assigned\n  // to.\n  {\n    A a;\n    std::move(a);\n    if (i < 10) {\n      a = A();\n    }\n    if (i > 5) {\n      a.foo();\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-7]]:5: note: move occurred here\n    }\n  }\n}\n\n// Passing the object to a function through a non-const pointer or reference\n// counts as a re-initialization.\nvoid passByNonConstPointer(A *);\nvoid passByNonConstReference(A &);\nvoid passByNonConstPointerIsReinit() {\n  {\n    A a;\n    std::move(a);\n    passByNonConstPointer(&a);\n    a.foo();\n  }\n  {\n    A a;\n    std::move(a);\n    passByNonConstReference(a);\n    a.foo();\n  }\n}\n\n// Passing the object through a const pointer or reference counts as a use --\n// since the called function cannot reinitialize the object.\nvoid passByConstPointer(const A *);\nvoid passByConstReference(const A &);\nvoid passByConstPointerIsUse() {\n  {\n    // Declaring 'a' as const so that no ImplicitCastExpr is inserted into the\n    // AST -- we wouldn't want the check to rely solely on that to detect a\n    // const pointer argument.\n    const A a;\n    std::move(a);\n    passByConstPointer(&a);\n    // CHECK-NOTES: [[@LINE-1]]:25: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  const A a;\n  std::move(a);\n  passByConstReference(a);\n  // CHECK-NOTES: [[@LINE-1]]:24: warning: 'a' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:3: note: move occurred here\n}\n\n// Clearing a standard container using clear() is treated as a\n// re-initialization.\nvoid standardContainerClearIsReinit() {\n  {\n    std::string container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::vector<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n\n    auto container2 = container;\n    std::move(container2);\n    container2.clear();\n    container2.empty();\n  }\n  {\n    std::deque<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::forward_list<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::list<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::set<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::map<int, int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::multiset<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::multimap<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::unordered_set<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::unordered_map<int, int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::unordered_multiset<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  {\n    std::unordered_multimap<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  // This should also work for typedefs of standard containers.\n  {\n    typedef std::vector<int> IntVector;\n    IntVector container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  // But it shouldn't work for non-standard containers.\n  {\n    // This might be called \"vector\", but it's not in namespace \"std\".\n    struct vector {\n      void clear() {}\n    } container;\n    std::move(container);\n    container.clear();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'container' used after it was\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // An intervening clear() on a different container does not reinitialize.\n  {\n    std::vector<int> container1, container2;\n    std::move(container1);\n    container2.clear();\n    container1.empty();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'container1' used after it was\n    // CHECK-NOTES: [[@LINE-4]]:5: note: move occurred here\n  }\n}\n\n// Clearing a standard container using assign() is treated as a\n// re-initialization.\nvoid standardContainerAssignIsReinit() {\n  {\n    std::string container;\n    std::move(container);\n    container.assign(0, ' ');\n    container.empty();\n  }\n  {\n    std::vector<int> container;\n    std::move(container);\n    container.assign(0, 0);\n    container.empty();\n  }\n  {\n    std::deque<int> container;\n    std::move(container);\n    container.assign(0, 0);\n    container.empty();\n  }\n  {\n    std::forward_list<int> container;\n    std::move(container);\n    container.assign(0, 0);\n    container.empty();\n  }\n  {\n    std::list<int> container;\n    std::move(container);\n    container.clear();\n    container.empty();\n  }\n  // But it doesn't work for non-standard containers.\n  {\n    // This might be called \"vector\", but it's not in namespace \"std\".\n    struct vector {\n      void assign(std::size_t, int) {}\n    } container;\n    std::move(container);\n    container.assign(0, 0);\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'container' used after it was\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  // An intervening assign() on a different container does not reinitialize.\n  {\n    std::vector<int> container1, container2;\n    std::move(container1);\n    container2.assign(0, 0);\n    container1.empty();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'container1' used after it was\n    // CHECK-NOTES: [[@LINE-4]]:5: note: move occurred here\n  }\n}\n\n// Resetting the standard smart owning types using reset() is treated as a\n// re-initialization. (We don't test std::weak_ptr<> because it can't be\n// dereferenced directly.)\nvoid resetIsReinit() {\n  {\n    std::unique_ptr<A> ptr;\n    std::move(ptr);\n    ptr.reset(new A);\n    *ptr;\n  }\n  {\n    std::shared_ptr<A> ptr;\n    std::move(ptr);\n    ptr.reset(new A);\n    *ptr;\n  }\n  {\n    std::optional<A> opt;\n    std::move(opt);\n    opt.reset();\n    std::optional<A> opt2 = opt;\n    (void)opt2;\n  }\n  {\n    std::any a;\n    std::move(a);\n    a.reset();\n    std::any a2 = a;\n    (void)a2;\n  }\n}\n\nvoid reinitAnnotation() {\n  {\n    AnnotatedContainer<int> obj;\n    std::move(obj);\n    obj.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'obj' used after it was\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  {\n    AnnotatedContainer<int> obj;\n    std::move(obj);\n    obj.clear();\n    obj.foo();\n  }\n  {\n    // Calling clear() on a different object to the one that was moved is not\n    // considered a reinitialization.\n    AnnotatedContainer<int> obj1, obj2;\n    std::move(obj1);\n    obj2.clear();\n    obj1.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'obj1' used after it was\n    // CHECK-NOTES: [[@LINE-4]]:5: note: move occurred here\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Tests related to order of evaluation within expressions\n\n// Relative sequencing of move and use.\nvoid passByRvalueReference(int i, A &&a);\nvoid passByValue(int i, A a);\nvoid passByValue(A a, int i);\nA g(A, A &&);\nint intFromA(A &&);\nint intFromInt(int);\nvoid sequencingOfMoveAndUse() {\n  // This case is fine because the move only happens inside\n  // passByRvalueReference(). At this point, a.getInt() is guaranteed to have\n  // been evaluated.\n  {\n    A a;\n    passByRvalueReference(a.getInt(), std::move(a));\n  }\n  // However, if we pass by value, the move happens when the move constructor is\n  // called to create a temporary, and this happens before the call to\n  // passByValue(). Because the order in which arguments are evaluated isn't\n  // defined, the move may happen before the call to a.getInt().\n  //\n  // Check that we warn about a potential use-after move for both orderings of\n  // a.getInt() and std::move(a), independent of the order in which the\n  // arguments happen to get evaluated by the compiler.\n  {\n    A a;\n    passByValue(a.getInt(), std::move(a));\n    // CHECK-NOTES: [[@LINE-1]]:17: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:29: note: move occurred here\n    // CHECK-NOTES: [[@LINE-3]]:17: note: the use and move are unsequenced\n  }\n  {\n    A a;\n    passByValue(std::move(a), a.getInt());\n    // CHECK-NOTES: [[@LINE-1]]:31: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:17: note: move occurred here\n    // CHECK-NOTES: [[@LINE-3]]:31: note: the use and move are unsequenced\n  }\n  // An even more convoluted example.\n  {\n    A a;\n    g(g(a, std::move(a)), g(a, std::move(a)));\n    // CHECK-NOTES: [[@LINE-1]]:9: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:27: note: move occurred here\n    // CHECK-NOTES: [[@LINE-3]]:9: note: the use and move are unsequenced\n    // CHECK-NOTES: [[@LINE-4]]:29: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-5]]:7: note: move occurred here\n    // CHECK-NOTES: [[@LINE-6]]:29: note: the use and move are unsequenced\n  }\n  // This case is fine because the actual move only happens inside the call to\n  // operator=(). a.getInt(), by necessity, is evaluated before that call.\n  {\n    A a;\n    A vec[1];\n    vec[a.getInt()] = std::move(a);\n  }\n  // However, in the following case, the move happens before the assignment, and\n  // so the order of evaluation is not guaranteed.\n  {\n    A a;\n    int v[3];\n    v[a.getInt()] = intFromA(std::move(a));\n    // CHECK-NOTES: [[@LINE-1]]:7: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:21: note: move occurred here\n    // CHECK-NOTES: [[@LINE-3]]:7: note: the use and move are unsequenced\n  }\n  {\n    A a;\n    int v[3];\n    v[intFromA(std::move(a))] = intFromInt(a.i);\n    // CHECK-NOTES: [[@LINE-1]]:44: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:7: note: move occurred here\n    // CHECK-NOTES: [[@LINE-3]]:44: note: the use and move are unsequenced\n  }\n}\n\n// Relative sequencing of move and reinitialization. If the two are unsequenced,\n// we conservatively assume that the move happens after the reinitialization,\n// i.e. the that object does not get reinitialized after the move.\nA MutateA(A a);\nvoid passByValue(A a1, A a2);\nvoid sequencingOfMoveAndReinit() {\n  // Move and reinitialization as function arguments (which are indeterminately\n  // sequenced). Again, check that we warn for both orderings.\n  {\n    A a;\n    passByValue(std::move(a), (a = A()));\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:17: note: move occurred here\n  }\n  {\n    A a;\n    passByValue((a = A()), std::move(a));\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:28: note: move occurred here\n  }\n  // Common usage pattern: Move the object to a function that mutates it in some\n  // way, then reassign the result to the object. This pattern is fine.\n  {\n    A a;\n    a = MutateA(std::move(a));\n    a.foo();\n  }\n}\n\n// Relative sequencing of reinitialization and use. If the two are unsequenced,\n// we conservatively assume that the reinitialization happens after the use,\n// i.e. that the object is not reinitialized at the point in time when it is\n// used.\nvoid sequencingOfReinitAndUse() {\n  // Reinitialization and use in function arguments. Again, check both possible\n  // orderings.\n  {\n    A a;\n    std::move(a);\n    passByValue(a.getInt(), (a = A()));\n    // CHECK-NOTES: [[@LINE-1]]:17: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n  {\n    A a;\n    std::move(a);\n    passByValue((a = A()), a.getInt());\n    // CHECK-NOTES: [[@LINE-1]]:28: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n}\n\n// The comma operator sequences its operands.\nvoid commaOperatorSequences() {\n  {\n    A a;\n    A(std::move(a))\n    , (a = A());\n    a.foo();\n  }\n  {\n    A a;\n    (a = A()), A(std::move(a));\n    a.foo();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:16: note: move occurred here\n  }\n}\n\nnamespace InitializerListSequences {\n\nstruct S1 {\n  int i;\n  A a;\n};\n\nstruct S2 {\n  A a;\n  int i;\n};\n\nstruct S3 {\n  S3() {}\n  S3(int, A) {}\n  S3(A, int) {}\n};\n\n// An initializer list sequences its initialization clauses.\nvoid initializerListSequences() {\n  {\n    A a;\n    S1 s1{a.getInt(), std::move(a)};\n  }\n  {\n    A a;\n    S1 s1{.i = a.getInt(), .a = std::move(a)};\n  }\n  {\n    A a;\n    S2 s2{std::move(a), a.getInt()};\n    // CHECK-NOTES: [[@LINE-1]]:25: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:11: note: move occurred here\n  }\n  {\n    A a;\n    S2 s2{.a = std::move(a), .i = a.getInt()};\n    // CHECK-NOTES: [[@LINE-1]]:35: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:11: note: move occurred here\n  }\n  {\n    // Check the case where the constructed type has a constructor and the\n    // initializer list therefore manifests as a `CXXConstructExpr` instead of\n    // an `InitListExpr`.\n    A a;\n    S3 s3{a.getInt(), std::move(a)};\n  }\n  {\n    A a;\n    S3 s3{std::move(a), a.getInt()};\n    // CHECK-NOTES: [[@LINE-1]]:25: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:11: note: move occurred here\n  }\n}\n\n} // namespace InitializerListSequences\n\n// A declaration statement containing multiple declarations sequences the\n// initializer expressions.\nvoid declarationSequences() {\n  {\n    A a;\n    A a1 = a, a2 = std::move(a);\n  }\n  {\n    A a;\n    A a1 = std::move(a), a2 = a;\n    // CHECK-NOTES: [[@LINE-1]]:31: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:12: note: move occurred here\n  }\n}\n\n// The logical operators && and || sequence their operands.\nvoid logicalOperatorsSequence() {\n  {\n    A a;\n    if (a.getInt() > 0 && A(std::move(a)).getInt() > 0) {\n      A().foo();\n    }\n  }\n  // A variation: Negate the result of the && (which pushes the && further down\n  // into the AST).\n  {\n    A a;\n    if (!(a.getInt() > 0 && A(std::move(a)).getInt() > 0)) {\n      A().foo();\n    }\n  }\n  {\n    A a;\n    if (A(std::move(a)).getInt() > 0 && a.getInt() > 0) {\n      // CHECK-NOTES: [[@LINE-1]]:41: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-2]]:9: note: move occurred here\n      A().foo();\n    }\n  }\n  {\n    A a;\n    if (a.getInt() > 0 || A(std::move(a)).getInt() > 0) {\n      A().foo();\n    }\n  }\n  {\n    A a;\n    if (A(std::move(a)).getInt() > 0 || a.getInt() > 0) {\n      // CHECK-NOTES: [[@LINE-1]]:41: warning: 'a' used after it was moved\n      // CHECK-NOTES: [[@LINE-2]]:9: note: move occurred here\n      A().foo();\n    }\n  }\n}\n\n// A range-based for sequences the loop variable declaration before the body.\nvoid forRangeSequences() {\n  A v[2] = {A(), A()};\n  for (A &a : v) {\n    std::move(a);\n  }\n}\n\n// If a variable is declared in an if, while or switch statement, the init\n// statement (for if and switch) is sequenced before the variable declaration,\n// which in turn is sequenced before the evaluation of the condition. We place\n// all tests inside a for loop to ensure that the checker understands the\n// sequencing. If it didn't, then the loop would trigger the \"moved twice\"\n// logic.\nvoid ifWhileAndSwitchSequenceInitDeclAndCondition() {\n  for (int i = 0; i < 10; ++i) {\n    A a1;\n    if (A a2 = std::move(a1)) {\n      std::move(a2);\n    }\n  }\n  for (int i = 0; i < 10; ++i) {\n    A a1;\n    if (A a2 = std::move(a1); a2) {\n      std::move(a2);\n    }\n  }\n  for (int i = 0; i < 10; ++i) {\n    A a1;\n    if (A a2 = std::move(a1); A a3 = std::move(a2)) {\n      std::move(a3);\n    }\n  }\n  for (int i = 0; i < 10; ++i) {\n    // init followed by condition with move, but without variable declaration.\n    if (A a1; A(std::move(a1)).getInt() > 0) {}\n  }\n  for (int i = 0; i < 10; ++i) {\n    if (A a1; A(std::move(a1)).getInt() > a1.getInt()) {}\n    // CHECK-NOTES: [[@LINE-1]]:43: warning: 'a1' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:15: note: move occurred here\n    // CHECK-NOTES: [[@LINE-3]]:43: note: the use and move are unsequenced\n  }\n  for (int i = 0; i < 10; ++i) {\n    A a1;\n    if (A a2 = std::move(a1); A(a1) > 0) {}\n    // CHECK-NOTES: [[@LINE-1]]:33: warning: 'a1' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:16: note: move occurred here\n  }\n  while (A a = A()) {\n    std::move(a);\n  }\n  for (int i = 0; i < 10; ++i) {\n    A a1;\n    switch (A a2 = std::move(a1); a2) {\n      case true:\n        std::move(a2);\n    }\n  }\n  for (int i = 0; i < 10; ++i) {\n    A a1;\n    switch (A a2 = a1; A a3 = std::move(a2)) {\n      case true:\n        std::move(a3);\n    }\n  }\n}\n\n// In a function call, the expression that determines the callee is sequenced\n// before the arguments -- but only in C++17 and later.\nnamespace CalleeSequencedBeforeArguments {\nint consumeA(std::unique_ptr<A> a);\nint consumeA(A &&a);\n\nvoid calleeSequencedBeforeArguments() {\n  {\n    std::unique_ptr<A> a;\n    a->bar(consumeA(std::move(a)));\n    // CHECK-NOTES-CXX11: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES-CXX11: [[@LINE-2]]:21: note: move occurred here\n    // CHECK-NOTES-CXX11: [[@LINE-3]]:5: note: the use and move are unsequenced\n  }\n  {\n    std::unique_ptr<A> a;\n    std::unique_ptr<A> getArg(std::unique_ptr<A> a);\n    getArg(std::move(a))->bar(a->getInt());\n    // CHECK-NOTES: [[@LINE-1]]:31: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:12: note: move occurred here\n    // CHECK-NOTES-CXX11: [[@LINE-3]]:31: note: the use and move are unsequenced\n  }\n  {\n    A a;\n    // Nominally, the callee `a.bar` is evaluated before the argument\n    // `consumeA(std::move(a))`, but in effect `a` is only accessed after the\n    // call to `A::bar()` happens, i.e. after the argument has been evaluted.\n    a.bar(consumeA(std::move(a)));\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'a' used after it was moved\n    // CHECK-NOTES: [[@LINE-2]]:11: note: move occurred here\n  }\n}\n} // namespace CalleeSequencedBeforeArguments\n\n// Some statements in templates (e.g. null, break and continue statements) may\n// be shared between the uninstantiated and instantiated versions of the\n// template and therefore have multiple parents. Make sure the sequencing code\n// handles this correctly.\ntemplate <class> void nullStatementSequencesInTemplate() {\n  int c = 0;\n  (void)c;\n  ;\n  std::move(c);\n}\ntemplate void nullStatementSequencesInTemplate<int>();\n\nnamespace PR33020 {\nclass D {\n  ~D();\n};\nstruct A {\n  D d;\n};\nclass B {\n  A a;\n};\ntemplate <typename T>\nclass C : T, B {\n  void m_fn1() {\n    int a;\n    std::move(a);\n    C c;\n  }\n};\n} // namespace PR33020\n\nnamespace UnevalContext {\nstruct Foo {};\nvoid noExcept() {\n  Foo Bar;\n  (void) noexcept(Foo{std::move(Bar)});\n  Foo Other{std::move(Bar)};\n}\nvoid sizeOf() {\n  Foo Bar;\n  (void)sizeof(Foo{std::move(Bar)});\n  Foo Other{std::move(Bar)};\n}\nvoid alignOf() {\n  Foo Bar;\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgnu-alignof-expression\"\n  (void)alignof(Foo{std::move(Bar)});\n#pragma clang diagnostic pop\n  Foo Other{std::move(Bar)};\n}\nvoid typeId() {\n  Foo Bar;\n  // error: you need to include <typeinfo> before using the 'typeid' operator\n  // (void) typeid(Foo{std::move(Bar)}).name();\n  Foo Other{std::move(Bar)};\n}\n} // namespace UnevalContext\n\nclass CtorInit {\npublic:\n  CtorInit(std::string val)\n      : a{val.empty()},    // fine\n        s{std::move(val)},\n        b{val.empty()}\n  // CHECK-NOTES: [[@LINE-1]]:11: warning: 'val' used after it was moved\n  // CHECK-NOTES: [[@LINE-3]]:9: note: move occurred here\n  {}\n\nprivate:\n  bool a;\n  std::string s;\n  bool b;\n};\n\nclass CtorInitLambda {\npublic:\n  CtorInitLambda(std::string val)\n      : a{val.empty()},    // fine\n        s{std::move(val)},\n        b{[&] { return val.empty(); }()},\n        // CHECK-NOTES: [[@LINE-1]]:12: warning: 'val' used after it was moved\n        // CHECK-NOTES: [[@LINE-3]]:9: note: move occurred here\n        c{[] {\n          std::string str{};\n          std::move(str);\n          return str.empty();\n          // CHECK-NOTES: [[@LINE-1]]:18: warning: 'str' used after it was moved\n          // CHECK-NOTES: [[@LINE-3]]:11: note: move occurred here\n        }()} {\n    std::move(val);\n    // CHECK-NOTES: [[@LINE-1]]:15: warning: 'val' used after it was moved\n    // CHECK-NOTES: [[@LINE-13]]:9: note: move occurred here\n    std::string val2{};\n    std::move(val2);\n    val2.empty();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'val2' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:5: note: move occurred here\n  }\n\nprivate:\n  bool a;\n  std::string s;\n  bool b;\n  bool c;\n  bool d{};\n};\n\nclass CtorInitOrder {\npublic:\n  CtorInitOrder(std::string val)\n      : a{val.empty()}, // fine\n        b{val.empty()},\n        // CHECK-NOTES: [[@LINE-1]]:11: warning: 'val' used after it was moved\n        s{std::move(val)} {} // wrong order\n  // CHECK-NOTES: [[@LINE-1]]:9: note: move occurred here\n\nprivate:\n  bool a;\n  std::string s;\n  bool b;\n};\n\nstruct Obj {};\nstruct CtorD {\n  CtorD(Obj b);\n};\n\nstruct CtorC {\n  CtorC(Obj b);\n};\n\nstruct CtorB {\n  CtorB(Obj &b);\n};\n\nstruct CtorA : CtorB, CtorC, CtorD {\n  CtorA(Obj b) : CtorB{b}, CtorC{std::move(b)}, CtorD{b} {}\n  // CHECK-NOTES: [[@LINE-1]]:55: warning: 'b' used after it was moved\n  // CHECK-NOTES: [[@LINE-2]]:34: note: move occurred here\n};\n\nstruct Base {\n  Base(Obj b) : bb{std::move(b)} {}\n  template <typename Call> Base(Call &&c) : bb{c()} {};\n\n  Obj bb;\n};\n\nstruct Derived : Base, CtorC {\n  Derived(Obj b)\n      : Base{[&] mutable { return std::move(b); }()},\n        // False negative: The lambda/std::move was executed, so it should warn\n        // below\n        CtorC{b} {}\n};\n\nstruct Derived2 : Base, CtorC {\n  Derived2(Obj b)\n      : Base{[&] mutable { return std::move(b); }},\n        // This was a move, but it doesn't warn below, because it can't know if\n        // the lambda/std::move was actually called\n        CtorC{b} {}\n};\n\nstruct Derived3 : Base, CtorC {\n  Derived3(Obj b)\n      : Base{[c = std::move(b)] mutable { return std::move(c); }}, CtorC{b} {}\n  // CHECK-NOTES: [[@LINE-1]]:74: warning: 'b' used after it was moved\n  // CHECK-NOTES: [[@LINE-2]]:19: note: move occurred here\n};\n\nclass PR38187 {\npublic:\n  PR38187(std::string val) : val_(std::move(val)) {\n    val.empty();\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: 'val' used after it was moved\n    // CHECK-NOTES: [[@LINE-3]]:30: note: move occurred here\n  }\n\nprivate:\n  std::string val_;\n};\n\nnamespace issue82023\n{\n\nstruct S {\n  S();\n  S(S&&);\n};\n\nvoid consume(S s);\n\ntemplate <typename T>\nvoid forward(T&& t) {\n  consume(std::forward<T>(t));\n  consume(std::forward<T>(t));\n  // CHECK-NOTES: [[@LINE-1]]:27: warning: 't' used after it was forwarded\n  // CHECK-NOTES: [[@LINE-3]]:11: note: forward occurred here\n}\n\nvoid create() {\n  S s;\n  forward(std::move(s));\n}\n\n} // namespace issue82023"
    }
  ]
}