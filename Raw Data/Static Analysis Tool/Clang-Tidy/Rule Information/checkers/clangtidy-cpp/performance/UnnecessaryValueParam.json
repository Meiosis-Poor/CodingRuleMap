{
  "name": "UnnecessaryValueParam",
  "language": "cpp",
  "description": ".. title:: clang-tidy - performance-unnecessary-value-param",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 192,
  "branches": 13,
  "apis": 148,
  "test": [
    {
      "description": null,
      "expected-problems": 27,
      "expected-linenumbers": [
        86,
        93,
        102,
        112,
        117,
        124,
        125,
        131,
        183,
        189,
        196,
        221,
        227,
        243,
        250,
        266,
        271,
        280,
        289,
        297,
        305,
        311,
        322,
        329,
        334,
        339,
        367
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes %s performance-unnecessary-value-param %t -- -- -fno-delayed-template-parsing\n\n// CHECK-FIXES: #include <utility>\n\nnamespace std {\ntemplate <typename>\nstruct remove_reference;\n\ntemplate <typename _Tp>\nstruct remove_reference {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_reference<_Tp &> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_reference<_Tp &&> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nconstexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) {\n  return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);\n}\n} // namespace std\n\nstruct ExpensiveToCopyType {\n  const ExpensiveToCopyType & constReference() const {\n    return *this;\n  }\n  void nonConstMethod();\n  virtual ~ExpensiveToCopyType();\n};\n\nvoid mutate(ExpensiveToCopyType &);\nvoid mutate(ExpensiveToCopyType *);\nvoid useAsConstReference(const ExpensiveToCopyType &);\nvoid useByValue(ExpensiveToCopyType);\n\ntemplate <class T> class Vector {\n public:\n  using iterator = T*;\n  using const_iterator = const T*;\n\n  Vector(const Vector&);\n  Vector& operator=(const Vector&);\n\n  iterator begin();\n  iterator end();\n  const_iterator begin() const;\n  const_iterator end() const;\n};\n\n// This class simulates std::pair<>. It is trivially copy constructible\n// and trivially destructible, but not trivially copy assignable.\nclass SomewhatTrivial {\n public:\n  SomewhatTrivial();\n  SomewhatTrivial(const SomewhatTrivial&) = default;\n  ~SomewhatTrivial() = default;\n  SomewhatTrivial& operator=(const SomewhatTrivial&);\n};\n\nstruct MoveOnlyType {\n  MoveOnlyType(const MoveOnlyType &) = delete;\n  MoveOnlyType(MoveOnlyType &&) = default;\n  ~MoveOnlyType();\n  void constMethod() const;\n};\n\nstruct ExpensiveMovableType {\n  ExpensiveMovableType();\n  ExpensiveMovableType(ExpensiveMovableType &&);\n  ExpensiveMovableType(const ExpensiveMovableType &) = default;\n  ExpensiveMovableType &operator=(const ExpensiveMovableType &) = default;\n  ExpensiveMovableType &operator=(ExpensiveMovableType &&);\n  ~ExpensiveMovableType();\n};\n\nvoid positiveExpensiveConstValue(const ExpensiveToCopyType Obj);\n// CHECK-FIXES: void positiveExpensiveConstValue(const ExpensiveToCopyType& Obj);\nvoid positiveExpensiveConstValue(const ExpensiveToCopyType Obj) {\n  // CHECK-MESSAGES: [[@LINE-1]]:60: warning: the const qualified parameter 'Obj' is copied for each invocation; consider making it a reference [performance-unnecessary-value-param]\n  // CHECK-FIXES: void positiveExpensiveConstValue(const ExpensiveToCopyType& Obj) {\n}\n\nvoid positiveExpensiveValue(ExpensiveToCopyType Obj);\n// CHECK-FIXES: void positiveExpensiveValue(const ExpensiveToCopyType& Obj);\nvoid positiveExpensiveValue(ExpensiveToCopyType Obj) {\n  // CHECK-MESSAGES: [[@LINE-1]]:49: warning: the parameter 'Obj' is copied for each invocation but only used as a const reference; consider making it a const reference [performance-unnecessary-value-param]\n  // CHECK-FIXES: void positiveExpensiveValue(const ExpensiveToCopyType& Obj) {\n  Obj.constReference();\n  useAsConstReference(Obj);\n  auto Copy = Obj;\n  useByValue(Obj);\n}\n\nvoid positiveVector(Vector<ExpensiveToCopyType> V) {\n  // CHECK-MESSAGES: [[@LINE-1]]:49: warning: the parameter 'V' is copied for each invocation but only used as a const reference; consider making it a const reference [performance-unnecessary-value-param]\n  // CHECK-FIXES: void positiveVector(const Vector<ExpensiveToCopyType>& V) {\n  for (const auto& Obj : V) {\n    useByValue(Obj);\n  }\n}\n\nvoid positiveWithComment(const ExpensiveToCopyType /* important */ S);\n// CHECK-FIXES: void positiveWithComment(const ExpensiveToCopyType& /* important */ S);\nvoid positiveWithComment(const ExpensiveToCopyType /* important */ S) {\n  // CHECK-MESSAGES: [[@LINE-1]]:68: warning: the const qualified\n  // CHECK-FIXES: void positiveWithComment(const ExpensiveToCopyType& /* important */ S) {\n}\n\nvoid positiveUnnamedParam(const ExpensiveToCopyType) {\n  // CHECK-MESSAGES: [[@LINE-1]]:52: warning: the const qualified parameter #1\n  // CHECK-FIXES: void positiveUnnamedParam(const ExpensiveToCopyType&) {\n}\n\nvoid positiveAndNegative(const ExpensiveToCopyType ConstCopy, const ExpensiveToCopyType& ConstRef, ExpensiveToCopyType Copy);\n// CHECK-FIXES: void positiveAndNegative(const ExpensiveToCopyType& ConstCopy, const ExpensiveToCopyType& ConstRef, const ExpensiveToCopyType& Copy);\nvoid positiveAndNegative(const ExpensiveToCopyType ConstCopy, const ExpensiveToCopyType& ConstRef, ExpensiveToCopyType Copy) {\n  // CHECK-MESSAGES: [[@LINE-1]]:52: warning: the const qualified parameter 'ConstCopy'\n  // CHECK-MESSAGES: [[@LINE-2]]:120: warning: the parameter 'Copy'\n  // CHECK-FIXES: void positiveAndNegative(const ExpensiveToCopyType& ConstCopy, const ExpensiveToCopyType& ConstRef, const ExpensiveToCopyType& Copy) {\n}\n\nstruct PositiveConstValueConstructor {\n  PositiveConstValueConstructor(const ExpensiveToCopyType ConstCopy) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:59: warning: the const qualified parameter 'ConstCopy'\n  // CHECK-FIXES: PositiveConstValueConstructor(const ExpensiveToCopyType& ConstCopy) {}\n};\n\nvoid negativeArray(const ExpensiveToCopyType[]) {\n}\n\nvoid negativePointer(ExpensiveToCopyType* Obj) {\n}\n\nvoid negativeConstPointer(const ExpensiveToCopyType* Obj) {\n}\n\nvoid negativeConstReference(const ExpensiveToCopyType& Obj) {\n}\n\nvoid negativeReference(ExpensiveToCopyType& Obj) {\n}\n\nvoid negativeUniversalReference(ExpensiveToCopyType&& Obj) {\n}\n\nvoid negativeSomewhatTrivialConstValue(const SomewhatTrivial Somewhat) {\n}\n\nvoid negativeSomewhatTrivialValue(SomewhatTrivial Somewhat) {\n}\n\nvoid negativeConstBuiltIn(const int I) {\n}\n\nvoid negativeValueBuiltIn(int I) {\n}\n\nvoid negativeValueIsMutatedByReference(ExpensiveToCopyType Obj) {\n  mutate(Obj);\n}\n\nvoid negativeValueIsMutatatedByPointer(ExpensiveToCopyType Obj) {\n  mutate(&Obj);\n}\n\nvoid negativeValueIsReassigned(ExpensiveToCopyType Obj) {\n  Obj = ExpensiveToCopyType();\n}\n\nvoid negativeValueNonConstMethodIsCalled(ExpensiveToCopyType Obj) {\n  Obj.nonConstMethod();\n}\n\nstruct PositiveValueUnusedConstructor {\n  PositiveValueUnusedConstructor(ExpensiveToCopyType Copy) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:54: warning: the parameter 'Copy'\n  // CHECK-FIXES: PositiveValueUnusedConstructor(const ExpensiveToCopyType& Copy) {}\n};\n\nstruct PositiveValueCopiedConstructor {\n  PositiveValueCopiedConstructor(ExpensiveToCopyType Copy) : Field(Copy) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:54: warning: the parameter 'Copy'\n  // CHECK-FIXES: PositiveValueCopiedConstructor(const ExpensiveToCopyType& Copy) : Field(Copy) {}\n  ExpensiveToCopyType Field;\n};\n\nstruct PositiveValueMovableConstructor {\n  PositiveValueMovableConstructor(ExpensiveMovableType Copy) : Field(Copy) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:70: warning: parameter 'Copy'\n  // CHECK-FIXES: PositiveValueMovableConstructor(ExpensiveMovableType Copy) : Field(std::move(Copy)) {}\n  ExpensiveMovableType Field;\n};\n\nstruct NegativeValueMovedConstructor {\n  NegativeValueMovedConstructor(ExpensiveMovableType Copy) : Field(static_cast<ExpensiveMovableType &&>(Copy)) {}\n  ExpensiveMovableType Field;\n};\n\ntemplate <typename T>\nstruct Container {\n  typedef const T & const_reference;\n};\n\nvoid NegativeTypedefParam(const Container<ExpensiveToCopyType>::const_reference Param) {\n}\n\n#define UNNECESSARY_VALUE_PARAM_IN_MACRO_BODY()         \\\n  void inMacro(const ExpensiveToCopyType T) {           \\\n  }                                                     \\\n// Ensure fix is not applied.\n// CHECK-FIXES: void inMacro(const ExpensiveToCopyType T) {\n\nUNNECESSARY_VALUE_PARAM_IN_MACRO_BODY()\n// CHECK-MESSAGES: [[@LINE-1]]:1: warning: the const qualified parameter 'T'\n\n#define UNNECESSARY_VALUE_PARAM_IN_MACRO_ARGUMENT(ARGUMENT)     \\\n  ARGUMENT\n\nUNNECESSARY_VALUE_PARAM_IN_MACRO_ARGUMENT(void inMacroArgument(const ExpensiveToCopyType InMacroArg) {})\n// CHECK-MESSAGES: [[@LINE-1]]:90: warning: the const qualified parameter 'InMacroArg'\n// CHECK-FIXES: void inMacroArgument(const ExpensiveToCopyType InMacroArg) {}\n\nstruct VirtualMethod {\n  virtual ~VirtualMethod() {}\n  virtual void handle(ExpensiveToCopyType T) const = 0;\n};\n\nstruct NegativeOverriddenMethod : public VirtualMethod {\n  void handle(ExpensiveToCopyType Overridden) const {\n    // CHECK-FIXES: handle(ExpensiveToCopyType Overridden) const {\n  }\n};\n\nstruct VirtualMethodWarningOnly {\n  virtual void methodWithExpensiveValueParam(ExpensiveToCopyType T) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:66: warning: the parameter 'T' is copied\n  // CHECK-FIXES: virtual void methodWithExpensiveValueParam(ExpensiveToCopyType T) {}\n  virtual ~VirtualMethodWarningOnly() {}\n};\n\nstruct PositiveNonVirualMethod {\n  void method(const ExpensiveToCopyType T) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:41: warning: the const qualified parameter 'T' is copied\n  // CHECK-FIXES: void method(const ExpensiveToCopyType& T) {}\n};\n\nstruct NegativeDeletedMethod {\n  ~NegativeDeletedMethod() {}\n  NegativeDeletedMethod& operator=(NegativeDeletedMethod N) = delete;\n  // CHECK-FIXES: NegativeDeletedMethod& operator=(NegativeDeletedMethod N) = delete;\n};\n\nvoid NegativeMoveOnlyTypePassedByValue(MoveOnlyType M) {\n  M.constMethod();\n}\n\nvoid PositiveMoveOnCopyConstruction(ExpensiveMovableType E) {\n  auto F = E;\n  // CHECK-MESSAGES: [[@LINE-1]]:12: warning: parameter 'E' is passed by value and only copied once; consider moving it to avoid unnecessary copies [performance-unnecessary-value-param]\n  // CHECK-FIXES: auto F = std::move(E);\n}\n\nvoid PositiveConstRefNotMoveSinceReferencedMultipleTimes(ExpensiveMovableType E) {\n  // CHECK-MESSAGES: [[@LINE-1]]:79: warning: the parameter 'E' is copied\n  // CHECK-FIXES: void PositiveConstRefNotMoveSinceReferencedMultipleTimes(const ExpensiveMovableType& E) {\n  auto F = E;\n  auto G = E;\n}\n\nvoid PositiveMoveOnCopyAssignment(ExpensiveMovableType E) {\n  ExpensiveMovableType F;\n  F = E;\n  // CHECK-MESSAGES: [[@LINE-1]]:7: warning: parameter 'E' is passed by value\n  // CHECK-FIXES: F = std::move(E);\n}\n\nstruct NotCopyAssigned {\n  NotCopyAssigned &operator=(const ExpensiveMovableType &);\n};\n\nvoid PositiveNoMoveForNonCopyAssigmentOperator(ExpensiveMovableType E) {\n  // CHECK-MESSAGES: [[@LINE-1]]:69: warning: the parameter 'E' is copied\n  // CHECK-FIXES: void PositiveNoMoveForNonCopyAssigmentOperator(const ExpensiveMovableType& E) {\n  NotCopyAssigned N;\n  N = E;\n}\n\n// The argument could be moved but is not since copy statement is inside a loop.\nvoid PositiveNoMoveInsideLoop(ExpensiveMovableType E) {\n  // CHECK-MESSAGES: [[@LINE-1]]:52: warning: the parameter 'E' is copied\n  // CHECK-FIXES: void PositiveNoMoveInsideLoop(const ExpensiveMovableType& E) {\n  for (;;) {\n    auto F = E;\n  }\n}\n\nvoid PositiveConstRefNotMoveConstructible(ExpensiveToCopyType T) {\n  // CHECK-MESSAGES: [[@LINE-1]]:63: warning: the parameter 'T' is copied\n  // CHECK-FIXES: void PositiveConstRefNotMoveConstructible(const ExpensiveToCopyType& T) {\n  auto U = T;\n}\n\nvoid PositiveConstRefNotMoveAssignable(ExpensiveToCopyType A) {\n  // CHECK-MESSAGES: [[@LINE-1]]:60: warning: the parameter 'A' is copied\n  // CHECK-FIXES: void PositiveConstRefNotMoveAssignable(const ExpensiveToCopyType& A) {\n  ExpensiveToCopyType B;\n  B = A;\n}\n\n// Case where parameter in declaration is already const-qualified but not in\n// implementation. Make sure a second 'const' is not added to the declaration.\nvoid PositiveConstDeclaration(const ExpensiveToCopyType A);\n// CHECK-FIXES: void PositiveConstDeclaration(const ExpensiveToCopyType& A);\nvoid PositiveConstDeclaration(ExpensiveToCopyType A) {\n  // CHECK-MESSAGES: [[@LINE-1]]:51: warning: the parameter 'A' is copied\n  // CHECK-FIXES: void PositiveConstDeclaration(const ExpensiveToCopyType& A) {\n}\n\nvoid PositiveNonConstDeclaration(ExpensiveToCopyType A);\n// CHECK-FIXES: void PositiveNonConstDeclaration(const ExpensiveToCopyType& A);\nvoid PositiveNonConstDeclaration(const ExpensiveToCopyType A) {\n  // CHECK-MESSAGES: [[@LINE-1]]:60: warning: the const qualified parameter 'A'\n  // CHECK-FIXES: void PositiveNonConstDeclaration(const ExpensiveToCopyType& A) {\n}\n\nvoid PositiveOnlyMessageAsReferencedInCompilationUnit(ExpensiveToCopyType A) {\n  // CHECK-MESSAGES: [[@LINE-1]]:75: warning: the parameter 'A' is copied\n  // CHECK-FIXES: void PositiveOnlyMessageAsReferencedInCompilationUnit(const ExpensiveToCopyType& A) {\n}\n\nvoid PositiveMessageAndFixAsFunctionIsCalled(ExpensiveToCopyType A) {\n  // CHECK-MESSAGES: [[@LINE-1]]:66: warning: the parameter 'A' is copied\n  // CHECK-FIXES: void PositiveMessageAndFixAsFunctionIsCalled(const ExpensiveToCopyType& A) {\n}\n\nvoid ReferenceFunctionByCallingIt() {\n  PositiveMessageAndFixAsFunctionIsCalled(ExpensiveToCopyType());\n}\n\n// Virtual method overrides of dependent types cannot be recognized unless they\n// are marked as override or final. Test that check is not triggered on methods\n// marked with override or final.\ntemplate <typename T>\nstruct NegativeDependentTypeInterface {\n  virtual void Method(ExpensiveToCopyType E) = 0;\n};\n\ntemplate <typename T>\nstruct NegativeOverrideImpl : public NegativeDependentTypeInterface<T> {\n  void Method(ExpensiveToCopyType E) override {}\n};\n\ntemplate <typename T>\nstruct NegativeFinalImpl : public NegativeDependentTypeInterface<T> {\n  void Method(ExpensiveToCopyType E) final {}\n};\n\nstruct PositiveConstructor {\n  PositiveConstructor(ExpensiveToCopyType E) : E(E) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:43: warning: the parameter 'E' is copied\n  // CHECK-FIXES: PositiveConstructor(const ExpensiveToCopyType& E) : E(E) {}\n\n  ExpensiveToCopyType E;\n};\n\nstruct NegativeUsingConstructor : public PositiveConstructor {\n  using PositiveConstructor::PositiveConstructor;\n};\n\nvoid fun() {\n  ExpensiveToCopyType E;\n  NegativeUsingConstructor S(E);\n}\n\nstruct B {\n  static void bar(ExpensiveMovableType a, ExpensiveMovableType b);\n};\n\ntemplate <typename T>\nvoid NegativeCallWithDependentAndNondependentArgs(ExpensiveMovableType a, T b) {\n    B::bar(std::move(a), b);\n}"
    }
  ]
}