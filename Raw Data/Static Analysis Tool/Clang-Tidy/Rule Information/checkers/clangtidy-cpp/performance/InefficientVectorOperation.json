{
  "name": "InefficientVectorOperation",
  "language": "cpp",
  "description": ".. title:: clang-tidy - performance-inefficient-vector-operation",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 273,
  "branches": 27,
  "apis": 177,
  "test": [
    {
      "description": null,
      "expected-problems": 19,
      "expected-linenumbers": [
        98,
        105,
        112,
        119,
        134,
        141,
        149,
        156,
        164,
        172,
        180,
        188,
        197,
        372,
        385,
        401,
        408,
        415,
        422
      ],
      "code": "\n// RUN: %check_clang_tidy %s performance-inefficient-vector-operation %t -- \\\n// RUN: -format-style=llvm \\\n// RUN: -config='{CheckOptions: \\\n// RUN:  {performance-inefficient-vector-operation.EnableProto: true}}'\n\nnamespace std {\n\ntypedef decltype(sizeof 0) size_t;\n\ntemplate<class E> class initializer_list {\npublic:\n  using value_type = E;\n  using reference = E&;\n  using const_reference = const E&;\n  using size_type = size_t;\n  using iterator = const E*;\n  using const_iterator = const E*;\n  iterator p;\n  size_t sz;\n  initializer_list();\n  size_t size() const; // number of elements\n  const E* begin() const; // first element\n  const E* end() const; // one past the last element\n};\n\n// initializer list range access\ntemplate<class E> const E* begin(initializer_list<E> il);\ntemplate<class E> const E* end(initializer_list<E> il);\n\ntemplate <class T>\nclass vector {\n public:\n  typedef T* iterator;\n  typedef const T* const_iterator;\n  typedef T& reference;\n  typedef const T& const_reference;\n  typedef size_t size_type;\n\n  explicit vector();\n  explicit vector(size_type n);\n\n  void push_back(const T& val);\n\n  template <class... Args> void emplace_back(Args &&... args);\n\n  void reserve(size_t n);\n  void resize(size_t n);\n\n  size_t size() const;\n  const_reference operator[] (size_type) const;\n  reference operator[] (size_type);\n\n  const_iterator begin() const;\n  const_iterator end() const;\n};\n} // namespace std\n\nclass Foo {\n public:\n  explicit Foo(int);\n};\n\nclass Bar {\n public:\n  Bar(int);\n};\n\nint Op(int);\n\nnamespace proto2 {\nclass MessageLite {};\nclass Message : public MessageLite {};\n} // namespace proto2\n\nclass FooProto : public proto2::Message {\n public:\n  int *add_x();  // repeated int x;\n  void add_x(int x);\n  void mutable_x();\n  void mutable_y();\n  int add_z() const; // optional int add_z;\n};\n\nclass BarProto : public proto2::Message {\n public:\n  int *add_x();\n  void add_x(int x);\n  void mutable_x();\n  void mutable_y();\n};\n\nvoid f(std::vector<int>& t) {\n  {\n    std::vector<int> v0;\n    // CHECK-FIXES: v0.reserve(10);\n    for (int i = 0; i < 10; ++i)\n      v0.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop\n  }\n  {\n    std::vector<int> v1;\n    // CHECK-FIXES: v1.reserve(10);\n    for (int i = 0; i < 10; i++)\n      v1.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n  }\n  {\n    std::vector<int> v2;\n    // CHECK-FIXES: v2.reserve(10);\n    for (int i = 0; i < 10; ++i)\n      v2.push_back(0);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n  }\n  {\n    std::vector<int> v3;\n    // CHECK-FIXES: v3.reserve(5);\n    for (int i = 0; i < 5; ++i) {\n      v3.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n    // CHECK-FIXES-NOT: v3.reserve(10);\n    for (int i = 0; i < 10; ++i) {\n      // No fix for this loop as we encounter the prior loops.\n      v3.push_back(i);\n    }\n  }\n  {\n    std::vector<int> v4;\n    std::vector<int> v5;\n    v5.reserve(3);\n    // CHECK-FIXES: v4.reserve(10);\n    for (int i = 0; i < 10; ++i)\n      v4.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n  }\n  {\n    std::vector<int> v6;\n    // CHECK-FIXES: v6.reserve(t.size());\n    for (std::size_t i = 0; i < t.size(); ++i) {\n      v6.push_back(t[i]);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n  }\n  {\n    std::vector<int> v7;\n    // CHECK-FIXES: v7.reserve(t.size() - 1);\n    for (std::size_t i = 0; i < t.size() - 1; ++i) {\n      v7.push_back(t[i]);\n    } // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n  }\n  {\n    std::vector<int> v8;\n    // CHECK-FIXES: v8.reserve(t.size());\n    for (const auto &e : t) {\n      v8.push_back(e);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n  }\n  {\n    std::vector<int> v9;\n    // CHECK-FIXES: v9.reserve(t.size());\n    for (const auto &e : t) {\n      v9.push_back(Op(e));\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n  }\n  {\n    std::vector<Foo> v10;\n    // CHECK-FIXES: v10.reserve(t.size());\n    for (const auto &e : t) {\n      v10.push_back(Foo(e));\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n  }\n  {\n    std::vector<Bar> v11;\n    // CHECK-FIXES: v11.reserve(t.size());\n    for (const auto &e : t) {\n      v11.push_back(e);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n  }\n  {\n    std::vector<Foo> v12;\n    // CHECK-FIXES: v12.reserve(t.size());\n    for (const auto &e : t) {\n      v12.emplace_back(e);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'emplace_back' is called\n    }\n  }\n\n  {\n    FooProto foo;\n    // CHECK-FIXES: foo.mutable_x()->Reserve(5);\n    for (int i = 0; i < 5; i++) {\n      foo.add_x(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'add_x' is called inside a loop; consider pre-allocating the container capacity before the loop\n    }\n  }\n\n  // ---- Non-fixed Cases ----\n  {\n    std::vector<int> z0;\n    z0.reserve(20);\n    // CHECK-FIXES-NOT: z0.reserve(10);\n    // There is a \"reserve\" call already.\n    for (int i = 0; i < 10; ++i) {\n      z0.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z1;\n    z1.reserve(5);\n    // CHECK-FIXES-NOT: z1.reserve(10);\n    // There is a \"reserve\" call already.\n    for (int i = 0; i < 10; ++i) {\n      z1.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z2;\n    z2.resize(5);\n    // CHECK-FIXES-NOT: z2.reserve(10);\n    // There is a ref usage of v before the loop.\n    for (int i = 0; i < 10; ++i) {\n      z2.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z3;\n    z3.push_back(0);\n    // CHECK-FIXES-NOT: z3.reserve(10);\n    // There is a ref usage of v before the loop.\n    for (int i = 0; i < 10; ++i) {\n      z3.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z4;\n    f(z4);\n    // CHECK-FIXES-NOT: z4.reserve(10);\n    // There is a ref usage of z4 before the loop.\n    for (int i = 0; i < 10; ++i) {\n      z4.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z5(20);\n    // CHECK-FIXES-NOT: z5.reserve(10);\n    // z5 is not constructed with default constructor.\n    for (int i = 0; i < 10; ++i) {\n      z5.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z6;\n    // CHECK-FIXES-NOT: z6.reserve(10);\n    // For-loop is not started with 0.\n    for (int i = 1; i < 10; ++i) {\n      z6.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z7;\n    // CHECK-FIXES-NOT: z7.reserve(t.size());\n    // z7 isn't referenced in for-loop body.\n    for (std::size_t i = 0; i < t.size(); ++i) {\n      t.push_back(i);\n    }\n  }\n  {\n    std::vector<int> z8;\n    int k;\n    // CHECK-FIXES-NOT: z8.reserve(10);\n    // For-loop isn't a fixable loop.\n    for (std::size_t i = 0; k < 10; ++i) {\n      z8.push_back(t[i]);\n    }\n  }\n  {\n    std::vector<int> z9;\n    // CHECK-FIXES-NOT: z9.reserve(i + 1);\n    // The loop end expression refers to the loop variable i.\n    for (int i = 0; i < i + 1; i++)\n      z9.push_back(i);\n  }\n  {\n    std::vector<int> z10;\n    int k;\n    // CHECK-FIXES-NOT: z10.reserve(10);\n    // For-loop isn't a fixable loop.\n    for (std::size_t i = 0; i < 10; ++k) {\n      z10.push_back(t[i]);\n    }\n  }\n  {\n    std::vector<int> z11;\n    // initializer_list should not trigger the check.\n    for (int e : {1, 2, 3, 4, 5}) {\n      z11.push_back(e);\n    }\n  }\n  {\n    std::vector<int> z12;\n    std::vector<int>* z13 = &t;\n    // We only support detecting the range init expression which references\n    // container directly.\n    // Complex range init expressions like `*z13` is not supported.\n    for (const auto &e : *z13) {\n      z12.push_back(e);\n    }\n  }\n\n  {\n    FooProto foo;\n    foo.mutable_x();\n    // CHECK-FIXES-NOT: foo.mutable_x()->Reserve(5);\n    for (int i = 0; i < 5; i++) {\n      foo.add_x(i);\n    }\n  }\n  {\n    FooProto foo;\n    // CHECK-FIXES-NOT: foo.mutable_x()->Reserve(5);\n    for (int i = 0; i < 5; i++) {\n      foo.add_x(i);\n      foo.add_x(i);\n    }\n  }\n  {\n    FooProto foo;\n    // CHECK-FIXES-NOT: foo.mutable_x()->Reserve(5);\n    foo.add_x(-1);\n    for (int i = 0; i < 5; i++) {\n      foo.add_x(i);\n    }\n  }\n  {\n    FooProto foo;\n    BarProto bar;\n    bar.mutable_x();\n    // CHECK-FIXES-NOT: foo.mutable_x()->Reserve(5);\n    for (int i = 0; i < 5; i++) {\n      foo.add_x();\n      bar.add_x();\n    }\n  }\n  {\n    FooProto foo;\n    foo.mutable_y();\n    // CHECK-FIXES-NOT: foo.mutable_x()->Reserve(5);\n    for (int i = 0; i < 5; i++) {\n      foo.add_x(i);\n    }\n  }\n  {\n    FooProto foo;\n    // CHECK-FIXES-NOT: foo.mutable_z()->Reserve(5);\n    for (int i = 0; i < 5; i++) {\n      foo.add_z();\n    }\n  }\n}\n\nstruct StructWithFieldContainer {\n  std::vector<int> Numbers;\n  std::vector<int> getNumbers() const {\n    std::vector<int> Result;\n    // CHECK-FIXES: Result.reserve(Numbers.size());\n    for (auto Number : Numbers) {\n      Result.push_back(Number);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called\n    }\n    return Result;\n  }\n};\n\nStructWithFieldContainer getStructWithField();\n\nvoid foo(const StructWithFieldContainer &Src) {\n  std::vector<int> A;\n  // CHECK-FIXES: A.reserve(Src.Numbers.size());\n  for (auto Number : Src.Numbers) {\n    A.push_back(Number);\n    // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: 'push_back' is called\n  }\n  std::vector<int> B;\n  for (auto Number : getStructWithField().Numbers) {\n    B.push_back(Number);\n  }\n}\n\nnamespace gh95596 {\n\nvoid f(std::vector<int>& t) {\n  {\n    std::vector<int> gh95596_0;\n    // CHECK-FIXES: gh95596_0.reserve(10);\n    for (unsigned i = 0; i < 10; ++i)\n      gh95596_0.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop\n  }\n  {\n    std::vector<int> gh95596_1;\n    // CHECK-FIXES: gh95596_1.reserve(10);\n    for (int i = 0U; i < 10; ++i)\n      gh95596_1.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop\n  }\n  {\n    std::vector<int> gh95596_2;\n    // CHECK-FIXES: gh95596_2.reserve(10);\n    for (unsigned i = 0U; i < 10; ++i)\n      gh95596_2.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop\n  }\n  {\n    std::vector<int> gh95596_3;\n    // CHECK-FIXES: gh95596_3.reserve(10U);\n    for (int i = 0; i < 10U; ++i)\n      gh95596_3.push_back(i);\n      // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop\n  }\n}\n\n} // namespace gh95596"
    }
  ]
}