{
  "name": "MoveConstArg",
  "language": "cpp",
  "description": ".. title:: clang-tidy - performance-move-const-arg",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 235,
  "branches": 27,
  "apis": 153,
  "test": [
    {
      "description": null,
      "expected-problems": 83,
      "expected-linenumbers": [
        55,
        60,
        66,
        72,
        78,
        88,
        94,
        109,
        149,
        154,
        159,
        164,
        169,
        178,
        183,
        188,
        193,
        198,
        331,
        342,
        358,
        359,
        362,
        363,
        366,
        367,
        369,
        370,
        373,
        374,
        376,
        377,
        380,
        381,
        383,
        384,
        393,
        412,
        413,
        415,
        416,
        419,
        420,
        423,
        424,
        426,
        427,
        429,
        430,
        432,
        433,
        440,
        441,
        443,
        444,
        447,
        448,
        451,
        452,
        454,
        455,
        457,
        458,
        460,
        461,
        480,
        482,
        497,
        498,
        514,
        515,
        527,
        528,
        531,
        532,
        540,
        541,
        544,
        545,
        560,
        576,
        577,
        581
      ],
      "code": "\n// RUN: %check_clang_tidy %s performance-move-const-arg %t\n\nnamespace std {\ntemplate <typename>\nstruct remove_reference;\n\ntemplate <typename _Tp>\nstruct remove_reference {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_reference<_Tp &> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nstruct remove_reference<_Tp &&> {\n  typedef _Tp type;\n};\n\ntemplate <typename _Tp>\nconstexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) {\n  return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);\n}\n\ntemplate <typename _Tp>\nconstexpr _Tp &&\nforward(typename remove_reference<_Tp>::type &__t) noexcept {\n  return static_cast<_Tp &&>(__t);\n}\n\n} // namespace std\n\nclass A {\npublic:\n  A() {}\n  A(const A &rhs) {}\n  A(A &&rhs) {}\n};\n\nusing AlsoA = A;\n\nstruct TriviallyCopyable {\n  int i;\n};\n\nusing TrivialAlias = TriviallyCopyable;\n\nvoid f(TriviallyCopyable) {}\n\nvoid g() {\n  TriviallyCopyable obj;\n  f(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: std::move of the variable 'obj' of the trivially-copyable type 'TriviallyCopyable' has no effect; remove std::move() [performance-move-const-arg]\n  // CHECK-FIXES: f(obj);\n\n  TrivialAlias obj2;\n  f(std::move(obj2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: std::move of the variable 'obj2' of the trivially-copyable type 'TrivialAlias' (aka 'TriviallyCopyable') has no effect; remove std::move() [performance-move-const-arg]\n  // CHECK-FIXES: f(obj2);\n}\n\nint f1() {\n  return std::move(42);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the expression of the trivially-copyable type 'int' has no effect; remove std::move() [performance-move-const-arg]\n  // CHECK-FIXES: return 42;\n}\n\nint f2(int x2) {\n  return std::move(x2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the variable 'x2' of the trivially-copyable type 'int'\n  // CHECK-FIXES: return x2;\n}\n\nint *f3(int *x3) {\n  return std::move(x3);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the variable 'x3' of the trivially-copyable type 'int *'\n  // CHECK-FIXES: return x3;\n}\n\nA f4(A x4) { return std::move(x4); }\n\nAlsoA f4_a(AlsoA x4) { return std::move(x4); }\n\nA f5(const A x5) {\n  return std::move(x5);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the const variable 'x5' has no effect; remove std::move() or make the variable non-const [performance-move-const-arg]\n  // CHECK-FIXES: return x5;\n}\n\nAlsoA f5_a(const AlsoA x5) {\n  return std::move(x5);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the const variable 'x5' has no effect; remove std::move() or make the variable non-const [performance-move-const-arg]\n  // CHECK-FIXES: return x5;\n}\n\ntemplate <typename T>\nT f6(const T x6) {\n  return std::move(x6);\n}\n\nvoid f7() { int a = f6(10); }\n\n#define M1(x) x\nvoid f8() {\n  const A a;\n  M1(A b = std::move(a);)\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: std::move of the const variable 'a' has no effect; remove std::move() or make the variable non-const\n  // CHECK-FIXES: M1(A b = a;)\n}\n\n#define M2(x) std::move(x)\nint f9() { return M2(1); }\n\ntemplate <typename T>\nT f_unknown_target(const int x10) {\n  return std::move(x10);\n}\n\nvoid f11() {\n  f_unknown_target<int>(1);\n  f_unknown_target<double>(1);\n}\n\nA&& f_return_right_ref() {\n  static A a{};\n  return std::move(a);\n}\n\nclass NoMoveSemantics {\npublic:\n  NoMoveSemantics();\n  NoMoveSemantics(const NoMoveSemantics &);\n\n  NoMoveSemantics &operator=(const NoMoveSemantics &);\n};\n\nusing NoMoveSemanticsAlias = NoMoveSemantics;\n\nvoid callByConstRef(const NoMoveSemantics &);\nvoid callByConstRef(int i, const NoMoveSemantics &);\n\nvoid moveToConstReferencePositives() {\n  NoMoveSemantics obj;\n\n  // Basic case.\n  callByConstRef(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: passing result of std::move() as\n  // CHECK-FIXES: callByConstRef(obj);\n\n  // Also works for second argument.\n  callByConstRef(1, std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: passing result of std::move() as\n  // CHECK-FIXES: callByConstRef(1, obj);\n\n  // Works if std::move() applied to a temporary.\n  callByConstRef(std::move(NoMoveSemantics()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: passing result of std::move() as\n  // CHECK-FIXES: callByConstRef(NoMoveSemantics());\n\n  // Works if calling a copy constructor.\n  NoMoveSemantics other(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: passing result of std::move() as\n  // CHECK-FIXES: NoMoveSemantics other(obj);\n\n  // Works if calling assignment operator.\n  other = std::move(obj);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: passing result of std::move() as\n  // CHECK-FIXES: other = obj;\n}\n\nvoid moveToConstReferencePositivesAlias() {\n  NoMoveSemanticsAlias obj;\n\n  // Basic case.\n  callByConstRef(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-FIXES: callByConstRef(obj);\n\n  // Also works for second argument.\n  callByConstRef(1, std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-FIXES: callByConstRef(1, obj);\n\n  // Works if std::move() applied to a temporary.\n  callByConstRef(std::move(NoMoveSemanticsAlias()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-FIXES: callByConstRef(NoMoveSemanticsAlias());\n\n  // Works if calling a copy constructor.\n  NoMoveSemanticsAlias other(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-FIXES: NoMoveSemanticsAlias other(obj);\n\n  // Works if calling assignment operator.\n  other = std::move(obj);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-FIXES: other = obj;\n}\n\nclass MoveSemantics {\npublic:\n  MoveSemantics();\n  MoveSemantics(MoveSemantics &&);\n\n  MoveSemantics &operator=(MoveSemantics &&);\n};\n\nusing MoveSemanticsAlias = MoveSemantics;\n\nvoid callByValue(MoveSemantics);\n\nvoid callByRValueRef(MoveSemantics &&);\n\ntemplate <class T>\nvoid templateFunction(T obj) {\n  T other = std::move(obj);\n}\n\n#define M3(T, obj)            \\\n  do {                        \\\n    T other = std::move(obj); \\\n  } while (true)\n\n#define CALL(func) (func)()\n\nvoid moveToConstReferenceNegatives() {\n  // No warning when actual move takes place.\n  MoveSemantics move_semantics;\n  callByValue(std::move(move_semantics));\n  callByRValueRef(std::move(move_semantics));\n  MoveSemantics other(std::move(move_semantics));\n  other = std::move(move_semantics);\n\n  // No warning if std::move() not used.\n  NoMoveSemantics no_move_semantics;\n  callByConstRef(no_move_semantics);\n\n  // No warning if instantiating a template.\n  templateFunction(no_move_semantics);\n\n  // No warning inside of macro expansions.\n  M3(NoMoveSemantics, no_move_semantics);\n\n  // No warning inside of macro expansion, even if the macro expansion is inside\n  // a lambda that is, in turn, an argument to a macro.\n  CALL([no_move_semantics] { M3(NoMoveSemantics, no_move_semantics); });\n\n  auto lambda = [] {};\n  auto lambda2 = std::move(lambda);\n}\n\nvoid moveToConstReferenceNegativesAlias() {\n  // No warning when actual move takes place.\n  MoveSemanticsAlias move_semantics;\n  callByValue(std::move(move_semantics));\n  callByRValueRef(std::move(move_semantics));\n  MoveSemanticsAlias other(std::move(move_semantics));\n  other = std::move(move_semantics);\n\n  // No warning if std::move() not used.\n  NoMoveSemanticsAlias no_move_semantics;\n  callByConstRef(no_move_semantics);\n\n  // No warning if instantiating a template.\n  templateFunction(no_move_semantics);\n\n  // No warning inside of macro expansions.\n  M3(NoMoveSemanticsAlias, no_move_semantics);\n\n  // No warning inside of macro expansion, even if the macro expansion is inside\n  // a lambda that is, in turn, an argument to a macro.\n  CALL([no_move_semantics] { M3(NoMoveSemanticsAlias, no_move_semantics); });\n\n  auto lambda = [] {};\n  auto lambda2 = std::move(lambda);\n}\n\nclass MoveOnly {\npublic:\n  MoveOnly(const MoveOnly &other) = delete;\n  MoveOnly &operator=(const MoveOnly &other) = delete;\n  MoveOnly(MoveOnly &&other) = default;\n  MoveOnly &operator=(MoveOnly &&other) = default;\n};\ntemplate <class T>\nvoid Q(T);\nvoid moveOnlyNegatives(MoveOnly val) {\n  Q(std::move(val));\n}\n\nusing MoveOnlyAlias = MoveOnly;\n\nvoid fmovable(MoveSemantics);\n\nvoid lambda1() {\n  auto f = [](MoveSemantics m) {\n    fmovable(std::move(m));\n  };\n  f(MoveSemantics());\n}\n\ntemplate<class T> struct function {};\n\ntemplate<typename Result, typename... Args>\nclass function<Result(Args...)> {\npublic:\n  function() = default;\n  void operator()(Args... args) const {\n    fmovable(std::forward<Args>(args)...);\n  }\n};\n\nvoid functionInvocation() {\n  function<void(MoveSemantics)> callback;\n  MoveSemantics m;\n  callback(std::move(m));\n}\n\nvoid functionInvocationAlias() {\n  function<void(MoveSemanticsAlias)> callback;\n  MoveSemanticsAlias m;\n  callback(std::move(m));\n}\n\nvoid lambda2() {\n  function<void(MoveSemantics)> callback;\n\n  auto f = [callback = std::move(callback)](MoveSemantics m) mutable {\n    // CHECK-MESSAGES: :[[@LINE-1]]:24: warning: std::move of the variable 'callback' of the trivially-copyable type 'function<void (MoveSemantics)>' has no effect; remove std::move()\n    // CHECK-FIXES: auto f = [callback = callback](MoveSemantics m) mutable {\n    callback(std::move(m));\n  };\n  f(MoveSemantics());\n}\n\nvoid lambda2Alias() {\n  function<void(MoveSemanticsAlias)> callback;\n\n  auto f = [callback = std::move(callback)](MoveSemanticsAlias m) mutable {\n    // CHECK-MESSAGES: :[[@LINE-1]]:24: warning: std::move of the variable 'callback' of the trivially-copyable type 'function<void (MoveSemanticsAlias)>' (aka 'function<void (MoveSemantics)>') has no effect; remove std::move() [performance-move-const-arg]\n    // CHECK-FIXES: auto f = [callback = callback](MoveSemanticsAlias m) mutable {\n    callback(std::move(m));\n  };\n  f(MoveSemanticsAlias());\n}\n\nvoid showInt(int &&v);\nvoid showInt(int v1, int &&v2);\nvoid showPointer(const char *&&s);\nvoid showPointer2(const char *const &&s);\nvoid showTriviallyCopyable(TriviallyCopyable &&obj);\nvoid showTriviallyCopyablePointer(const TriviallyCopyable *&&obj);\nvoid testFunctions() {\n  int a = 10;\n  showInt(std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-10]]:20: note: consider changing the 1st parameter of 'showInt' from 'int &&' to 'const int &'\n  showInt(int());\n  showInt(a, std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-13]]:28: note: consider changing the 2nd parameter of 'showInt' from 'int &&' to 'const int &'\n  const char* s = \"\";\n  showPointer(std::move(s));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: std::move of the variable 's' of the trivially-copyable type 'const char *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-16]]:32: note: consider changing the 1st parameter of 'showPointer' from 'const char *&&' to 'const char *'\n  showPointer2(std::move(s));\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: std::move of the variable 's' of the trivially-copyable type 'const char *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-18]]:39: note: consider changing the 1st parameter of 'showPointer2' from 'const char *const &&' to 'const char *const'\n  TriviallyCopyable *obj = new TriviallyCopyable();\n  showTriviallyCopyable(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: std::move of the expression of the trivially-copyable type 'TriviallyCopyable' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-21]]:48: note: consider changing the 1st parameter of 'showTriviallyCopyable' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n  showTriviallyCopyablePointer(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: std::move of the variable 'obj' of the trivially-copyable type 'TriviallyCopyable *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-23]]:62: note: consider changing the 1st parameter of 'showTriviallyCopyablePointer' from 'const TriviallyCopyable *&&' to 'const TriviallyCopyable *'\n  TrivialAlias* obj2 = new TrivialAlias();\n  showTriviallyCopyable(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: std::move of the expression of the trivially-copyable type 'TriviallyCopyable' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-28]]:48: note: consider changing the 1st parameter of 'showTriviallyCopyable' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n  showTriviallyCopyablePointer(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: std::move of the variable 'obj' of the trivially-copyable type 'TriviallyCopyable *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-30]]:62: note: consider changing the 1st parameter of 'showTriviallyCopyablePointer' from 'const TriviallyCopyable *&&' to 'const TriviallyCopyable *'\n}\ntemplate <class T>\nvoid forwardToShowInt(T && t) {\n  showInt(static_cast<T &&>(t));\n}\nvoid testTemplate() {\n  int a = 10;\n  forwardToShowInt(std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n}\n\nstruct Tmp {\n  Tmp();\n  Tmp(int &&a);\n  Tmp(int v1, int &&a);\n  Tmp(const char *&&s);\n  Tmp(TriviallyCopyable&& obj);\n  Tmp(const TriviallyCopyable *&&obj);\n  void showTmp(TriviallyCopyable&& t);\n  static void showTmpStatic(TriviallyCopyable&& t);\n};\nusing TmpAlias = Tmp;\n\nvoid testMethods() {\n  Tmp t;\n  int a = 10;\n  Tmp t1(std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-15]]:13: note: consider changing the 1st parameter of 'Tmp' from 'int &&' to 'const int &'\n  Tmp t2(a, std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-17]]:21: note: consider changing the 2nd parameter of 'Tmp' from 'int &&' to 'const int &'\n  const char* s = \"\";\n  Tmp t3(std::move(s));\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the variable 's' of the trivially-copyable type 'const char *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-20]]:21: note: consider changing the 1st parameter of 'Tmp' from 'const char *&&' to 'const char *'\n  TriviallyCopyable *obj = new TriviallyCopyable();\n  Tmp t4(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the expression of the trivially-copyable type 'TriviallyCopyable' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-23]]:27: note: consider changing the 1st parameter of 'Tmp' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n  Tmp t5(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the variable 'obj' of the trivially-copyable type 'TriviallyCopyable *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-25]]:34: note: consider changing the 1st parameter of 'Tmp' from 'const TriviallyCopyable *&&' to 'const TriviallyCopyable *'\n  t.showTmp(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: std::move of the expression of the trivially-copyable type 'TriviallyCopyable' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-27]]:36: note: consider changing the 1st parameter of 'showTmp' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n  Tmp::showTmpStatic(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: std::move of the expression of the trivially-copyable type 'TriviallyCopyable' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-29]]:49: note: consider changing the 1st parameter of 'showTmpStatic' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n}\n\nvoid testMethodsAlias() {\n  TmpAlias t;\n  int a = 10;\n  TmpAlias t1(std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-43]]:13: note: consider changing the 1st parameter of 'Tmp' from 'int &&' to 'const int &'\n  TmpAlias t2(a, std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-45]]:21: note: consider changing the 2nd parameter of 'Tmp' from 'int &&' to 'const int &'\n  const char* s = \"\";\n  TmpAlias t3(std::move(s));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: std::move of the variable 's' of the trivially-copyable type 'const char *' has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-48]]:21: note: consider changing the 1st parameter of 'Tmp' from 'const char *&&' to 'const char *'\n  TrivialAlias *obj = new TrivialAlias();\n  TmpAlias t4(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: std::move of the expression of the trivially-copyable type 'TrivialAlias' (aka 'TriviallyCopyable') has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-51]]:27: note: consider changing the 1st parameter of 'Tmp' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n  TmpAlias t5(std::move(obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: std::move of the variable 'obj' of the trivially-copyable type 'TrivialAlias *' (aka 'TriviallyCopyable *') has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-53]]:34: note: consider changing the 1st parameter of 'Tmp' from 'const TriviallyCopyable *&&' to 'const TriviallyCopyable *'\n  t.showTmp(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: std::move of the expression of the trivially-copyable type 'TrivialAlias' (aka 'TriviallyCopyable') has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-55]]:36: note: consider changing the 1st parameter of 'showTmp' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n  TmpAlias::showTmpStatic(std::move(*obj));\n  // CHECK-MESSAGES: :[[@LINE-1]]:27: warning: std::move of the expression of the trivially-copyable type 'TrivialAlias' (aka 'TriviallyCopyable') has no effect [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-57]]:49: note: consider changing the 1st parameter of 'showTmpStatic' from 'TriviallyCopyable &&' to 'const TriviallyCopyable &'\n}\n\nvoid showA(A &&v) {}\nvoid testA() {\n  A a;\n  showA(std::move(a));\n}\n\nvoid testAAlias() {\n  AlsoA a;\n  showA(std::move(a));\n}\n\nvoid testFuncPointer() {\n  int a = 10;\n  void (*choice)(int, int &&);\n  choice = showInt;\n  choice(std::move(a), std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect; remove std::move() [performance-move-const-arg]\n  // CHECK-FIXES: choice(a, std::move(a));\n  // CHECK-MESSAGES: :[[@LINE-3]]:24: warning: std::move of the variable 'a' of the trivially-copyable type 'int' has no effect [performance-move-const-arg]\n}\n\nnamespace issue_62550 {\n\nstruct NonMoveConstructable {\n  NonMoveConstructable();\n  NonMoveConstructable(const NonMoveConstructable&);\n  NonMoveConstructable& operator=(const NonMoveConstructable&);\n  NonMoveConstructable& operator=(NonMoveConstructable&&);\n};\n\nvoid testNonMoveConstructible() {\n  NonMoveConstructable t1;\n  NonMoveConstructable t2{std::move(t1)};\n  // CHECK-MESSAGES: :[[@LINE-1]]:27: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-11]]:8: note: 'NonMoveConstructable' is not move constructible\n}\n\nstruct NonMoveAssignable {\n  NonMoveAssignable();\n  NonMoveAssignable(const NonMoveAssignable&);\n  NonMoveAssignable(NonMoveAssignable&&);\n\n  NonMoveAssignable& operator=(const NonMoveAssignable&);\n};\n\nvoid testNonMoveAssignable() {\n  NonMoveAssignable t1;\n  NonMoveAssignable t2;\n\n  t2 = std::move(t1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-14]]:8: note: 'NonMoveAssignable' is not move assignable\n}\n\nstruct NonMoveable {\n  NonMoveable();\n  NonMoveable(const NonMoveable&);\n  NonMoveable& operator=(const NonMoveable&);\n};\n\nvoid testNonMoveable() {\n  NonMoveable t1;\n  NonMoveable t2{std::move(t1)};\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-10]]:8: note: 'NonMoveable' is not move assignable/constructible\n\n  t1 = std::move(t2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-14]]:8: note: 'NonMoveable' is not move assignable/constructible\n}\n\nusing AlsoNonMoveable = NonMoveable;\n\nvoid testAlsoNonMoveable() {\n  AlsoNonMoveable t1;\n  AlsoNonMoveable t2{std::move(t1)};\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-23]]:8: note: 'NonMoveable' is not move assignable/constructible\n\n  t1 = std::move(t2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-27]]:8: note: 'NonMoveable' is not move assignable/constructible\n}\n\n} // namespace issue_62550\n\nnamespace GH111450 {\nstruct Status;\n\nstruct Error {\n    Error(const Status& S);\n};\n\nstruct Result {\n  Error E;\n  Result(Status&& S) : E(std::move(S)) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:{{[0-9]+}}: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n};\n} // namespace GH111450\n\nnamespace GH126515 {\n\nstruct TernaryMoveCall {\nTernaryMoveCall();\nTernaryMoveCall(const TernaryMoveCall&);\nTernaryMoveCall operator=(const TernaryMoveCall&);\n\nvoid TernaryCheckTriviallyCopyable(const char * c) {}\n\nvoid testTernaryMove() {\n  TernaryMoveCall t1;\n  TernaryMoveCall other(false ? TernaryMoveCall() : TernaryMoveCall(std::move(t1)) );\n  // CHECK-MESSAGES: :[[@LINE-1]]:69: warning: passing result of std::move() as a const reference argument; no move will actually happen [performance-move-const-arg]\n  // CHECK-MESSAGES: :[[@LINE-11]]:8: note: 'TernaryMoveCall' is not move assignable/constructible\n\n  const char* a = \"a\";\n  TernaryCheckTriviallyCopyable(true ? std::move(a) : \"\" );\n  // CHECK-MESSAGES: :[[@LINE-1]]:40: warning: std::move of the variable 'a' of the trivially-copyable type 'const char *' has no effect; remove std::move() [performance-move-const-arg]\n}\n\n};\n} // namespace GH126515"
    }
  ]
}