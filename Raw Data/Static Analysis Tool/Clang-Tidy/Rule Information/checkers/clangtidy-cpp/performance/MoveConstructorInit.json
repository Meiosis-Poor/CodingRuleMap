{
  "name": "MoveConstructorInit",
  "language": "cpp",
  "description": ".. title:: clang-tidy - performance-move-constructor-init",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 84,
  "branches": 9,
  "apis": 44,
  "test": [
    {
      "description": null,
      "expected-problems": 0,
      "expected-linenumbers": [],
      "code": "\n// RUN: %check_clang_tidy %s performance-move-constructor-init,modernize-pass-by-value %t -- \\\n// RUN: -config='{CheckOptions: \\\n// RUN:  {modernize-pass-by-value.ValuesOnly: true}}' \\\n// RUN: -- -isystem %clang_tidy_headers\n\n#include <s.h>\n\n// CHECK-FIXES: #include <utility>\n\ntemplate <class T> struct remove_reference      {typedef T type;};\ntemplate <class T> struct remove_reference<T&>  {typedef T type;};\ntemplate <class T> struct remove_reference<T&&> {typedef T type;};\n\ntemplate <typename T>\ntypename remove_reference<T>::type&& move(T&& arg) {\n  return static_cast<typename remove_reference<T>::type&&>(arg);\n}\n\nstruct C {\n  C() = default;\n  C(const C&) = default;\n};\n\nstruct B {\n  B() {}\n  B(const B&) {}\n  B(B &&) {}\n};\n\nstruct D : B {\n  D() : B() {}\n  D(const D &RHS) : B(RHS) {}\n  // CHECK-NOTES: :[[@LINE+3]]:16: warning: move constructor initializes base class by calling a copy constructor [performance-move-constructor-init]\n  // CHECK-NOTES: 26:3: note: copy constructor being called\n  // CHECK-NOTES: 27:3: note: candidate move constructor here\n  D(D &&RHS) : B(RHS) {}\n};\n\nstruct E : B {\n  E() : B() {}\n  E(const E &RHS) : B(RHS) {}\n  E(E &&RHS) : B(move(RHS)) {} // ok\n};\n\nstruct F {\n  C M;\n\n  F(F &&) : M(C()) {} // ok\n};\n\nstruct G {\n  G() = default;\n  G(const G&) = default;\n  G(G&&) = delete;\n};\n\nstruct H : G {\n  H() = default;\n  H(const H&) = default;\n  H(H &&RHS) : G(RHS) {} // ok\n};\n\nstruct I {\n  I(const I &) = default; // suppresses move constructor creation\n};\n\nstruct J : I {\n  J(J &&RHS) : I(RHS) {} // ok\n};\n\nstruct K {}; // Has implicit copy and move constructors, is trivially copyable\nstruct L : K {\n  L(L &&RHS) : K(RHS) {} // ok\n};\n\nstruct M {\n  B Mem;\n  // CHECK-NOTES: :[[@LINE+1]]:16: warning: move constructor initializes class member by calling a copy constructor [performance-move-constructor-init]\n  M(M &&RHS) : Mem(RHS.Mem) {}\n  // CHECK-NOTES: 26:3: note: copy constructor being called\n  // CHECK-NOTES: 27:3: note: candidate move constructor here\n};\n\nstruct N {\n  B Mem;\n  N(N &&RHS) : Mem(move(RHS.Mem)) {}\n};\n\nstruct O {\n  O(O&& other) : b(other.b) {} // ok\n  const B b;\n};\n\nstruct P {\n  P(O&& other) : b(other.b) {} // ok\n  B b;\n};\n\nstruct Movable {\n  Movable(Movable &&) = default;\n  Movable(const Movable &) = default;\n  Movable &operator=(const Movable &) = default;\n  ~Movable() {}\n};\n\nstruct TriviallyCopyable {\n  TriviallyCopyable() = default;\n  TriviallyCopyable(TriviallyCopyable &&) = default;\n  TriviallyCopyable(const TriviallyCopyable &) = default;\n};\n\nstruct Positive {\n  Positive(Movable M) : M_(M) {}\n  // CHECK-NOTES: [[@LINE-1]]:12: warning: pass by value and use std::move [modernize-pass-by-value]\n  // CHECK-FIXES: Positive(Movable M) : M_(std::move(M)) {}\n  Movable M_;\n};\n\nstruct NegativeMultipleInitializerReferences {\n  NegativeMultipleInitializerReferences(Movable M) : M_(M), n_(M) {}\n  Movable M_;\n  Movable n_;\n};\n\nstruct NegativeReferencedInConstructorBody {\n  NegativeReferencedInConstructorBody(Movable M) : M_(M) { M_ = M; }\n  Movable M_;\n};\n\nstruct NegativeParamTriviallyCopyable {\n  NegativeParamTriviallyCopyable(TriviallyCopyable T) : T_(T) {}\n  NegativeParamTriviallyCopyable(int I) : I_(I) {}\n\n  TriviallyCopyable T_;\n  int I_;\n};\n\nstruct NegativeNotPassedByValue {\n  // This const ref constructor isn't warned about because the ValuesOnly option is set.\n  NegativeNotPassedByValue(const Movable &M) : M_(M) {}\n  NegativeNotPassedByValue(const Movable M) : M_(M) {}\n  NegativeNotPassedByValue(Movable &M) : M_(M) {}\n  NegativeNotPassedByValue(Movable *M) : M_(*M) {}\n  NegativeNotPassedByValue(const Movable *M) : M_(*M) {}\n  Movable M_;\n};\n\nstruct Immovable {\n  Immovable(const Immovable &) = default;\n  Immovable(Immovable &&) = delete;\n};\n\nstruct NegativeImmovableParameter {\n  NegativeImmovableParameter(Immovable I) : I_(I) {}\n  Immovable I_;\n};"
    }
  ]
}