{
  "name": "NoexceptMoveConstructor",
  "language": "cpp",
  "description": ".. title:: clang-tidy - performance-noexcept-move-constructor",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 44,
  "branches": 1,
  "apis": 18,
  "test": [
    {
      "description": null,
      "expected-problems": 32,
      "expected-linenumbers": [
        40,
        43,
        50,
        52,
        58,
        61,
        68,
        70,
        77,
        79,
        86,
        88,
        93,
        96,
        106,
        108,
        114,
        116,
        129,
        131,
        136,
        139,
        148,
        151,
        159,
        162,
        168,
        171,
        177,
        180,
        411,
        412
      ],
      "code": "\n// RUN: %check_clang_tidy %s performance-noexcept-move-constructor %t -- -- -fexceptions\n// RUN: %check_clang_tidy -std=c++17 -check-suffixes=,ERR %s performance-noexcept-move-constructor %t \\\n// RUN:                   -- --fix-errors -- -fexceptions -DENABLE_ERROR\n\nnamespace std\n{\n  template <typename T>\n  struct is_nothrow_move_constructible\n  {\n    static constexpr bool value = __is_nothrow_constructible(T, __add_rvalue_reference(T));\n  };\n} // namespace std\n\nstruct Empty\n{};\n\nstruct IntWrapper {\n  int value;\n};\n\ntemplate <typename T>\nstruct FalseT {\n  static constexpr bool value = false;\n};\n\ntemplate <typename T>\nstruct TrueT {\n  static constexpr bool value = true;\n};\n\nstruct ThrowOnAnything {\n  ThrowOnAnything() noexcept(false);\n  ThrowOnAnything(ThrowOnAnything&&) noexcept(false);\n  ThrowOnAnything& operator=(ThrowOnAnything &&) noexcept(false);\n  ~ThrowOnAnything() noexcept(false);\n};\n\nclass A {\n  A(A &&);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: A(A &&) noexcept ;\n  A &operator=(A &&);\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: A &operator=(A &&) noexcept ;\n};\n\nstruct B {\n  static constexpr bool kFalse = false;\n  B(B &&) noexcept(kFalse);\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  B &operator=(B &&) noexcept(kFalse);\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false' [performance-noexcept-move-constructor]\n};\n\ntemplate <typename>\nstruct C {\n  C(C &&);\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: C(C &&) noexcept ;\n  C& operator=(C &&);\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: C& operator=(C &&) noexcept ;\n};\n\nstruct D {\n  static constexpr bool kFalse = false;\n  D(D &&) noexcept(kFalse) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  D& operator=(D &&) noexcept(kFalse) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false' [performance-noexcept-move-constructor]\n};\n\ntemplate <typename>\nstruct E {\n  static constexpr bool kFalse = false;\n  E(E &&) noexcept(kFalse);\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  E& operator=(E &&) noexcept(kFalse);\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false'\n};\n\ntemplate <typename>\nstruct F {\n  static constexpr bool kFalse = false;\n  F(F &&) noexcept(kFalse) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  F& operator=(F &&) noexcept(kFalse) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false' [performance-noexcept-move-constructor]\n};\n\nstruct G {\n  G(G &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: G(G &&)  noexcept = default;\n  G& operator=(G &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: G& operator=(G &&)  noexcept = default;\n\n  ThrowOnAnything field;\n};\n\nvoid throwing_function() noexcept(false) {}\n\nstruct H {\n  H(H &&) noexcept(noexcept(throwing_function()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  H &operator=(H &&) noexcept(noexcept(throwing_function()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false' [performance-noexcept-move-constructor]\n};\n\ntemplate <typename>\nstruct I {\n  I(I &&) noexcept(noexcept(throwing_function()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  I &operator=(I &&) noexcept(noexcept(throwing_function()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false' [performance-noexcept-move-constructor]\n};\n\ntemplate <typename T> struct TemplatedType {\n  static void f() {}\n};\n\ntemplate <> struct TemplatedType<int> {\n  static void f() noexcept {}\n};\n\nstruct J {\n  J(J &&) noexcept(noexcept(TemplatedType<double>::f()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: noexcept specifier on the move constructor evaluates to 'false' [performance-noexcept-move-constructor]\n  J &operator=(J &&) noexcept(noexcept(TemplatedType<double>::f()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: noexcept specifier on the move assignment operator evaluates to 'false' [performance-noexcept-move-constructor]\n};\n\nstruct K : public ThrowOnAnything {\n  K(K &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: K(K &&)  noexcept = default;\n  K &operator=(K &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: K &operator=(K &&)  noexcept = default;\n};\n\nstruct InheritFromThrowOnAnything : public ThrowOnAnything\n{};\n\nstruct L {\n  L(L &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: L(L &&)  noexcept = default;\n  L &operator=(L &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: L &operator=(L &&)  noexcept = default;\n\n  InheritFromThrowOnAnything IFF;\n};\n\nstruct M : public InheritFromThrowOnAnything {\n  M(M &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: M(M &&)  noexcept = default;\n  M &operator=(M &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: M &operator=(M &&)  noexcept = default;\n};\n\nstruct N : public IntWrapper, ThrowOnAnything {\n  N(N &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: N(N &&)  noexcept = default;\n  N &operator=(N &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: N &operator=(N &&)  noexcept = default;\n};\n\nstruct O : virtual IntWrapper, ThrowOnAnything {\n  O(O &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: move constructors should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: O(O &&)  noexcept = default;\n  O &operator=(O &&) = default;\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: move assignment operators should be marked noexcept [performance-noexcept-move-constructor]\n  // CHECK-FIXES: O &operator=(O &&)  noexcept = default;\n};\n\nclass OK {};\n\nvoid f() {\n  OK a;\n  a = OK();\n}\n\nstruct OK1 {\n  OK1(const OK1 &);\n  OK1(OK1 &&) noexcept;\n  OK1 &operator=(OK1 &&) noexcept;\n  void f();\n  void g() noexcept;\n};\n\nstruct OK2 {\n  static constexpr bool kTrue = true;\n\n  OK2(OK2 &&) noexcept(true) {}\n  OK2 &operator=(OK2 &&) noexcept(kTrue) { return *this; }\n};\n\nstruct OK4 {\n  OK4(OK4 &&) noexcept(false) {}\n  OK4 &operator=(OK4 &&) = delete;\n};\n\nstruct OK3 {\n  OK3(OK3 &&) noexcept = default;\n  OK3 &operator=(OK3 &&) noexcept = default;\n};\n\nstruct OK5 {\n  OK5(OK5 &&) noexcept(true) = default;\n  OK5 &operator=(OK5 &&) noexcept(true) = default;\n};\n\nstruct OK6 {\n  OK6(OK6 &&) = default;\n  OK6& operator=(OK6 &&) = default;\n};\n\ntemplate <typename>\nstruct OK7 {\n  OK7(OK7 &&) = default;\n  OK7& operator=(OK7 &&) = default;\n};\n\ntemplate <typename>\nstruct OK8 {\n  OK8(OK8 &&) noexcept = default;\n  OK8& operator=(OK8 &&) noexcept = default;\n};\n\ntemplate <typename>\nstruct OK9 {\n  OK9(OK9 &&) noexcept(true) = default;\n  OK9& operator=(OK9 &&) noexcept(true) = default;\n};\n\ntemplate <typename>\nstruct OK10 {\n  OK10(OK10 &&) noexcept(false) = default;\n  OK10& operator=(OK10 &&) noexcept(false) = default;\n};\n\ntemplate <typename>\nstruct OK11 {\n  OK11(OK11 &&) = delete;\n  OK11& operator=(OK11 &&) = delete;\n};\n\nvoid noexcept_function() noexcept {}\n\nstruct OK12 {\n  OK12(OK12 &&) noexcept(noexcept(noexcept_function()));\n  OK12 &operator=(OK12 &&) noexcept(noexcept(noexcept_function));\n};\n\nstruct OK13 {\n  OK13(OK13 &&) noexcept(noexcept(noexcept_function)) = default;\n  OK13 &operator=(OK13 &&) noexcept(noexcept(noexcept_function)) = default;\n};\n\ntemplate <typename>\nstruct OK14 {\n  OK14(OK14 &&) noexcept(noexcept(TemplatedType<int>::f()));\n  OK14 &operator=(OK14 &&) noexcept(noexcept(TemplatedType<int>::f()));\n};\n\nstruct OK15 {\n  OK15(OK15 &&) = default;\n  OK15 &operator=(OK15 &&) = default;\n\n  int member;\n};\n\ntemplate <typename>\nstruct OK16 {\n  OK16(OK16 &&) = default;\n  OK16 &operator=(OK16 &&) = default;\n\n  int member;\n};\n\nstruct OK17 {\n  OK17(OK17 &&) = default;\n  OK17 &operator=(OK17 &&) = default;\n\n  OK empty_field;\n};\n\ntemplate <typename>\nstruct OK18 {\n  OK18(OK18 &&) = default;\n  OK18 &operator=(OK18 &&) = default;\n\n  OK empty_field;\n};\n\nstruct OK19 : public OK {\n  OK19(OK19 &&) = default;\n  OK19 &operator=(OK19 &&) = default;\n};\n\nstruct OK20 : virtual OK {\n  OK20(OK20 &&) = default;\n  OK20 &operator=(OK20 &&) = default;\n};\n\ntemplate <typename T>\nstruct OK21 : public T {\n  OK21() = default;\n  OK21(OK21 &&) = default;\n  OK21 &operator=(OK21 &&) = default;\n};\n\ntemplate <typename T>\nstruct OK22 : virtual T {\n  OK22() = default;\n  OK22(OK22 &&) = default;\n  OK22 &operator=(OK22 &&) = default;\n};\n\ntemplate <typename T>\nstruct OK23 {\n  OK23() = default;\n  OK23(OK23 &&) = default;\n  OK23 &operator=(OK23 &&) = default;\n\n  T member;\n};\n\nvoid testTemplates() {\n  OK21<Empty> value(OK21<Empty>{});\n  value = OK21<Empty>{};\n\n  OK22<Empty> value2{OK22<Empty>{}};\n  value2 = OK22<Empty>{};\n\n  OK23<Empty> value3{OK23<Empty>{}};\n  value3 =OK23<Empty>{};\n}\n\nstruct OK24 : public Empty, OK1 {\n  OK24(OK24 &&) = default;\n  OK24 &operator=(OK24 &&) = default;\n};\n\nstruct OK25 : virtual Empty, OK1 {\n  OK25(OK25 &&) = default;\n  OK25 &operator=(OK25 &&) = default;\n};\n\nstruct OK26 : public Empty, IntWrapper {\n  OK26(OK26 &&) = default;\n  OK26 &operator=(OK26 &&) = default;\n};\n\ntemplate <typename T>\nstruct OK27 : public T {\n  OK27(OK27 &&) = default;\n  OK27 &operator=(OK27 &&) = default;\n};\n\ntemplate <typename T>\nstruct OK28 : virtual T {\n  OK28(OK28 &&) = default;\n  OK28 &operator=(OK28 &&) = default;\n};\n\ntemplate <typename T>\nstruct OK29 {\n  OK29(OK29 &&) = default;\n  OK29 &operator=(OK29 &&) = default;\n\n  T member;\n};\n\nstruct OK30 {\n  OK30(OK30 &&) noexcept(TrueT<OK30>::value) = default;\n  OK30& operator=(OK30 &&) noexcept(TrueT<OK30>::value) = default;\n};\n\ntemplate <typename>\nstruct OK31 {\n  OK31(OK31 &&) noexcept(TrueT<int>::value) = default;\n  OK31& operator=(OK31 &&) noexcept(TrueT<int>::value) = default;\n};\n\nnamespace gh68101\n{\n  template <typename T>\n  class Container {\n     public:\n      Container(Container&&) noexcept(std::is_nothrow_move_constructible<T>::value);\n  };\n} // namespace gh68101\n\nnamespace gh111436\n{\n\ntemplate <typename value_type> class set {\n  set(set &&) = default;\n\n#ifdef ENABLE_ERROR\n  set(initializer_list<value_type> __l) {};\n  // CHECK-MESSAGES-ERR: :[[@LINE-1]]:7: error: member 'initializer_list' cannot have template arguments [clang-diagnostic-error]\n  // CHECK-MESSAGES-ERR: :[[@LINE-2]]:36: error: expected ')' [clang-diagnostic-error]\n#endif\n};\n\n} // namespace gh111436"
    }
  ]
}