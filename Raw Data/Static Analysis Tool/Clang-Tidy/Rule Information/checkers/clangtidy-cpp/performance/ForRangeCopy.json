{
  "name": "ForRangeCopy",
  "language": "cpp",
  "description": ".. title:: clang-tidy - performance-for-range-copy",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 139,
  "branches": 16,
  "apis": 110,
  "test": [
    {
      "description": null,
      "expected-problems": 14,
      "expected-linenumbers": [
        81,
        92,
        96,
        100,
        216,
        224,
        235,
        244,
        260,
        269,
        277,
        285,
        314,
        324
      ],
      "code": "\n// RUN: %check_clang_tidy %s performance-for-range-copy %t -- -- -fno-delayed-template-parsing\n\nnamespace std {\n\ntemplate <typename _Tp>\nstruct remove_reference { typedef _Tp type; };\ntemplate <typename _Tp>\nstruct remove_reference<_Tp&> { typedef _Tp type; };\ntemplate <typename _Tp>\nstruct remove_reference<_Tp&&> { typedef _Tp type; };\n\ntemplate <typename _Tp>\nconstexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) {\n  return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);\n}\n\n} // std\n\ntemplate <typename T>\nstruct Iterator {\n  void operator++() {}\n  const T& operator*() {\n    static T* TT = new T();\n    return *TT;\n  }\n  bool operator!=(const Iterator &) { return false; }\n  typedef const T& const_reference;\n};\ntemplate <typename T>\nstruct View {\n  View() = default;\n  T begin() { return T(); }\n  T begin() const { return T(); }\n  T end() { return T(); }\n  T end() const { return T(); }\n  typedef typename T::const_reference const_reference;\n};\n\nstruct ConstructorConvertible {\n};\n\nstruct S {\n  S();\n  S(const S &);\n  S(const ConstructorConvertible&) {}\n  ~S();\n  S &operator=(const S &);\n};\n\nstruct Point {\n  ~Point() {}\n  int x, y;\n};\n\nstruct Convertible {\n  operator S() const {\n    return S();\n  }\n};\n\nvoid negativeConstReference() {\n  for (const S &S1 : View<Iterator<S>>()) {\n  }\n}\n\nvoid negativeUserDefinedConversion() {\n  Convertible C[0];\n  for (const S S1 : C) {\n  }\n}\n\nvoid negativeImplicitConstructorConversion() {\n  ConstructorConvertible C[0];\n  for (const S S1 : C) {\n  }\n}\n\ntemplate <typename T>\nvoid uninstantiated() {\n  for (const S S1 : View<Iterator<S>>()) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:16: warning: the loop variable's type is not a reference type; this creates a copy in each iteration; consider making this a reference [performance-for-range-copy]\n  // CHECK-FIXES: for (const S& S1 : View<Iterator<S>>()) {}\n\n  // Don't warn on dependent types.\n  for (const T t1 : View<Iterator<T>>()) {\n  }\n}\n\ntemplate <typename T>\nvoid instantiated() {\n  for (const S S2 : View<Iterator<S>>()) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:16: warning: the loop variable's type is {{.*}}\n  // CHECK-FIXES: for (const S& S2 : View<Iterator<S>>()) {}\n\n  for (const auto [X, Y] : View<Iterator<Point>>()) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:19: warning: the loop variable's type is\n  // CHECK-FIXES: for (const auto& [X, Y] : View<Iterator<Point>>()) {}\n\n  for (const T T2 : View<Iterator<T>>()) {}\n  // CHECK-MESSAGES: [[@LINE-1]]:16: warning: the loop variable's type is {{.*}}\n  // CHECK-FIXES: for (const T& T2 : View<Iterator<T>>()) {}\n}\n\ntemplate <typename T>\nvoid instantiatedNegativeTypedefConstReference() {\n  for (typename T::const_reference T2 : T()) {\n    S S1 = T2;\n  }\n}\n\nvoid f() {\n  instantiated<int>();\n  instantiated<S>();\n  instantiatedNegativeTypedefConstReference<View<Iterator<S>>>();\n}\n\nstruct Mutable {\n  Mutable() {}\n  Mutable(const Mutable &) = default;\n  Mutable(Mutable&&) = default;\n  Mutable(const Mutable &, const Mutable &) {}\n  void setBool(bool B) {}\n  bool constMethod() const {\n    return true;\n  }\n  Mutable& operator[](int I) {\n    return *this;\n  }\n  bool operator==(const Mutable &Other) const {\n    return true;\n  }\n  ~Mutable() {}\n};\n\nMutable& operator<<(Mutable &Out, bool B) {\n  Out.setBool(B);\n  return Out;\n}\n\nbool operator!=(const Mutable& M1, const Mutable& M2) {\n  return false;\n}\n\nvoid use(const Mutable &M);\nvoid use(int I);\nvoid useTwice(const Mutable &M1, const Mutable &M2);\nvoid useByValue(Mutable M);\nvoid useByConstValue(const Mutable M);\nvoid mutate(Mutable *M);\nvoid mutate(Mutable &M);\nvoid mutate(int &);\nvoid onceConstOnceMutated(const Mutable &M1, Mutable &M2);\n\nvoid negativeVariableIsMutated() {\n  for (auto M : View<Iterator<Mutable>>()) {\n    mutate(M);\n  }\n  for (auto M : View<Iterator<Mutable>>()) {\n    mutate(&M);\n  }\n  for (auto M : View<Iterator<Mutable>>()) {\n    M.setBool(true);\n  }\n}\n\nvoid negativeOnceConstOnceMutated() {\n  for (auto M : View<Iterator<Mutable>>()) {\n    onceConstOnceMutated(M, M);\n  }\n}\n\nvoid negativeVarIsMoved() {\n  for (auto M : View<Iterator<Mutable>>()) {\n    auto Moved = std::move(M);\n  }\n}\n\nvoid negativeNonConstOperatorIsInvoked() {\n  for (auto NonConstOperatorInvokee : View<Iterator<Mutable>>()) {\n    auto& N = NonConstOperatorInvokee[0];\n  }\n}\n\nvoid negativeNonConstNonMemberOperatorInvoked() {\n  for (auto NonConstOperatorInvokee : View<Iterator<Mutable>>()) {\n    NonConstOperatorInvokee << true;\n  }\n}\n\nvoid negativeConstCheapToCopy() {\n  for (const int I : View<Iterator<int>>()) {\n  }\n}\n\nvoid negativeConstCheapToCopyTypedef() {\n  typedef const int ConstInt;\n  for (ConstInt C  : View<Iterator<ConstInt>>()) {\n  }\n}\n\nvoid negativeCheapToCopy() {\n  for (int I : View<Iterator<int>>()) {\n    use(I);\n  }\n}\n\nvoid negativeCheapToCopyTypedef() {\n  typedef int Int;\n  for (Int I : View<Iterator<Int>>()) {\n    use(I);\n  }\n}\n\nvoid positiveOnlyConstMethodInvoked() {\n  for (auto M : View<Iterator<Mutable>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& M : View<Iterator<Mutable>>()) {\n    M.constMethod();\n  }\n}\n\nvoid positiveOnlyUsedAsConstArguments() {\n  for (auto UsedAsConst : View<Iterator<Mutable>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& UsedAsConst : View<Iterator<Mutable>>()) {\n    use(UsedAsConst);\n    useTwice(UsedAsConst, UsedAsConst);\n    useByValue(UsedAsConst);\n    useByConstValue(UsedAsConst);\n  }\n}\n\nvoid positiveOnlyAccessedFieldAsConst() {\n  for (auto UsedAsConst : View<Iterator<Point>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& UsedAsConst : View<Iterator<Point>>()) {\n    use(UsedAsConst.x);\n    use(UsedAsConst.y);\n  }\n}\n\nvoid positiveOnlyUsedAsConstBinding() {\n  for (auto [X, Y] : View<Iterator<Point>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but\n    // CHECK-FIXES: for (const auto& [X, Y] : View<Iterator<Point>>()) {\n    use(X);\n    use(Y);\n  }\n}\n\nvoid negativeMutatedBinding() {\n  for (auto [X, Y] : View<Iterator<Point>>()) {\n    use(X);\n    mutate(Y);\n  }\n}\n\nvoid positiveOnlyUsedInCopyConstructor() {\n  for (auto A : View<Iterator<Mutable>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& A : View<Iterator<Mutable>>()) {\n    Mutable Copy = A;\n    Mutable Copy2(A);\n  }\n}\n\nvoid positiveTwoConstConstructorArgs() {\n  for (auto A : View<Iterator<Mutable>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& A : View<Iterator<Mutable>>()) {\n    Mutable Copy(A, A);\n  }\n}\n\nvoid PositiveConstMemberOperatorInvoked() {\n  for (auto ConstOperatorInvokee : View<Iterator<Mutable>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& ConstOperatorInvokee : View<Iterator<Mutable>>()) {\n    bool result = ConstOperatorInvokee == Mutable();\n  }\n}\n\nvoid PositiveConstNonMemberOperatorInvoked() {\n  for (auto ConstOperatorInvokee : View<Iterator<Mutable>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:13: warning: loop variable is copied but only used as const reference; consider making it a const reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const auto& ConstOperatorInvokee : View<Iterator<Mutable>>()) {\n    bool result = ConstOperatorInvokee != Mutable();\n  }\n}\n\nvoid IgnoreLoopVariableNotUsedInLoopBody() {\n  for (auto _ : View<Iterator<S>>()) {\n  }\n}\n\ntemplate <typename T>\nstruct ValueReturningIterator {\n  void operator++() {}\n  T operator*() { return T(); }\n  bool operator!=(const ValueReturningIterator &) { return false; }\n  typedef const T &const_reference;\n};\n\nvoid negativeValueIterator() {\n  // Check does not trigger for iterators that return elements by value.\n  for (const S SS : View<ValueReturningIterator<S>>()) {\n  }\n}\n\nView<Iterator<S>> createView(S) { return View<Iterator<S>>(); }\n\nvoid positiveValueIteratorUsedElseWhere() {\n  for (const S SS : createView(*ValueReturningIterator<S>())) {\n    // CHECK-MESSAGES: [[@LINE-1]]:16: warning: the loop variable's type is not a reference type; this creates a copy in each iteration; consider making this a reference [performance-for-range-copy]\n    // CHECK-FIXES: for (const S& SS : createView(*ValueReturningIterator<S>())) {\n  }\n}\n\nvoid positiveConstMemberExpr() {\n  struct Struct {\n    Mutable Member;\n  };\n  for (Struct SS : View<Iterator<Struct>>()) {\n    // CHECK-MESSAGES: [[@LINE-1]]:15: warning: loop variable is copied\n    // CHECK-FIXES: for (const Struct& SS : View<Iterator<Struct>>()) {\n    auto MemberCopy = SS.Member;\n    const auto &ConstRef = SS.Member;\n    bool b = SS.Member.constMethod();\n    use(SS.Member);\n    useByConstValue(SS.Member);\n    useByValue(SS.Member);\n  }\n}\n\nvoid negativeNonConstMemberExpr() {\n  struct Struct {\n    Mutable Member;\n  };\n  for (Struct SS : View<Iterator<Struct>>()) {\n    SS.Member.setBool(true);\n  }\n  for (Struct SS : View<Iterator<Struct>>()) {\n    SS.Member[1];\n  }\n  for (Struct SS : View<Iterator<Struct>>()) {\n    mutate(SS.Member);\n  }\n  for (Struct SS : View<Iterator<Struct>>()) {\n    mutate(&SS.Member);\n  }\n}\n"
    }
  ]
}