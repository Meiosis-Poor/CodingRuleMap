{
  "name": "ProBoundsConstantArrayIndex",
  "language": "cpp",
  "description": ".. title:: clang-tidy - cppcoreguidelines-pro-bounds-constant-array-index",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 130,
  "branches": 14,
  "apis": 90,
  "test": [
    {
      "description": null,
      "expected-problems": 21,
      "expected-linenumbers": [
        31,
        33,
        39,
        41,
        44,
        54,
        56,
        61,
        63,
        66,
        87,
        89,
        95,
        97,
        100,
        110,
        112,
        117,
        119,
        122,
        153
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes %s cppcoreguidelines-pro-bounds-constant-array-index %t\n\ntypedef __SIZE_TYPE__ size_t;\n\nnamespace std {\n  template<typename T, size_t N>\n  struct array {\n    T& operator[](size_t n);\n    T& at(size_t n);\n  };\n}\n\n\nnamespace gsl {\n  template<class T, size_t N>\n  T& at( T(&a)[N], size_t index );\n\n  template<class T, size_t N>\n  T& at( std::array<T, N> &a, size_t index );\n}\n\nconstexpr int const_index(int base) {\n  return base + 3;\n}\n\ntemplate<class T, size_t N>\nclass DerivedArray : public std::array<T, N> {};\n\nvoid f(std::array<int, 10> a, int pos) {\n  a [ pos / 2 /*comment*/] = 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index]\n  int j = a[pos - 1];\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: do not use array subscript when the index is not an integer constant expression\n\n  a.at(pos-1) = 2; // OK, at() instead of []\n  gsl::at(a, pos-1) = 2; // OK, gsl::at() instead of []\n\n  a[-1] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index -1 is negative [cppcoreguidelines-pro-bounds-constant-array-index]\n  a[10] = 4;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements) [cppcoreguidelines-pro-bounds-constant-array-index]\n\n  a[const_index(7)] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements)\n\n  a[0] = 3; // OK, constant index and inside bounds\n  a[1] = 3; // OK, constant index and inside bounds\n  a[9] = 3; // OK, constant index and inside bounds\n  a[const_index(6)] = 3; // OK, constant index and inside bounds\n\n  using MyArray = std::array<int, 10>;\n  MyArray m{};\n  m [ pos / 2 /*comment*/] = 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index]\n  int jj = m[pos - 1];\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use array subscript when the index is not an integer constant expression\n\n  m.at(pos-1) = 2; // OK, at() instead of []\n  gsl::at(m, pos-1) = 2; // OK, gsl::at() instead of []\n  m[-1] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index -1 is negative [cppcoreguidelines-pro-bounds-constant-array-index]\n  m[10] = 4;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements) [cppcoreguidelines-pro-bounds-constant-array-index]\n\n  m[const_index(7)] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements)\n\n  m[0] = 3; // OK, constant index and inside bounds\n  m[1] = 3; // OK, constant index and inside bounds\n  m[9] = 3; // OK, constant index and inside bounds\n  m[const_index(6)] = 3; // OK, constant index and inside bounds\n}\n\ntemplate<class T, size_t N>\nclass PrivateDerivedArray : std::array<T, N> {\npublic:\n  T& operator[](size_t n){\n    return std::array<T, N>::operator[](static_cast<int>(n));\n  };\n  T& at(size_t n) {\n    return std::array<T, N>::at(static_cast<int>(n));\n  };\n};\n\nvoid f_derived(DerivedArray<int, 10> a, int pos) {\n  a [ pos / 2 /*comment*/] = 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index]\n  int j = a[pos - 1];\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: do not use array subscript when the index is not an integer constant expression\n\n  a.at(pos-1) = 2; // OK, at() instead of []\n  gsl::at(a, pos-1) = 2; // OK, gsl::at() instead of []\n\n  a[-1] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index -1 is negative [cppcoreguidelines-pro-bounds-constant-array-index]\n  a[10] = 4;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements) [cppcoreguidelines-pro-bounds-constant-array-index]\n\n  a[const_index(7)] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements)\n\n  a[0] = 3; // OK, constant index and inside bounds\n  a[1] = 3; // OK, constant index and inside bounds\n  a[9] = 3; // OK, constant index and inside bounds\n  a[const_index(6)] = 3; // OK, constant index and inside bounds\n\n  using MyArray = DerivedArray<int, 10>;\n  MyArray m{};\n  m [ pos / 2 /*comment*/] = 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: do not use array subscript when the index is not an integer constant expression [cppcoreguidelines-pro-bounds-constant-array-index]\n  int jj = m[pos - 1];\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use array subscript when the index is not an integer constant expression\n\n  m.at(pos-1) = 2; // OK, at() instead of []\n  gsl::at(m, pos-1) = 2; // OK, gsl::at() instead of []\n  m[-1] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index -1 is negative [cppcoreguidelines-pro-bounds-constant-array-index]\n  m[10] = 4;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements) [cppcoreguidelines-pro-bounds-constant-array-index]\n\n  m[const_index(7)] = 3;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: std::array<> index 10 is past the end of the array (which contains 10 elements)\n\n  m[0] = 3; // OK, constant index and inside bounds\n  m[1] = 3; // OK, constant index and inside bounds\n  m[9] = 3; // OK, constant index and inside bounds\n  m[const_index(6)] = 3; // OK, constant index and inside bounds\n\n  using MyPrivateArray = PrivateDerivedArray<int, 10>;\n  MyPrivateArray pm{};\n  pm [ pos / 2 /*comment*/] = 1;\n  int jjj = pm[pos - 1];\n\n  pm.at(pos-1) = 2; // OK, at() instead of []\n  pm[-1] = 3;\n  pm[10] = 4;\n\n  pm[const_index(7)] = 3;\n\n  pm[0] = 3; // OK, constant index and inside bounds\n  pm[1] = 3; // OK, constant index and inside bounds\n  pm[9] = 3; // OK, constant index and inside bounds\n  pm[const_index(6)] = 3; // OK, constant index and inside bounds\n}\n\n\n\n\nvoid g() {\n  int a[10];\n  for (int i = 0; i < 10; ++i) {\n    a[i] = i;\n    // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: do not use array subscript when the index is not an integer constant expression\n    // CHECK-FIXES: gsl::at(a, i) = i;\n    gsl::at(a, i) = i; // OK, gsl::at() instead of []\n  }\n\n  a[-1] = 3; // flagged by clang-diagnostic-array-bounds\n  a[10] = 4; // flagged by clang-diagnostic-array-bounds\n  a[const_index(7)] = 3; // flagged by clang-diagnostic-array-bounds\n\n  a[0] = 3; // OK, constant index and inside bounds\n  a[1] = 3; // OK, constant index and inside bounds\n  a[9] = 3; // OK, constant index and inside bounds\n  a[const_index(6)] = 3; // OK, constant index and inside bounds\n}\n\nstruct S {\n  int& operator[](int i);\n};\n\nvoid customOperator() {\n  S s;\n  int i = 0;\n  s[i] = 3; // OK, custom operator\n}\n\nnamespace ArrayInitIndexExpr {\nstruct A {\n  // The compiler-generated copy constructor uses an ArraySubscriptExpr. Don't warn.\n  int x[3];\n};\n\nvoid implicitCopyMoveCtor() {\n  // Force the compiler to generate a copy constructor.\n  A a;\n  A a2(a);\n\n  // Force the compiler to generate a move constructor.\n  A a3 = (A&&) a;\n}\n\nvoid lambdaCapture() {\n  int arr[3];\n\n  // Capturing an array by value uses an ArraySubscriptExpr. Don't warn. \n  [arr](){};\n}\n\n#if __cplusplus >= 201703L\nvoid structuredBindings() {\n  int arr[3];\n\n  // Creating structured bindings by value uses an ArraySubscriptExpr. Don't warn.\n  auto [a,b,c] = arr;\n}\n#endif\n} // namespace ArrayInitIndexExpr"
    }
  ]
}