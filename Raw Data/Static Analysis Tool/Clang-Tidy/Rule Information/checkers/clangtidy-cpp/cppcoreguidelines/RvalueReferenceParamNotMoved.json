{
  "name": "RvalueReferenceParamNotMoved",
  "language": "cpp",
  "description": ".. title:: clang-tidy - cppcoreguidelines-rvalue-reference-param-not-moved",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 137,
  "branches": 10,
  "apis": 129,
  "test": [
    {
      "description": null,
      "expected-problems": 21,
      "expected-linenumbers": [
        43,
        50,
        56,
        61,
        62,
        66,
        72,
        75,
        82,
        86,
        117,
        123,
        160,
        173,
        185,
        268,
        319,
        325,
        343,
        355,
        358
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++11 %s cppcoreguidelines-rvalue-reference-param-not-moved %t -- \\\n// RUN: -config=\"{CheckOptions: {cppcoreguidelines-rvalue-reference-param-not-moved.AllowPartialMove: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreUnnamedParams: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreNonDeducedTemplateTypes: true}}\" -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -check-suffix=,CXX14 -std=c++14 %s cppcoreguidelines-rvalue-reference-param-not-moved %t -- \\\n// RUN: -config=\"{CheckOptions: {cppcoreguidelines-rvalue-reference-param-not-moved.AllowPartialMove: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreUnnamedParams: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreNonDeducedTemplateTypes: true}}\" -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -check-suffix=,NOSUBEXPR -std=c++11 %s cppcoreguidelines-rvalue-reference-param-not-moved %t -- \\\n// RUN: -config=\"{CheckOptions: {cppcoreguidelines-rvalue-reference-param-not-moved.AllowPartialMove: false, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreUnnamedParams: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreNonDeducedTemplateTypes: true}}\" -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -check-suffix=,UNNAMED -std=c++11 %s cppcoreguidelines-rvalue-reference-param-not-moved %t -- \\\n// RUN: -config=\"{CheckOptions: {cppcoreguidelines-rvalue-reference-param-not-moved.AllowPartialMove: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreUnnamedParams: false, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreNonDeducedTemplateTypes: true}}\" -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -check-suffix=,NONDEDUCED -std=c++11 %s cppcoreguidelines-rvalue-reference-param-not-moved %t -- \\\n// RUN: -config=\"{CheckOptions: {cppcoreguidelines-rvalue-reference-param-not-moved.AllowPartialMove: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreUnnamedParams: true, cppcoreguidelines-rvalue-reference-param-not-moved.IgnoreNonDeducedTemplateTypes: false}}\" -- -fno-delayed-template-parsing\n\n// NOLINTBEGIN\nnamespace std {\ntemplate <typename>\nstruct remove_reference;\n\ntemplate <typename _Tp> struct remove_reference { typedef _Tp type; };\ntemplate <typename _Tp> struct remove_reference<_Tp&> { typedef _Tp type; };\ntemplate <typename _Tp> struct remove_reference<_Tp&&> { typedef _Tp type; };\n\ntemplate <typename _Tp>\nconstexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept;\n\ntemplate <typename _Tp>\nconstexpr _Tp &&\nforward(typename remove_reference<_Tp>::type &__t) noexcept;\n\n}\n// NOLINTEND\n\nstruct Obj {\n  Obj();\n  Obj(const Obj&);\n  Obj& operator=(const Obj&);\n  Obj(Obj&&);\n  Obj& operator=(Obj&&);\n  void member() const;\n};\n\nvoid consumes_object(Obj);\n\nvoid never_moves_param(Obj&& o) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  o.member();\n}\n\nvoid just_a_declaration(Obj&& o);\n\nvoid copies_object(Obj&& o) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  Obj copy = o;\n}\n\ntemplate <typename T>\nvoid never_moves_param_template(Obj&& o, T t) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:39: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  o.member();\n}\n\nvoid never_moves_params(Obj&& o1, Obj&& o2) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:31: warning: rvalue reference parameter 'o1' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  // CHECK-MESSAGES: :[[@LINE-2]]:41: warning: rvalue reference parameter 'o2' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n}\n\nvoid never_moves_some_params(Obj&& o1, Obj&& o2) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:36: warning: rvalue reference parameter 'o1' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n\n  Obj other{std::move(o2)};\n}\n\nvoid never_moves_unnamed(Obj&&) {}\n// CHECK-MESSAGES-UNNAMED: :[[@LINE-1]]:31: warning: rvalue reference parameter '' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n\nvoid never_moves_mixed(Obj o1, Obj&& o2) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:38: warning: rvalue reference parameter 'o2' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n}\n\nvoid lambda_captures_parameter_as_value(Obj&& o) {\n  auto f = [o]() {\n    consumes_object(std::move(o));\n  };\n  // CHECK-MESSAGES: :[[@LINE-4]]:47: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n}\n\nvoid lambda_captures_parameter_as_value_nested(Obj&& o) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:54: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  auto f = [&o]() {\n    auto f_nested = [o]() {\n      consumes_object(std::move(o));\n    };\n  };\n  auto f2 = [o]() {\n    auto f_nested = [&o]() {\n      consumes_object(std::move(o));\n    };\n  };\n  auto f3 = [o]() {\n    auto f_nested = [&o]() {\n      auto f_nested_inner = [&o]() {\n        consumes_object(std::move(o));\n      };\n    };\n  };\n  auto f4 = [&o]() {\n    auto f_nested = [&o]() {\n      auto f_nested_inner = [o]() {\n        consumes_object(std::move(o));\n      };\n    };\n  };\n}\n\nvoid misc_lambda_checks() {\n  auto never_moves = [](Obj&& o1) {\n    Obj other{o1};\n  };\n  // CHECK-MESSAGES: :[[@LINE-3]]:31: warning: rvalue reference parameter 'o1' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n\n#if __cplusplus >= 201402L\n  auto never_moves_with_auto_param = [](Obj&& o1, auto& v) {\n    Obj other{o1};\n  };\n  // CHECK-MESSAGES-CXX14: :[[@LINE-3]]:47: warning: rvalue reference parameter 'o1' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n#endif\n}\n\ntemplate <typename T>\nvoid forwarding_ref(T&& t) {\n  t.member();\n}\n\ntemplate <typename T>\nvoid forwarding_ref_forwarded(T&& t) {\n  forwarding_ref(std::forward<T>(t));\n}\n\ntemplate <typename... Ts>\nvoid type_pack(Ts&&... ts) {\n  (forwarding_ref(std::forward<Ts>(ts)), ...);\n}\n\nvoid call_forwarding_functions() {\n  Obj o;\n\n  forwarding_ref(Obj{});\n  type_pack(Obj{});\n  type_pack(Obj{}, o);\n  type_pack(Obj{}, Obj{});\n}\n\nvoid moves_parameter(Obj&& o) {\n  Obj moved = std::move(o);\n}\n\nvoid moves_parameter_extra_parens(Obj&& o) {\n  Obj moved = std::move((o));\n}\n\nvoid does_not_move_in_evaluated(Obj&& o) {\n  // CHECK-MESSAGES: :[[@LINE-1]]:39: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  using result_t = decltype(std::move(o));\n  unsigned size = sizeof(std::move(o));\n  Obj moved = o;\n}\n\ntemplate <typename T1, typename T2>\nstruct mypair {\n  T1 first;\n  T2 second;\n};\n\nvoid moves_member_of_parameter(mypair<Obj, Obj>&& pair) {\n  // CHECK-MESSAGES-NOSUBEXPR: :[[@LINE-1]]:51: warning: rvalue reference parameter 'pair' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  Obj a = std::move(pair.first);\n  Obj b = std::move(pair.second);\n}\n\ntemplate <typename T>\nstruct myoptional {\n  T& operator*() &;\n  T&& operator*() &&;\n};\n\nvoid moves_deref_optional(myoptional<Obj>&& opt) {\n  // CHECK-MESSAGES-NOSUBEXPR: :[[@LINE-1]]:45: warning: rvalue reference parameter 'opt' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n  Obj other = std::move(*opt);\n}\n\nvoid moves_optional_then_deref_resulting_rvalue(myoptional<Obj>&& opt) {\n  Obj other = *std::move(opt);\n}\n\nvoid pass_by_lvalue_reference(Obj& o) {\n  o.member();\n}\n\nvoid pass_by_value(Obj o) {\n  o.member();\n}\n\nvoid pass_by_const_lvalue_reference(const Obj& o) {\n  o.member();\n}\n\nvoid pass_by_const_lvalue_reference(const Obj&& o) {\n  o.member();\n}\n\nvoid lambda_captures_parameter_as_reference(Obj&& o) {\n  auto f = [&o]() {\n    consumes_object(std::move(o));\n  };\n}\n\nvoid lambda_captures_parameter_as_reference_nested(Obj&& o) {\n  auto f = [&o]() {\n    auto f_nested = [&o]() {\n      auto f_nested2 = [&o]() {\n        consumes_object(std::move(o));\n      };\n    };\n  };\n}\n\n#if __cplusplus >= 201402L\nvoid lambda_captures_parameter_generalized(Obj&& o) {\n  auto f = [o = std::move(o)]() {\n    consumes_object(std::move(o));\n  };\n}\n#endif\n\nvoid negative_lambda_checks() {\n  auto never_moves_nested = [](Obj&& o1) {\n    auto nested = [&]() {\n      Obj other{std::move(o1)};\n    };\n  };\n\n#if __cplusplus >= 201402L\n  auto auto_lvalue_ref_param = [](auto& o1) {\n    Obj other{o1};\n  };\n\n  auto auto_forwarding_ref_param = [](auto&& o1) {\n    Obj other{o1};\n  };\n\n  auto does_move_auto_rvalue_ref_param = [](auto&& o1) {\n    Obj other{std::forward(o1)};\n  };\n#endif\n\n  auto does_move = [](Obj&& o1) {\n    Obj other{std::move(o1)};\n  };\n\n  auto not_rvalue_ref = [](Obj& o1) {\n    Obj other{std::move(o1)};\n  };\n\n  Obj local;\n  auto captures = [local]() { };\n}\n\nstruct AClass {\n  void member_with_lambda_no_move(Obj&& o) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:41: warning: rvalue reference parameter 'o' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n    auto captures_this = [=, this]() {\n      Obj other = std::move(o);\n    };\n  }\n  void member_with_lambda_that_moves(Obj&& o) {\n    auto captures_this = [&, this]() {\n      Obj other = std::move(o);\n    };\n  }\n};\n\nvoid useless_move(Obj&& o) {\n  // FIXME - The object is not actually moved from - this should probably be\n  // flagged by *some* check. Which one?\n  std::move(o);\n}\n\ntemplate <typename>\nclass TemplatedClass;\n\ntemplate <typename T>\nvoid unresolved_lookup(TemplatedClass<T>&& o) {\n  TemplatedClass<T> moved = std::move(o);\n}\n\nstruct DefinesMove {\n  DefinesMove(DefinesMove&& rhs) : o(std::move(rhs.o)) { }\n  DefinesMove& operator=(DefinesMove&& rhs) {\n    if (this != &rhs) {\n      o = std::move(rhs.o);\n    }\n    return *this;\n  }\n  Obj o;\n};\n\nstruct DeclaresMove {\n  DeclaresMove(DeclaresMove&& rhs);\n  DeclaresMove& operator=(DeclaresMove&& rhs);\n};\n\nstruct AnotherObj {\n  AnotherObj(Obj&& o) : o(std::move(o)) {}\n  AnotherObj(Obj&& o, int) { o = std::move(o); }\n  Obj o;\n};\n\ntemplate <class T>\nstruct AClassTemplate {\n  AClassTemplate(T&& t) {}\n  // CHECK-MESSAGES-NONDEDUCED: :[[@LINE-1]]:22: warning: rvalue reference parameter 't' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n\n  void moves(T&& t) {\n    T other = std::move(t);\n  }\n  void never_moves(T&& t) {}\n  // CHECK-MESSAGES-NONDEDUCED: :[[@LINE-1]]:24: warning: rvalue reference parameter 't' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n};\n\nvoid instantiate_a_class_template() {\n  Obj o;\n  AClassTemplate<Obj> withObj{std::move(o)};\n  withObj.never_moves(std::move(o));\n\n  AClassTemplate<Obj&> withObjRef(o);\n  withObjRef.never_moves(o);\n}\n\nnamespace gh68209 {\n  void f1([[maybe_unused]] int&& x) {}\n\n  void f2(__attribute__((unused)) int&& x) {}\n\n  void f3(int&& x) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: rvalue reference parameter 'x' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n\n  template <typename T>\n  void f4([[maybe_unused]] T&& x) {}\n\n  template <typename T>\n  void f5(__attribute((unused)) T&& x) {}\n\n  template<typename T>\n  void f6(T&& x) {}\n\n  void f7([[maybe_unused]] int&& x) { x += 1; }\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: rvalue reference parameter 'x' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n\n  void f8(__attribute__((unused)) int&& x) { x += 1; }\n  // CHECK-MESSAGES: :[[@LINE-1]]:41: warning: rvalue reference parameter 'x' is never moved from inside the function body [cppcoreguidelines-rvalue-reference-param-not-moved]\n} // namespace gh68209\n\nnamespace gh69412 {\n  struct S\n  {\n      S(const int&);\n      S(int&&) = delete;\n\n      void foo(int&&) = delete;\n  };\n} // namespace gh69412"
    }
  ]
}