{
  "name": "AvoidConstOrRefDataMembers",
  "language": "cpp",
  "description": ".. title:: clang-tidy - cppcoreguidelines-avoid-const-or-ref-data-members",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 123,
  "branches": 27,
  "apis": 104,
  "test": [
    {
      "description": null,
      "expected-problems": 36,
      "expected-linenumbers": [
        26,
        31,
        36,
        41,
        46,
        48,
        50,
        52,
        68,
        73,
        78,
        83,
        88,
        90,
        92,
        94,
        104,
        106,
        108,
        110,
        118,
        123,
        128,
        133,
        144,
        150,
        156,
        162,
        217,
        228,
        269,
        275,
        291,
        297,
        315,
        322
      ],
      "code": "\n// RUN: %check_clang_tidy %s cppcoreguidelines-avoid-const-or-ref-data-members %t\nnamespace std {\ntemplate <typename T>\nstruct unique_ptr {};\n\ntemplate <typename T>\nstruct shared_ptr {};\n} // namespace std\n\nnamespace gsl {\ntemplate <typename T>\nstruct not_null {};\n} // namespace gsl\n\nstruct Ok {\n  int i;\n  int *p;\n  const int *pc;\n  std::unique_ptr<int> up;\n  std::shared_ptr<int> sp;\n  gsl::not_null<int*> n;\n};\n\nstruct ConstMember {\n  const int c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: member 'c' of type 'const int' is const qualified [cppcoreguidelines-avoid-const-or-ref-data-members]\n};\n\nstruct LvalueRefMember {\n  int &lr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'lr' of type 'int &' is a reference\n};\n\nstruct ConstRefMember {\n  const int &cr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: member 'cr' of type 'const int &' is a reference\n};\n\nstruct RvalueRefMember {\n  int &&rr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: member 'rr' of type 'int &&' is a reference\n};\n\nstruct ConstAndRefMembers {\n  const int c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: member 'c' of type 'const int' is const qualified\n  int &lr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'lr' of type 'int &' is a reference\n  const int &cr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: member 'cr' of type 'const int &' is a reference\n  int &&rr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: member 'rr' of type 'int &&' is a reference\n};\n\nstruct Foo {};\n\nstruct Ok2 {\n  Foo i;\n  Foo *p;\n  const Foo *pc;\n  std::unique_ptr<Foo> up;\n  std::shared_ptr<Foo> sp;\n  gsl::not_null<Foo*> n;\n};\n\nstruct ConstMember2 {\n  const Foo c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: member 'c' of type 'const Foo' is const qualified\n};\n\nstruct LvalueRefMember2 {\n  Foo &lr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'lr' of type 'Foo &' is a reference\n};\n\nstruct ConstRefMember2 {\n  const Foo &cr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: member 'cr' of type 'const Foo &' is a reference\n};\n\nstruct RvalueRefMember2 {\n  Foo &&rr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: member 'rr' of type 'Foo &&' is a reference\n};\n\nstruct ConstAndRefMembers2 {\n  const Foo c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: member 'c' of type 'const Foo' is const qualified\n  Foo &lr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'lr' of type 'Foo &' is a reference\n  const Foo &cr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: member 'cr' of type 'const Foo &' is a reference\n  Foo &&rr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: member 'rr' of type 'Foo &&' is a reference\n};\n\nusing ConstType = const int;\nusing RefType = int &;\nusing ConstRefType = const int &;\nusing RefRefType = int &&;\n\nstruct WithAlias {\n  ConstType c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: member 'c' of type 'ConstType' (aka 'const int') is const qualified\n  RefType lr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: member 'lr' of type 'RefType' (aka 'int &') is a reference\n  ConstRefType cr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: member 'cr' of type 'ConstRefType' (aka 'const int &') is a reference\n  RefRefType rr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: member 'rr' of type 'RefRefType' (aka 'int &&') is a reference\n};\n\ntemplate <int N>\nusing Array = int[N];\n\nstruct ConstArrayMember {\n  const Array<1> c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: member 'c' of type 'const Array<1>' (aka 'const int[1]') is const qualified\n};\n\nstruct LvalueRefArrayMember {\n  Array<2> &lr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: member 'lr' of type 'Array<2> &' (aka 'int (&)[2]') is a reference\n};\n\nstruct ConstLvalueRefArrayMember {\n  const Array<3> &cr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: member 'cr' of type 'const Array<3> &' (aka 'const int (&)[3]') is a reference\n};\n\nstruct RvalueRefArrayMember {\n  Array<4> &&rr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: member 'rr' of type 'Array<4> &&' (aka 'int (&&)[4]') is a reference\n};\n\ntemplate <typename T>\nstruct TemplatedOk {\n  T t;\n};\n\ntemplate <typename T>\nstruct TemplatedConst {\n  T t;\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: member 't' of type 'const int' is const qualified\n};\n\ntemplate <typename T>\nstruct TemplatedConstRef {\n  T t;\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: member 't' of type 'const int &' is a reference\n};\n\ntemplate <typename T>\nstruct TemplatedRefRef {\n  T t;\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: member 't' of type 'int &&' is a reference\n};\n\ntemplate <typename T>\nstruct TemplatedRef {\n  T t;\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: member 't' of type 'int &' is a reference\n};\n\nTemplatedOk<int> t1{};\nTemplatedConst<const int> t2{123};\nTemplatedConstRef<const int &> t3{123};\nTemplatedRefRef<int &&> t4{123};\nTemplatedRef<int &> t5{t1.t};\n\n// Lambdas capturing const or ref members should not trigger warnings\nvoid lambdas()\n{\n  int x1{123};\n  const int x2{123};\n  const int& x3{123};\n  int&& x4{123};\n  int& x5{x1};\n\n  auto v1 = [x1]{};\n  auto v2 = [x2]{};\n  auto v3 = [x3]{};\n  auto v4 = [x4]{};\n  auto v5 = [x5]{};\n\n  auto r1 = [&x1]{};\n  auto r2 = [&x2]{};\n  auto r3 = [&x3]{};\n  auto r4 = [&x4]{};\n  auto r5 = [&x5]{};\n\n  auto iv = [=]{\n    auto c1 = x1;\n    auto c2 = x2;\n    auto c3 = x3;\n    auto c4 = x4;\n    auto c5 = x5;\n  };\n\n  auto ir = [&]{\n    auto c1 = x1;\n    auto c2 = x2;\n    auto c3 = x3;\n    auto c4 = x4;\n    auto c5 = x5;\n  };\n}\n\nstruct NonCopyableWithRef\n{\n  NonCopyableWithRef(NonCopyableWithRef const&) = delete;\n  NonCopyableWithRef& operator=(NonCopyableWithRef const&) = delete;\n  NonCopyableWithRef(NonCopyableWithRef&&) = default;\n  NonCopyableWithRef& operator=(NonCopyableWithRef&&) = default;\n\n  int& x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'x' of type 'int &' is a reference\n};\n\nstruct NonMovableWithRef\n{\n  NonMovableWithRef(NonMovableWithRef const&) = default;\n  NonMovableWithRef& operator=(NonMovableWithRef const&) = default;\n  NonMovableWithRef(NonMovableWithRef&&) = delete;\n  NonMovableWithRef& operator=(NonMovableWithRef&&) = delete;\n\n  int& x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'x' of type 'int &' is a reference\n};\n\nstruct NonCopyableNonMovableWithRef\n{\n  NonCopyableNonMovableWithRef(NonCopyableNonMovableWithRef const&) = delete;\n  NonCopyableNonMovableWithRef(NonCopyableNonMovableWithRef&&) = delete;\n  NonCopyableNonMovableWithRef& operator=(NonCopyableNonMovableWithRef const&) = delete;\n  NonCopyableNonMovableWithRef& operator=(NonCopyableNonMovableWithRef&&) = delete;\n\n  int& x; // OK, non copyable nor movable\n};\n\nstruct NonCopyable\n{\n  NonCopyable(NonCopyable const&) = delete;\n  NonCopyable& operator=(NonCopyable const&) = delete;\n  NonCopyable(NonCopyable&&) = default;\n  NonCopyable& operator=(NonCopyable&&) = default;\n};\n\nstruct NonMovable\n{\n  NonMovable(NonMovable const&) = default;\n  NonMovable& operator=(NonMovable const&) = default;\n  NonMovable(NonMovable&&) = delete;\n  NonMovable& operator=(NonMovable&&) = delete;\n};\n\nstruct NonCopyableNonMovable\n{\n  NonCopyableNonMovable(NonCopyableNonMovable const&) = delete;\n  NonCopyableNonMovable(NonCopyableNonMovable&&) = delete;\n  NonCopyableNonMovable& operator=(NonCopyableNonMovable const&) = delete;\n  NonCopyableNonMovable& operator=(NonCopyableNonMovable&&) = delete;\n};\n\n// Test inheritance\nstruct InheritFromNonCopyable : NonCopyable\n{\n  int& x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'x' of type 'int &' is a reference\n};\n\nstruct InheritFromNonMovable : NonMovable\n{\n  int& x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'x' of type 'int &' is a reference\n};\n\nstruct InheritFromNonCopyableNonMovable : NonCopyableNonMovable\n{\n  int& x;  // OK, non copyable nor movable\n};\n\nstruct InheritBothFromNonCopyableAndNonMovable : NonCopyable, NonMovable\n{\n  int& x;  // OK, non copyable nor movable\n};\n\ntemplate<class T> struct TemplateInheritFromNonCopyable : NonCopyable\n{\n  int& x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'x' of type 'int &' is a reference\n};\n\ntemplate<class T> struct TemplateInheritFromNonMovable : NonMovable\n{\n  int& x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'x' of type 'int &' is a reference\n};\n\ntemplate<class T> struct TemplateInheritFromNonCopyableNonMovable : NonCopyableNonMovable\n{\n  int& x;  // OK, non copyable nor movable\n};\n\ntemplate<class T> struct TemplateInheritBothFromNonCopyableAndNonMovable : NonCopyable, NonMovable\n{\n  int& x;  // OK, non copyable nor movable\n};\n\n// Test composition\nstruct ContainsNonCopyable\n{\n  NonCopyable x;\n  int& y;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'y' of type 'int &' is a reference\n};\n\nstruct ContainsNonMovable\n{\n  NonMovable x;\n  int& y;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: member 'y' of type 'int &' is a reference\n};\n\nstruct ContainsNonCopyableNonMovable\n{\n  NonCopyableNonMovable x;\n  int& y;  // OK, non copyable nor movable\n};\n\nstruct ContainsBothNonCopyableAndNonMovable\n{\n  NonCopyable x;\n  NonMovable y;\n  int& z;  // OK, non copyable nor movable\n};\n\n// If copies are deleted and moves are not declared, moves are not implicitly declared,\n// so the class is also not movable and we should not warn\nstruct NonCopyableMovesNotDeclared\n{\n  NonCopyableMovesNotDeclared(NonCopyableMovesNotDeclared const&) = delete;\n  NonCopyableMovesNotDeclared& operator=(NonCopyableMovesNotDeclared const&) = delete;\n\n  int& x;  // OK, non copyable nor movable\n};\n\n// If moves are deleted but copies are not declared, copies are implicitly deleted,\n// so the class is also not copyable and we should not warn\nstruct NonMovableCopiesNotDeclared\n{\n  NonMovableCopiesNotDeclared(NonMovableCopiesNotDeclared&&) = delete;\n  NonMovableCopiesNotDeclared& operator=(NonMovableCopiesNotDeclared&&) = delete;\n\n  int& x;  // OK, non copyable nor movable\n};"
    }
  ]
}