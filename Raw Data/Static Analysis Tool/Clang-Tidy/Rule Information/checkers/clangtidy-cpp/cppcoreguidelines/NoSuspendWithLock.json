{
  "name": "NoSuspendWithLock",
  "language": "cpp",
  "description": ".. title:: clang-tidy - cppcoreguidelines-no-suspend-with-lock",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 73,
  "branches": 4,
  "apis": 46,
  "test": [
    {
      "description": null,
      "expected-problems": 22,
      "expected-linenumbers": [
        80,
        83,
        87,
        94,
        101,
        112,
        119,
        127,
        135,
        142,
        149,
        163,
        169,
        195,
        201,
        220,
        227,
        234,
        242,
        250,
        259,
        266
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++20 %s cppcoreguidelines-no-suspend-with-lock %t -- -- -fno-delayed-template-parsing -fexceptions\n\n// NOLINTBEGIN\nnamespace std {\ntemplate <typename T, typename... Args>\nstruct coroutine_traits {\n  using promise_type = typename T::promise_type;\n};\ntemplate <typename T = void>\nstruct coroutine_handle;\ntemplate <>\nstruct coroutine_handle<void> {\n  coroutine_handle() noexcept;\n  coroutine_handle(decltype(nullptr)) noexcept;\n  static constexpr coroutine_handle from_address(void*);\n};\ntemplate <typename T>\nstruct coroutine_handle {\n  coroutine_handle() noexcept;\n  coroutine_handle(decltype(nullptr)) noexcept;\n  static constexpr coroutine_handle from_address(void*);\n  operator coroutine_handle<>() const noexcept;\n};\n\ntemplate <class Mutex>\nclass unique_lock {\npublic:\n  unique_lock() noexcept;\n  explicit unique_lock(Mutex &m);\n  unique_lock& operator=(unique_lock&&);\n  void unlock();\n  Mutex* release() noexcept;\n  Mutex* mutex() const noexcept;\n  void swap(unique_lock& other) noexcept;\n};\n\nclass mutex {\npublic:\n  mutex() noexcept;\n  ~mutex();\n  mutex(const mutex &) = delete;\n  mutex &operator=(const mutex &) = delete;\n\n  void lock();\n  void unlock();\n};\n} // namespace std\n\nclass my_own_mutex {\npublic:\n  void lock();\n  void unlock();\n};\n\nstruct Awaiter {\n  bool await_ready() noexcept;\n  void await_suspend(std::coroutine_handle<>) noexcept;\n  void await_resume() noexcept;\n};\n\nstruct Coro {\n  struct promise_type {\n    Awaiter initial_suspend();\n    Awaiter final_suspend() noexcept;\n    void return_void();\n    Coro get_return_object();\n    void unhandled_exception();\n    Awaiter yield_value(int);\n  };\n};\n// NOLINTEND\n\nstd::mutex mtx;\nstd::mutex mtx2;\n\nCoro awaits_with_lock() {\n  std::unique_lock<std::mutex> lock(mtx);\n\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n\n  if (true) {\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  if (true) {\n    std::unique_lock<std::mutex> lock2;\n    lock2.unlock();\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock2' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n}\n\nCoro awaits_with_lock_in_try() try {\n  std::unique_lock<std::mutex> lock(mtx);\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n} catch (...) {}\n\nCoro lock_possibly_unlocked() {\n  // CppCoreGuideline CP.52's enforcement strictly requires flagging\n  // code that suspends while any lock guard is not destructed.\n\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n    lock.unlock();\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n    lock.release();\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n    std::unique_lock<std::mutex> lock2;\n    lock.swap(lock2);\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n    std::unique_lock<std::mutex> lock2{mtx2};\n    lock.swap(lock2);\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n    lock = std::unique_lock<std::mutex>{};\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n    lock = std::unique_lock<std::mutex>{mtx2};\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n}\n\nCoro await_with_underlying_mutex_unlocked() {\n  std::unique_lock<std::mutex> lock(mtx);\n\n  // Even though we unlock the mutex here, 'lock' is still active unless\n  // there is a call to lock.unlock(). This is a bug in the program since\n  // it will result in locking the mutex twice. The check does not track\n  // unlock calls on the underlying mutex held by a lock guard object.\n  mtx.unlock();\n\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\nCoro await_with_empty_lock() {\n  std::unique_lock<std::mutex> lock;\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\nCoro await_before_lock() {\n  co_await Awaiter{};\n  std::unique_lock<std::mutex> lock(mtx);\n}\n\nCoro await_with_lock_different_scope() {\n  {\n    std::unique_lock<std::mutex> lock(mtx);\n  }\n  co_await Awaiter{};\n}\n\nCoro await_with_goto() {\nfirst:\n  co_await Awaiter{};\n  std::unique_lock<std::mutex> lock(mtx);\n  goto first;\n}\n\nvoid await_in_lambda() {\n  auto f1 = []() -> Coro {\n    std::unique_lock<std::mutex> lock(mtx);\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  };\n\n  auto f2 = [](auto& m) -> Coro {\n    std::unique_lock<decltype(m)> lock(m);\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  };\n}\n\nvoid await_in_lambda_without_immediate_mutex() {\n  std::unique_lock<std::mutex> lock(mtx);\n\n  auto f1 = []() -> Coro {\n    co_await Awaiter{};\n  };\n\n  // The check only finds suspension points where there is a lock held in the\n  // immediate callable.\n  f1();\n}\n\nCoro yields_with_lock() {\n  std::unique_lock<std::mutex> lock(mtx);\n  co_yield 0;\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\ntemplate <class Mutex>\nCoro awaits_templated_type(Mutex& m) {\n  std::unique_lock<Mutex> lock(m);\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\ntemplate <class T>\nCoro awaits_in_template_function(T) {\n  std::unique_lock<std::mutex> lock(mtx);\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\ntemplate <class Mutex>\nCoro awaits_in_never_instantiated_template_of_mutex(Mutex& m) {\n  // Nothing should instantiate this function\n  std::unique_lock<Mutex> lock(m);\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\ntemplate <class T>\nCoro awaits_in_never_instantiated_templated_function(T) {\n  // Nothing should instantiate this function\n  std::unique_lock<std::mutex> lock(mtx);\n  co_await Awaiter{};\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n}\n\ntemplate <class T>\nstruct my_container {\n\n  Coro push_back() {\n    std::unique_lock<std::mutex> lock(mtx_);\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  template <class... Args>\n  Coro emplace_back(Args&&...) {\n    std::unique_lock<std::mutex> lock(mtx_);\n    co_await Awaiter{};\n    // CHECK-MESSAGES: [[@LINE-1]]:5: warning: coroutine suspended with lock 'lock' held [cppcoreguidelines-no-suspend-with-lock]\n  }\n\n  std::mutex mtx_;\n};\n\nvoid calls_templated_functions() {\n  my_own_mutex m2;\n  awaits_templated_type(mtx);\n  awaits_templated_type(m2);\n\n  awaits_in_template_function(1);\n  awaits_in_template_function(1.0);\n}"
    }
  ]
}