{
  "name": "OwningMemory",
  "language": "cpp",
  "description": ".. title:: clang-tidy - cppcoreguidelines-owning-memory",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 421,
  "branches": 18,
  "apis": 272,
  "test": [
    {
      "description": null,
      "expected-problems": 0,
      "expected-linenumbers": [],
      "code": "\n// RUN: %check_clang_tidy %s cppcoreguidelines-owning-memory %t\n\nnamespace gsl {\ntemplate <class T>\nusing owner = T;\n} // namespace gsl\n\ntemplate <typename T>\nclass unique_ptr {\npublic:\n  unique_ptr(gsl::owner<T> resource) : memory(resource) {}\n  unique_ptr(const unique_ptr<T> &) = default;\n\n  ~unique_ptr() { delete memory; }\n\nprivate:\n  gsl::owner<T> memory;\n};\n\nvoid takes_owner(gsl::owner<int *> owned_int) {\n}\n\nvoid takes_pointer(int *unowned_int) {\n}\n\nvoid takes_owner_and_more(int some_int, gsl::owner<int *> owned_int, float f) {\n}\n\ntemplate <typename T>\nvoid takes_templated_owner(gsl::owner<T> owned_T) {\n}\n\ngsl::owner<int *> returns_owner1() { return gsl::owner<int *>(new int(42)); } // Ok\ngsl::owner<int *> returns_owner2() { return new int(42); }                    // Ok\n\nint *returns_no_owner1() { return nullptr; }\nint *returns_no_owner2() {\n  return new int(42);\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: returning a newly created resource of type 'int *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'\n}\nint *returns_no_owner3() {\n  int *should_be_owner = new int(42);\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: initializing non-owner 'int *' with a newly created 'gsl::owner<>'\n  return should_be_owner;\n}\nint *returns_no_owner4() {\n  gsl::owner<int *> owner = new int(42);\n  return owner;\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: returning a newly created resource of type 'int *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'\n}\n\nunique_ptr<int *> returns_no_owner5() {\n  return unique_ptr<int *>(new int(42)); // Ok\n}\n\n/// FIXME: CSA finds it, but the report is misleading. Ownersemantics can catch this\n/// by flow analysis similar to bugprone-use-after-move.\nvoid csa_not_finding_leak() {\n  gsl::owner<int *> o1 = new int(42); // Ok\n\n  gsl::owner<int *> o2 = o1; // Ok\n  o2 = new int(45);          // conceptual leak, the memory from o1 is now leaked, since its considered moved in the guidelines\n\n  delete o2;\n  // actual leak occurs here, its found, but mixed\n  delete o1;\n}\n\nvoid test_assignment_and_initialization() {\n  int stack_int1 = 15;\n  int stack_int2;\n\n  gsl::owner<int *> owned_int1 = &stack_int1; // BAD\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected initialization with value of type 'gsl::owner<>'; got 'int *'\n\n  gsl::owner<int *> owned_int2;\n  owned_int2 = &stack_int2; // BAD since no owner, bad since uninitialized\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected assignment source to be of type 'gsl::owner<>'; got 'int *'\n\n  gsl::owner<int *> owned_int3 = new int(42); // Good\n  owned_int3 = nullptr;                       // Good\n\n  gsl::owner<int *> owned_int4(nullptr); // Ok\n  owned_int4 = new int(42);              // Good\n\n  gsl::owner<int *> owned_int5 = owned_int3; // Good\n\n  gsl::owner<int *> owned_int6{nullptr}; // Ok\n  owned_int6 = owned_int4;               // Good\n\n  // FIXME:, flow analysis for the case of reassignment. Value must be released before\n  owned_int6 = owned_int3; // BAD, because reassignment without resource release\n\n  auto owned_int7 = returns_owner1(); // Ok, since type deduction does not eliminate the owner wrapper\n\n  const auto owned_int8 = returns_owner2(); // Ok, since type deduction does not eliminate the owner wrapper\n\n  gsl::owner<int *> owned_int9 = returns_owner1(); // Ok\n  int *unowned_int3 = returns_owner1();            // Bad\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: initializing non-owner 'int *' with a newly created 'gsl::owner<>'\n\n  gsl::owner<int *> owned_int10;\n  owned_int10 = returns_owner1(); // Ok\n\n  int *unowned_int4;\n  unowned_int4 = returns_owner1(); // Bad\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: assigning newly created 'gsl::owner<>' to non-owner 'int *'\n\n  gsl::owner<int *> owned_int11 = returns_no_owner1(); // Bad since no owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected initialization with value of type 'gsl::owner<>'; got 'int *'\n\n  gsl::owner<int *> owned_int12;\n  owned_int12 = returns_no_owner1(); // Bad since no owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected assignment source to be of type 'gsl::owner<>'; got 'int *'\n\n  int *unowned_int5 = returns_no_owner1(); // Ok\n  int *unowned_int6;\n  unowned_int6 = returns_no_owner1(); // Ok\n\n  int *unowned_int7 = new int(42); // Bad, since resource not assigned to an owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: initializing non-owner 'int *' with a newly created 'gsl::owner<>'\n\n  int *unowned_int8;\n  unowned_int8 = new int(42);\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: assigning newly created 'gsl::owner<>' to non-owner 'int *'\n\n  gsl::owner<int *> owned_int13 = nullptr; // Ok\n}\n\nvoid test_deletion() {\n  gsl::owner<int *> owned_int1 = new int(42);\n  delete owned_int1; // Good\n\n  gsl::owner<int *> owned_int2 = new int[42];\n  delete[] owned_int2; // Good\n\n  int *unowned_int1 = new int(42); // BAD, since new creates and owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: initializing non-owner 'int *' with a newly created 'gsl::owner<>'\n  delete unowned_int1; // BAD, since no owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: deleting a pointer through a type that is not marked 'gsl::owner<>'; consider using a smart pointer instead\n  // CHECK-NOTES: [[@LINE-4]]:3: note: variable declared here\n\n  int *unowned_int2 = new int[42]; // BAD, since new creates and owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: initializing non-owner 'int *' with a newly created 'gsl::owner<>'\n  delete[] unowned_int2; // BAD since no owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: deleting a pointer through a type that is not marked 'gsl::owner<>'; consider using a smart pointer instead\n  // CHECK-NOTES: [[@LINE-4]]:3: note: variable declared here\n\n  delete new int(42);   // Technically ok, but stupid\n  delete[] new int[42]; // Technically ok, but stupid\n}\n\nvoid test_owner_function_calls() {\n  int stack_int = 42;\n  int *unowned_int1 = &stack_int;\n  takes_owner(&stack_int); // BAD\n  // CHECK-NOTES: [[@LINE-1]]:15: warning: expected argument of type 'gsl::owner<>'; got 'int *'\n  takes_owner(unowned_int1); // BAD\n  // CHECK-NOTES: [[@LINE-1]]:15: warning: expected argument of type 'gsl::owner<>'; got 'int *'\n\n  gsl::owner<int *> owned_int1 = new int(42);\n  takes_owner(owned_int1); // Ok\n\n  takes_owner_and_more(42, &stack_int, 42.0f); // BAD\n  // CHECK-NOTES: [[@LINE-1]]:28: warning: expected argument of type 'gsl::owner<>'; got 'int *'\n  takes_owner_and_more(42, unowned_int1, 42.0f); // BAD\n  // CHECK-NOTES: [[@LINE-1]]:28: warning: expected argument of type 'gsl::owner<>'; got 'int *'\n\n  takes_owner_and_more(42, new int(42), 42.0f); // Ok, since new is consumed by owner\n  takes_owner_and_more(42, owned_int1, 42.0f);  // Ok, since owner as argument\n\n  takes_templated_owner(owned_int1);   // Ok\n  takes_templated_owner(new int(42));  // Ok\n  takes_templated_owner(unowned_int1); // Bad\n  // CHECK-NOTES: [[@LINE-1]]:25: warning: expected argument of type 'gsl::owner<>'; got 'int *'\n\n  takes_owner(returns_owner1());    // Ok\n  takes_owner(returns_no_owner1()); // BAD\n  // CHECK-NOTES: [[@LINE-1]]:15: warning: expected argument of type 'gsl::owner<>'; got 'int *'\n}\n\nvoid test_unowned_function_calls() {\n  int stack_int = 42;\n  int *unowned_int1 = &stack_int;\n  gsl::owner<int *> owned_int1 = new int(42);\n\n  takes_pointer(&stack_int);   // Ok\n  takes_pointer(unowned_int1); // Ok\n  takes_pointer(owned_int1);   // Ok\n  takes_pointer(new int(42));  // Bad, since new creates and owner\n  // CHECK-NOTES: [[@LINE-1]]:17: warning: initializing non-owner argument of type 'int *' with a newly created 'gsl::owner<>'\n\n  takes_pointer(returns_owner1()); // Bad\n  // CHECK-NOTES: [[@LINE-1]]:17: warning: initializing non-owner argument of type 'int *' with a newly created 'gsl::owner<>'\n\n  takes_pointer(returns_no_owner1()); // Ok\n}\n\n// FIXME: Typedefing owner<> to something else does not work.\n// This might be necessary for code already having a similar typedef like owner<> and\n// replacing it with owner<>. This might be the same problem as with templates.\n// The canonical type will ignore the owner<> alias, since its a typedef as well.\n//\n// Check, if owners hidden by typedef are handled the same as 'obvious' owners.\n#if 0\nusing heap_int = gsl::owner<int *>;\ntypedef gsl::owner<float *> heap_float;\n\n// This tests only a subset, assuming that the check will either see through the\n// typedef or not (it doesn't!).\nvoid test_typedefed_values() {\n  // Modern typedef.\n  int StackInt1 = 42;\n  heap_int HeapInt1 = &StackInt1;\n  // CHECK MESSAGES: [[@LINE-1]]:3: warning: expected assignment source to be of type 'gsl::owner<>'; got 'int *'\n\n  //FIXME: Typedef not considered correctly here.\n  // heap_int HeapInt2 = new int(42); // Ok\n  takes_pointer(HeapInt1); // Ok\n  takes_owner(HeapInt1);   // Ok\n\n  // Traditional typedef.\n  float StackFloat1 = 42.0f;\n  heap_float HeapFloat1 = &StackFloat1;\n  // CHECK MESSAGES: [[@LINE-1]]:3: warning: expected assignment source to be of type 'gsl::owner<>'; got 'float *'\n\n  //FIXME: Typedef not considered correctly here.\n  // heap_float HeapFloat2 = new float(42.0f);\n  HeapFloat2 = HeapFloat1; // Ok\n}\n#endif\n\nstruct ArbitraryClass {};\nstruct ClassWithOwner {                    // Does not define destructor, necessary with owner\n  ClassWithOwner() : owner_var(nullptr) {} // Ok\n\n  ClassWithOwner(ArbitraryClass &other) : owner_var(&other) {}\n  // CHECK-NOTES: [[@LINE-1]]:43: warning: expected initialization of owner member variable with value of type 'gsl::owner<>'; got 'ArbitraryClass *'\n\n  ClassWithOwner(gsl::owner<ArbitraryClass *> other) : owner_var(other) {} // Ok\n\n  ClassWithOwner(gsl::owner<ArbitraryClass *> data, int /* unused */) { // Ok\n    owner_var = data;                                                   // Ok\n  }\n\n  ClassWithOwner(ArbitraryClass *bad_data, int /* unused */, int /* unused */) {\n    owner_var = bad_data;\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: expected assignment source to be of type 'gsl::owner<>'; got 'ArbitraryClass *'\n  }\n\n  ClassWithOwner(ClassWithOwner &&other) : owner_var{other.owner_var} {} // Ok\n\n  ClassWithOwner &operator=(ClassWithOwner &&other) {\n    owner_var = other.owner_var; // Ok\n    return *this;\n  }\n\n  // Returning means, that the owner is \"moved\", so the class should not access this\n  // variable anymore after this method gets called.\n  gsl::owner<ArbitraryClass *> buggy_but_returns_owner() { return owner_var; }\n\n  gsl::owner<ArbitraryClass *> owner_var;\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: member variable of type 'gsl::owner<>' requires the class 'ClassWithOwner' to implement a destructor to release the owned resource\n};\n\nclass DefaultedDestructor {         // Bad since default constructor with owner\n  ~DefaultedDestructor() = default; // Bad, since will not destroy the owner\n  gsl::owner<int *> Owner;\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: member variable of type 'gsl::owner<>' requires the class 'DefaultedDestructor' to implement a destructor to release the owned resource\n};\n\nstruct DeletedDestructor {\n  ~DeletedDestructor() = delete;\n  gsl::owner<int *> Owner;\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: member variable of type 'gsl::owner<>' requires the class 'DeletedDestructor' to implement a destructor to release the owned resource\n};\n\nvoid test_class_with_owner() {\n  ArbitraryClass A;\n  ClassWithOwner C1;                                                   // Ok\n  ClassWithOwner C2{A};                                                // Bad, since the owner would be initialized with an non-owner, but catched in the class\n  ClassWithOwner C3{gsl::owner<ArbitraryClass *>(new ArbitraryClass)}; // Ok\n\n  const auto Owner1 = C3.buggy_but_returns_owner(); // Ok, deduces Owner1 to owner<ArbitraryClass *> const\n\n  auto Owner2 = C2.buggy_but_returns_owner(); // Ok, deduces Owner2 to owner<ArbitraryClass *>\n\n  Owner2 = &A; // BAD, since type deduction resulted in owner<ArbitraryClass *>\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected assignment source to be of type 'gsl::owner<>'; got 'ArbitraryClass *'\n\n  gsl::owner<ArbitraryClass *> Owner3 = C1.buggy_but_returns_owner(); // Ok, still an owner\n  Owner3 = &A;                                                        // Bad, since assignment of non-owner to owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected assignment source to be of type 'gsl::owner<>'; got 'ArbitraryClass *'\n}\n\ntemplate <typename T>\nstruct HeapArray {                                          // Ok, since destructor with owner\n  HeapArray() : _data(nullptr), size(0) {}                  // Ok\n  HeapArray(int size) : _data(new int[size]), size(size) {} // Ok\n  HeapArray(int size, T val) {\n    _data = new int[size]; // Ok\n    size = size;\n    for (auto i = 0u; i < size; ++i)\n      _data[i] = val; // Ok\n  }\n  HeapArray(int size, T val, int *problematic) : _data{problematic}, size(size) {} // Bad\n  // CHECK-NOTES: [[@LINE-1]]:50: warning: expected initialization of owner member variable with value of type 'gsl::owner<>'; got 'void'\n  // FIXME: void is incorrect type, probably wrong thing matched\n\n  HeapArray(HeapArray &&other) : _data(other._data), size(other.size) { // Ok\n    other._data = nullptr;                                              // Ok\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: expected assignment source to be of type 'gsl::owner<>'; got 'std::nullptr_t'\n    // FIXME: This warning is emitted because an ImplicitCastExpr for the NullToPointer conversion isn't created for dependent types.\n    other.size = 0;\n  }\n\n  HeapArray<T> &operator=(HeapArray<T> &&other) {\n    _data = other._data; // Ok, NOLINT warning here about bad types, why?\n    size = other.size;\n    return *this;\n  }\n\n  ~HeapArray() { delete[] _data; } // Ok\n\n  T *data() { return _data; } // Ok NOLINT, because it \"looks\" like a factory\n\n  gsl::owner<T *> _data;\n  unsigned int size;\n};\n\nvoid test_inner_template() {\n  HeapArray<int> Array1;\n  HeapArray<int> Array2(100);\n  HeapArray<int> Array3(100, 0);\n  HeapArray<int> Array4(100, 0, nullptr);\n\n  Array1 = static_cast<HeapArray<int> &&>(Array2);\n  HeapArray<int> Array5(static_cast<HeapArray<int> &&>(Array3));\n\n  int *NonOwningPtr = Array1.data();           // Ok\n  gsl::owner<int *> OwningPtr = Array1.data(); // Bad, since it does not return the owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected initialization with value of type 'gsl::owner<>'; got 'int *'\n}\n\n// FIXME: Typededuction removes the owner - wrapper, therefore gsl::owner can not be used\n// with Template classes like this. Is there a walkaround?\ntemplate <typename T>\nstruct TemplateValue {\n  TemplateValue() = default;\n  TemplateValue(T t) : val{t} {}\n\n  void setVal(const T &t) { val = t; }\n  const T getVal() const { return val; }\n\n  T val;\n};\n\n// FIXME: Same typededcution problems\ntemplate <typename T>\nvoid template_function(T t) {\n  gsl::owner<int *> owner_t = t; // Probably bad, since type deduction still wrong\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected initialization with value of type 'gsl::owner<>'; got 'T'\n  // CHECK-NOTES: [[@LINE-2]]:3: warning: expected initialization with value of type 'gsl::owner<>'; got 'int *'\n}\n\n// FIXME: Same typededcution problems\nvoid test_templates() {\n  int stack_int = 42;\n  int *stack_ptr1 = &stack_int;\n\n  TemplateValue<gsl::owner<int *>> Owner0; // Ok, T should be owner, but is int*\n\n  TemplateValue<gsl::owner<int *>> Owner1(new int(42)); // Ok, T should be owner, but is int*\n  Owner1.setVal(&stack_int);                            // Bad since non-owner assignment\n  Owner1.setVal(stack_ptr1);                            // Bad since non-owner assignment\n  //Owner1.setVal(new int(42)); // Ok, but since type deduction is wrong, this one is considered harmful\n\n  int *stack_ptr2 = Owner1.getVal(); // Bad, initializing non-owner with owner\n\n  TemplateValue<int *> NonOwner1(new int(42));      // Bad, T is int *, hence dynamic memory to non-owner\n  gsl::owner<int *> IntOwner1 = NonOwner1.getVal(); // Bad, since owner initialized with non-owner\n  // CHECK-NOTES: [[@LINE-1]]:3: warning: expected initialization with value of type 'gsl::owner<>'; got 'int *'\n\n  template_function(IntOwner1);  // Ok, but not actually ok, since type deduction removes owner\n  template_function(stack_ptr1); // Bad, but type deduction gets it wrong\n}\n\nnamespace PR63994 {\n  struct A {\n    virtual ~A() {}\n  };\n\n  struct B : public A {};\n\n  A* foo(int x) {\n    return new B;\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: returning a newly created resource of type 'A *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'\n  }\n}\n\nnamespace PR59389 {\n  struct S {\n    S();\n    S(int);\n\n    int value = 1;\n  };\n\n  void testLambdaInFunctionNegative() {\n    const auto MakeS = []() -> ::gsl::owner<S*> {\n      return ::gsl::owner<S*>{new S{}};\n    };\n  }\n\n  void testLambdaInFunctionPositive() {\n    const auto MakeS = []() -> S* {\n      return ::gsl::owner<S*>{new S{}};\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a lambda whose return type is not 'gsl::owner<>'\n    };\n  }\n\n  void testFunctionInFunctionNegative() {\n    struct C {\n      ::gsl::owner<S*> test() {\n        return ::gsl::owner<S*>{new S{}};\n      }\n    };\n  }\n\n  void testFunctionInFunctionPositive() {\n    struct C {\n      S* test() {\n        return ::gsl::owner<S*>{new S{}};\n        // CHECK-NOTES: [[@LINE-1]]:9: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'\n      }\n    };\n  }\n\n  ::gsl::owner<S*> testReverseLambdaNegative() {\n    const auto MakeI = [] -> int { return 5; };\n    return ::gsl::owner<S*>{new S(MakeI())};\n  }\n\n  S* testReverseLambdaPositive() {\n    const auto MakeI = [] -> int { return 5; };\n    return ::gsl::owner<S*>{new S(MakeI())};\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'\n  }\n\n  ::gsl::owner<S*> testReverseFunctionNegative() {\n    struct C {\n      int test() { return 5; }\n    };\n    return ::gsl::owner<S*>{new S(C().test())};\n  }\n\n  S* testReverseFunctionPositive() {\n    struct C {\n      int test() { return 5; }\n    };\n    return ::gsl::owner<S*>{new S(C().test())};\n    // CHECK-NOTES: [[@LINE-1]]:5: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a function whose return type is not 'gsl::owner<>'\n  }\n\n  void testLambdaInLambdaNegative() {\n    const auto MakeS = []() -> ::gsl::owner<S*> {\n      const auto MakeI = []() -> int { return 5; };\n      return ::gsl::owner<S*>{new S(MakeI())};\n    };\n  }\n\n  void testLambdaInLambdaPositive() {\n    const auto MakeS = []() -> S* {\n      const auto MakeI = []() -> int { return 5; };\n      return ::gsl::owner<S*>{new S(MakeI())};\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a lambda whose return type is not 'gsl::owner<>'\n    };\n  }\n\n  void testLambdaInLambdaWithDoubleReturns() {\n    const auto MakeS = []() -> S* {\n      const auto MakeS2 = []() -> S* {\n        return ::gsl::owner<S*>{new S(1)};\n        // CHECK-NOTES: [[@LINE-1]]:9: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a lambda whose return type is not 'gsl::owner<>' [cppcoreguidelines-owning-memory]\n      };\n      return ::gsl::owner<S*>{new S(2)};\n      // CHECK-NOTES: [[@LINE-1]]:7: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a lambda whose return type is not 'gsl::owner<>'\n    };\n  }\n\n  void testReverseLambdaInLambdaNegative() {\n    const auto MakeI = []() -> int {\n      const auto MakeS = []() -> ::gsl::owner<S*> { return new S(); };\n      return 5;\n    };\n  }\n\n  void testReverseLambdaInLambdaPositive() {\n    const auto MakeI = []() -> int {\n      const auto MakeS = []() -> S* { return new S(); };\n      // CHECK-NOTES: [[@LINE-1]]:39: warning: returning a newly created resource of type 'S *' or 'gsl::owner<>' from a lambda whose return type is not 'gsl::owner<>'\n      return 5;\n    };\n  }\n}"
    }
  ]
}