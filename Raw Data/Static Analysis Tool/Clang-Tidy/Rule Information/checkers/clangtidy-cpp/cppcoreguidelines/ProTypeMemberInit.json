{
  "name": "ProTypeMemberInit",
  "language": "cpp",
  "description": ".. title:: clang-tidy - cppcoreguidelines-pro-type-member-init",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 585,
  "branches": 116,
  "apis": 392,
  "test": [
    {
      "description": null,
      "expected-problems": 38,
      "expected-linenumbers": [
        8,
        14,
        30,
        35,
        47,
        111,
        113,
        122,
        134,
        146,
        174,
        182,
        203,
        206,
        209,
        221,
        228,
        229,
        234,
        238,
        271,
        286,
        305,
        318,
        330,
        385,
        394,
        401,
        409,
        410,
        417,
        435,
        437,
        468,
        511,
        515,
        532,
        567
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes -std=c++11,c++14,c++17 %s cppcoreguidelines-pro-type-member-init %t -- -- -fno-delayed-template-parsing\n// FIXME: Fix the checker to work in C++20 mode.\n\nstruct PositiveFieldBeforeConstructor {\n  int F;\n  // CHECK-FIXES: int F{};\n  PositiveFieldBeforeConstructor() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: F\n  // CHECK-FIXES: PositiveFieldBeforeConstructor() {}\n};\n\nstruct PositiveFieldAfterConstructor {\n  PositiveFieldAfterConstructor() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: F, G\n  // CHECK-FIXES: PositiveFieldAfterConstructor() {}\n  int F;\n  // CHECK-FIXES: int F{};\n  bool G /* with comment */;\n  // CHECK-FIXES: bool G{} /* with comment */;\n  PositiveFieldBeforeConstructor IgnoredField;\n};\n\nstruct PositiveSeparateDefinition {\n  PositiveSeparateDefinition();\n  int F;\n  // CHECK-FIXES: int F{};\n};\n\nPositiveSeparateDefinition::PositiveSeparateDefinition() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: constructor does not initialize these fields: F\n// CHECK-FIXES: PositiveSeparateDefinition::PositiveSeparateDefinition() {}\n\nstruct PositiveMixedFieldOrder {\n  PositiveMixedFieldOrder() : J(0) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: I, K\n  // CHECK-FIXES: PositiveMixedFieldOrder() : J(0) {}\n  int I;\n  // CHECK-FIXES: int I{};\n  int J;\n  int K;\n  // CHECK-FIXES: int K{};\n};\n\ntemplate <typename T>\nstruct Template {\n  Template() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: F\n  int F;\n  // CHECK-FIXES: int F{};\n  T T1;\n  // CHECK-FIXES: T T1;\n};\n\nvoid instantiate() {\n  Template<int> TInt;\n}\n\nstruct NegativeFieldInitialized {\n  int F;\n\n  NegativeFieldInitialized() : F() {}\n};\n\nstruct NegativeFieldInitializedInDefinition {\n  int F;\n\n  NegativeFieldInitializedInDefinition();\n};\nNegativeFieldInitializedInDefinition::NegativeFieldInitializedInDefinition() : F() {}\n\nstruct NegativeInClassInitialized {\n  int F = 0;\n\n  NegativeInClassInitialized() {}\n};\n\nstruct NegativeInClassInitializedDefaulted {\n  int F = 0;\n  NegativeInClassInitializedDefaulted() = default;\n};\n\nstruct NegativeConstructorDelegated {\n  int F;\n\n  NegativeConstructorDelegated(int F) : F(F) {}\n  NegativeConstructorDelegated() : NegativeConstructorDelegated(0) {}\n};\n\nstruct NegativeInitializedInBody {\n  NegativeInitializedInBody() { I = 0; }\n  int I;\n};\n\nstruct A {};\ntemplate <class> class AA;\ntemplate <class T> class NegativeTemplateConstructor {\n  NegativeTemplateConstructor(const AA<T> &, A) {}\n  bool Bool{false};\n  // CHECK-FIXES: bool Bool{false};\n};\n\n#define UNINITIALIZED_FIELD_IN_MACRO_BODY(FIELD) \\\n  struct UninitializedField##FIELD {             \\\n    UninitializedField##FIELD() {}               \\\n    int FIELD;                                   \\\n  };                                             \\\n// Ensure FIELD is not initialized since fixes inside of macros are disabled.\n// CHECK-FIXES: int FIELD;\n\nUNINITIALIZED_FIELD_IN_MACRO_BODY(F);\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: constructor does not initialize these fields: F\nUNINITIALIZED_FIELD_IN_MACRO_BODY(G);\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: constructor does not initialize these fields: G\n\n#define UNINITIALIZED_FIELD_IN_MACRO_ARGUMENT(ARGUMENT) \\\n  ARGUMENT\n\nUNINITIALIZED_FIELD_IN_MACRO_ARGUMENT(struct UninitializedFieldInMacroArg {\n  UninitializedFieldInMacroArg() {}\n  int Field;\n});\n// CHECK-MESSAGES: :[[@LINE-3]]:3: warning: constructor does not initialize these fields: Field\n// Ensure FIELD is not initialized since fixes inside of macros are disabled.\n// CHECK-FIXES: int Field;\n\nstruct NegativeAggregateType {\n  int X;\n  int Y;\n  int Z;\n};\n\nstruct PositiveTrivialType {\n  PositiveTrivialType() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: F\n\n  NegativeAggregateType F;\n  // CHECK-FIXES: NegativeAggregateType F{};\n};\n\nstruct NegativeNonTrivialType {\n  PositiveTrivialType F;\n};\n\nstatic void PositiveUninitializedTrivialType() {\n  NegativeAggregateType X;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: uninitialized record type: 'X'\n  // CHECK-FIXES: NegativeAggregateType X{};\n\n  NegativeAggregateType A[10]; // Don't warn because this isn't an object type.\n}\n\nstatic void NegativeInitializedTrivialType() {\n  NegativeAggregateType X{};\n  NegativeAggregateType Y = {};\n  NegativeAggregateType Z = NegativeAggregateType();\n  NegativeAggregateType A[10]{};\n  NegativeAggregateType B[10] = {};\n  int C; // No need to initialize this because we don't have a constructor.\n  int D[8];\n  NegativeAggregateType E = {0, 1, 2};\n  NegativeAggregateType F({});\n}\n\nstruct NonTrivialType {\n  NonTrivialType() = default;\n  NonTrivialType(const NonTrivialType &RHS) : X(RHS.X), Y(RHS.Y) {}\n\n  int X;\n  int Y;\n};\n\nstatic void PositiveNonTrivialTypeWithCopyConstructor() {\n  NonTrivialType T;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: uninitialized record type: 'T'\n  // CHECK-FIXES: NonTrivialType T{};\n\n  NonTrivialType A[8];\n  // Don't warn because this isn't an object type\n}\n\nstruct ComplexNonTrivialType {\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: constructor does not initialize these fields: Y\n  NegativeFieldInitialized X;\n  int Y;\n  // CHECK-FIXES: int Y{};\n};\n\nstatic void PositiveComplexNonTrivialType() {\n  ComplexNonTrivialType T;\n}\n\nstruct NegativeStaticMember {\n  static NonTrivialType X;\n  static NonTrivialType Y;\n  static constexpr NonTrivialType Z{};\n};\n\nNonTrivialType NegativeStaticMember::X;\nNonTrivialType NegativeStaticMember::Y{};\n\nstruct PositiveMultipleConstructors {\n  PositiveMultipleConstructors() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: A, B\n\n  PositiveMultipleConstructors(int) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: A, B\n\n  PositiveMultipleConstructors(const PositiveMultipleConstructors &) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: A, B\n\n  int A, B;\n  // CHECK-FIXES: int A{}, B{};\n};\n\ntypedef struct {\n  int Member;\n} CStyleStruct;\n\nstruct PositiveUninitializedBase : public NegativeAggregateType, CStyleStruct {\n  PositiveUninitializedBase() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these bases: NegativeAggregateType, CStyleStruct\n  // CHECK-FIXES: PositiveUninitializedBase() : NegativeAggregateType(), CStyleStruct() {}\n};\n\nstruct PositiveUninitializedBaseOrdering : public NegativeAggregateType,\n                                           public NonTrivialType {\n  PositiveUninitializedBaseOrdering() : B() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these bases: NegativeAggregateType, NonTrivialType\n  // CHECK-MESSAGES: :[[@LINE-2]]:3: warning: constructor does not initialize these fields: A\n  // CHECK-FIXES: PositiveUninitializedBaseOrdering() : NegativeAggregateType(), NonTrivialType(), B() {}\n\n  // This is somewhat pathological with the base class initializer at the end...\n  PositiveUninitializedBaseOrdering(int) : B(), NonTrivialType(), A() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these bases: NegativeAggregateType\n  // CHECK-FIXES: PositiveUninitializedBaseOrdering(int) : B(), NegativeAggregateType(), NonTrivialType(), A() {}\n\n  PositiveUninitializedBaseOrdering(float) : B(), NegativeAggregateType(), A() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these bases: NonTrivialType\n  // CHECK-FIXES: PositiveUninitializedBaseOrdering(float) : B(), NegativeAggregateType(), NonTrivialType(), A() {}\n\n  int A, B;\n  // CHECK-FIXES: int A{}, B;\n};\n\n// We shouldn't need to initialize anything because PositiveUninitializedBase\n// has a user-provided constructor.\nstruct NegativeUninitializedBase : public PositiveUninitializedBase {\n  NegativeUninitializedBase() {}\n};\n\nstruct InheritedAggregate : public NegativeAggregateType {\n  int F;\n};\n\nstatic InheritedAggregate NegativeGlobal;\n\nenum TestEnum {\n  A,\n  B,\n  C\n};\n\nenum class TestScopedEnum {\n  A,\n  B,\n  C\n};\n\nstruct PositiveEnumType {\n  PositiveEnumType() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: X, Y\n  // No proposed fixes, as we don't know whether value initialization for these\n  // enums really makes sense.\n\n  TestEnum X;\n  TestScopedEnum Y;\n};\n\nextern \"C\" {\nstruct NegativeCStruct {\n  int X, Y, Z;\n};\n\nstatic void PositiveCStructVariable() {\n  NegativeCStruct X;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: uninitialized record type: 'X'\n  // CHECK-FIXES: NegativeCStruct X{};\n}\n}\n\nstatic void NegativeStaticVariable() {\n  static NegativeCStruct S;\n  (void)S;\n}\n\nunion NegativeUnionInClass {\n  NegativeUnionInClass() {} // No message as a union can only initialize one member.\n  int X = 0;\n  float Y;\n};\n\nunion PositiveUnion {\n  PositiveUnion() : X() {} // No message as a union can only initialize one member.\n  PositiveUnion(int) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: union constructor should initialize one of these fields: X, Y\n\n  int X;\n  // CHECK-FIXES: int X{};\n\n  // Make sure we don't give Y an initializer.\n  float Y;\n  // CHECK-FIXES-NOT: float Y{};\n};\n\nunion PositiveUnionReversed {\n  PositiveUnionReversed() : X() {} // No message as a union can only initialize one member.\n  PositiveUnionReversed(int) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: union constructor should initialize one of these fields: Y, X\n\n  // Make sure we don't give Y an initializer.\n  TestEnum Y;\n  // CHECK-FIXES-NOT: TestEnum Y{};\n\n  int X;\n  // CHECK-FIXES: int X{};\n};\n\nstruct PositiveAnonymousUnionAndStruct {\n  PositiveAnonymousUnionAndStruct() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: A, B, Y, Z, C, D, E, F, X\n\n  union {\n    int A;\n    // CHECK-FIXES: int A{};\n    short B;\n  };\n\n  struct {\n    int Y;\n    // CHECK-FIXES: int Y{};\n    char *Z;\n    // CHECK-FIXES: char *Z{};\n\n    struct {\n      short C;\n      // CHECK-FIXES: short C{};\n      double D;\n      // CHECK-FIXES: double D{};\n    };\n\n    union {\n      long E;\n      // CHECK-FIXES: long E{};\n      float F;\n    };\n  };\n  int X;\n  // CHECK-FIXES: int X{};\n};\n\n// This check results in a CXXConstructorDecl with no body.\nstruct NegativeDeletedConstructor : NegativeAggregateType {\n  NegativeDeletedConstructor() = delete;\n\n  Template<int> F;\n};\n\n// This pathological template fails to compile if actually instantiated. It\n// results in the check seeing a null RecordDecl when examining the base class\n// initializer list.\ntemplate <typename T>\nclass PositiveSelfInitialization : NegativeAggregateType\n{\n  PositiveSelfInitialization() : PositiveSelfInitialization() {}\n  // This will be detected by -Wdelegating-ctor-cycles and there is no proper way to fix this\n};\n\nclass PositiveIndirectMember {\n  struct {\n    int *A;\n    // CHECK-FIXES: int *A{};\n  };\n\n  PositiveIndirectMember() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: A\n};\n\nvoid Bug30487()\n{\n  NegativeInClassInitializedDefaulted s;\n}\n\nstruct PositiveVirtualMethod {\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: constructor does not initialize these fields: F\n  int F;\n  // CHECK-FIXES: int F{};\n  virtual int f() = 0;\n};\n\nstruct PositiveVirtualDestructor {\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: constructor does not initialize these fields: F\n  PositiveVirtualDestructor() = default;\n  int F;\n  // CHECK-FIXES: int F{};\n  virtual ~PositiveVirtualDestructor() {}\n};\n\nstruct PositiveVirtualBase : public virtual NegativeAggregateType {\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: constructor does not initialize these bases: NegativeAggregateType\n  // CHECK-MESSAGES: :[[@LINE-2]]:8: warning: constructor does not initialize these fields: F\n  int F;\n  // CHECK-FIXES: int F{};\n};\n\ntemplate <typename T>\nstruct PositiveTemplateVirtualDestructor {\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: constructor does not initialize these fields: F\n  T Val;\n  int F;\n  // CHECK-FIXES: int F{};\n  virtual ~PositiveTemplateVirtualDestructor() = default;\n};\n\ntemplate struct PositiveTemplateVirtualDestructor<int>;\n\n#define UNINITIALIZED_FIELD_IN_MACRO_BODY_VIRTUAL(FIELD) \\\n  struct UninitializedFieldVirtual##FIELD {              \\\n    int FIELD;                                           \\\n    virtual ~UninitializedFieldVirtual##FIELD() {}       \\\n  };                                                     \\\n// Ensure FIELD is not initialized since fixes inside of macros are disabled.\n// CHECK-FIXES: int FIELD;\n\nUNINITIALIZED_FIELD_IN_MACRO_BODY_VIRTUAL(F);\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: constructor does not initialize these fields: F\nUNINITIALIZED_FIELD_IN_MACRO_BODY_VIRTUAL(G);\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: constructor does not initialize these fields: G\n\nstruct NegativeEmpty {\n};\n\nstatic void NegativeEmptyVar() {\n  NegativeEmpty e;\n  (void)e;\n}\n\nstruct NegativeEmptyMember {\n  NegativeEmptyMember() {}\n  NegativeEmpty e;\n};\n\nstruct NegativeEmptyBase : NegativeEmpty {\n  NegativeEmptyBase() {}\n};\n\nstruct NegativeEmptyArrayMember {\n  NegativeEmptyArrayMember() {}\n  char e[0];\n};\n\nstruct NegativeIncompleteArrayMember {\n  NegativeIncompleteArrayMember() {}\n  char e[];\n};\n\nstruct PositiveBitfieldMember {\n  PositiveBitfieldMember() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: F\n  unsigned F : 5;\n  // CHECK-FIXES-NOT: unsigned F : 5{};\n};\n\nstruct NegativeUnnamedBitfieldMember {\n  NegativeUnnamedBitfieldMember() {}\n  unsigned : 5;\n};\n\nstruct NegativeInitializedBitfieldMembers {\n  NegativeInitializedBitfieldMembers() : F(3) { G = 2; }\n  unsigned F : 5;\n  unsigned G : 5;\n};\n\nstruct NegativeImplicitInheritedCtorBase {\n  NegativeImplicitInheritedCtorBase(unsigned F) : F(F) {}\n  unsigned F;\n};\n\nstruct NegativeImplicitInheritedCtor : NegativeImplicitInheritedCtorBase {\n  using NegativeImplicitInheritedCtorBase::NegativeImplicitInheritedCtorBase;\n};\n\nvoid Bug33557() {\n  NegativeImplicitInheritedCtor I(5);\n}\n\nstruct NegativeDefaultedCtorOutOfDecl {\n  NegativeDefaultedCtorOutOfDecl(const NegativeDefaultedCtorOutOfDecl &);\n  int F;\n};\n\nNegativeDefaultedCtorOutOfDecl::NegativeDefaultedCtorOutOfDecl(const NegativeDefaultedCtorOutOfDecl &) = default;\n\nstruct PositiveDefaultConstructorOutOfDecl {\n  PositiveDefaultConstructorOutOfDecl();\n  int F;\n  // CHECK-FIXES: int F{};\n};\n\nPositiveDefaultConstructorOutOfDecl::PositiveDefaultConstructorOutOfDecl() = default;\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: constructor does not initialize these fields: F\n\nunion U1 {\n  U1() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: union constructor should initialize one of these fields: X, K, Z, Y\n  int X;\n  // CHECK-FIXES: int X{};\n  union {\n    int K;\n    // CHECK-FIXES-NOT: int K{};\n  };\n  union {\n    int Z;\n    // CHECK-FIXES-NOT: int Z{};\n    int Y;\n    // CHECK-FIXES-NOT: int Y{};\n  };\n};\n\nunion U2 {\n  U2() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: union constructor should initialize one of these fields: B, C, A\n  struct {\n    int B;\n    // CHECK-FIXES: int B{};\n    union {\n      struct {\n        PositiveMultipleConstructors Value;\n        // CHECK-FIXES-NOT: PositiveMultipleConstructors Value{};\n      };\n      int C;\n      // CHECK-FIXES: int C{};\n    };\n  };\n  int A;\n  // CHECK-FIXES-NOT: int A{};\n};\n\nstruct S1 {\n  S1() {}\n  union {\n    int a = 0;\n    int b;\n  };\n};\n\nstruct S2 {\n  S2() : a{} {}\n  union {\n    int a;\n    int b;\n  };\n};\n\nstruct S3 {\n  S3() {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: constructor does not initialize these fields: A [cppcoreguidelines-pro-type-member-init]\n  int A;\n  // CHECK-FIXES: int A{};\n  union {\n    int B;\n    int C = 0;\n  };\n};\n\n// Ignore issues from delegate constructors\nnamespace PR37250 {\n  template <typename T>\n  struct A {\n    A() : A(42) {}\n    explicit A(int value) : value_(value) {}\n    int value_;\n  };\n\n  struct B {\n    B() : B(42) {}\n    explicit B(int value) : value_(value) {}\n    int value_;\n  };\n\n  template <typename T>\n  struct C {\n    C() : C(T()) {}\n    explicit C(T value) : value_(value) {}\n    T value_;\n  };\n\n  struct V {\n    unsigned size() const;\n  };\n\n  struct S {\n    unsigned size_;\n\n    S(unsigned size) : size_{size} {}\n\n    template<typename U>\n    S(const U& u) : S(u.size()) {}\n  };\n\n  const V v;\n  const S s{v};\n}"
    }
  ]
}