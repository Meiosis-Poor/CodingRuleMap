{
  "name": "MacroToEnum",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-macro-to-enum",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 555,
  "branches": 58,
  "apis": 310,
  "test": [
    {
      "description": null,
      "expected-problems": 51,
      "expected-linenumbers": [
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        58,
        59,
        60,
        61,
        71,
        72,
        73,
        91,
        92,
        93,
        94,
        116,
        117,
        133,
        134,
        135,
        144,
        145,
        146,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        187,
        188,
        189,
        190,
        191,
        208,
        209,
        210,
        217,
        218
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++14-or-later %s modernize-macro-to-enum %t -- -- -I%S/Inputs/macro-to-enum -fno-delayed-template-parsing\n// C++14 or later required for binary literals.\n\n#if 1\n#include \"modernize-macro-to-enum.h\"\n\n// These macros are skipped due to being inside a conditional compilation block.\n#define GOO_RED 1\n#define GOO_GREEN 2\n#define GOO_BLUE 3\n\n#endif\n\n// Macros expanding to expressions involving only literals are converted.\n#define EXPR1 1 - 1\n#define EXPR2 1 + 1\n#define EXPR3 1 * 1\n#define EXPR4 1 / 1\n#define EXPR5 1 | 1\n#define EXPR6 1 & 1\n#define EXPR7 1 << 1\n#define EXPR8 1 >> 1\n#define EXPR9 1 % 2\n#define EXPR10 1 ^ 1\n#define EXPR11 (1 + (2))\n#define EXPR12 ((1) + (2 + 0) + (1 * 1) + (1 / 1) + (1 | 1 ) + (1 & 1) + (1 << 1) + (1 >> 1) + (1 % 2) + (1 ^ 1))\n// CHECK-MESSAGES: :[[@LINE-12]]:1: warning: replace macro with enum [modernize-macro-to-enum]\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR1' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR2' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR3' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR4' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR5' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR6' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR7' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR8' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR9' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR10' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR11' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-13]]:9: warning: macro 'EXPR12' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: EXPR1 = 1 - 1,\n// CHECK-FIXES-NEXT: EXPR2 = 1 + 1,\n// CHECK-FIXES-NEXT: EXPR3 = 1 * 1,\n// CHECK-FIXES-NEXT: EXPR4 = 1 / 1,\n// CHECK-FIXES-NEXT: EXPR5 = 1 | 1,\n// CHECK-FIXES-NEXT: EXPR6 = 1 & 1,\n// CHECK-FIXES-NEXT: EXPR7 = 1 << 1,\n// CHECK-FIXES-NEXT: EXPR8 = 1 >> 1,\n// CHECK-FIXES-NEXT: EXPR9 = 1 % 2,\n// CHECK-FIXES-NEXT: EXPR10 = 1 ^ 1,\n// CHECK-FIXES-NEXT: EXPR11 = (1 + (2)),\n// CHECK-FIXES-NEXT: EXPR12 = ((1) + (2 + 0) + (1 * 1) + (1 / 1) + (1 | 1 ) + (1 & 1) + (1 << 1) + (1 >> 1) + (1 % 2) + (1 ^ 1))\n// CHECK-FIXES-NEXT: };\n\n#define RED 0xFF0000\n#define GREEN 0x00FF00\n#define BLUE 0x0000FF\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: replace macro with enum [modernize-macro-to-enum]\n// CHECK-MESSAGES: :[[@LINE-4]]:9: warning: macro 'RED' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-4]]:9: warning: macro 'GREEN' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-4]]:9: warning: macro 'BLUE' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: RED = 0xFF0000,\n// CHECK-FIXES-NEXT: GREEN = 0x00FF00,\n// CHECK-FIXES-NEXT: BLUE = 0x0000FF\n// CHECK-FIXES-NEXT: };\n\n// Verify that comments are preserved.\n#define CoordModeOrigin         0   /* relative to the origin */\n#define CoordModePrevious       1   /* relative to previous point */\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'CoordModeOrigin' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'CoordModePrevious' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: CoordModeOrigin =         0,   /* relative to the origin */\n// CHECK-FIXES-NEXT: CoordModePrevious =       1   /* relative to previous point */\n// CHECK-FIXES-NEXT: };\n\n// Verify that multiline comments are preserved.\n#define BadDrawable         9   /* parameter not a Pixmap or Window */\n#define BadAccess           10  /* depending on context:\n                                - key/button already grabbed\n                                - attempt to free an illegal \n                                  cmap entry \n                                - attempt to store into a read-only \n                                  color map entry. */\n                                // - attempt to modify the access control\n                                //   list from other than the local host.\n                                //\n#define BadAlloc            11  /* insufficient resources */\n// CHECK-MESSAGES: :[[@LINE-11]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-12]]:9: warning: macro 'BadDrawable' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-12]]:9: warning: macro 'BadAccess' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-4]]:9: warning: macro 'BadAlloc' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: BadDrawable =         9,   /* parameter not a Pixmap or Window */\n// CHECK-FIXES-NEXT: BadAccess =           10,  /* depending on context:\n// CHECK-FIXES-NEXT:                                 - key/button already grabbed\n// CHECK-FIXES-NEXT:                                 - attempt to free an illegal \n// CHECK-FIXES-NEXT:                                   cmap entry \n// CHECK-FIXES-NEXT:                                 - attempt to store into a read-only \n// CHECK-FIXES-NEXT:                                   color map entry. */\n// CHECK-FIXES-NEXT:                                 // - attempt to modify the access control\n// CHECK-FIXES-NEXT:                                 //   list from other than the local host.\n// CHECK-FIXES-NEXT:                                 //\n// CHECK-FIXES-NEXT: BadAlloc =            11  /* insufficient resources */\n// CHECK-FIXES-NEXT: };\n\n// Undefining a macro invalidates adjacent macros\n// from being considered as an enum.\n#define REMOVED1 1\n#define REMOVED2 2\n#define REMOVED3 3\n#undef REMOVED2\n#define VALID1 1\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-2]]:9: warning: macro 'VALID1' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: VALID1 = 1\n// CHECK-FIXES-NEXT: };\n\n#define UNDEF1 1\n#define UNDEF2 2\n#define UNDEF3 3\n\n// Undefining a macro later invalidates the set of possible adjacent macros\n// from being considered as an enum.\n#undef UNDEF2\n\n// Integral constants can have an optional sign\n#define SIGNED1 +1\n#define SIGNED2 -1\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'SIGNED1' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'SIGNED2' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: SIGNED1 = +1,\n// CHECK-FIXES-NEXT: SIGNED2 = -1\n// CHECK-FIXES-NEXT: };\n\n// Integral constants with bitwise negated values\n#define UNOP1 ~0U\n#define UNOP2 ~1U\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'UNOP1' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'UNOP2' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: UNOP1 = ~0U,\n// CHECK-FIXES-NEXT: UNOP2 = ~1U\n// CHECK-FIXES-NEXT: };\n\n// Integral constants in other bases and with suffixes are OK\n#define BASE1 0777    // octal\n#define BASE2 0xDEAD  // hexadecimal\n#define BASE3 0b0011  // binary\n#define SUFFIX1 +1U\n#define SUFFIX2 -1L\n#define SUFFIX3 +1UL\n#define SUFFIX4 -1LL\n#define SUFFIX5 +1ULL\n// CHECK-MESSAGES: :[[@LINE-8]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'BASE1' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'BASE2' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'BASE3' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'SUFFIX1' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'SUFFIX2' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'SUFFIX3' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'SUFFIX4' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-9]]:9: warning: macro 'SUFFIX5' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: BASE1 = 0777,    // octal\n// CHECK-FIXES-NEXT: BASE2 = 0xDEAD,  // hexadecimal\n// CHECK-FIXES-NEXT: BASE3 = 0b0011,  // binary\n// CHECK-FIXES-NEXT: SUFFIX1 = +1U,\n// CHECK-FIXES-NEXT: SUFFIX2 = -1L,\n// CHECK-FIXES-NEXT: SUFFIX3 = +1UL,\n// CHECK-FIXES-NEXT: SUFFIX4 = -1LL,\n// CHECK-FIXES-NEXT: SUFFIX5 = +1ULL\n// CHECK-FIXES-NEXT: };\n\n// A limited form of constant expression is recognized: a parenthesized\n// literal or a parenthesized literal with the unary operators +, - or ~.\n#define PAREN1 (-1)\n#define PAREN2 (1)\n#define PAREN3 (+1)\n#define PAREN4 (~1)\n// CHECK-MESSAGES: :[[@LINE-4]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-5]]:9: warning: macro 'PAREN1' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-5]]:9: warning: macro 'PAREN2' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-5]]:9: warning: macro 'PAREN3' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-5]]:9: warning: macro 'PAREN4' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: PAREN1 = (-1),\n// CHECK-FIXES-NEXT: PAREN2 = (1),\n// CHECK-FIXES-NEXT: PAREN3 = (+1),\n// CHECK-FIXES-NEXT: PAREN4 = (~1)\n// CHECK-FIXES-NEXT: };\n\n// More complicated parenthesized expressions are excluded.\n// Expansions that are not surrounded by parentheses are excluded.\n// Nested matching parentheses are stripped.\n#define COMPLEX_PAREN1 (x+1)\n#define COMPLEX_PAREN2 (x+1\n#define COMPLEX_PAREN3 (())\n#define COMPLEX_PAREN4 ()\n#define COMPLEX_PAREN5 (+1)\n#define COMPLEX_PAREN6 ((+1))\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'COMPLEX_PAREN5' defines an integral constant; prefer an enum instead\n// CHECK-MESSAGES: :[[@LINE-3]]:9: warning: macro 'COMPLEX_PAREN6' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: COMPLEX_PAREN5 = (+1),\n// CHECK-FIXES-NEXT: COMPLEX_PAREN6 = ((+1))\n// CHECK-FIXES-NEXT: };\n\n#define GOOD_COMMA (1, 2)\n// CHECK-MESSAGES: :[[@LINE-1]]:1: warning: replace macro with enum\n// CHECK-MESSAGES: :[[@LINE-2]]:9: warning: macro 'GOOD_COMMA' defines an integral constant; prefer an enum instead\n// CHECK-FIXES: enum {\n// CHECK-FIXES-NEXT: GOOD_COMMA = (1, 2)\n// CHECK-FIXES-NEXT: };\n\n// Macros appearing in conditional expressions can't be replaced\n// by enums.\n#define USE_FOO 1\n#define USE_BAR 0\n#define USE_IF 1\n#define USE_ELIF 1\n#define USE_IFDEF 1\n#define USE_IFNDEF 1\n\n// Undef'ing first and then defining later should still exclude this macro\n#undef USE_UINT64\n#define USE_UINT64 0\n#undef USE_INT64\n#define USE_INT64 0\n\n#if defined(USE_FOO) && USE_FOO\nextern void foo();\n#else\ninline void foo() {}\n#endif\n\n#if USE_BAR\nextern void bar();\n#else\ninline void bar() {}\n#endif\n\n#if USE_IF\ninline void used_if() {}\n#endif\n\n#if 0\n#elif USE_ELIF\ninline void used_elif() {}\n#endif\n\n#ifdef USE_IFDEF\ninline void used_ifdef() {}\n#endif\n\n#ifndef USE_IFNDEF\n#else\ninline void used_ifndef() {}\n#endif\n\n// Regular conditional compilation blocks should leave previous\n// macro enums alone.\n#if 0\n#include <non-existent.h>\n#endif\n\n// Conditional compilation blocks invalidate adjacent macros\n// from being considered as an enum.  Conditionally compiled\n// blocks could contain macros that should rightly be included\n// in the enum, but we can't explore multiple branches of a\n// conditionally compiled section in clang-tidy, only the active\n// branch based on compilation options.\n#define CONDITION1 1\n#define CONDITION2 2\n#if 0\n#define CONDITION3 3\n#else\n#define CONDITION3 -3\n#endif\n\n#define IFDEF1 1\n#define IFDEF2 2\n#ifdef FROB\n#define IFDEF3 3\n#endif\n\n#define IFNDEF1 1\n#define IFNDEF2 2\n#ifndef GOINK\n#define IFNDEF3 3\n#endif\n\n// Macros used in conditions are invalidated, even if they look\n// like enums after they are used in conditions.\n#if DEFINED_LATER1\n#endif\n#ifdef DEFINED_LATER2\n#endif\n#ifndef DEFINED_LATER3\n#endif\n#undef DEFINED_LATER4\n#if ((defined(DEFINED_LATER5) || DEFINED_LATER6) && DEFINED_LATER7) || (DEFINED_LATER8 > 10)\n#endif\n\n#define DEFINED_LATER1 1\n#define DEFINED_LATER2 2\n#define DEFINED_LATER3 3\n#define DEFINED_LATER4 4\n#define DEFINED_LATER5 5\n#define DEFINED_LATER6 6\n#define DEFINED_LATER7 7\n#define DEFINED_LATER8 8\n\n// Sometimes an argument to ifdef can be classified as a keyword token.\n#ifdef __restrict\n#endif\n\n// These macros do not expand to integral constants.\n#define HELLO \"Hello, \"\n#define WORLD \"World\"\n#define EPS1 1.0F\n#define EPS2 1e5\n#define EPS3 1.\n\n// Ignore macros invoking comma operator unless they are inside parens.\n#define BAD_COMMA 1, 2\n\nextern void draw(unsigned int Color);\n\nvoid f()\n{\n  // Usage of macros converted to enums should still compile.\n  draw(RED);\n  draw(GREEN | RED);\n  draw(BLUE + RED);\n}\n\n// Ignore macros defined inside a top-level function definition.\nvoid g(int x)\n{\n  if (x != 0) {\n#define INSIDE1 1\n#define INSIDE2 2\n    if (INSIDE1 > 1) {\n      f();\n    }\n  } else {\n    if (INSIDE2 == 1) {\n      f();\n    }\n  }\n}\n\n// Ignore macros defined inside a top-level function declaration.\nextern void g2(\n#define INSIDE3 3\n#define INSIDE4 4\n);\n\n// Ignore macros defined inside a record (structure) declaration.\nstruct S {\n#define INSIDE5 5\n#define INSIDE6 6\n  char storage[INSIDE5];\n};\nclass C {\n#define INSIDE7 7\n#define INSIDE8 8\n};\n\n// Ignore macros defined inside a template function definition.\ntemplate <int N>\n#define INSIDE9 9\nbool fn()\n{\n#define INSIDE10 10\n  return INSIDE9 > 1 || INSIDE10 < N;\n}\n\n// Ignore macros defined inside a variable declaration.\nextern int\n#define INSIDE11 11\nv;\n\n// Ignore macros defined inside a template class definition.\ntemplate <int N>\nclass C2 {\npublic:\n#define INSIDE12 12\n    char storage[N];\n  bool f() {\n    return N > INSIDE12;\n  }\n  bool g();\n};\n\n// Ignore macros defined inside a template member function definition.\ntemplate <int N>\n#define INSIDE13 13\nbool C2<N>::g() {\n#define INSIDE14 14\n  return N < INSIDE12 || N > INSIDE13 || INSIDE14 > N;\n};\n\n// Ignore macros defined inside a template type alias.\ntemplate <typename T>\nclass C3 {\n  T data;\n};\ntemplate <typename T>\n#define INSIDE15 15\nusing Data = C3<T[INSIDE15]>;\n\n// Ignore macros defined inside a type alias.\nusing Data2 =\n#define INSIDE16 16\n    char[INSIDE16];\n\n// Ignore macros defined inside a (constexpr) variable definition.\nconstexpr int\n#define INSIDE17 17\nvalue = INSIDE17;\n\n// Ignore macros used in the expansion of other macros\n#define INSIDE18 18\n#define INSIDE19 19\n\n#define CONCAT(n_, s_) n_##s_\n#define FN_NAME(n_, s_) CONCAT(n_, s_)\n\nextern void FN_NAME(g, INSIDE18)();\n\nvoid gg()\n{\n    g18();\n}"
    }
  ]
}