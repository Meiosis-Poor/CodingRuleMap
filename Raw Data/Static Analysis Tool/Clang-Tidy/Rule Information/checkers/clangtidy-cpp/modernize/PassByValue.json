{
  "name": "PassByValue",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-pass-by-value",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 338,
  "branches": 30,
  "apis": 187,
  "test": [
    {
      "description": null,
      "expected-problems": 17,
      "expected-linenumbers": [
        26,
        56,
        62,
        80,
        94,
        102,
        144,
        151,
        160,
        170,
        186,
        187,
        202,
        236,
        296,
        303,
        310
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes %s modernize-pass-by-value %t -- -- -fno-delayed-template-parsing\n\nnamespace {\n// POD types are trivially move constructible.\nstruct POD {\n  int a, b, c;\n};\n\nstruct Movable {\n  int a, b, c;\n  Movable() = default;\n  Movable(const Movable &) {}\n  Movable(Movable &&) {}\n};\n\nstruct NotMovable {\n  NotMovable() = default;\n  NotMovable(const NotMovable &) = default;\n  NotMovable(NotMovable &&) = delete;\n  int a, b, c;\n};\n}\n\nstruct A {\n  A(const Movable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move [modernize-pass-by-value]\n  // CHECK-FIXES: A(Movable M) : M(std::move(M)) {}\n  Movable M;\n};\n\n// Test that we aren't modifying other things than a parameter.\nMovable GlobalObj;\nstruct B {\n  B(const Movable &M) : M(GlobalObj) {}\n  Movable M;\n};\n\n// Test that a parameter with more than one reference to it won't be changed.\nstruct C {\n  // Tests extra-reference in body.\n  C(const Movable &M) : M(M) { this->i = M.a; }\n\n  // Tests extra-reference in init-list.\n  C(const Movable &M, int) : M(M), i(M.a) {}\n  Movable M;\n  int i;\n};\n\n// Test that both declaration and definition are updated.\nstruct D {\n  D(const Movable &M);\n  // CHECK-FIXES: D(Movable M);\n  Movable M;\n};\nD::D(const Movable &M) : M(M) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n// CHECK-FIXES: D::D(Movable M) : M(std::move(M)) {}\n\n// Test with default parameter.\nstruct E {\n  E(const Movable &M = Movable()) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: E(Movable M = Movable()) : M(std::move(M)) {}\n  Movable M;\n};\n\n// Test with object that can't be moved.\nstruct F {\n  F(const NotMovable &NM) : NM(NM) {}\n  NotMovable NM;\n};\n\n// Test unnamed parameter in declaration.\nstruct G {\n  G(const Movable &);\n  // CHECK-FIXES: G(Movable );\n  Movable M;\n};\nG::G(const Movable &M) : M(M) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n// CHECK-FIXES: G::G(Movable M) : M(std::move(M)) {}\n\n// Test parameter with and without qualifier.\nnamespace ns_H {\ntypedef ::Movable HMovable;\n}\nstruct H {\n  H(const ns_H::HMovable &M);\n  // CHECK-FIXES: H(ns_H::HMovable M);\n  ns_H::HMovable M;\n};\nusing namespace ns_H;\nH::H(const HMovable &M) : M(M) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n// CHECK-FIXES: H(HMovable M) : M(std::move(M)) {}\n\n// Try messing up with macros.\n#define MOVABLE_PARAM(Name) const Movable & Name\n// CHECK-FIXES: #define MOVABLE_PARAM(Name) const Movable & Name\nstruct I {\n  I(MOVABLE_PARAM(M)) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: I(MOVABLE_PARAM(M)) : M(M) {}\n  Movable M;\n};\n#undef MOVABLE_PARAM\n\n// Test that templates aren't modified.\ntemplate <typename T> struct J {\n  J(const T &M) : M(M) {}\n  T M;\n};\nJ<Movable> j1(Movable());\nJ<NotMovable> j2(NotMovable());\n\ntemplate<class T>\nstruct MovableTemplateT\n{\n  MovableTemplateT() {}\n  MovableTemplateT(const MovableTemplateT& o) { }\n  MovableTemplateT(MovableTemplateT&& o) { }\n};\n\ntemplate <class T>\nstruct J2 {\n  J2(const MovableTemplateT<T>& A);\n  MovableTemplateT<T> M;\n};\n\ntemplate <class T>\nJ2<T>::J2(const MovableTemplateT<T>& A) : M(A) {}\nJ2<int> j3(MovableTemplateT<int>{});\n\nstruct K_Movable {\n  K_Movable() = default;\n  K_Movable(const K_Movable &) = default;\n  K_Movable(K_Movable &&o) { dummy = o.dummy; }\n  int dummy;\n};\n\n// Test with movable type with an user defined move constructor.\nstruct K {\n  K(const K_Movable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: K(K_Movable M) : M(std::move(M)) {}\n  K_Movable M;\n};\n\ntemplate <typename T> struct L {\n  L(const Movable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: L(Movable M) : M(std::move(M)) {}\n  Movable M;\n};\nL<int> l(Movable());\n\n// Test with a non-instantiated template class.\ntemplate <typename T> struct N {\n  N(const Movable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: N(Movable M) : M(std::move(M)) {}\n\n  Movable M;\n  T A;\n};\n\n// Test with value parameter.\nstruct O {\n  O(Movable M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: O(Movable M) : M(std::move(M)) {}\n  Movable M;\n};\n\n// Test with a const-value parameter.\nstruct P {\n  P(const Movable M) : M(M) {}\n  Movable M;\n};\n\n// Test with multiples parameters where some need to be changed and some don't.\n// need to.\nstruct Q {\n  Q(const Movable &A, const Movable &B, const Movable &C, double D)\n      : A(A), B(B), C(C), D(D) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:23: warning: pass by value and use std::move\n  // CHECK-MESSAGES: :[[@LINE-3]]:41: warning: pass by value and use std::move\n  // CHECK-FIXES:      Q(const Movable &A, Movable B, Movable C, double D)\n  // CHECK-FIXES:     : A(A), B(std::move(B)), C(std::move(C)), D(D) {}\n  const Movable &A;\n  Movable B;\n  Movable C;\n  double D;\n};\n\n// Test that value-parameters with a nested name specifier are left as-is.\nnamespace ns_R {\ntypedef ::Movable RMovable;\n}\nstruct R {\n  R(ns_R::RMovable M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: pass by value and use std::move\n  // CHECK-FIXES: R(ns_R::RMovable M) : M(std::move(M)) {}\n  ns_R::RMovable M;\n};\n\n// Test with rvalue parameter.\nstruct S {\n  S(Movable &&M) : M(M) {}\n  Movable M;\n};\n\ntemplate <typename T, int N> struct array { T A[N]; };\n\n// Test that types that are trivially copyable will not use std::move. This will\n// cause problems with performance-move-const-arg, as it will revert it.\nstruct T {\n  T(array<int, 10> a) : a_(a) {}\n  array<int, 10> a_;\n};\n\nstruct U {\n  U(const POD &M) : M(M) {}\n  POD M;\n};\n\n// The rewrite can't look through `typedefs` and `using`.\n// Test that we don't partially rewrite one decl without rewriting the other.\nusing MovableConstRef = const Movable &;\nstruct V {\n  V(MovableConstRef M);\n  // CHECK-FIXES: V(MovableConstRef M);\n  Movable M;\n};\nV::V(const Movable &M) : M(M) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n// CHECK-FIXES: V::V(const Movable &M) : M(M) {}\n\n// Test with paired lvalue/rvalue overloads.\nstruct W1 {\n  W1(const Movable &M) : M(M) {}\n  W1(Movable &&M);\n  Movable M;\n};\nstruct W2 {\n  W2(const Movable &M, int) : M(M) {}\n  W2(Movable &&M, int);\n  Movable M;\n};\nstruct W3 {\n  W3(const W1 &, const Movable &M) : M(M) {}\n  W3(W1 &&, Movable &&M);\n  Movable M;\n};\n\nstruct ProtectedMovable {\n  ProtectedMovable() = default;\n  ProtectedMovable(const ProtectedMovable &) {}\nprotected:\n  ProtectedMovable(ProtectedMovable &&) {}\n};\n\nstruct PrivateMovable {\n  PrivateMovable() = default;\n  PrivateMovable(const PrivateMovable &) {}\nprivate:\n  PrivateMovable(PrivateMovable &&) {}\n\n  friend struct X5;\n};\n\nstruct InheritedProtectedMovable : ProtectedMovable {\n  InheritedProtectedMovable() = default;\n  InheritedProtectedMovable(const InheritedProtectedMovable &) {}\n  InheritedProtectedMovable(InheritedProtectedMovable &&) {}\n};\n\nstruct InheritedPrivateMovable : PrivateMovable {\n  InheritedPrivateMovable() = default;\n  InheritedPrivateMovable(const InheritedPrivateMovable &) {}\n  InheritedPrivateMovable(InheritedPrivateMovable &&) {}\n};\n\nstruct X1 {\n  X1(const ProtectedMovable &M) : M(M) {}\n  ProtectedMovable M;\n};\n\nstruct X2 {\n  X2(const PrivateMovable &M) : M(M) {}\n  PrivateMovable M;\n};\n\nstruct X3 {\n  X3(const InheritedProtectedMovable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n  // CHECK-FIXES: X3(InheritedProtectedMovable M) : M(std::move(M)) {}\n  InheritedProtectedMovable M;\n};\n\nstruct X4 {\n  X4(const InheritedPrivateMovable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n  // CHECK-FIXES: X4(InheritedPrivateMovable M) : M(std::move(M)) {}\n  InheritedPrivateMovable M;\n};\n\nstruct X5 {\n  X5(const PrivateMovable &M) : M(M) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: pass by value and use std::move\n  // CHECK-FIXES: X5(PrivateMovable M) : M(std::move(M)) {}\n  PrivateMovable M;\n};"
    }
  ]
}