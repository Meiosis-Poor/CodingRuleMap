{
  "name": "RawStringLiteral",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-raw-string-literal",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 181,
  "branches": 19,
  "apis": 101,
  "test": [
    {
      "description": null,
      "expected-problems": 15,
      "expected-linenumbers": [
        4,
        61,
        65,
        69,
        73,
        77,
        81,
        85,
        89,
        93,
        113,
        120,
        126,
        129,
        142
      ],
      "code": "\n// RUN: %check_clang_tidy %s modernize-raw-string-literal %t -- -config=\"{CheckOptions: {modernize-raw-string-literal.ReplaceShorterLiterals: true}}\"\n\nchar const *const BackSlash(\"goink\\\\frob\");\n// CHECK-MESSAGES: :[[@LINE-1]]:29: warning: escaped string literal can be written as a raw string literal [modernize-raw-string-literal]\n// CHECK-FIXES: {{^}}char const *const BackSlash(R\"(goink\\frob)\");{{$}}\n\nchar const *const PlainLiteral(\"plain literal\");\n\n// Non-printable ASCII characters.\nchar const *const Nul(\"goink\\\\\\000\");\nchar const *const Soh(\"goink\\\\\\001\");\nchar const *const Stx(\"goink\\\\\\002\");\nchar const *const Etx(\"goink\\\\\\003\");\nchar const *const Enq(\"goink\\\\\\004\");\nchar const *const Ack(\"goink\\\\\\005\");\nchar const *const Bell(\"goink\\\\\\afrob\");\nchar const *const BackSpace(\"goink\\\\\\bfrob\");\nchar const *const HorizontalTab(\"goink\\\\\\tfrob\");\nchar const *const NewLine(\"goink\\nfrob\");\nchar const *const VerticalTab(\"goink\\\\\\vfrob\");\nchar const *const FormFeed(\"goink\\\\\\ffrob\");\nchar const *const CarraigeReturn(\"goink\\\\\\rfrob\");\nchar const *const So(\"goink\\\\\\016\");\nchar const *const Si(\"goink\\\\\\017\");\nchar const *const Dle(\"goink\\\\\\020\");\nchar const *const Dc1(\"goink\\\\\\021\");\nchar const *const Dc2(\"goink\\\\\\022\");\nchar const *const Dc3(\"goink\\\\\\023\");\nchar const *const Dc4(\"goink\\\\\\024\");\nchar const *const Nak(\"goink\\\\\\025\");\nchar const *const Syn(\"goink\\\\\\026\");\nchar const *const Etb(\"goink\\\\\\027\");\nchar const *const Can(\"goink\\\\\\030\");\nchar const *const Em(\"goink\\\\\\031\");\nchar const *const Sub(\"goink\\\\\\032\");\nchar const *const Esc(\"goink\\\\\\033\");\nchar const *const Fs(\"goink\\\\\\034\");\nchar const *const Gs(\"goink\\\\\\035\");\nchar const *const Rs(\"goink\\\\\\036\");\nchar const *const Us(\"goink\\\\\\037\");\nchar const *const HexNonPrintable(\"\\\\\\x03\");\nchar const *const Delete(\"\\\\\\177\");\nchar const *const MultibyteSnowman(\"\\xE2\\x98\\x83\");\n// CHECK-FIXES: {{^}}char const *const MultibyteSnowman(\"\\xE2\\x98\\x83\");{{$}}\n\nchar const *const TrailingSpace(\"A line \\\\with space. \\n\");\nchar const *const TrailingNewLine(\"A single \\\\line.\\n\");\nchar const *const AlreadyRaw(R\"(foobie\\\\bletch)\");\nauto const *const UTF8Literal(u8\"foobie\\\\bletch\");\nauto const *const UTF8RawLiteral(u8R\"(foobie\\\\bletch)\");\n// TODO: enable these tests once all supported compilers\n// support char16_t and char32_t (VS2013 does not)\n// char16_t const *const UTF16Literal(u\"foobie\\\\bletch\");\n// char16_t const *const UTF16RawLiteral(uR\"(foobie\\\\bletch)\");\n// char32_t const *const UTF32Literal(U\"foobie\\\\bletch\");\n// char32_t const *const UTF32RawLiteral(UR\"(foobie\\\\bletch)\");\nwchar_t const *const WideLiteral(L\"foobie\\\\bletch\");\nwchar_t const *const WideRawLiteral(LR\"(foobie\\\\bletch)\");\n\nchar const *const SingleQuote(\"goink\\'frob\");\n// CHECK-MESSAGES: :[[@LINE-1]]:31: warning: {{.*}} can be written as a raw string literal\n// CHECK-XFIXES: {{^}}char const *const SingleQuote(R\"(goink'frob)\");{{$}}\n\nchar const *const DoubleQuote(\"goink\\\"frob\");\n// CHECK-MESSAGES: :[[@LINE-1]]:31: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const DoubleQuote(R\"(goink\"frob)\");{{$}}\n\nchar const *const QuestionMark(\"goink\\?frob\");\n// CHECK-MESSAGES: :[[@LINE-1]]:32: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const QuestionMark(R\"(goink?frob)\");{{$}}\n\nchar const *const RegEx(\"goink\\\\(one|two\\\\)\\\\\\\\\\\\?.*\\\\nfrob\");\n// CHECK-MESSAGES: :[[@LINE-1]]:25: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const RegEx(R\"(goink\\(one|two\\)\\\\\\?.*\\nfrob)\");{{$}}\n\nchar const *const Path(\"C:\\\\Program Files\\\\Vendor\\\\Application\\\\Application.exe\");\n// CHECK-MESSAGES: :[[@LINE-1]]:24: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const Path(R\"(C:\\Program Files\\Vendor\\Application\\Application.exe)\");{{$}}\n\nchar const *const ContainsSentinel(\"who\\\\ops)\\\"\");\n// CHECK-MESSAGES: :[[@LINE-1]]:36: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const ContainsSentinel(R\"lit(who\\ops)\")lit\");{{$}}\n\nchar const *const ContainsDelim(\"whoops)\\\")lit\\\"\");\n// CHECK-MESSAGES: :[[@LINE-1]]:33: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const ContainsDelim(R\"lit1(whoops)\")lit\")lit1\");{{$}}\n\nchar const *const OctalPrintable(\"\\100\\\\\");\n// CHECK-MESSAGES: :[[@LINE-1]]:34: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const OctalPrintable(R\"(@\\)\");{{$}}\n\nchar const *const HexPrintable(\"\\x40\\\\\");\n// CHECK-MESSAGES: :[[@LINE-1]]:32: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}char const *const HexPrintable(R\"(@\\)\");{{$}}\n\nchar const *const prettyFunction(__PRETTY_FUNCTION__);\nchar const *const function(__FUNCTION__);\nchar const *const func(__func__);\n\n#define TRICK(arg_) #arg_\nchar const *const MacroBody = TRICK(foo\\\\bar);\n\n#define HAT(rabbit_) #rabbit_ \"foo\\\\bar\"\nchar const *const StringizedMacroArgument = HAT(foo\\\\bar);\n\n#define SUBST(lit_) lit_\nchar const *const MacroArgument = SUBST(\"foo\\\\bar\");\n// FIXME: We should be able to replace this string literal macro argument\n\ntemplate <typename T>\nvoid fn(char const *const Arg) {\n  char const *const Str(\"foo\\\\bar\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: {{.*}} can be written as a raw string literal\n  // CHECK-FIXES: {{^}}  char const *const Str(R\"(foo\\bar)\");{{$}}\n}\n\ntemplate <>\nvoid fn<int>(char const *const Arg) {\n  char const *const Str(\"foo\\\\bar\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: {{.*}} can be written as a raw string literal\n  // CHECK-FIXES: {{^}}  char const *const Str(R\"(foo\\bar)\");{{$}}\n}\n\nvoid callFn() {\n  fn<int>(\"foo\\\\bar\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: {{.*}} can be written as a raw string literal\n  // CHECK-FIXES: {{^}}  fn<int>(R\"(foo\\bar)\");{{$}}\n  fn<double>(\"foo\\\\bar\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: {{.*}} can be written as a raw string literal\n  // CHECK-FIXES: {{^}}  fn<double>(R\"(foo\\bar)\");{{$}}\n}\n\nnamespace std {\nusing size_t = decltype(sizeof(0));\nnamespace ud {\nint operator\"\"_abc(const char *str, std::size_t len);\n} // namespace ud\n} // namespace std\nnamespace gh97243 {\nusing namespace std::ud;\nauto UserDefinedLiteral = \"foo\\\\bar\"_abc;\n// CHECK-MESSAGES: :[[@LINE-1]]:27: warning: {{.*}} can be written as a raw string literal\n// CHECK-FIXES: {{^}}auto UserDefinedLiteral = R\"(foo\\bar)\"_abc;\n} // namespace gh97243"
    }
  ]
}