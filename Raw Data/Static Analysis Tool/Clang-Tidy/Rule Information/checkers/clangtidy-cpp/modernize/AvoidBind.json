{
  "name": "AvoidBind",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-avoid-bind",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 724,
  "branches": 107,
  "apis": 300,
  "test": [
    {
      "description": null,
      "expected-problems": 52,
      "expected-linenumbers": [
        139,
        144,
        150,
        155,
        159,
        166,
        170,
        174,
        182,
        186,
        194,
        198,
        202,
        208,
        212,
        216,
        223,
        231,
        235,
        239,
        243,
        247,
        251,
        257,
        265,
        275,
        279,
        284,
        290,
        295,
        301,
        305,
        310,
        314,
        318,
        328,
        333,
        338,
        352,
        356,
        360,
        365,
        369,
        373,
        377,
        382,
        386,
        390,
        394,
        398,
        402,
        411
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes -std=c++14-or-later %s modernize-avoid-bind %t\n\nnamespace std {\ninline namespace impl {\ntemplate <class Fp, class... Arguments>\nclass bind_rt {};\n\ntemplate <class Fp, class... Arguments>\nbind_rt<Fp, Arguments...> bind(Fp &&, Arguments &&...);\n} // namespace impl\n\ntemplate <typename T>\nT ref(T &t);\n} // namespace std\n\nnamespace boost {\ntemplate <class Fp, class... Arguments>\nclass bind_rt {};\n\ntemplate <class Fp, class... Arguments>\nbind_rt<Fp, Arguments...> bind(const Fp &, Arguments...);\n\ntemplate <class T>\nstruct reference_wrapper {\n  explicit reference_wrapper(T &t) {}\n};\n\ntemplate <class T>\nreference_wrapper<T> const ref(T &t) {\n  return reference_wrapper<T>(t);\n}\n\n} // namespace boost\n\nnamespace C {\nint add(int x, int y) { return x + y; }\n} // namespace C\n\nstruct Foo {\n  static int add(int x, int y) { return x + y; }\n};\n\nstruct D {\n  D() = default;\n  void operator()(int x, int y) const {}\n  operator bool() const { return true; }\n\n  void MemberFunction(int x) {}\n  int MemberFunctionWithReturn(int x) { return 0; }\n\n  static D *create();\n};\n\nstruct F {\n  F(int x) {}\n  ~F() {}\n\n  int get() { return 42; }\n};\n\nvoid UseF(F);\n\nstruct G {\n  G() : _member(0) {}\n  G(int m) : _member(m) {}\n\n  template <typename T>\n  void operator()(T) const {}\n\n  int _member;\n};\n\ntemplate <typename T>\nstruct H {\n  void operator()(T) const {};\n};\n\nstruct placeholder {};\nplaceholder _1;\nplaceholder _2;\n\nnamespace placeholders {\nusing ::_1;\nusing ::_2;\n} // namespace placeholders\n\nint add(int x, int y) { return x + y; }\nint addThree(int x, int y, int z) { return x + y + z; }\nvoid sub(int &x, int y) { x += y; }\n\n// Let's fake a minimal std::function-like facility.\nnamespace std {\ntemplate <typename _Tp>\n_Tp declval();\n\ntemplate <typename _Functor, typename... _ArgTypes>\nstruct __res {\n  template <typename... _Args>\n  static decltype(declval<_Functor>()(_Args()...)) _S_test(int);\n\n  template <typename...>\n  static void _S_test(...);\n\n  using type = decltype(_S_test<_ArgTypes...>(0));\n};\n\ntemplate <typename>\nstruct function;\n\ntemplate <typename... _ArgTypes>\nstruct function<void(_ArgTypes...)> {\n  template <typename _Functor,\n            typename = typename __res<_Functor, _ArgTypes...>::type>\n  function(_Functor) {}\n};\n} // namespace std\n\nstruct Thing {};\nvoid UseThing(Thing *);\n\nstruct Callback {\n  Callback();\n  Callback(std::function<void()>);\n  void Reset(std::function<void()>);\n};\n\nint GlobalVariable = 42;\n\nstruct TestCaptureByValueStruct {\n  int MemberVariable;\n  static int StaticMemberVariable;\n  F MemberStruct;\n  G MemberStructWithData;\n\n  void testCaptureByValue(int Param, F f) {\n    int x = 3;\n    int y = 4;\n    auto AAA = std::bind(add, x, y);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto AAA = [x, y] { return add(x, y); };\n\n    // When the captured variable is repeated, it should only appear in the capture list once.\n    auto BBB = std::bind(add, x, x);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto BBB = [x] { return add(x, x); };\n\n    int LocalVariable;\n    // Global variables shouldn't be captured at all, and members should be captured through this.\n    auto CCC = std::bind(add, MemberVariable, GlobalVariable);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto CCC = [this] { return add(MemberVariable, GlobalVariable); };\n\n    // Static member variables shouldn't be captured, but locals should\n    auto DDD = std::bind(add, TestCaptureByValueStruct::StaticMemberVariable, LocalVariable);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto DDD = [LocalVariable] { return add(TestCaptureByValueStruct::StaticMemberVariable, LocalVariable); };\n\n    auto EEE = std::bind(add, Param, Param);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto EEE = [Param] { return add(Param, Param); };\n\n    // The signature of boost::bind() is different, and causes\n    // CXXBindTemporaryExprs to be created in certain cases.  So let's test\n    // those here.\n    auto FFF = boost::bind(UseF, f);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to boost::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto FFF = [f] { UseF(f); };\n\n    auto GGG = boost::bind(UseF, MemberStruct);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to boost::bind [modernize-avoid-bind]\n    // CHECK-FIXES: auto GGG = [this] { UseF(MemberStruct); };\n\n    auto HHH = std::bind(add, MemberStructWithData._member, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // Correctly distinguish data members of other classes\n    // CHECK-FIXES: auto HHH = [capture0 = MemberStructWithData._member] { return add(capture0, 1); };\n  }\n};\n\nvoid testLiteralParameters() {\n  auto AAA = std::bind(add, 2, 2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n  // CHECK-FIXES: auto AAA = [] { return add(2, 2); };\n\n  auto BBB = std::bind(addThree, 2, 3, 4);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind [modernize-avoid-bind]\n  // CHECK-FIXES: auto BBB = [] { return addThree(2, 3, 4); };\n}\n\nvoid testCaptureByReference() {\n  int x = 2;\n  int y = 2;\n  auto AAA = std::bind(add, std::ref(x), std::ref(y));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto AAA = [&x, &y] { return add(x, y); };\n\n  auto BBB = std::bind(add, std::ref(x), y);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto BBB = [&x, y] { return add(x, y); };\n\n  auto CCC = std::bind(add, y, std::ref(x));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto CCC = [y, &x] { return add(y, x); };\n\n  // Make sure it works with boost::ref() too which has slightly different\n  // semantics.\n  auto DDD = boost::bind(add, boost::ref(x), boost::ref(y));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to boost::bind\n  // CHECK-FIXES: auto DDD = [&x, &y] { return add(x, y); };\n\n  auto EEE = boost::bind(add, boost::ref(x), y);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to boost::bind\n  // CHECK-FIXES: auto EEE = [&x, y] { return add(x, y); };\n\n  auto FFF = boost::bind(add, y, boost::ref(x));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to boost::bind\n  // CHECK-FIXES: auto FFF = [y, &x] { return add(y, x); };\n}\n\nvoid testCaptureByInitExpression() {\n  int x = 42;\n  auto AAA = std::bind(add, x, F(x).get());\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto AAA = [x, capture0 = F(x).get()] { return add(x, capture0); };\n}\n\nvoid testFunctionObjects() {\n  D d;\n  D *e = nullptr;\n  auto AAA = std::bind(d, 1, 2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto AAA = [d] { d(1, 2); }\n\n  auto BBB = std::bind(*e, 1, 2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto BBB = [e] { (*e)(1, 2); }\n\n  auto CCC = std::bind(D{}, 1, 2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto CCC = [] { D{}(1, 2); }\n\n  auto DDD = std::bind(D(), 1, 2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto DDD = [] { D()(1, 2); }\n\n  auto EEE = std::bind(*D::create(), 1, 2);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto EEE = [Func = *D::create()] { Func(1, 2); };\n\n  auto FFF = std::bind(G(), 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // Templated function call operators may be used\n  // CHECK-FIXES: auto FFF = [] { G()(1); };\n\n  int CTorArg = 42;\n  auto GGG = std::bind(G(CTorArg), 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // Function objects with constructor arguments should be captured\n  // CHECK-FIXES: auto GGG = [Func = G(CTorArg)] { Func(1); };\n}\n\ntemplate <typename T>\nvoid testMemberFnOfClassTemplate(T) {\n  auto HHH = std::bind(H<T>(), 42);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // Ensure function class template arguments are preserved\n  // CHECK-FIXES: auto HHH = [] { H<T>()(42); };\n}\n\ntemplate void testMemberFnOfClassTemplate(int);\n\nvoid testPlaceholders() {\n  int x = 2;\n  auto AAA = std::bind(add, x, _1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto AAA = [x](auto && PH1) { return add(x, std::forward<decltype(PH1)>(PH1)); };\n\n  auto BBB = std::bind(add, _2, _1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto BBB = [](auto && PH1, auto && PH2) { return add(std::forward<decltype(PH2)>(PH2), std::forward<decltype(PH1)>(PH1)); };\n\n  // No fix is applied for reused placeholders.\n  auto CCC = std::bind(add, _1, _1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto CCC = std::bind(add, _1, _1);\n\n  // When a placeholder is skipped, we always add skipped ones to the lambda as\n  // unnamed parameters.\n  auto DDD = std::bind(add, _2, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto DDD = [](auto &&, auto && PH2) { return add(std::forward<decltype(PH2)>(PH2), 1); };\n\n  // Namespace-qualified placeholders are valid too\n  auto EEE = std::bind(add, placeholders::_2, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto EEE = [](auto &&, auto && PH2) { return add(std::forward<decltype(PH2)>(PH2), 1); };\n}\n\nvoid testGlobalFunctions() {\n  auto AAA = std::bind(C::add, 1, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto AAA = [] { return C::add(1, 1); };\n\n  auto BBB = std::bind(Foo::add, 1, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto BBB = [] { return Foo::add(1, 1); };\n\n  // The & should get removed inside of the lambda body.\n  auto CCC = std::bind(&C::add, 1, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto CCC = [] { return C::add(1, 1); };\n\n  auto DDD = std::bind(&Foo::add, 1, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto DDD = [] { return Foo::add(1, 1); };\n\n  auto EEE = std::bind(&add, 1, 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: auto EEE = [] { return add(1, 1); };\n}\n\nvoid testCapturedSubexpressions() {\n  int x = 3;\n  int y = 3;\n  int *p = &x;\n\n  auto AAA = std::bind(add, 1, add(2, 5));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // Results of nested calls are captured by value.\n  // CHECK-FIXES: auto AAA = [capture0 = add(2, 5)] { return add(1, capture0); };\n\n  auto BBB = std::bind(add, x, add(y, 5));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // Results of nested calls are captured by value.\n  // CHECK-FIXES: auto BBB = [x, capture0 = add(y, 5)] { return add(x, capture0); };\n\n  auto CCC = std::bind(sub, std::ref(*p), _1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // Expressions returning references are captured\n  // CHECK-FIXES: auto CCC = [&capture0 = *p](auto && PH1) { sub(capture0, std::forward<decltype(PH1)>(PH1)); };\n}\n\nstruct E {\n  void MemberFunction(int x) {}\n  int MemberFunctionWithReturn(int x) { return 0; }\n  int operator()(int x, int y) const { return x + y; }\n\n  void testMemberFunctions() {\n    D *d;\n    D dd;\n    auto AAA = std::bind(&D::MemberFunction, d, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto AAA = [d] { d->MemberFunction(1); };\n\n    auto BBB = std::bind(&D::MemberFunction, &dd, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto BBB = [ObjectPtr = &dd] { ObjectPtr->MemberFunction(1); };\n\n    auto CCC = std::bind(&E::MemberFunction, this, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto CCC = [this] { MemberFunction(1); };\n\n    // Test what happens when the object pointer is itself a placeholder.\n    auto DDD = std::bind(&D::MemberFunction, _1, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto DDD = [](auto && PH1) { PH1->MemberFunction(1); };\n\n    auto EEE = std::bind(&D::MemberFunctionWithReturn, d, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto EEE = [d] { return d->MemberFunctionWithReturn(1); };\n\n    auto FFF = std::bind(&D::MemberFunctionWithReturn, &dd, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto FFF = [ObjectPtr = &dd] { return ObjectPtr->MemberFunctionWithReturn(1); };\n\n    auto GGG = std::bind(&E::MemberFunctionWithReturn, this, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto GGG = [this] { return MemberFunctionWithReturn(1); };\n\n    // Test what happens when the object pointer is itself a placeholder.\n    auto HHH = std::bind(&D::MemberFunctionWithReturn, _1, 1);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto HHH = [](auto && PH1) { return PH1->MemberFunctionWithReturn(1); };\n\n    auto III = std::bind(&D::operator(), d, 1, 2);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto III = [d] { (*d)(1, 2); }\n\n    auto JJJ = std::bind(&D::operator(), &dd, 1, 2);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto JJJ = [ObjectPtr = &dd] { (*ObjectPtr)(1, 2); }\n\n    auto KKK = std::bind(&D::operator(), _1, 1, 2);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto KKK = [](auto && PH1) { (*PH1)(1, 2); };\n\n    auto LLL = std::bind(&D::operator bool, d);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto LLL = [d] { return d->operator bool(); }\n\n    auto MMM = std::bind(&E::operator(), this, 1, 2);\n    // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: prefer a lambda to std::bind\n    // CHECK-FIXES: auto MMM = [this] { return (*this)(1, 2); }\n  }\n};\n\nvoid testStdFunction(Thing *t) {\n  Callback cb;\n  if (t)\n    cb.Reset(std::bind(UseThing, t));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: prefer a lambda to std::bind\n  // CHECK-FIXES: cb.Reset([t] { UseThing(t); });\n}"
    }
  ]
}