{
  "name": "UseEmplace",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-use-emplace",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 430,
  "branches": 47,
  "apis": 358,
  "test": [
    {
      "description": null,
      "expected-problems": 172,
      "expected-linenumbers": [
        373,
        377,
        381,
        385,
        390,
        394,
        398,
        431,
        435,
        447,
        452,
        457,
        464,
        468,
        472,
        477,
        481,
        512,
        519,
        523,
        527,
        532,
        538,
        563,
        567,
        571,
        584,
        592,
        601,
        609,
        613,
        617,
        653,
        657,
        661,
        665,
        670,
        674,
        678,
        685,
        689,
        694,
        698,
        703,
        708,
        713,
        718,
        723,
        757,
        760,
        763,
        766,
        769,
        774,
        814,
        818,
        844,
        878,
        883,
        887,
        891,
        895,
        899,
        904,
        910,
        915,
        917,
        921,
        923,
        927,
        929,
        950,
        954,
        958,
        962,
        966,
        970,
        974,
        978,
        982,
        986,
        990,
        994,
        998,
        1002,
        1006,
        1010,
        1014,
        1018,
        1022,
        1026,
        1030,
        1034,
        1038,
        1041,
        1045,
        1048,
        1052,
        1056,
        1060,
        1069,
        1074,
        1081,
        1086,
        1093,
        1098,
        1107,
        1112,
        1119,
        1124,
        1131,
        1136,
        1201,
        1204,
        1207,
        1210,
        1213,
        1216,
        1219,
        1222,
        1226,
        1229,
        1232,
        1235,
        1249,
        1252,
        1255,
        1258,
        1261,
        1264,
        1267,
        1270,
        1274,
        1277,
        1280,
        1283,
        1298,
        1301,
        1304,
        1307,
        1310,
        1313,
        1316,
        1319,
        1323,
        1326,
        1329,
        1332,
        1358,
        1361,
        1364,
        1368,
        1371,
        1374,
        1378,
        1381,
        1384,
        1388,
        1391,
        1394,
        1398,
        1401,
        1404,
        1408,
        1411,
        1414,
        1418,
        1421,
        1424,
        1428,
        1431,
        1434
      ],
      "code": "\n// RUN: %check_clang_tidy %s modernize-use-emplace %t -- \\\n// RUN:   -config=\"{CheckOptions: \\\n// RUN:             {modernize-use-emplace.ContainersWithPushBack: \\\n// RUN:                '::std::vector; ::std::list; ::std::deque; llvm::LikeASmallVector', \\\n// RUN:              modernize-use-emplace.TupleTypes: \\\n// RUN:                '::std::pair; std::tuple; ::test::Single', \\\n// RUN:              modernize-use-emplace.TupleMakeFunctions: \\\n// RUN:                '::std::make_pair; ::std::make_tuple; ::test::MakeSingle'}}\"\n\nnamespace std {\ntemplate <typename E>\nclass initializer_list {\npublic:\n  const E *a, *b;\n  initializer_list() noexcept {}\n};\n\ntemplate <typename T1, typename T2>\nclass pair {\npublic:\n  pair() = default;\n  pair(const pair &) = default;\n  pair(pair &&) = default;\n\n  pair(const T1 &, const T2 &) {}\n  pair(T1 &&, T2 &&) {}\n\n  template <typename U1, typename U2>\n  pair(const pair<U1, U2> &){};\n  template <typename U1, typename U2>\n  pair(pair<U1, U2> &&){};\n};\n\ntemplate <typename T>\nclass vector {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  vector() = default;\n  vector(initializer_list<T>) {}\n\n  void push_back(const T &) {}\n  void push_back(T &&) {}\n\n  template <typename... Args>\n  void emplace_back(Args &&... args){};\n  template <typename... Args>\n  iterator emplace(const_iterator pos, Args &&...args);\n  ~vector();\n};\n\ntemplate <typename T>\nclass list {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  void push_front(const T &) {}\n  void push_front(T &&) {}\n\n  void push_back(const T &) {}\n  void push_back(T &&) {}\n\n  template <typename... Args>\n  iterator emplace(const_iterator pos, Args &&...args);\n  template <typename... Args>\n  void emplace_back(Args &&... args){};\n  template <typename... Args>\n  void emplace_front(Args &&...args){};\n  ~list();\n};\n\ntemplate <typename T>\nclass deque {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  void push_back(const T &) {}\n  void push_back(T &&) {}\n\n  void push_front(const T &) {}\n  void push_front(T &&) {}\n\n  template <typename... Args>\n  iterator emplace(const_iterator pos, Args &&...args);\n  template <typename... Args>\n  void emplace_back(Args &&... args){};\n  template <typename... Args>\n  void emplace_front(Args &&...args){};\n  ~deque();\n};\n\ntemplate <typename T>\nclass forward_list {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  void push_front(const T &) {}\n  void push_front(T &&) {}\n\n  template <typename... Args>\n  void emplace_front(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_after(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename T>\nclass set {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename Key, typename T>\nclass map {\npublic:\n  using value_type = std::pair<Key, T>;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename T>\nclass multiset {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename Key, typename T>\nclass multimap {\npublic:\n  using value_type = std::pair<Key, T>;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename T>\nclass unordered_set {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename Key, typename T>\nclass unordered_map {\npublic:\n  using value_type = std::pair<Key, T>;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename T>\nclass unordered_multiset {\npublic:\n  using value_type = T;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename Key, typename T>\nclass unordered_multimap {\npublic:\n  using value_type = std::pair<Key, T>;\n\n  class iterator {};\n  class const_iterator {};\n  const_iterator begin() { return const_iterator{}; }\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n  template <typename... Args>\n  iterator emplace_hint(const_iterator pos, Args &&...args);\n};\n\ntemplate <typename T>\nclass stack {\npublic:\n  using value_type = T;\n\n  void push(const T &) {}\n  void push(T &&) {}\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n};\n\ntemplate <typename T>\nclass queue {\npublic:\n  using value_type = T;\n\n  void push(const T &) {}\n  void push(T &&) {}\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n};\n\ntemplate <typename T>\nclass priority_queue {\npublic:\n  using value_type = T;\n\n  void push(const T &) {}\n  void push(T &&) {}\n\n  template <typename... Args>\n  void emplace(Args &&...args){};\n};\n\ntemplate <typename T>\nstruct remove_reference { using type = T; };\ntemplate <typename T>\nstruct remove_reference<T &> { using type = T; };\ntemplate <typename T>\nstruct remove_reference<T &&> { using type = T; };\n\ntemplate <typename T1, typename T2>\npair<typename remove_reference<T1>::type, typename remove_reference<T2>::type>\nmake_pair(T1 &&, T2 &&) {\n  return {};\n};\n\ntemplate <typename... Ts>\nclass tuple {\npublic:\n  tuple() = default;\n  tuple(const tuple &) = default;\n  tuple(tuple &&) = default;\n\n  tuple(const Ts &...) {}\n  tuple(Ts &&...) {}\n\n  template <typename... Us>\n  tuple(const tuple<Us...> &){};\n  template <typename... Us>\n  tuple(tuple<Us...> &&) {}\n\n  template <typename U1, typename U2>\n  tuple(const pair<U1, U2> &) {\n    static_assert(sizeof...(Ts) == 2, \"Wrong tuple size\");\n  };\n  template <typename U1, typename U2>\n  tuple(pair<U1, U2> &&) {\n    static_assert(sizeof...(Ts) == 2, \"Wrong tuple size\");\n  };\n};\n\ntemplate <typename... Ts>\ntuple<typename remove_reference<Ts>::type...> make_tuple(Ts &&...) {\n  return {};\n}\n\ntemplate <typename T>\nclass unique_ptr {\npublic:\n  explicit unique_ptr(T *) {}\n  ~unique_ptr();\n};\n} // namespace std\n\nnamespace llvm {\ntemplate <typename T>\nclass LikeASmallVector {\npublic:\n  void push_back(const T &) {}\n  void push_back(T &&) {}\n\n  template <typename... Args>\n  void emplace_back(Args &&... args){};\n};\n\n} // namespace llvm\n\nvoid testInts() {\n  std::vector<int> v;\n  v.push_back(42);\n  v.push_back(int(42));\n  v.push_back(int{42});\n  v.push_back(42.0);\n  int z;\n  v.push_back(z);\n}\n\nstruct Something {\n  Something(int a, int b = 41) {}\n  Something() {}\n  void push_back(Something);\n  int getInt() { return 42; }\n};\n\nstruct Convertable {\n  operator Something() { return Something{}; }\n};\n\nstruct Zoz {\n  Zoz(Something, int = 42) {}\n};\n\nZoz getZoz(Something s) { return Zoz(s); }\n\nvoid test_Something() {\n  std::vector<Something> v;\n\n  v.push_back(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: v.emplace_back(1, 2);\n\n  v.push_back(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, 2);\n\n  v.push_back(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back();\n\n  v.push_back(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back();\n\n  Something Different;\n  v.push_back(Something(Different.getInt(), 42));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(Different.getInt(), 42);\n\n  v.push_back(Different.getInt());\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(Different.getInt());\n\n  v.push_back(42);\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(42);\n\n  Something temporary(42, 42);\n  temporary.push_back(temporary);\n  v.push_back(temporary);\n\n  v.push_back(Convertable());\n  v.push_back(Convertable{});\n  Convertable s;\n  v.push_back(s);\n}\n\ntemplate <typename ElemType>\nvoid dependOnElem() {\n  std::vector<ElemType> v;\n  v.push_back(ElemType(42));\n}\n\ntemplate <typename ContainerType>\nvoid dependOnContainer() {\n  ContainerType v;\n  v.push_back(Something(42));\n}\n\nvoid callDependent() {\n  dependOnElem<Something>();\n  dependOnContainer<std::vector<Something>>();\n}\n\nvoid test2() {\n  std::vector<Zoz> v;\n  v.push_back(Zoz(Something(21, 37)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(Something(21, 37));\n\n  v.push_back(Zoz(Something(21, 37), 42));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(Something(21, 37), 42);\n\n  v.push_back(getZoz(Something(1, 2)));\n}\n\nstruct GetPair {\n  std::pair<int, long> getPair();\n};\nvoid testPair() {\n  std::vector<std::pair<int, int>> v;\n  v.push_back(std::pair<int, int>(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, 2);\n\n  GetPair g;\n  v.push_back(g.getPair());\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(g.getPair());\n\n  std::vector<std::pair<Something, Zoz>> v2;\n  v2.push_back(std::pair<Something, Zoz>(Something(42, 42), Zoz(Something(21, 37))));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back(Something(42, 42), Zoz(Something(21, 37)));\n}\n\nvoid testTuple() {\n  std::vector<std::tuple<bool, char, int>> v;\n  v.push_back(std::tuple<bool, char, int>(false, 'x', 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(false, 'x', 1);\n\n  v.push_back(std::tuple<bool, char, int>{false, 'y', 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(false, 'y', 2);\n\n  v.push_back({true, 'z', 3});\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(true, 'z', 3);\n\n  std::vector<std::tuple<int, bool>> x;\n  x.push_back(std::make_pair(1, false));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: x.emplace_back(1, false);\n\n  x.push_back(std::make_pair(2LL, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: x.emplace_back(2LL, 1);\n}\n\nstruct Base {\n  Base(int, int *, int = 42);\n};\n\nstruct Derived : Base {\n  Derived(int *, Something) : Base(42, nullptr) {}\n};\n\nvoid testDerived() {\n  std::vector<Base> v;\n  v.push_back(Derived(nullptr, Something{}));\n}\n\nvoid testNewExpr() {\n  std::vector<Derived> v;\n  v.push_back(Derived(new int, Something{}));\n}\n\nvoid testSpaces() {\n  std::vector<Something> v;\n\n  // clang-format off\n\n  v.push_back(Something(1, //arg1\n                2 // arg2\n               ) // Something\n              );\n  // CHECK-MESSAGES: :[[@LINE-4]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, //arg1\n  // CHECK-FIXES:                2 // arg2\n  // CHECK-FIXES:                  // Something\n  // CHECK-FIXES:                );\n\n  v.push_back(    Something   (1, 2)    );\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, 2   );\n\n  v.push_back(    Something   {1, 2}    );\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, 2   );\n\n  v.push_back(  Something {}    );\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(   );\n\n  v.push_back(\n             Something(1, 2)    );\n  // CHECK-MESSAGES: :[[@LINE-2]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, 2   );\n\n  std::vector<Base> v2;\n  v2.push_back(\n    Base(42, nullptr));\n  // CHECK-MESSAGES: :[[@LINE-2]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back(42, nullptr);\n\n  // clang-format on\n}\n\nvoid testPointers() {\n  std::vector<int *> v;\n  v.push_back(new int(5));\n\n  std::vector<std::unique_ptr<int>> v2;\n  v2.push_back(std::unique_ptr<int>(new int(42)));\n  // This call can't be replaced with emplace_back.\n  // If emplacement will fail (not enough memory to add to vector)\n  // we will have leak of int because unique_ptr won't be constructed\n  // (and destructed) as in push_back case.\n\n  auto *ptr = new int;\n  v2.push_back(std::unique_ptr<int>(ptr));\n  // Same here\n}\n\nvoid testMakePair() {\n  std::vector<std::pair<int, int>> v;\n  v.push_back(std::make_pair(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, 2);\n\n  v.push_back(std::make_pair(42LL, 13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(42LL, 13);\n\n  v.push_back(std::make_pair<char, char>(0, 3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(std::make_pair<char, char>(0, 3));\n  //\n  // Even though the call above could be turned into v.emplace_back(0, 3),\n  // we don't eliminate the make_pair call here, because of the explicit\n  // template parameters provided. make_pair's arguments can be convertible\n  // to its explicitly provided template parameter, but not to the pair's\n  // element type. The examples below illustrate the problem.\n  struct D {\n    D(...) {}\n    operator char() const { return 0; }\n  };\n  v.push_back(std::make_pair<D, int>(Something(), 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(std::make_pair<D, int>(Something(), 2));\n\n  struct X {\n    X(std::pair<int, int>) {}\n  };\n  std::vector<X> x;\n  x.push_back(std::make_pair(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: x.emplace_back(std::make_pair(1, 2));\n  // make_pair cannot be removed here, as X is not constructible with two ints.\n\n  struct Y {\n    Y(std::pair<int, int> &&) {}\n  };\n  std::vector<Y> y;\n  y.push_back(std::make_pair(2, 3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: y.emplace_back(std::make_pair(2, 3));\n  // make_pair cannot be removed here, as Y is not constructible with two ints.\n}\n\nvoid testMakeTuple() {\n  std::vector<std::tuple<int, bool, char>> v;\n  v.push_back(std::make_tuple(1, true, 'v'));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1, true, 'v');\n\n  v.push_back(std::make_tuple(2ULL, 1, 0));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(2ULL, 1, 0);\n\n  v.push_back(std::make_tuple<long long, int, int>(3LL, 1, 0));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(std::make_tuple<long long, int, int>(3LL, 1, 0));\n  // make_tuple is not removed when there are explicit template\n  // arguments provided.\n}\n\nnamespace test {\ntemplate <typename T>\nstruct Single {\n  Single() = default;\n  Single(const Single &) = default;\n  Single(Single &&) = default;\n\n  Single(const T &) {}\n  Single(T &&) {}\n\n  template <typename U>\n  Single(const Single<U> &) {}\n  template <typename U>\n  Single(Single<U> &&) {}\n\n  template <typename U>\n  Single(const std::tuple<U> &) {}\n  template <typename U>\n  Single(std::tuple<U> &&) {}\n};\n\ntemplate <typename T>\nSingle<typename std::remove_reference<T>::type> MakeSingle(T &&) {\n  return {};\n}\n} // namespace test\n\nvoid testOtherTuples() {\n  std::vector<test::Single<int>> v;\n  v.push_back(test::Single<int>(1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(1);\n\n  v.push_back({2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(2);\n\n  v.push_back(test::MakeSingle(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(3);\n\n  v.push_back(test::MakeSingle<long long>(4));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(test::MakeSingle<long long>(4));\n  // We don't remove make functions with explicit template parameters.\n\n  v.push_back(test::MakeSingle(5LL));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(5LL);\n\n  v.push_back(std::make_tuple(6));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(6);\n\n  v.push_back(std::make_tuple(7LL));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(7LL);\n}\n\nvoid testOtherContainers() {\n  std::list<Something> l;\n  l.push_back(Something(42, 41));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: l.emplace_back(42, 41);\n\n  l.push_front(Something(42, 41));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_front\n  // CHECK-FIXES: l.emplace_front(42, 41);\n\n  std::deque<Something> d;\n  d.push_back(Something(42));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: d.emplace_back(42);\n\n  d.push_front(Something(42));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_front\n  // CHECK-FIXES: d.emplace_front(42);\n\n  llvm::LikeASmallVector<Something> ls;\n  ls.push_back(Something(42));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: ls.emplace_back(42);\n\n  std::stack<Something> s;\n  s.push(Something(42, 41));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace\n  // CHECK-FIXES: s.emplace(42, 41);\n\n  std::queue<Something> q;\n  q.push(Something(42, 41));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace\n  // CHECK-FIXES: q.emplace(42, 41);\n\n  std::priority_queue<Something> pq;\n  pq.push(Something(42, 41));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace\n  // CHECK-FIXES: pq.emplace(42, 41);\n\n  std::forward_list<Something> fl;\n  fl.push_front(Something(42, 41));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_front\n  // CHECK-FIXES: fl.emplace_front(42, 41);\n}\n\nclass IntWrapper {\npublic:\n  IntWrapper(int x) : value(x) {}\n  IntWrapper operator+(const IntWrapper other) const {\n    return IntWrapper(value + other.value);\n  }\n\nprivate:\n  int value;\n};\n\nvoid testMultipleOpsInPushBack() {\n  std::vector<IntWrapper> v;\n  v.push_back(IntWrapper(42) + IntWrapper(27));\n}\n\n// Macro tests.\n#define PUSH_BACK_WHOLE(c, x) c.push_back(x)\n#define PUSH_BACK_NAME push_back\n#define PUSH_BACK_ARG(x) (x)\n#define SOME_OBJ Something(10)\n#define MILLION 3\n#define SOME_WEIRD_PUSH(v) v.push_back(Something(\n#define OPEN (\n#define CLOSE )\nvoid macroTest() {\n  std::vector<Something> v;\n  Something s;\n\n  PUSH_BACK_WHOLE(v, Something(5, 6));\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use emplace_back\n\n  v.PUSH_BACK_NAME(Something(5));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n\n  v.push_back PUSH_BACK_ARG(Something(5, 6));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n\n  v.push_back(SOME_OBJ);\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n\n  v.push_back(Something(MILLION));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(MILLION);\n\n  // clang-format off\n  v.push_back(  Something OPEN 3 CLOSE  );\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // clang-format on\n  PUSH_BACK_WHOLE(s, Something(1));\n}\n\nstruct A {\n  int value1, value2;\n};\n\nstruct B {\n  B(A) {}\n};\n\nstruct C {\n  int value1, value2, value3;\n};\n\nvoid testAggregation() {\n  // This should not be noticed or fixed; after the correction, the code won't\n  // compile.\n\n  std::vector<A> v;\n  v.push_back(A({1, 2}));\n\n  std::vector<B> vb;\n  vb.push_back(B({10, 42}));\n}\n\nstruct Bitfield {\n  unsigned bitfield : 1;\n  unsigned notBitfield;\n};\n\nvoid testBitfields() {\n  std::vector<Something> v;\n  Bitfield b;\n  v.push_back(Something(42, b.bitfield));\n  v.push_back(Something(b.bitfield));\n\n  v.push_back(Something(42, b.notBitfield));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(42, b.notBitfield);\n  int var;\n  v.push_back(Something(42, var));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(42, var);\n}\n\nclass PrivateCtor {\n  PrivateCtor(int z);\n\npublic:\n  void doStuff() {\n    std::vector<PrivateCtor> v;\n    // This should not change it because emplace back doesn't have permission.\n    // Check currently doesn't support friend declarations because pretty much\n    // nobody would want to be friend with std::vector :(.\n    v.push_back(PrivateCtor(42));\n  }\n};\n\nstruct WithDtor {\n  WithDtor(int) {}\n  ~WithDtor();\n};\n\nvoid testWithDtor() {\n  std::vector<WithDtor> v;\n\n  v.push_back(WithDtor(42));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back\n  // CHECK-FIXES: v.emplace_back(42);\n}\n\nvoid testInitializerList() {\n  std::vector<std::vector<int>> v;\n  v.push_back(std::vector<int>({1}));\n  // Test against the bug reported in PR32896.\n\n  v.push_back({{2}});\n\n  using PairIntVector = std::pair<int, std::vector<int>>;\n  std::vector<PairIntVector> x;\n  x.push_back(PairIntVector(3, {4}));\n  x.push_back({5, {6}});\n}\n\nclass Foo {\npublic:\n  Foo(){};\n  Foo(int){};\n  Foo(int, int){};\n  Foo(std::pair<int, int>){};\n\nprotected:\n  Foo(char *) : Foo(){};\n};\n\nvoid testSomeEmplaceCases() {\n  std::vector<std::pair<char *, char *>> v1;\n  std::vector<Foo> v2;\n  std::unordered_map<int, char *> m1;\n\n  v1.emplace_back(std::make_pair(\"foo\", \"bar\"));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v1.emplace_back(\"foo\", \"bar\");\n\n  char *foo = \"bar\";\n  v1.emplace_back(std::make_pair(foo, \"bar\"));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v1.emplace_back(foo, \"bar\");\n\n  v1.emplace(v1.begin(), std::make_pair(\"foo\", \"bar\"));\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: v1.emplace(v1.begin(), \"foo\", \"bar\");\n\n  v2.emplace_back(Foo());\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n\n  v2.emplace_back(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back(13);\n\n  v2.emplace_back(Foo{13});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back(13);\n\n  int a = 31;\n  v2.emplace_back(Foo(13, a));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back(13, a);\n\n  v2.emplace_back(std::make_pair(3, 3));\n\n  m1.emplace(std::make_pair(13, \"foo\"));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: m1.emplace(13, \"foo\");\n\n  std::vector<std::pair<int, int>> v3;\n  v3.emplace_back(std::pair<int, int>(13, 71));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  v3.emplace_back(std::make_pair(13, 71));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n\n  std::vector<std::tuple<int, int, int>> v4;\n  v4.emplace_back(std::tuple<int, int, int>(13, 31, 71));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  v4.emplace_back(std::make_tuple(13, 31, 71));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n\n  std::vector<test::Single<int>> v5;\n  v5.emplace_back(test::Single<int>(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  v5.emplace_back(test::MakeSingle(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n}\n\nvoid testAllSTLEmplacyFunctions() {\n  std::vector<Foo> vector;\n  std::deque<Foo> deque;\n  std::forward_list<Foo> forward_list;\n  std::list<Foo> list;\n  std::set<Foo> set;\n  std::map<int, Foo> map;\n  std::multiset<Foo> multiset;\n  std::multimap<int, Foo> multimap;\n  std::unordered_set<Foo> unordered_set;\n  std::unordered_map<int, Foo> unordered_map;\n  std::unordered_multiset<Foo> unordered_multiset;\n  std::unordered_multimap<int, Foo> unordered_multimap;\n  std::stack<Foo> stack;\n  std::queue<Foo> queue;\n  std::priority_queue<Foo> priority_queue;\n\n  vector.emplace_back(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: vector.emplace_back(13);\n\n  vector.emplace(vector.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: vector.emplace(vector.begin(), 13);\n\n  deque.emplace(deque.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: deque.emplace(deque.begin(), 13);\n\n  deque.emplace_front(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: deque.emplace_front(13);\n\n  deque.emplace_back(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: deque.emplace_back(13);\n\n  forward_list.emplace_after(forward_list.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:52: warning: unnecessary temporary object created while calling emplace_after\n  // CHECK-FIXES: forward_list.emplace_after(forward_list.begin(), 13);\n\n  forward_list.emplace_front(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: forward_list.emplace_front(13);\n\n  list.emplace(list.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: list.emplace(list.begin(), 13);\n\n  list.emplace_back(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: list.emplace_back(13);\n\n  list.emplace_front(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: list.emplace_front(13);\n\n  set.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: set.emplace(13);\n\n  set.emplace_hint(set.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:33: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: set.emplace_hint(set.begin(), 13);\n\n  map.emplace(std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: map.emplace(13, Foo(13));\n\n  map.emplace_hint(map.begin(), std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:33: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: map.emplace_hint(map.begin(), 13, Foo(13));\n\n  multiset.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: multiset.emplace(13);\n\n  multiset.emplace_hint(multiset.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:43: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: multiset.emplace_hint(multiset.begin(), 13);\n\n  multimap.emplace(std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: multimap.emplace(13, Foo(13));\n\n  multimap.emplace_hint(multimap.begin(), std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:43: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: multimap.emplace_hint(multimap.begin(), 13, Foo(13));\n\n  unordered_set.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: unordered_set.emplace(13);\n\n  unordered_set.emplace_hint(unordered_set.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:53: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: unordered_set.emplace_hint(unordered_set.begin(), 13);\n\n  unordered_map.emplace(std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: unordered_map.emplace(13, Foo(13));\n\n  unordered_map.emplace_hint(unordered_map.begin(), std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:53: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: unordered_map.emplace_hint(unordered_map.begin(), 13, Foo(13));\n\n  unordered_multiset.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: unordered_multiset.emplace(13);\n  unordered_multiset.emplace_hint(unordered_multiset.begin(), Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:63: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: unordered_multiset.emplace_hint(unordered_multiset.begin(), 13);\n\n  unordered_multimap.emplace(std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: unordered_multimap.emplace(13, Foo(13));\n  unordered_multimap.emplace_hint(unordered_multimap.begin(), std::make_pair(13, Foo(13)));\n  // CHECK-MESSAGES: :[[@LINE-1]]:63: warning: unnecessary temporary object created while calling emplace_hint\n  // CHECK-FIXES: unordered_multimap.emplace_hint(unordered_multimap.begin(), 13, Foo(13));\n\n  stack.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: stack.emplace(13);\n\n  queue.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: queue.emplace(13);\n\n  priority_queue.emplace(Foo(13));\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: priority_queue.emplace(13);\n}\n\nvoid test_AliasEmplacyFunctions() {\n  typedef std::list<Foo> L;\n  using DQ = std::deque<Foo>;\n  L l;\n  l.emplace_back(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: l.emplace_back(3);\n\n  DQ dq;\n  dq.emplace_back(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: dq.emplace_back(3);\n\n  typedef std::stack<Foo> STACK;\n  using PQ = std::priority_queue<Foo>;\n  STACK stack;\n  stack.emplace(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: stack.emplace(3);\n\n  PQ pq;\n  pq.emplace(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: pq.emplace(3);\n\n  typedef std::forward_list<Foo> FL;\n  using DQ2 = std::deque<Foo>;\n  FL fl;\n  fl.emplace_front(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: fl.emplace_front(3);\n\n  DQ2 dq2;\n  dq2.emplace_front(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: dq2.emplace_front(3);\n}\n\nvoid test_Alias() {\n  typedef std::list<Foo> L;\n  using DQ = std::deque<Foo>;\n  L l;\n  l.push_back(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: l.emplace_back(3);\n\n  DQ dq;\n  dq.push_back(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: dq.emplace_back(3);\n\n  typedef std::stack<Foo> STACK;\n  using PQ = std::priority_queue<Foo>;\n  STACK stack;\n  stack.push(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use emplace instead of push [modernize-use-emplace]\n  // CHECK-FIXES: stack.emplace(3);\n\n  PQ pq;\n  pq.push(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace instead of push [modernize-use-emplace]\n  // CHECK-FIXES: pq.emplace(3);\n\n  typedef std::forward_list<Foo> FL;\n  using DQ2 = std::deque<Foo>;\n  FL fl;\n  fl.push_front(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_front instead of push_front [modernize-use-emplace]\n  // CHECK-FIXES: fl.emplace_front(3);\n\n  DQ2 dq2;\n  dq2.push_front(Foo(3));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_front instead of push_front [modernize-use-emplace]\n  // CHECK-FIXES: dq2.emplace_front(3);\n}\n\nstruct Bar {\npublic:\n  Bar(){};\n  void testWithPrivateAndProtectedCtor() {\n    std::vector<Bar> vec;\n\n    vec.emplace_back(Bar(13));\n    vec.emplace_back(Bar(13, 13));\n  }\n\nprotected:\n  Bar(int){};\n\nprivate:\n  Bar(int, int){};\n};\n\nvoid testPossibleFalsePositives() {\n  struct Y {\n    Y(std::pair<int, int> &&) {}\n  };\n  std::vector<Y> y;\n  y.emplace_back(std::make_pair(2, 3));\n\n  std::vector<std::pair<int, int>> v;\n  v.emplace_back(std::make_pair<char, char>(0, 3));\n\n  struct D {\n    D(...) {}\n    operator char() const { return 0; }\n  };\n  v.emplace_back(std::make_pair<D, int>(Something(), 2));\n}\n\nstruct InnerType {\n  InnerType();\n  InnerType(char const*);\n};\n\nstruct NonTrivialNoCtor {\n  InnerType it;\n};\n\nstruct NonTrivialWithVector {\n  std::vector<int> it;\n};\n\nstruct NonTrivialWithIntAndVector {\n  int x;\n  std::vector<int> it;\n};\n\nstruct NonTrivialWithCtor {\n  NonTrivialWithCtor();\n  NonTrivialWithCtor(std::vector<int> const&);\n};\n\nvoid testBracedInitTemporaries() {\n  std::vector<NonTrivialNoCtor> v1;\n\n  v1.push_back(NonTrivialNoCtor());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back(NonTrivialNoCtor{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back({});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back(NonTrivialNoCtor{InnerType{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back({InnerType{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back(NonTrivialNoCtor{InnerType()});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back({InnerType()});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.push_back({{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n\n  v1.emplace_back(NonTrivialNoCtor());\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.emplace_back(NonTrivialNoCtor{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.emplace_back(NonTrivialNoCtor{InnerType{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n  v1.emplace_back(NonTrivialNoCtor{{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v1.emplace_back();\n\n  // These should not be noticed or fixed; after the correction, the code won't\n  // compile.\n  v1.push_back(NonTrivialNoCtor{\"\"});\n  v1.push_back({\"\"});\n  v1.push_back(NonTrivialNoCtor{InnerType{\"\"}});\n  v1.push_back({InnerType{\"\"}});\n  v1.emplace_back(NonTrivialNoCtor{\"\"});\n\n  std::vector<NonTrivialWithVector> v2;\n\n  v2.push_back(NonTrivialWithVector());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back(NonTrivialWithVector{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back({});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back(NonTrivialWithVector{std::vector<int>{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back({std::vector<int>{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back(NonTrivialWithVector{std::vector<int>()});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back({std::vector<int>()});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.push_back({{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n\n  v2.emplace_back(NonTrivialWithVector());\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.emplace_back(NonTrivialWithVector{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.emplace_back(NonTrivialWithVector{std::vector<int>{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n  v2.emplace_back(NonTrivialWithVector{{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v2.emplace_back();\n\n\n  // These should not be noticed or fixed; after the correction, the code won't\n  // compile.\n  v2.push_back(NonTrivialWithVector{{0}});\n  v2.push_back({{0}});\n  v2.push_back(NonTrivialWithVector{std::vector<int>{0}});\n  v2.push_back({std::vector<int>{0}});\n  v2.emplace_back(NonTrivialWithVector{std::vector<int>{0}});\n\n  std::vector<NonTrivialWithCtor> v3;\n\n  v3.push_back(NonTrivialWithCtor());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back();\n  v3.push_back(NonTrivialWithCtor{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back();\n  v3.push_back({});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back();\n  v3.push_back(NonTrivialWithCtor{std::vector<int>()});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>());\n  v3.push_back(NonTrivialWithCtor{std::vector<int>{0}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>{0});\n  v3.push_back(NonTrivialWithCtor{std::vector<int>{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>{});\n  v3.push_back({std::vector<int>{0}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>{0});\n  v3.push_back({std::vector<int>{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>{});\n\n  v3.emplace_back(NonTrivialWithCtor());\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v3.emplace_back();\n  v3.emplace_back(NonTrivialWithCtor{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v3.emplace_back();\n  v3.emplace_back(NonTrivialWithCtor{std::vector<int>{}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>{});\n  v3.emplace_back(NonTrivialWithCtor{std::vector<int>{0}});\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: v3.emplace_back(std::vector<int>{0});\n\n  // These should not be noticed or fixed; after the correction, the code won't\n  // compile.\n  v3.push_back(NonTrivialWithCtor{{0}});\n  v3.push_back(NonTrivialWithCtor{{}});\n  v3.push_back({{0}});\n  v3.push_back({{}});\n\n  std::vector<NonTrivialWithIntAndVector> v4;\n\n  // These should not be noticed or fixed; after the correction, the code won't\n  // compile.\n  v4.push_back(NonTrivialWithIntAndVector{1, {}});\n  v4.push_back(NonTrivialWithIntAndVector{});\n  v4.push_back({});\n}\n\nvoid testWithPointerTypes() {\n  std::list<Something> l;\n  std::list<Something>* lp = &l;\n  std::stack<Something> s;\n  std::stack<Something>* sp;\n\n  lp->push_back(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_back(1, 2);\n  lp->push_front(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_front instead of push_front [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_front(1, 2);\n  sp->push(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace instead of push [modernize-use-emplace]\n  // CHECK-FIXES: sp->emplace(1, 2);\n\n  lp->push_back(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_back(1, 2);\n  lp->push_front(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_front instead of push_front [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_front(1, 2);\n  sp->push(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace instead of push [modernize-use-emplace]\n  // CHECK-FIXES: sp->emplace(1, 2);\n\n  lp->push_back(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_back();\n  lp->push_front(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_front instead of push_front [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_front();\n  sp->push(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace instead of push [modernize-use-emplace]\n  // CHECK-FIXES: sp->emplace();\n\n  lp->push_back(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_back instead of push_back [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_back();\n  lp->push_front(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace_front instead of push_front [modernize-use-emplace]\n  // CHECK-FIXES: lp->emplace_front();\n  sp->push(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use emplace instead of push [modernize-use-emplace]\n  // CHECK-FIXES: sp->emplace();\n\n  lp->emplace_back(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: lp->emplace_back(1, 2);\n  lp->emplace_front(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: lp->emplace_front(1, 2);\n  sp->emplace(Something(1, 2));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: sp->emplace(1, 2);\n\n  lp->emplace_back(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: lp->emplace_back(1, 2);\n  lp->emplace_front(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: lp->emplace_front(1, 2);\n  sp->emplace(Something{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: sp->emplace(1, 2);\n\n  lp->emplace_back(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: lp->emplace_back();\n  lp->emplace_front(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: lp->emplace_front();\n  sp->emplace(Something());\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: sp->emplace();\n\n  lp->emplace_back(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: unnecessary temporary object created while calling emplace_back\n  // CHECK-FIXES: lp->emplace_back();\n  lp->emplace_front(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: unnecessary temporary object created while calling emplace_front\n  // CHECK-FIXES: lp->emplace_front();\n  sp->emplace(Something{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: unnecessary temporary object created while calling emplace\n  // CHECK-FIXES: sp->emplace();\n}"
    }
  ]
}