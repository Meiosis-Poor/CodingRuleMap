{
  "name": "UseNullptr",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-use-nullptr",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 526,
  "branches": 76,
  "apis": 255,
  "test": [
    {
      "description": null,
      "expected-problems": 33,
      "expected-linenumbers": [
        82,
        93,
        100,
        118,
        122,
        126,
        132,
        136,
        155,
        158,
        164,
        167,
        174,
        177,
        190,
        193,
        206,
        207,
        215,
        218,
        228,
        241,
        248,
        260,
        281,
        292,
        313,
        314,
        317,
        320,
        324,
        325,
        326
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes %s modernize-use-nullptr %t -- \\\n// RUN:   -config=\"{CheckOptions: {modernize-use-nullptr.NullMacros: 'MY_NULL,NULL'}}\"\n\n#define NULL 0\n\nnamespace std {\n\ntypedef decltype(nullptr) nullptr_t;\n\n} // namespace std\n\n// Just to make sure make_null() could have side effects.\nvoid external();\n\nstd::nullptr_t make_null() {\n  external();\n  return nullptr;\n}\n\nvoid func() {\n  void *CallTest = make_null();\n\n  int var = 1;\n  void *CommaTest = (var+=2, make_null());\n\n  int *CastTest = static_cast<int*>(make_null());\n}\n\nvoid dummy(int*) {}\nvoid side_effect() {}\n\n#define MACRO_EXPANSION_HAS_NULL \\\n  void foo() { \\\n    dummy(0); \\\n    dummy(NULL); \\\n    side_effect(); \\\n  }\n\nMACRO_EXPANSION_HAS_NULL;\n#undef MACRO_EXPANSION_HAS_NULL\n\n\nvoid test_macro_expansion1() {\n#define MACRO_EXPANSION_HAS_NULL \\\n  dummy(NULL); \\\n  side_effect();\n\n  MACRO_EXPANSION_HAS_NULL;\n\n#undef MACRO_EXPANSION_HAS_NULL\n}\n\n// Test macro expansion with cast sequence, PR15572.\nvoid test_macro_expansion2() {\n#define MACRO_EXPANSION_HAS_NULL \\\n  dummy((int*)0); \\\n  side_effect();\n\n  MACRO_EXPANSION_HAS_NULL;\n\n#undef MACRO_EXPANSION_HAS_NULL\n}\n\nvoid test_macro_expansion3() {\n#define MACRO_EXPANSION_HAS_NULL \\\n  dummy(NULL); \\\n  side_effect();\n\n#define OUTER_MACRO \\\n  MACRO_EXPANSION_HAS_NULL; \\\n  side_effect();\n\n  OUTER_MACRO;\n\n#undef OUTER_MACRO\n#undef MACRO_EXPANSION_HAS_NULL\n}\n\nvoid test_macro_expansion4() {\n#define MY_NULL NULL\n  int *p = MY_NULL;\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: use nullptr [modernize-use-nullptr]\n  // CHECK-FIXES: int *p = nullptr;\n#undef MY_NULL\n}\n\ntemplate <typename T> struct pear {\n  // If you say __null (or NULL), we assume that T will always be a pointer\n  // type, so we suggest replacing it with nullptr. (We only check __null here,\n  // because in this test NULL is defined as 0, but real library implementations\n  // it is often defined as __null and the check will catch it.)\n  void f() { x = __null; }\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: use nullptr [modernize-use-nullptr]\n  // CHECK-FIXES: x = nullptr;\n\n  // But if you say 0, we allow the possibility that T can be used with integral\n  // and pointer types, and \"0\" is an acceptable initializer (even if \"{}\" might\n  // be even better).\n  void g() { y = 0; }\n  // CHECK-MESSAGES-NOT: :[[@LINE-1]] warning: use nullptr\n\n  T x;\n  T y;\n};\nvoid test_templated() {\n  pear<int*> p;\n  p.f();\n  p.g();\n  dummy(p.x);\n}\n\n#define IS_EQ(x, y) if (x != y) return;\nvoid test_macro_args() {\n  int i = 0;\n  int *Ptr;\n\n  IS_EQ(static_cast<int*>(0), Ptr);\n  // CHECK-MESSAGES: :[[@LINE-1]]:27: warning: use nullptr\n  // CHECK-FIXES: IS_EQ(static_cast<int*>(nullptr), Ptr);\n\n  IS_EQ(0, Ptr);    // literal\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use nullptr\n  // CHECK-FIXES: IS_EQ(nullptr, Ptr);\n\n  IS_EQ(NULL, Ptr); // macro\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use nullptr\n  // CHECK-FIXES: IS_EQ(nullptr, Ptr);\n\n  // These are ok since the null literal is not spelled within a macro.\n#define myassert(x) if (!(x)) return;\n  myassert(0 == Ptr);\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: use nullptr\n  // CHECK-FIXES: myassert(nullptr == Ptr);\n\n  myassert(NULL == Ptr);\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: use nullptr\n  // CHECK-FIXES: myassert(nullptr == Ptr);\n\n  // These are bad as the null literal is buried in a macro.\n#define BLAH(X) myassert(0 == (X));\n#define BLAH2(X) myassert(NULL == (X));\n  BLAH(Ptr);\n  BLAH2(Ptr);\n\n  // Same as above but testing extra macro expansion.\n#define EXPECT_NULL(X) IS_EQ(0, X);\n#define EXPECT_NULL2(X) IS_EQ(NULL, X);\n  EXPECT_NULL(Ptr);\n  EXPECT_NULL2(Ptr);\n\n  // Almost the same as above but now null literal is not in a macro so ok\n  // to transform.\n#define EQUALS_PTR(X) IS_EQ(X, Ptr);\n  EQUALS_PTR(0);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: use nullptr\n  // CHECK-FIXES: EQUALS_PTR(nullptr);\n  EQUALS_PTR(NULL);\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: use nullptr\n  // CHECK-FIXES: EQUALS_PTR(nullptr);\n\n  // Same as above but testing extra macro expansion.\n#define EQUALS_PTR_I(X) EQUALS_PTR(X)\n  EQUALS_PTR_I(0);\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use nullptr\n  // CHECK-FIXES: EQUALS_PTR_I(nullptr);\n  EQUALS_PTR_I(NULL);\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use nullptr\n  // CHECK-FIXES: EQUALS_PTR_I(nullptr);\n\n  // Ok since null literal not within macro. However, now testing macro\n  // used as arg to another macro.\n#define decorate(EXPR) side_effect(); EXPR;\n  decorate(IS_EQ(NULL, Ptr));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: use nullptr\n  // CHECK-FIXES: decorate(IS_EQ(nullptr, Ptr));\n  decorate(IS_EQ(0, Ptr));\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: use nullptr\n  // CHECK-FIXES: decorate(IS_EQ(nullptr, Ptr));\n\n  // This macro causes a NullToPointer cast to happen where 0 is assigned to z\n  // but the 0 literal cannot be replaced because it is also used as an\n  // integer in the comparison.\n#define INT_AND_PTR_USE(X) do { int *z = X; if (X == 4) break; } while(false)\n  INT_AND_PTR_USE(0);\n\n  // Both uses of X in this case result in NullToPointer casts so replacement\n  // is possible.\n#define PTR_AND_PTR_USE(X) do { int *z = X; if (X != z) break; } while(false)\n  PTR_AND_PTR_USE(0);\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use nullptr\n  // CHECK-FIXES: PTR_AND_PTR_USE(nullptr);\n  PTR_AND_PTR_USE(NULL);\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use nullptr\n  // CHECK-FIXES: PTR_AND_PTR_USE(nullptr);\n\n#define OPTIONAL_CODE(...) __VA_ARGS__\n#define NOT_NULL dummy(0)\n#define CALL(X) X\n  OPTIONAL_CODE(NOT_NULL);\n  CALL(NOT_NULL);\n\n#define ENTRY(X) {X}\n  struct A {\n    int *Ptr;\n  } a[2] = {ENTRY(0), {0}};\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use nullptr\n  // CHECK-MESSAGES: :[[@LINE-2]]:24: warning: use nullptr\n  // CHECK-FIXES: a[2] = {ENTRY(nullptr), {nullptr}};\n#undef ENTRY\n\n#define assert1(expr) (expr) ? 0 : 1\n#define assert2 assert1\n  int *p;\n  assert2(p == 0);\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use nullptr\n  // CHECK-FIXES: assert2(p == nullptr);\n  assert2(p == NULL);\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use nullptr\n  // CHECK-FIXES: assert2(p == nullptr);\n#undef assert2\n#undef assert1\n\n#define ASSERT_EQ(a, b) a == b\n#define ASSERT_NULL(x) ASSERT_EQ(static_cast<void *>(NULL), x)\n  int *pp;\n  ASSERT_NULL(pp);\n  ASSERT_NULL(NULL);\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: use nullptr\n  // CHECK-FIXES: ASSERT_NULL(nullptr);\n#undef ASSERT_NULL\n#undef ASSERT_EQ\n}\n\n// One of the ancestor of the cast is a NestedNameSpecifierLoc.\nclass NoDef;\nchar function(NoDef *p);\n#define F(x) (sizeof(function(x)) == 1)\ntemplate<class T, T t>\nclass C {};\nC<bool, F(0)> c;\n// CHECK-MESSAGES: :[[@LINE-1]]:11: warning: use nullptr\n// CHECK-FIXES: C<bool, F(nullptr)> c;\n#undef F\n\n// Test default argument expression.\nstruct D {\n  explicit D(void *t, int *c = NULL) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: use nullptr\n  // CHECK-FIXES: explicit D(void *t, int *c = nullptr) {}\n};\n\nvoid test_default_argument() {\n  D(nullptr);\n}\n\n// Test on two neighbour CXXDefaultArgExprs nodes.\ntypedef unsigned long long uint64;\nstruct ZZ {\n  explicit ZZ(uint64, const uint64* = NULL) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:39: warning: use nullptr\n// CHECK-FIXES: explicit ZZ(uint64, const uint64* = nullptr) {}\n  operator bool()  { return true; }\n};\n\nuint64 Hash(uint64 seed = 0) { return 0; }\n\nvoid f() {\n  bool a;\n  a = ZZ(Hash());\n}\n\n// Test on ignoring substituted template types.\ntemplate<typename T>\nclass TemplateClass {\n public:\n  explicit TemplateClass(int a, T default_value = 0) {}\n\n  void h(T *default_value = 0) {}\n\n  void f(int* p = 0) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use nullptr\n// CHECK-FIXES: void f(int* p = nullptr) {}\n};\n\nvoid IgnoreSubstTemplateType() {\n  TemplateClass<int*> a(1);\n}\n\n// Test on casting nullptr.\nstruct G {\n  explicit G(bool, const char * = NULL) {}\n  // CHECK-MESSAGES: :[[@LINE-1]]:35: warning: use nullptr\n  // CHECK-FIXES: explicit G(bool, const char * = nullptr) {}\n};\nbool g(const char*);\nvoid test_cast_nullptr() {\n  G(g(nullptr));\n  G(g((nullptr)));\n  G(g(static_cast<char*>(nullptr)));\n  G(g(static_cast<const char*>(nullptr)));\n}\n\n// Test on recognizing multiple NULLs.\nclass H {\npublic:\n  H(bool);\n};\n\n#define T(expression) H(expression);\nbool h(int *, int *, int * = nullptr);\nvoid test_multiple_nulls() {\n  T(h(NULL, NULL));\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use nullptr\n// CHECK-MESSAGES: :[[@LINE-2]]:13: warning: use nullptr\n// CHECK-FIXES: T(h(nullptr, nullptr));\n  T(h(NULL, nullptr));\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use nullptr\n// CHECK-FIXES: T(h(nullptr, nullptr));\n  T(h(nullptr, NULL));\n// CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use nullptr\n// CHECK-FIXES: T(h(nullptr, nullptr));\n  T(h(nullptr, nullptr));\n  T(h(NULL, NULL, NULL));\n// CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use nullptr\n// CHECK-MESSAGES: :[[@LINE-2]]:13: warning: use nullptr\n// CHECK-MESSAGES: :[[@LINE-3]]:19: warning: use nullptr\n// CHECK-FIXES: T(h(nullptr, nullptr, nullptr));\n}\n#undef T"
    }
  ]
}