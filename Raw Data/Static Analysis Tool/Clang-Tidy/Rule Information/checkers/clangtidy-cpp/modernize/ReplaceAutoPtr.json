{
  "name": "ReplaceAutoPtr",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-replace-auto-ptr",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 150,
  "branches": 10,
  "apis": 90,
  "test": [
    {
      "description": null,
      "expected-problems": 57,
      "expected-linenumbers": [
        11,
        17,
        23,
        26,
        33,
        37,
        45,
        49,
        58,
        61,
        72,
        77,
        80,
        85,
        86,
        90,
        96,
        101,
        106,
        109,
        112,
        117,
        120,
        121,
        126,
        127,
        132,
        137,
        143,
        148,
        153,
        162,
        169,
        173,
        181,
        184,
        188,
        192,
        203,
        208,
        240,
        244,
        250,
        254,
        259,
        264,
        268,
        274,
        277,
        282,
        283,
        284,
        288,
        289,
        294,
        297,
        301
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes %s modernize-replace-auto-ptr %t -- -- -I %S/Inputs/replace-auto-ptr\n\n// CHECK-FIXES: #include <utility>\n\n#include \"memory.h\"\n\n// Instrumentation for auto_ptr_ref test.\nstruct Base {};\nstruct Derived : Base {};\nstd::auto_ptr<Derived> create_derived_ptr();\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: auto_ptr is deprecated, use unique_ptr instead [modernize-replace-auto-ptr]\n// CHECK-FIXES: std::unique_ptr<Derived> create_derived_ptr();\n\n\n// Test function return values (declaration)\nstd::auto_ptr<char> f_5();\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: auto_ptr is deprecated\n// CHECK-FIXES: std::unique_ptr<char> f_5()\n\n\n// Test function parameters.\nvoid f_6(std::auto_ptr<int>);\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: auto_ptr is deprecated\n// CHECK-FIXES: void f_6(std::unique_ptr<int>);\nvoid f_7(const std::auto_ptr<int> &);\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: auto_ptr is deprecated\n// CHECK-FIXES: void f_7(const std::unique_ptr<int> &);\n\n\n// Test on record type fields.\nstruct A {\n  std::auto_ptr<int> field;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> field;\n\n  typedef std::auto_ptr<int> int_ptr_type;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: auto_ptr is deprecated\n  // CHECK-FIXES: typedef std::unique_ptr<int> int_ptr_type;\n};\n\n\n// FIXME: Test template WITH instantiation.\ntemplate <typename T> struct B {\n  typedef typename std::auto_ptr<T> created_type;\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: auto_ptr is deprecated\n  // CHECK-FIXES: typedef typename std::unique_ptr<T> created_type;\n\n  created_type create() { return std::auto_ptr<T>(new T()); }\n  // CHECK-MESSAGES: :[[@LINE-1]]:39: warning: auto_ptr is deprecated\n  // CHECK-FIXES: created_type create() { return std::unique_ptr<T>(new T()); }\n};\n\n\n// Test 'using' in a namespace (declaration)\nnamespace ns_1 {\n// Test multiple using declarations.\n  using std::auto_ptr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: auto_ptr is deprecated\n  // CHECK-FIXES: using std::unique_ptr;\n  using std::auto_ptr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: auto_ptr is deprecated\n  // CHECK-FIXES: using std::unique_ptr;\n}\n\n\nnamespace ns_2 {\ntemplate <typename T> struct auto_ptr {};\n}\n\nvoid f_1() {\n  std::auto_ptr<int> a;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> a;\n\n  // Check that spaces aren't modified unnecessarily.\n  std:: auto_ptr <int> b;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std:: unique_ptr <int> b;\n  std :: auto_ptr < char > c(new char());\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std :: unique_ptr < char > c(new char());\n\n  // Test construction from a temporary.\n  std::auto_ptr<char> d = std::auto_ptr<char>();\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-MESSAGES: :[[@LINE-2]]:32: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<char> d = std::unique_ptr<char>();\n\n  typedef std::auto_ptr<int> int_ptr_t;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: auto_ptr is deprecated\n  // CHECK-FIXES: typedef std::unique_ptr<int> int_ptr_t;\n  int_ptr_t e(new int());\n\n  // Test pointers.\n  std::auto_ptr<int> *f;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> *f;\n\n  // Test 'static' declarations.\n  static std::auto_ptr<int> g;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: auto_ptr is deprecated\n  // CHECK-FIXES: static std::unique_ptr<int> g;\n\n  // Test with cv-qualifiers.\n  const std::auto_ptr<int> h;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: auto_ptr is deprecated\n  // CHECK-FIXES: const std::unique_ptr<int> h;\n  volatile std::auto_ptr<int> i;\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: auto_ptr is deprecated\n  // CHECK-FIXES: volatile std::unique_ptr<int> i;\n  const volatile std::auto_ptr<int> j;\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: auto_ptr is deprecated\n  // CHECK-FIXES: const volatile std::unique_ptr<int> j;\n\n  // Test auto and initializer-list.\n  auto k = std::auto_ptr<int>{};\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: auto_ptr is deprecated\n  // CHECK-FIXES: auto k = std::unique_ptr<int>{};\n  std::auto_ptr<int> l{std::auto_ptr<int>()};\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-MESSAGES: :[[@LINE-2]]:29: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> l{std::unique_ptr<int>()};\n\n  // Test interlocked auto_ptr.\n  std::auto_ptr<std::auto_ptr<int> > m;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-MESSAGES: :[[@LINE-2]]:22: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<std::unique_ptr<int> > m;\n\n  // Test temporaries.\n  std::auto_ptr<char>();\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<char>();\n\n  // Test void-specialization.\n  std::auto_ptr<void> n;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<void> n;\n\n  // Test template WITH instantiation (instantiation).\n  B<double> o;\n  std::auto_ptr<double> p(o.create());\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<double> p(o.create());\n\n  // Test 'using' in a namespace (\"definition\").\n  ns_1::auto_ptr<int> q;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: auto_ptr is deprecated\n  // CHECK-FIXES: ns_1::unique_ptr<int> q;\n\n  // Test construction with an 'auto_ptr_ref'.\n  std::auto_ptr<Base> r(create_derived_ptr());\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<Base> r(create_derived_ptr());\n}\n\n// Test without the nested name specifiers.\nvoid f_2() {\n  using namespace std;\n\n  auto_ptr<int> a;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: auto_ptr is deprecated\n  // CHECK-FIXES: unique_ptr<int> a;\n}\n\n// Test using declaration.\nvoid f_3() {\n  using std::auto_ptr;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: auto_ptr is deprecated\n  // CHECK-FIXES: using std::unique_ptr;\n\n  auto_ptr<int> a;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: auto_ptr is deprecated\n  // CHECK-FIXES: unique_ptr<int> a;\n}\n\n// Test messing-up with macros.\nvoid f_4() {\n#define MACRO_1 <char>\n  std::auto_ptr MACRO_1 p(new char());\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr MACRO_1 p(new char());\n#define MACRO_2 auto_ptr\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: auto_ptr is deprecated\n  // CHECK-FIXES: #define MACRO_2 unique_ptr\n  std::MACRO_2<int> q;\n#define MACRO_3(Type) std::auto_ptr<Type>\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: auto_ptr is deprecated\n  // CHECK-FIXES: #define MACRO_3(Type) std::unique_ptr<Type>\n  MACRO_3(float)r(new float());\n#define MACRO_4 std::auto_ptr\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: auto_ptr is deprecated\n  // CHECK-FIXES: #define MACRO_4 std::unique_ptr\n  using MACRO_4;\n#undef MACRO_1\n#undef MACRO_2\n#undef MACRO_3\n#undef MACRO_4\n}\n\n// Test function return values (definition).\nstd::auto_ptr<char> f_5()\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<char> f_5()\n{\n  // Test constructor.\n  return std::auto_ptr<char>(new char());\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: auto_ptr is deprecated\n  // CHECK-FIXES: return std::unique_ptr<char>(new char());\n}\n\n// Test that non-std auto_ptr aren't replaced.\nvoid f_8() {\n  ns_2::auto_ptr<char> a;\n  using namespace ns_2;\n  auto_ptr<int> b;\n}\n\n// Fail to modify when the template is never instantiated.\n//\n// This might not be an issue. If it's never used it doesn't really matter if\n// it's changed or not. If it's a header and one of the source use it, then it\n// will still be changed.\ntemplate <typename X>\nvoid f() {\n  std::auto_ptr<X> p;\n}\n\n// FIXME: Alias template could be replaced if a matcher existed.\nnamespace std {\ntemplate <typename T> using aaaaaaaa = auto_ptr<T>;\n}\n\n// We want to avoid replacing 'aaaaaaaa' by unique_ptr here. It's better to\n// change the type alias directly.\nstd::aaaaaaaa<int> d;\n\n\nvoid takes_ownership_fn(std::auto_ptr<int> x);\n// CHECK-MESSAGES: :[[@LINE-1]]:30: warning: auto_ptr is deprecated\n// CHECK-FIXES: void takes_ownership_fn(std::unique_ptr<int> x);\n\nstd::auto_ptr<int> get_by_value();\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: auto_ptr is deprecated\n// CHECK-FIXES: std::unique_ptr<int> get_by_value();\n\nclass Wrapper {\n public:\n  std::auto_ptr<int> &get_wrapped();\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n\n private:\n  std::auto_ptr<int> wrapped;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n};\n\nvoid f() {\n  std::auto_ptr<int> a, b, c;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> a, b, c;\n  Wrapper wrapper_a, wrapper_b;\n\n  a = b;\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::move to transfer ownership\n  // CHECK-FIXES: a = std::move(b);\n\n  wrapper_a.get_wrapped() = wrapper_b.get_wrapped();\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: use std::move to transfer ownership\n  // CHECK-FIXES: wrapper_a.get_wrapped() = std::move(wrapper_b.get_wrapped());\n\n  // Test that 'std::move()' is inserted when call to the\n  // copy-constructor are made.\n  takes_ownership_fn(c);\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: use std::move to transfer ownership\n  // CHECK-FIXES: takes_ownership_fn(std::move(c));\n  takes_ownership_fn(wrapper_a.get_wrapped());\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: use std::move to transfer ownership\n  // CHECK-FIXES: takes_ownership_fn(std::move(wrapper_a.get_wrapped()));\n\n  std::auto_ptr<int> d[] = { std::auto_ptr<int>(new int(1)),\n                             std::auto_ptr<int>(new int(2)) };\n  // CHECK-MESSAGES: :[[@LINE-2]]:8: warning: auto_ptr is deprecated\n  // CHECK-MESSAGES: :[[@LINE-3]]:35: warning: auto_ptr is deprecated\n  // CHECK-MESSAGES: :[[@LINE-3]]:35: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> d[] = { std::unique_ptr<int>(new int(1)),\n  // CHECK-FIXES-NEXT:                         std::unique_ptr<int>(new int(2)) };\n  std::auto_ptr<int> e = d[0];\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-MESSAGES: :[[@LINE-2]]:26: warning: use std::move to transfer ownership\n  // CHECK: std::unique_ptr<int> e = std::move(d[0]);\n\n  // Test that std::move() is not used when assigning an rvalue\n  std::auto_ptr<int> f;\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> f;\n  f = std::auto_ptr<int>(new int(0));\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: auto_ptr is deprecated\n  // CHECK-NEXT: f = std::unique_ptr<int>(new int(0));\n\n  std::auto_ptr<int> g = get_by_value();\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: auto_ptr is deprecated\n  // CHECK-FIXES: std::unique_ptr<int> g = get_by_value();\n}"
    }
  ]
}