{
  "name": "MakeUnique",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-make-unique",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 44,
  "branches": 1,
  "apis": 32,
  "test": [
    {
      "description": null,
      "expected-problems": 91,
      "expected-linenumbers": [
        82,
        88,
        94,
        99,
        104,
        117,
        122,
        127,
        132,
        137,
        145,
        150,
        161,
        172,
        175,
        179,
        182,
        221,
        239,
        252,
        255,
        260,
        263,
        268,
        271,
        276,
        279,
        287,
        292,
        297,
        302,
        307,
        312,
        317,
        320,
        333,
        336,
        341,
        344,
        349,
        352,
        357,
        360,
        365,
        370,
        376,
        379,
        384,
        389,
        393,
        396,
        400,
        403,
        407,
        410,
        414,
        417,
        421,
        424,
        428,
        431,
        435,
        438,
        442,
        445,
        449,
        452,
        456,
        459,
        464,
        467,
        471,
        475,
        480,
        493,
        500,
        507,
        512,
        518,
        526,
        531,
        539,
        542,
        545,
        554,
        560,
        581,
        584,
        587,
        590,
        611
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes -std=c++14-or-later %s modernize-make-unique %t -- -- -I %S/Inputs/smart-ptr\n\n#include \"unique_ptr.h\"\n#include \"initializer_list.h\"\n// CHECK-FIXES: #include <memory>\n\nstruct Base {\n  Base();\n  Base(int, int);\n};\n\nstruct Derived : public Base {\n  Derived();\n  Derived(int, int);\n};\n\nstruct APair {\n  int a, b;\n};\n\nstruct DPair {\n  DPair() : a(0), b(0) {}\n  DPair(int x, int y) : a(y), b(x) {}\n  int a, b;\n};\n\ntemplate<typename T>\nstruct MyVector {\n  MyVector(std::initializer_list<T>);\n};\n\nstruct Empty {};\n\n\nstruct E {\n  E(std::initializer_list<int>);\n  E();\n};\n\nstruct F {\n  F(std::initializer_list<int>);\n  F();\n  int a;\n};\n\nstruct G {\n  G(std::initializer_list<int>);\n  G(int);\n};\n\nstruct H {\n  H(std::vector<int>);\n  H(std::vector<int> &, double);\n  H(MyVector<int>, int);\n};\n\nstruct I {\n  I(G);\n};\n\nstruct J {\n  J(E e, int);\n};\n\nnamespace {\nclass Foo {};\n} // namespace\n\nnamespace bar {\nclass Bar {};\n} // namespace bar\n\ntemplate <class T>\nusing unique_ptr_ = std::unique_ptr<T>;\n\nvoid *operator new(__SIZE_TYPE__ Count, void *Ptr);\n\nint g(std::unique_ptr<int> P);\n\nstd::unique_ptr<Base> getPointer() {\n  return std::unique_ptr<Base>(new Base);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: use std::make_unique instead\n  // CHECK-FIXES: return std::make_unique<Base>();\n}\n\nstd::unique_ptr<Base> getPointerValue() {\n  return std::unique_ptr<Base>(new Base());\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: use std::make_unique instead\n  // CHECK-FIXES: return std::make_unique<Base>();\n}\n\nvoid basic() {\n  std::unique_ptr<int> P1 = std::unique_ptr<int>(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: std::unique_ptr<int> P1 = std::make_unique<int>();\n  std::unique_ptr<int> P2 = std::unique_ptr<int>(new int);\n\n  P1.reset(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: P1 = std::make_unique<int>();\n  P2.reset(new int);\n\n  P1 = std::unique_ptr<int>(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: P1 = std::make_unique<int>();\n  P1 = std::unique_ptr<int>(new int);\n\n  // Without parenthesis, default initialization.\n  std::unique_ptr<int> P3 = std::unique_ptr<int>(new int);\n\n  P2.reset(new int);\n\n  P2 = std::unique_ptr<int>(new int);\n\n  // With auto.\n  auto P4 = std::unique_ptr<int>(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use std::make_unique instead\n  // CHECK-FIXES: auto P4 = std::make_unique<int>();\n  auto P5 = std::unique_ptr<int>(new int);\n\n  std::unique_ptr<int> P6 = std::unique_ptr<int>((new int()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: std::unique_ptr<int> P6 = std::make_unique<int>();\n  std::unique_ptr<int> P7 = std::unique_ptr<int>((new int));\n\n  P4.reset((new int()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: P4 = std::make_unique<int>();\n  P5.reset((new int));\n\n  std::unique_ptr<int> P8 = std::unique_ptr<int>((((new int()))));\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: std::unique_ptr<int> P8 = std::make_unique<int>();\n  std::unique_ptr<int> P9 = std::unique_ptr<int>((((new int))));\n\n  P5.reset(((((new int())))));\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use std::make_unique instead [modernize-make-unique]\n  // CHECK-FIXES: P5 = std::make_unique<int>();\n  P6.reset(((((new int)))));\n\n  {\n    // No std.\n    using namespace std;\n    unique_ptr<int> Q = unique_ptr<int>(new int());\n    // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: use std::make_unique instead\n    // CHECK-FIXES: unique_ptr<int> Q = std::make_unique<int>();\n    unique_ptr<int> P = unique_ptr<int>(new int);\n\n    Q = unique_ptr<int>(new int());\n    // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use std::make_unique instead\n    // CHECK-FIXES: Q = std::make_unique<int>();\n\n    P = unique_ptr<int>(new int);\n  }\n\n  std::unique_ptr<int> R(new int());\n  std::unique_ptr<int> S(new int);\n\n  // Create the unique_ptr as a parameter to a function.\n  int T = g(std::unique_ptr<int>(new int()));\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use std::make_unique instead\n  // CHECK-FIXES: int T = g(std::make_unique<int>());\n  T = g(std::unique_ptr<int>(new int));\n\n  // Only replace if the type in the template is the same as the type returned\n  // by the new operator.\n  auto Pderived = std::unique_ptr<Base>(new Derived());\n  auto PderivedNoparen = std::unique_ptr<Base>(new Derived);\n\n  // OK to replace for reset and assign\n  Pderived.reset(new Derived());\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: use std::make_unique instead\n  // CHECK-FIXES: Pderived = std::make_unique<Derived>();\n  PderivedNoparen.reset(new Derived);\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: use std::make_unique instead\n  // CHECK-FIXES: PderivedNoparen = std::make_unique<Derived>();\n\n  Pderived = std::unique_ptr<Derived>(new Derived());\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: use std::make_unique instead\n  // CHECK-FIXES: Pderived = std::make_unique<Derived>();\n  PderivedNoparen = std::unique_ptr<Derived>(new Derived);\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: use std::make_unique instead\n  // CHECK-FIXES: PderivedNoparen = std::make_unique<Derived>();\n\n  // FIXME: OK to replace if assigned to unique_ptr<Base>\n  Pderived = std::unique_ptr<Base>(new Derived());\n  Pderived = std::unique_ptr<Base>(new Derived);\n\n  // FIXME: OK to replace when auto is not used\n  std::unique_ptr<Base> PBase = std::unique_ptr<Base>(new Derived());\n  std::unique_ptr<Base> PBaseNoparen = std::unique_ptr<Base>(new Derived);\n\n  // The pointer is returned by the function, nothing to do.\n  std::unique_ptr<Base> RetPtr = getPointer();\n  RetPtr = getPointerValue();\n\n  // This emulates std::move.\n  std::unique_ptr<int> Move = static_cast<std::unique_ptr<int> &&>(P1);\n\n  // Placement arguments should not be removed.\n  int *PInt = new int;\n  std::unique_ptr<int> Placement = std::unique_ptr<int>(new (PInt) int{3});\n  Placement.reset(new (PInt) int{3});\n  Placement = std::unique_ptr<int>(new (PInt) int{3});\n\n  std::unique_ptr<int> PlacementNoparen = std::unique_ptr<int>(new (PInt) int);\n  PlacementNoparen.reset(new (PInt) int);\n  PlacementNoparen = std::unique_ptr<int>(new (PInt) int);\n}\n\n// Calling make_smart_ptr from within a member function of a type with a\n// private or protected constructor would be ill-formed.\nclass Private {\nprivate:\n  Private(int z) {}\n\npublic:\n  Private() {}\n  void create() {\n    auto callsPublic = std::unique_ptr<Private>(new Private);\n    // CHECK-MESSAGES: :[[@LINE-1]]:24: warning: use std::make_unique instead\n    // CHECK-FIXES: auto callsPublic = std::make_unique<Private>();\n    auto ptr = std::unique_ptr<Private>(new Private(42));\n    ptr.reset(new Private(42));\n    ptr = std::unique_ptr<Private>(new Private(42));\n  }\n\n  virtual ~Private();\n};\n\nclass Protected {\nprotected:\n  Protected() {}\n\npublic:\n  Protected(int, int) {}\n  void create() {\n    auto callsPublic = std::unique_ptr<Protected>(new Protected(1, 2));\n    // CHECK-MESSAGES: :[[@LINE-1]]:24: warning: use std::make_unique instead\n    // CHECK-FIXES: auto callsPublic = std::make_unique<Protected>(1, 2);\n    auto ptr = std::unique_ptr<Protected>(new Protected);\n    ptr.reset(new Protected);\n    ptr = std::unique_ptr<Protected>(new Protected);\n  }\n};\n\nvoid initialization(int T, Base b) {\n  // Test different kinds of initialization of the pointee.\n\n  // Direct initialization with parenthesis.\n  std::unique_ptr<DPair> PDir1 = std::unique_ptr<DPair>(new DPair(1, T));\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<DPair> PDir1 = std::make_unique<DPair>(1, T);\n  PDir1.reset(new DPair(1, T));\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use std::make_unique instead\n  // CHECK-FIXES: PDir1 = std::make_unique<DPair>(1, T);\n\n  // Direct initialization with braces.\n  std::unique_ptr<DPair> PDir2 = std::unique_ptr<DPair>(new DPair{2, T});\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<DPair> PDir2 = std::make_unique<DPair>(2, T);\n  PDir2.reset(new DPair{2, T});\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use std::make_unique instead\n  // CHECK-FIXES: PDir2 = std::make_unique<DPair>(2, T);\n\n  // Aggregate initialization.\n  std::unique_ptr<APair> PAggr = std::unique_ptr<APair>(new APair{T, 1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<APair> PAggr = std::make_unique<APair>(APair{T, 1});\n  PAggr.reset(new APair{T, 1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use std::make_unique instead\n  // CHECK-FIXES: std::make_unique<APair>(APair{T, 1});\n\n  // Check aggregate init with intermediate temporaries.\n  std::unique_ptr<APair> PAggrTemp = std::unique_ptr<APair>(new APair({T, 1}));\n  // CHECK-MESSAGES: :[[@LINE-1]]:38: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<APair> PAggrTemp = std::unique_ptr<APair>(new APair({T, 1}));\n  PAggrTemp.reset(new APair({T, 1}));\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use std::make_unique instead\n  // CHECK-FIXES: PAggrTemp.reset(new APair({T, 1}));\n\n  // Test different kinds of initialization of the pointee, when the unique_ptr\n  // is initialized with braces.\n\n  // Direct initialization with parenthesis.\n  std::unique_ptr<DPair> PDir3 = std::unique_ptr<DPair>{new DPair(3, T)};\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<DPair> PDir3 = std::make_unique<DPair>(3, T);\n\n  // Direct initialization with braces.\n  std::unique_ptr<DPair> PDir4 = std::unique_ptr<DPair>{new DPair{4, T}};\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<DPair> PDir4 = std::make_unique<DPair>(4, T);\n\n  // Aggregate initialization.\n  std::unique_ptr<APair> PAggr2 = std::unique_ptr<APair>{new APair{T, 2}};\n  // CHECK-MESSAGES: :[[@LINE-1]]:35: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<APair> PAggr2 = std::make_unique<APair>(APair{T, 2});\n\n  // Direct initialization with parenthesis, without arguments.\n  std::unique_ptr<DPair> PDir5 = std::unique_ptr<DPair>(new DPair());\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<DPair> PDir5 = std::make_unique<DPair>();\n\n  // Direct initialization with braces, without arguments.\n  std::unique_ptr<DPair> PDir6 = std::unique_ptr<DPair>(new DPair{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<DPair> PDir6 = std::make_unique<DPair>();\n\n  // Aggregate initialization without arguments.\n  std::unique_ptr<Empty> PEmpty = std::unique_ptr<Empty>(new Empty{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:35: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<Empty> PEmpty = std::make_unique<Empty>(Empty{});\n\n  // Initialization with default constructor.\n  std::unique_ptr<E> PE1 = std::unique_ptr<E>(new E{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<E> PE1 = std::make_unique<E>();\n  PE1.reset(new E{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PE1 = std::make_unique<E>();\n\n  // No warnings for `auto` new expression.\n  PE1.reset(new auto(E()));\n\n  //============================================================================\n  //  NOTE: For initializer-list constructors, the check only gives warnings,\n  //  and no fixes are generated.\n  //============================================================================\n\n  // Initialization with the initializer-list constructor.\n  std::unique_ptr<E> PE2 = std::unique_ptr<E>(new E{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<E> PE2 = std::unique_ptr<E>(new E{1, 2});\n  PE2.reset(new E{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PE2.reset(new E{1, 2});\n\n  // Initialization with default constructor.\n  std::unique_ptr<F> PF1 = std::unique_ptr<F>(new F());\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<F> PF1 = std::make_unique<F>();\n  PF1.reset(new F());\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PF1 = std::make_unique<F>();\n\n  // Initialization with default constructor.\n  std::unique_ptr<F> PF2 = std::unique_ptr<F>(new F{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<F> PF2 = std::make_unique<F>();\n  PF2.reset(new F());\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PF2 = std::make_unique<F>();\n\n  // Initialization with the initializer-list constructor.\n  std::unique_ptr<F> PF3 = std::unique_ptr<F>(new F{1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<F> PF3 = std::unique_ptr<F>(new F{1});\n  PF3.reset(new F{1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PF3.reset(new F{1});\n\n  // Initialization with the initializer-list constructor.\n  std::unique_ptr<F> PF4 = std::unique_ptr<F>(new F{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<F> PF4 = std::unique_ptr<F>(new F{1, 2});\n\n  // Initialization with the initializer-list constructor.\n  std::unique_ptr<F> PF5 = std::unique_ptr<F>(new F({1, 2}));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<F> PF5 = std::unique_ptr<F>(new F({1, 2}));\n\n  // Initialization with the initializer-list constructor as the default\n  // constructor is not present.\n  std::unique_ptr<G> PG1 = std::unique_ptr<G>(new G{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<G> PG1 = std::unique_ptr<G>(new G{});\n  PG1.reset(new G{});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PG1.reset(new G{});\n\n  // Initialization with the initializer-list constructor.\n  std::unique_ptr<G> PG2 = std::unique_ptr<G>(new G{1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<G> PG2 = std::unique_ptr<G>(new G{1});\n\n  // Initialization with the initializer-list constructor.\n  std::unique_ptr<G> PG3 = std::unique_ptr<G>(new G{1, 2});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<G> PG3 = std::unique_ptr<G>(new G{1, 2});\n\n  std::unique_ptr<H> PH1 = std::unique_ptr<H>(new H({1, 2, 3}));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<H> PH1 = std::unique_ptr<H>(new H({1, 2, 3}));\n  PH1.reset(new H({1, 2, 3}));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PH1.reset(new H({1, 2, 3}));\n\n  std::unique_ptr<H> PH2 = std::unique_ptr<H>(new H({1, 2, 3}, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<H> PH2 = std::unique_ptr<H>(new H({1, 2, 3}, 1));\n  PH2.reset(new H({1, 2, 3}, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PH2.reset(new H({1, 2, 3}, 1));\n\n  std::unique_ptr<H> PH3 = std::unique_ptr<H>(new H({1, 2, 3}, 1.0));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<H> PH3 = std::unique_ptr<H>(new H({1, 2, 3}, 1.0));\n  PH3.reset(new H({1, 2, 3}, 1.0));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PH3.reset(new H({1, 2, 3}, 1.0));\n\n  std::unique_ptr<I> PI1 = std::unique_ptr<I>(new I(G({1, 2, 3})));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<I> PI1 = std::make_unique<I>(G({1, 2, 3}));\n  PI1.reset(new I(G({1, 2, 3})));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PI1 = std::make_unique<I>(G({1, 2, 3}));\n\n  std::unique_ptr<J> PJ1 = std::unique_ptr<J>(new J({1, 2}, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<J> PJ1 = std::unique_ptr<J>(new J({1, 2}, 1));\n  PJ1.reset(new J({1, 2}, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PJ1.reset(new J({1, 2}, 1));\n\n  std::unique_ptr<J> PJ2 = std::unique_ptr<J>(new J(E{1, 2}, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<J> PJ2 = std::unique_ptr<J>(new J(E{1, 2}, 1));\n  PJ2.reset(new J(E{1, 2}, 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PJ2.reset(new J(E{1, 2}, 1));\n\n  std::unique_ptr<J> PJ3 = std::unique_ptr<J>(new J{ {1, 2}, 1 });\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<J> PJ3 = std::unique_ptr<J>(new J{ {1, 2}, 1 });\n  PJ3.reset(new J{ {1, 2}, 1 });\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES:  PJ3.reset(new J{ {1, 2}, 1 });\n\n  std::unique_ptr<J> PJ4 = std::unique_ptr<J>(new J{E{1, 2}, 1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<J> PJ4 = std::unique_ptr<J>(new J{E{1, 2}, 1});\n  PJ4.reset(new J{E{1, 2}, 1});\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: use std::make_unique instead\n  // CHECK-FIXES: PJ4.reset(new J{E{1, 2}, 1});\n\n  std::unique_ptr<Foo> FF = std::unique_ptr<Foo>(new Foo());\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning:\n  // CHECK-FIXES: std::unique_ptr<Foo> FF = std::make_unique<Foo>();\n  FF.reset(new Foo());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning:\n  // CHECK-FIXES: FF = std::make_unique<Foo>();\n\n  std::unique_ptr<bar::Bar> BB = std::unique_ptr<bar::Bar>(new bar::Bar());\n  // CHECK-MESSAGES: :[[@LINE-1]]:34: warning:\n  // CHECK-FIXES: std::unique_ptr<bar::Bar> BB = std::make_unique<bar::Bar>();\n  BB.reset(new bar::Bar());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning:\n  // CHECK-FIXES: BB = std::make_unique<bar::Bar>();\n\n  std::unique_ptr<Foo[]> FFs;\n  FFs.reset(new Foo[5]);\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning:\n  // CHECK-FIXES: FFs = std::make_unique<Foo[]>(5);\n  FFs.reset(new Foo[5]());\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning:\n  // CHECK-FIXES: FFs = std::make_unique<Foo[]>(5);\n  const int Num = 1;\n  FFs.reset(new Foo[Num]);\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning:\n  // CHECK-FIXES: FFs = std::make_unique<Foo[]>(Num);\n  int Num2 = 1;\n  FFs.reset(new Foo[Num2]);\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning:\n  // CHECK-FIXES: FFs = std::make_unique<Foo[]>(Num2);\n\n  std::unique_ptr<int[]> FI;\n  FI.reset(new int[5]()); // value initialization.\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning:\n  // CHECK-FIXES: FI = std::make_unique<int[]>(5);\n\n  // The check doesn't give warnings and fixes for cases where the original new\n  // expression does default initialization.\n  FI.reset(new int[5]);\n  FI.reset(new int[Num]);\n  FI.reset(new int[Num2]);\n}\n\nvoid aliases() {\n  typedef std::unique_ptr<int> IntPtr;\n  IntPtr Typedef = IntPtr(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: use std::make_unique instead\n  // CHECK-FIXES: IntPtr Typedef = std::make_unique<int>();\n  IntPtr Typedef2 = IntPtr(new int);\n\n  // We use 'bool' instead of '_Bool'.\n  typedef std::unique_ptr<bool> BoolPtr;\n  BoolPtr BoolType = BoolPtr(new bool());\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: use std::make_unique instead\n  // CHECK-FIXES: BoolPtr BoolType = std::make_unique<bool>();\n  BoolPtr BoolType2 = BoolPtr(new bool);\n\n  // We use 'Base' instead of 'struct Base'.\n  typedef std::unique_ptr<Base> BasePtr;\n  BasePtr StructType = BasePtr(new Base);\n// CHECK-MESSAGES: :[[@LINE-1]]:24: warning: use std::make_unique instead\n// CHECK-FIXES: BasePtr StructType = std::make_unique<Base>();\n\n#define PTR unique_ptr<int>\n  std::unique_ptr<int> Macro = std::PTR(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<int> Macro = std::make_unique<int>();\n  std::unique_ptr<int> Macro2 = std::PTR(new int);\n#undef PTR\n\n  std::unique_ptr<int> Using = unique_ptr_<int>(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: use std::make_unique instead\n  // CHECK-FIXES: std::unique_ptr<int> Using = std::make_unique<int>();\n  std::unique_ptr<int> Using2 = unique_ptr_<int>(new int);\n}\n\nvoid whitespaces() {\n  // clang-format off\n  auto Space = std::unique_ptr <int>(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: use std::make_unique instead\n  // CHECK-FIXES: auto Space = std::make_unique<int>();\n  auto Space2 = std::unique_ptr <int>(new int);\n\n  auto Spaces = std  ::    unique_ptr  <int>(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: use std::make_unique instead\n  // CHECK-FIXES: auto Spaces = std::make_unique<int>();\n  auto Spaces2 = std  ::    unique_ptr  <int>(new int);\n  // clang-format on\n}\n\nvoid nesting() {\n  auto Nest = std::unique_ptr<std::unique_ptr<int>>(new std::unique_ptr<int>(new int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: use std::make_unique instead\n  // CHECK-FIXES: auto Nest = std::make_unique<std::unique_ptr<int>>(new int);\n  Nest.reset(new std::unique_ptr<int>(new int));\n  // CHECK-MESSAGES: :[[@LINE-1]]:8: warning: use std::make_unique instead\n  // CHECK-FIXES: Nest = std::make_unique<std::unique_ptr<int>>(new int);\n  Nest->reset(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: use std::make_unique instead\n  // CHECK-FIXES: *Nest = std::make_unique<int>();\n}\n\nvoid reset() {\n  std::unique_ptr<int> P;\n  P.reset();\n  P.reset(nullptr);\n  P.reset(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: use std::make_unique instead\n  // CHECK-FIXES: P = std::make_unique<int>();\n  P.reset(new int);\n\n  auto Q = &P;\n  Q->reset(new int());\n  // CHECK-MESSAGES: :[[@LINE-1]]:6: warning: use std::make_unique instead\n  // CHECK-FIXES: *Q = std::make_unique<int>();\n  Q->reset(new int);\n}\n\n#define DEFINE(...) __VA_ARGS__\ntemplate<typename T>\nvoid g2(std::unique_ptr<Foo> *t) {\n  DEFINE(auto p = std::unique_ptr<Foo>(new Foo); t->reset(new Foo););\n}\nvoid macro() {\n  std::unique_ptr<Foo> *t;\n  g2<bar::Bar>(t);\n}\n#undef DEFINE\n\nclass UniqueFoo : public std::unique_ptr<Foo> {\n public:\n  void foo() {\n    reset(new Foo);\n    this->reset(new Foo);\n    // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: use std::make_unique instead\n    // CHECK-FIXES: *this = std::make_unique<Foo>();\n    this->reset(new Foo());\n    // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: use std::make_unique instead\n    // CHECK-FIXES: *this = std::make_unique<Foo>();\n    (*this).reset(new Foo);\n    // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use std::make_unique instead\n    // CHECK-FIXES: (*this) = std::make_unique<Foo>();\n    (*this).reset(new Foo());\n    // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: use std::make_unique instead\n    // CHECK-FIXES: (*this) = std::make_unique<Foo>();\n  }\n};\n\n// Ignore statements inside a template instantiation.\ntemplate<typename T>\nvoid template_fun(T* t) {\n  std::unique_ptr<T> t2 = std::unique_ptr<T>(new T);\n  std::unique_ptr<T> t3 = std::unique_ptr<T>(new T());\n  t2.reset(new T);\n  t3.reset(new T());\n}\n\nvoid invoke_template() {\n  Foo* foo;\n  template_fun(foo);\n}\n\nvoid fix_for_c_style_struct() {\n  auto T = std::unique_ptr<Base>(new struct Base);\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: use std::make_unique instead\n  // CHECK-FIXES: auto T = std::make_unique<Base>();\n}"
    }
  ]
}