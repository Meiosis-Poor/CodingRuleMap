{
  "name": "MinMaxUseInitializerList",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-min-max-use-initializer-list",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 280,
  "branches": 31,
  "apis": 162,
  "test": [
    {
      "description": null,
      "expected-problems": 25,
      "expected-linenumbers": [
        140,
        144,
        148,
        152,
        156,
        160,
        165,
        169,
        173,
        174,
        178,
        179,
        195,
        199,
        215,
        219,
        223,
        227,
        231,
        235,
        239,
        243,
        251,
        256,
        317
      ],
      "code": "\n// RUN: %check_clang_tidy --match-partial-fixes %s modernize-min-max-use-initializer-list %t\n\n// CHECK-FIXES: #include <algorithm>\nnamespace utils {\ntemplate <typename T>\nT max(T a, T b) {\n  return (a < b) ? b : a;\n}\n} // namespace utils\n\nnamespace std {\ntemplate< class T >\nstruct initializer_list {\n  const T *a, *b;\n  initializer_list()=default;\n  initializer_list(T*,int){}\n  const T* begin() const {return nullptr;}\n  const T* end() const {return nullptr;}\n};\n\ntemplate<class ForwardIt>\nForwardIt min_element(ForwardIt first, ForwardIt last)\n{\n    if (first == last)\n        return last;\n\n    ForwardIt smallest = first;\n\n    while (++first != last)\n        if (*first < *smallest)\n            smallest = first;\n\n    return smallest;\n}\n\ntemplate<class ForwardIt, class Compare>\nForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp)\n{\n    if (first == last)\n        return last;\n\n    ForwardIt smallest = first;\n\n    while (++first != last)\n        if (comp(*first, *smallest))\n            smallest = first;\n\n    return smallest;\n}\n\ntemplate<class ForwardIt>\nForwardIt max_element(ForwardIt first, ForwardIt last)\n{\n    if (first == last)\n        return last;\n\n    ForwardIt largest = first;\n\n    while (++first != last)\n        if (*largest < *first)\n            largest = first;\n\n    return largest;\n}\n\ntemplate<class ForwardIt, class Compare>\nForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp)\n{\n    if (first == last)\n        return last;\n\n    ForwardIt largest = first;\n\n    while(++first != last)\n        if (comp(*largest, *first))\n            largest = first;\n\n    return largest;\n}\n\ntemplate< class T >\nconst T& max( const T& a, const T& b ) {\n  return (a < b) ? b : a;\n};\n\ntemplate< class T >\nT max(std::initializer_list<T> ilist)\n{\n    return *std::max_element(ilist.begin(), ilist.end());\n}\n\ntemplate< class T, class Compare >\nconst T& max( const T& a, const T& b, Compare comp ) {\n  return (comp(a, b)) ? b : a;\n};\n\ntemplate< class T, class Compare >\nT max(std::initializer_list<T> ilist, Compare comp) {\n    return *std::max_element(ilist.begin(), ilist.end(), comp);\n};\n\ntemplate< class T >\nconst T& min( const T& a, const T& b ) {\n  return (b < a) ? b : a;\n};\n\ntemplate< class T >\nT min(std::initializer_list<T> ilist)\n{\n    return *std::min_element(ilist.begin(), ilist.end());\n}\n\n\ntemplate< class T, class Compare >\nconst T& min( const T& a, const T& b, Compare comp ) {\n  return (comp(b, a)) ? b : a;\n};\n\ntemplate< class T, class Compare >\nT min(std::initializer_list<T> ilist, Compare comp) {\n    return *std::min_element(ilist.begin(), ilist.end(), comp);\n};\n\n} // namespace std\n\nusing namespace std;\n\nnamespace {\nbool fless_than(int a, int b) {\nreturn a < b;\n}\n\nbool fgreater_than(int a, int b) {\nreturn a > b;\n}\nauto less_than = [](int a, int b) { return a < b; };\nauto greater_than = [](int a, int b) { return a > b; };\n\nint max1 = std::max(1, std::max(2, 3));\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max1 = std::max({1, 2, 3});\n\nint min1 = std::min(1, std::min(2, 3));\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int min1 = std::min({1, 2, 3});\n\nint max2 = std::max(1, std::max(2, std::max(3, 4)));\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max2 = std::max({1, 2, 3, 4});\n\nint max2b = std::max(std::max(std::max(1, 2), std::max(3, 4)), std::max(std::max(5, 6), std::max(7, 8)));\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max2b = std::max({1, 2, 3, 4, 5, 6, 7, 8});\n\nint max2c = std::max(std::max(1, std::max(2, 3)), 4);\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max2c = std::max({1, 2, 3, 4});\n\nint max2d = std::max(std::max({1, 2, 3}), 4);\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max2d = std::max({1, 2, 3, 4});\n\n\nint max2e = std::max(1, max(2, max(3, 4)));\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max2e = std::max({1, 2, 3, 4});\n\nint min2 = std::min(1, std::min(2, std::min(3, 4)));\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int min2 = std::min({1, 2, 3, 4});\n\nint max3 = std::max(std::max(4, 5), std::min(2, std::min(3, 1)));\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-MESSAGES: :[[@LINE-2]]:37: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max3 = std::max({4, 5, std::min({2, 3, 1})});\n\nint min3 = std::min(std::min(4, 5), std::max(2, std::max(3, 1)));\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-MESSAGES: :[[@LINE-2]]:37: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int min3 = std::min({4, 5, std::max({2, 3, 1})});\n\nint max4 = std::max(1, std::max(2, 3, greater_than), less_than);\n// CHECK-FIXES: int max4 = std::max(1, std::max(2, 3, greater_than), less_than);\n\nint min4 = std::min(1, std::min(2, 3, greater_than), less_than);\n// CHECK-FIXES: int min4 = std::min(1, std::min(2, 3, greater_than), less_than);\n\nint max5 = std::max(1, std::max(2, 3), less_than);\n// CHECK-FIXES: int max5 = std::max(1, std::max(2, 3), less_than);\n\nint min5 = std::min(1, std::min(2, 3), less_than);\n// CHECK-FIXES: int min5 = std::min(1, std::min(2, 3), less_than);\n\nint max6 = std::max(1, std::max(2, 3, greater_than), greater_than);\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max6 = std::max({1, 2, 3 }, greater_than);\n\nint min6 = std::min(1, std::min(2, 3, greater_than), greater_than);\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int min6 = std::min({1, 2, 3 }, greater_than);\n\nint max7 = std::max(1, std::max(2, 3, fless_than), fgreater_than);\n// CHECK-FIXES: int max7 = std::max(1, std::max(2, 3, fless_than), fgreater_than);\n\nint min7 = std::min(1, std::min(2, 3, fless_than), fgreater_than);\n// CHECK-FIXES: int min7 = std::min(1, std::min(2, 3, fless_than), fgreater_than);\n\nint max8 = std::max(1, std::max(2, 3, fless_than), less_than);\n// CHECK-FIXES: int max8 = std::max(1, std::max(2, 3, fless_than), less_than)\n\nint min8 = std::min(1, std::min(2, 3, fless_than), less_than);\n// CHECK-FIXES: int min8 = std::min(1, std::min(2, 3, fless_than), less_than);\n\nint max9 = std::max(1, std::max(2, 3, fless_than), fless_than);\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max9 = std::max({1, 2, 3 }, fless_than);\n\nint min9 = std::min(1, std::min(2, 3, fless_than), fless_than);\n// CHECK-MESSAGES: :[[@LINE-1]]:12: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int min9 = std::min({1, 2, 3 }, fless_than);\n\nint min10 = std::min(std::min(4, 5), std::max(2, utils::max(3, 1)));\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: do not use nested 'std::min' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int min10 = std::min({4, 5, std::max(2, utils::max(3, 1))});\n\nint max10 = std::max({std::max(1, 2), std::max({5, 6, 1}), 2, std::min({1, 2, 4})});\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int max10 = std::max({1, 2, 5, 6, 1, 2, std::min({1, 2, 4})});\n\nint typecastTest = std::max(std::max<int>(0U, 0.0f), 0);\n// CHECK-MESSAGES: :[[@LINE-1]]:20: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int typecastTest = std::max({static_cast<int>(0U), static_cast<int>(0.0f), 0});\n\nint typecastTest1 = std::max(std::max<long>(0U, 0.0f), 0L);\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int typecastTest1 = std::max({static_cast<long>(0U), static_cast<long>(0.0f), 0L});\n\nint typecastTest2 = std::max(std::max<int>(10U, 20.0f), 30);\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int typecastTest2 = std::max({static_cast<int>(10U), static_cast<int>(20.0f), 30});\n\nint typecastTest3 = std::max(std::max<int>(0U, std::max<int>(0.0f, 1.0f)), 0);\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int typecastTest3 = std::max({static_cast<int>(0U), static_cast<int>(0.0f), static_cast<int>(1.0f), 0});\n\n#define max3f(a, b, c) std::max(a, std::max(b, c))\n// CHECK-FIXES: #define max3f(a, b, c) std::max(a, std::max(b, c))\n\n#define value 4545\nint macroVarMax = std::max(value, std::max(1, 2));\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int macroVarMax = std::max({value, 1, 2});\n\n#define value2 45U\nint macroVarMax2 = std::max(1, std::max<int>(value2, 2.0f));\n// CHECK-MESSAGES: :[[@LINE-1]]:20: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: int macroVarMax2 = std::max({1, static_cast<int>(value2), static_cast<int>(2.0f)});\n\n// True-negative tests\nint maxTN1 = std::max(1, 2);\n// CHECK-FIXES: int maxTN1 = std::max(1, 2);\n\nint maxTN2 = std::max({1, 2, 3});\n// CHECK-FIXES: int maxTN2 = std::max({1, 2, 3});\n\nint maxTN3 = std::max({1, 2, 3}, less_than);\n// CHECK-FIXES: int maxTN3 = std::max({1, 2, 3}, less_than);\n\n// non-trivial types\nstruct A {\n  int a;\n  A(int a) : a(a) {}\n  bool operator<(const A &rhs) const { return a < rhs.a; }\n};\n\nA maxNT1 = std::max(A(1), A(2));\n// CHECK-FIXES: A maxNT1 = std::max(A(1), A(2));\n\nA maxNT2 = std::max(A(1), std::max(A(2), A(3)));\n// CHECK-FIXES: A maxNT2 = std::max(A(1), std::max(A(2), A(3)));\n\nA maxNT3 = std::max(A(1), std::max(A(2), A(3)), [](const A &lhs, const A &rhs) { return lhs.a < rhs.a; });\n// CHECK-FIXES: A maxNT3 = std::max(A(1), std::max(A(2), A(3)), [](const A &lhs, const A &rhs) { return lhs.a < rhs.a; });\n\n// Trivial type with size greater than 32\nstruct B {\n  // 9*4 = 36 bytes > 32 bytes\n  int a[9];\n\n  bool operator<(const B& rhs) const {\n    return a[0] < rhs.a[0];\n  }\n};\n\nB maxTT1 = std::max(B(), B());\n// CHECK-FIXES: B maxTT1 = std::max(B(), B());\n\nB maxTT2 = std::max(B(), std::max(B(), B()));\n// CHECK-FIXES: B maxTT2 = std::max(B(), std::max(B(), B()));\n\nB maxTT3 = std::max(B(), std::max(B(), B()), [](const B &lhs, const B &rhs) { return lhs.a[0] < rhs.a[0]; });\n// CHECK-FIXES: B maxTT3 = std::max(B(), std::max(B(), B()), [](const B &lhs, const B &rhs) { return lhs.a[0] < rhs.a[0]; });\n\nstruct GH91982 {\n  int fun0Args();\n  int fun1Arg(int a);\n  int fun2Args(int a, int b);\n  int fun3Args(int a, int b, int c);\n  int fun4Args(int a, int b, int c, int d);\n\n  int foo() {\n    return std::max(\n        fun0Args(),\n        std::max(fun1Arg(0),\n                 std::max(fun2Args(0, 1),\n                          std::max(fun3Args(0, 1, 2), fun4Args(0, 1, 2, 3)))));\n// CHECK-MESSAGES: :[[@LINE-5]]:12: warning: do not use nested 'std::max' calls, use an initializer list instead [modernize-min-max-use-initializer-list]\n// CHECK-FIXES: return std::max(\n// CHECK-FIXES-NEXT: {fun0Args(),\n// CHECK-FIXES-NEXT: fun1Arg(0),\n// CHECK-FIXES-NEXT: fun2Args(0, 1),\n// CHECK-FIXES-NEXT: fun3Args(0, 1, 2), fun4Args(0, 1, 2, 3)});\n  }\n};\n\nstruct GH107594 {\n    int foo(int a, int b, char c) {\n        return std::max<int>({a, b, c});\n    }\n};\n\n} // namespace\n"
    }
  ]
}