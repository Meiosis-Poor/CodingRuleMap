{
  "name": "UseConstraints",
  "language": "cpp",
  "description": ".. title:: clang-tidy - modernize-use-constraints",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 497,
  "branches": 62,
  "apis": 251,
  "test": [
    {
      "description": null,
      "expected-problems": 75,
      "expected-linenumbers": [
        35,
        42,
        49,
        56,
        81,
        89,
        97,
        105,
        114,
        122,
        129,
        135,
        141,
        151,
        157,
        163,
        169,
        215,
        221,
        227,
        233,
        239,
        245,
        251,
        265,
        272,
        281,
        290,
        304,
        311,
        318,
        325,
        332,
        337,
        342,
        356,
        364,
        372,
        379,
        387,
        394,
        401,
        409,
        426,
        433,
        440,
        459,
        465,
        471,
        477,
        483,
        489,
        502,
        508,
        520,
        528,
        539,
        549,
        557,
        585,
        586,
        594,
        603,
        619,
        626,
        633,
        647,
        653,
        659,
        665,
        671,
        681,
        688,
        696,
        707
      ],
      "code": "\n// RUN: %check_clang_tidy -std=c++20 %s modernize-use-constraints %t -- -- -fno-delayed-template-parsing\n\n// NOLINTBEGIN\nnamespace std {\ntemplate <bool B, class T = void> struct enable_if { };\n\ntemplate <class T> struct enable_if<true, T> { typedef T type; };\n\ntemplate <bool B, class T = void>\nusing enable_if_t = typename enable_if<B, T>::type;\n\n} // namespace std\n// NOLINTEND\n\ntemplate <typename...>\nstruct ConsumeVariadic;\n\nstruct Obj {\n};\n\nnamespace enable_if_in_return_type {\n\n////////////////////////////////\n// Section 1: enable_if in return type of function\n////////////////////////////////\n\n////////////////////////////////\n// General tests\n////////////////////////////////\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value, Obj>::type basic() {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj basic() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value, Obj> basic_t() {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj basic_t() requires T::some_value {{{$}}\n\ntemplate <typename T>\nauto basic_trailing() -> typename std::enable_if<T::some_value, Obj>::type {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:26: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}auto basic_trailing() -> Obj requires T::some_value {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value, Obj>::type existing_constraint() requires (T::another_value) {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}typename std::enable_if<T::some_value, Obj>::type existing_constraint() requires (T::another_value) {{{$}}\n\ntemplate <typename U>\ntypename std::enable_if<U::some_value, Obj>::type decl_without_def();\n\ntemplate <typename U>\ntypename std::enable_if<U::some_value, Obj>::type decl_with_separate_def();\n\ntemplate <typename U>\ntypename std::enable_if<U::some_value, Obj>::type decl_with_separate_def() {\n  return Obj{};\n}\n// FIXME - Support definitions with separate decls\n\ntemplate <typename U>\nstd::enable_if_t<true, Obj> no_dependent_type(U) {\n  return Obj{};\n}\n// FIXME - Support non-dependent enable_ifs. Low priority though...\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value, int>::type* pointer_of_enable_if() {\n  return nullptr;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}int* pointer_of_enable_if() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value, int>* pointer_of_enable_if_t() {\n  return nullptr;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}int* pointer_of_enable_if_t() requires T::some_value {{{$}}\n\ntemplate <typename T>\nconst std::enable_if_t<T::some_value, int>* const_pointer_of_enable_if_t() {\n  return nullptr;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:7: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}const int* const_pointer_of_enable_if_t() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value, int> const * const_pointer_of_enable_if_t2() {\n  return nullptr;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}int const * const_pointer_of_enable_if_t2() requires T::some_value {{{$}}\n\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value, int>& reference_of_enable_if_t() {\n  static int x; return x;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}int& reference_of_enable_if_t() requires T::some_value {{{$}}\n\ntemplate <typename T>\nconst std::enable_if_t<T::some_value, int>& const_reference_of_enable_if_t() {\n  static int x; return x;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:7: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}const int& const_reference_of_enable_if_t() requires T::some_value {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value>::type enable_if_default_void() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void enable_if_default_void() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value> enable_if_t_default_void() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void enable_if_t_default_void() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value>* enable_if_t_default_void_pointer() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void* enable_if_t_default_void_pointer() requires T::some_value {{{$}}\n\nnamespace using_namespace_std {\n\nusing namespace std;\n\ntemplate <typename T>\ntypename enable_if<T::some_value>::type with_typename() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void with_typename() requires T::some_value {{{$}}\n\ntemplate <typename T>\nenable_if_t<T::some_value> with_t() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void with_t() requires T::some_value {{{$}}\n\ntemplate <typename T>\ntypename enable_if<T::some_value, int>::type with_typename_and_type() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}int with_typename_and_type() requires T::some_value {{{$}}\n\ntemplate <typename T>\nenable_if_t<T::some_value, int> with_t_and_type() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}int with_t_and_type() requires T::some_value {{{$}}\n\n} // namespace using_namespace_std\n\n\n////////////////////////////////\n// Negative tests - incorrect uses of enable_if\n////////////////////////////////\ntemplate <typename U>\nstd::enable_if<U::some_value, Obj> not_enable_if() {\n  return {};\n}\ntemplate <typename U>\ntypename std::enable_if<U::some_value, Obj>::type123 not_enable_if_wrong_type() {\n  return {};\n}\ntemplate <typename U>\ntypename std::enable_if_t<U::some_value, Obj>::type not_enable_if_t() {\n  return {};\n}\ntemplate <typename U>\ntypename std::enable_if_t<U::some_value, Obj>::type123 not_enable_if_t_again() {\n  return {};\n}\ntemplate <typename U>\nstd::enable_if<U::some_value, int>* not_pointer_of_enable_if() {\n  return nullptr;\n}\ntemplate <typename U>\ntypename std::enable_if<U::some_value, int>::type123 * not_pointer_of_enable_if_t() {\n  return nullptr;\n}\n\n\nnamespace primary_expression_tests {\n\n////////////////////////////////\n// Primary/non-primary expression tests\n////////////////////////////////\n\ntemplate <typename T> struct Traits;\n\ntemplate <typename T>\nstd::enable_if_t<Traits<T>::value> type_trait_value() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void type_trait_value() requires Traits<T>::value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<Traits<T>::member()> type_trait_member_call() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void type_trait_member_call() requires (Traits<T>::member()) {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<!Traits<T>::value> negate() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void negate() requires (!Traits<T>::value) {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<Traits<T>::value1 && Traits<T>::value2> conjunction() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void conjunction() requires (Traits<T>::value1 && Traits<T>::value2) {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<Traits<T>::value1 || Traits<T>::value2> disjunction() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void disjunction() requires (Traits<T>::value1 || Traits<T>::value2) {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<Traits<T>::value1 && !Traits<T>::value2> conjunction_with_negate() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void conjunction_with_negate() requires (Traits<T>::value1 && !Traits<T>::value2) {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<Traits<T>::value1 == (Traits<T>::value2 + 5)> complex_operators() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}void complex_operators() requires (Traits<T>::value1 == (Traits<T>::value2 + 5)) {{{$}}\n\n} // namespace primary_expression_tests\n\n\n////////////////////////////////\n// Functions with specifier\n////////////////////////////////\n\ntemplate <typename T>\nconstexpr typename std::enable_if<T::some_value, int>::type constexpr_decl() {\n  return 10;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:11: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}constexpr int constexpr_decl() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstatic inline constexpr typename std::enable_if<T::some_value, int>::type static_inline_constexpr_decl() {\n  return 10;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}static inline constexpr int static_inline_constexpr_decl() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstatic\ntypename std::enable_if<T::some_value, int>::type\nstatic_decl() {\n  return 10;\n}\n// CHECK-MESSAGES: :[[@LINE-4]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}static{{$}}\n// CHECK-FIXES-NEXT: {{^}}int{{$}}\n// CHECK-FIXES-NEXT: {{^}}static_decl() requires T::some_value {{{$}}\n\ntemplate <typename T>\nconstexpr /* comment */ typename std::enable_if<T::some_value, int>::type constexpr_comment_decl() {\n  return 10;\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}constexpr /* comment */ int constexpr_comment_decl() requires T::some_value {{{$}}\n\n\n////////////////////////////////\n// Class definition tests\n////////////////////////////////\n\nstruct AClass {\n\n  template <typename T>\n  static typename std::enable_if<T::some_value, Obj>::type static_method() {\n    return Obj{};\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:10: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  static Obj static_method() requires T::some_value {{{$}}\n\n  template <typename T>\n  typename std::enable_if<T::some_value, Obj>::type member() {\n    return Obj{};\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  Obj member() requires T::some_value {{{$}}\n\n  template <typename T>\n  typename std::enable_if<T::some_value, Obj>::type const_qualifier() const {\n    return Obj{};\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  Obj const_qualifier() const requires T::some_value {{{$}}\n\n  template <typename T>\n  typename std::enable_if<T::some_value, Obj>::type rvalue_ref_qualifier() && {\n    return Obj{};\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  Obj rvalue_ref_qualifier() && requires T::some_value {{{$}}\n\n  template <typename T>\n  typename std::enable_if<T::some_value, Obj>::type rvalue_ref_qualifier_comment() /* c1 */ && /* c2 */ {\n    return Obj{};\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:3: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  Obj rvalue_ref_qualifier_comment() /* c1 */ && /* c2 */ requires T::some_value {{{$}}\n\n  template <typename T>\n  std::enable_if_t<T::some_value, AClass&> operator=(T&&) = delete;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  AClass& operator=(T&&) requires T::some_value = delete;\n\n  template<typename T>\n  std::enable_if_t<T::some_value, AClass&> operator=(ConsumeVariadic<T>) noexcept(requires (T t) { t = 4; }) = delete;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  AClass& operator=(ConsumeVariadic<T>) noexcept(requires (T t) { t = 4; }) requires T::some_value = delete;\n\n};\n\n\n////////////////////////////////\n// Comments and whitespace tests\n////////////////////////////////\n\ntemplate <typename T>\ntypename std::enable_if</* check1 */ T::some_value, Obj>::type leading_comment() {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj leading_comment() requires /* check1 */ T::some_value {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value, Obj>::type body_on_next_line()\n{\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-4]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj body_on_next_line(){{$}}\n// CHECK-FIXES-NEXT: {{^}}requires T::some_value {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if<  /* check1 */ T::some_value, Obj>::type leading_comment_whitespace() {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj leading_comment_whitespace() requires /* check1 */ T::some_value {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if</* check1 */ T::some_value /* check2 */, Obj>::type leading_and_trailing_comment() {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj leading_and_trailing_comment() requires /* check1 */ T::some_value /* check2 */ {{{$}}\n\ntemplate <typename T, typename U>\ntypename std::enable_if<T::some_value &&\n                        U::another_value, Obj>::type condition_on_two_lines() {\n  return Obj{};\n}\n// CHECK-MESSAGES: :[[@LINE-4]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}Obj condition_on_two_lines() requires (T::some_value &&{{$}}\n// CHECK-FIXES-NEXT: U::another_value) {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value, int> :: type* pointer_of_enable_if_t_with_spaces() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}int* pointer_of_enable_if_t_with_spaces() requires T::some_value {{{$}}\n\ntemplate <typename T>\ntypename std::enable_if<T::some_value, int> :: /*c*/ type* pointer_of_enable_if_t_with_comment() {\n}\n// CHECK-MESSAGES: :[[@LINE-2]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}int* pointer_of_enable_if_t_with_comment() requires T::some_value {{{$}}\n\ntemplate <typename T>\nstd::enable_if_t<T::some_value // comment\n              > trailing_slash_slash_comment() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void trailing_slash_slash_comment() requires T::some_value // comment{{$}}\n// CHECK-FIXES-NEXT: {{^}}               {{{$}}\n\n} // namespace enable_if_in_return_type\n\n\nnamespace enable_if_trailing_non_type_parameter {\n\n////////////////////////////////\n// Section 2: enable_if as final template non-type parameter\n////////////////////////////////\n\ntemplate <typename T, typename std::enable_if<T::some_value, int>::type = 0>\nvoid basic() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void basic() requires T::some_value {{{$}}\n\ntemplate <typename T, std::enable_if_t<T::some_value, int> = 0>\nvoid basic_t() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void basic_t() requires T::some_value {{{$}}\n\ntemplate <typename T, template <typename> class U, class V, std::enable_if_t<T::some_value, int> = 0>\nvoid basic_many_template_params() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:61: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T, template <typename> class U, class V>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void basic_many_template_params() requires T::some_value {{{$}}\n\ntemplate <std::enable_if_t<true, int> = 0>\nvoid no_dependent_type() {\n}\n// FIXME - Support non-dependent enable_ifs. Low priority though...\n\nstruct ABaseClass {\n  ABaseClass();\n  ABaseClass(int);\n};\n\ntemplate <typename T>\nstruct AClass : ABaseClass {\n  template <std::enable_if_t<T::some_value, int> = 0>\n  void no_other_template_params() {\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:13: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  {{$}}\n  // CHECK-FIXES-NEXT: {{^}}  void no_other_template_params() requires T::some_value {{{$}}\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass() {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass() requires U::some_value {}{{$}}\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass(int) : data(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int) requires U::some_value : data(0) {}{{$}}\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass(int, int) : AClass(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int, int) requires U::some_value : AClass(0) {}{{$}}\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass(int, int, int) : ABaseClass(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int, int, int) requires U::some_value : ABaseClass(0) {}{{$}}\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass(int, int, int, int) : data2(), data() {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int, int, int, int) requires U::some_value : data2(), data() {}{{$}}\n\n  int data;\n  int data2;\n};\n\ntemplate <typename T>\nstruct AClass2 : ABaseClass {\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass2() {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass2() requires U::some_value {}{{$}}\n\n  template <typename U, std::enable_if_t<U::some_value, int> = 0>\n  AClass2(int) : data2(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass2(int) requires U::some_value : data2(0) {}{{$}}\n\n  int data = 10;\n  int data2;\n  int data3;\n};\n\ntemplate <typename T, std::enable_if_t<T::some_value, T>* = 0>\nvoid pointer_type() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void pointer_type() requires T::some_value {{{$}}\n\ntemplate <typename T,\n          std::enable_if_t<T::some_value, T>* = nullptr>\nvoid param_on_newline() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:11: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void param_on_newline() requires T::some_value {{{$}}\n\ntemplate <typename T,\n          typename U,\n          std::enable_if_t<\n            ConsumeVariadic<T,\n                            U>::value, T>* = nullptr>\nvoid param_split_on_two_lines() {\n}\n// CHECK-MESSAGES: :[[@LINE-5]]:11: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T,{{$}}\n// CHECK-FIXES-NEXT: {{^}}          typename U>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void param_split_on_two_lines() requires ConsumeVariadic<T,{{$}}\n// CHECK-FIXES-NEXT: {{^}}                            U>::value {{{$}}\n\ntemplate <typename T, std::enable_if_t<T::some_value // comment\n         >* = nullptr>\nvoid trailing_slash_slash_comment() {\n}\n// CHECK-MESSAGES: :[[@LINE-4]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void trailing_slash_slash_comment() requires T::some_value // comment{{$}}\n// CHECK-FIXES-NEXT: {{^}}          {{{$}}\n\ntemplate <typename T, std::enable_if_t<T::some_value>* = nullptr, std::enable_if_t<T::another_value>* = nullptr>\nvoid two_enable_ifs() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:67: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T, std::enable_if_t<T::some_value>* = nullptr>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void two_enable_ifs() requires T::another_value {{{$}}\n\n////////////////////////////////\n// Negative tests\n////////////////////////////////\n\ntemplate <typename U, std::enable_if_t<U::some_value, int> V = 0>\nvoid non_type_param_has_name() {\n}\ntemplate <typename U, std::enable_if_t<U::some_value, int>>\nvoid non_type_param_has_no_default() {\n}\ntemplate <typename U, std::enable_if_t<U::some_value, int> V>\nvoid non_type_param_has_name_and_no_default() {\n}\ntemplate <typename U, std::enable_if_t<U::some_value, int>...>\nvoid non_type_variadic() {\n}\ntemplate <typename U, std::enable_if_t<U::some_value, int> = 0, int = 0>\nvoid non_type_not_last() {\n}\n\n#define TEMPLATE_REQUIRES(U, IF) template <typename U, std::enable_if_t<IF, int> = 0>\nTEMPLATE_REQUIRES(U, U::some_value)\nvoid macro_entire_enable_if() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:1: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-MESSAGES: :[[@LINE-5]]:56: note: expanded from macro 'TEMPLATE_REQUIRES'\n// CHECK-FIXES: {{^}}TEMPLATE_REQUIRES(U, U::some_value)\n// CHECK-FIXES-NEXT: {{^}}void macro_entire_enable_if() {{{$}}\n\n#define CONDITION U::some_value\ntemplate <typename U, std::enable_if_t<CONDITION, int> = 0>\nvoid macro_condition() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename U>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void macro_condition() requires CONDITION {{{$}}\n\n#undef CONDITION\n#define CONDITION !U::some_value\ntemplate <typename U, std::enable_if_t<CONDITION, int> = 0>\nvoid macro_condition_not_primary() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename U>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void macro_condition_not_primary() requires (CONDITION) {{{$}}\n\n} // namespace enable_if_trailing_non_type_parameter\n\n\nnamespace enable_if_trailing_type_parameter {\n\n////////////////////////////////\n// Section 3: enable_if as final template nameless defaulted type parameter\n////////////////////////////////\n\ntemplate <typename T, typename = std::enable_if<T::some_value>::type>\nvoid basic() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void basic() requires T::some_value {{{$}}\n\ntemplate <typename T, typename = std::enable_if_t<T::some_value>>\nvoid basic_t() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void basic_t() requires T::some_value {{{$}}\n\ntemplate <typename T, template <typename> class U, class V, typename = std::enable_if_t<T::some_value>>\nvoid basic_many_template_params() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:61: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T, template <typename> class U, class V>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void basic_many_template_params() requires T::some_value {{{$}}\n\nstruct ABaseClass {\n  ABaseClass();\n  ABaseClass(int);\n};\n\ntemplate <typename T>\nstruct AClass : ABaseClass {\n  template <typename = std::enable_if_t<T::some_value>>\n  void no_other_template_params() {\n  }\n  // CHECK-MESSAGES: :[[@LINE-3]]:13: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  {{$}}\n  // CHECK-FIXES-NEXT: {{^}}  void no_other_template_params() requires T::some_value {{{$}}\n\n  template <typename U, typename = std::enable_if_t<U::some_value>>\n  AClass() {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass() requires U::some_value {}{{$}}\n\n  template <typename U, typename = std::enable_if_t<U::some_value>>\n  AClass(int) : data(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int) requires U::some_value : data(0) {}{{$}}\n\n  template <typename U, typename = std::enable_if_t<U::some_value>>\n  AClass(int, int) : AClass(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int, int) requires U::some_value : AClass(0) {}{{$}}\n\n  template <typename U, typename = std::enable_if_t<U::some_value>>\n  AClass(int, int, int) : ABaseClass(0) {}\n  // CHECK-MESSAGES: :[[@LINE-2]]:25: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n  // CHECK-FIXES: {{^}}  template <typename U>{{$}}\n  // CHECK-FIXES-NEXT: {{^}}  AClass(int, int, int) requires U::some_value : ABaseClass(0) {}{{$}}\n\n  int data;\n};\n\ntemplate <typename T, typename = std::enable_if_t<T::some_value>*>\nvoid pointer_type() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void pointer_type() requires T::some_value {{{$}}\n\ntemplate <typename T, typename = std::enable_if_t<T::some_value>&>\nvoid reference_type() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:23: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void reference_type() requires T::some_value {{{$}}\n\ntemplate <typename T,\n          typename = std::enable_if_t<T::some_value>*>\nvoid param_on_newline() {\n}\n// CHECK-MESSAGES: :[[@LINE-3]]:11: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void param_on_newline() requires T::some_value {{{$}}\n\ntemplate <typename T,\n          typename U,\n          typename = std::enable_if_t<\n            ConsumeVariadic<T,\n                            U>::value>>\nvoid param_split_on_two_lines() {\n}\n// CHECK-MESSAGES: :[[@LINE-5]]:11: warning: use C++20 requires constraints instead of enable_if [modernize-use-constraints]\n// CHECK-FIXES: {{^}}template <typename T,{{$}}\n// CHECK-FIXES-NEXT: {{^}}          typename U>{{$}}\n// CHECK-FIXES-NEXT: {{^}}void param_split_on_two_lines() requires ConsumeVariadic<T,{{$}}\n// CHECK-FIXES-NEXT: {{^}}                            U>::value {{{$}}\n\n\n////////////////////////////////\n// Negative tests\n////////////////////////////////\n\ntemplate <typename U, typename Named = std::enable_if_t<U::some_value>>\nvoid param_has_name() {\n}\n\ntemplate <typename U, typename = std::enable_if_t<U::some_value>, typename = int>\nvoid not_last_param() {\n}\n\n} // namespace enable_if_trailing_type_parameter\n\n\n// Issue fixes:\n\nnamespace PR91872 {\n\nenum expression_template_option { value1, value2 };\n\ntemplate <typename T> struct number_category {\n  static const int value = 0;\n};\n\nconstexpr int number_kind_complex = 1;\n\ntemplate <typename T, expression_template_option ExpressionTemplates>\nstruct number {\n  using type = T;\n};\n\ntemplate <typename T> struct component_type {\n  using type = T;\n};\n\ntemplate <class T, expression_template_option ExpressionTemplates>\ninline typename std::enable_if<\n    number_category<T>::value == number_kind_complex,\n    component_type<number<T, ExpressionTemplates>>>::type::type\nabs(const number<T, ExpressionTemplates> &v) {\n  return {};\n}\n\n}"
    }
  ]
}