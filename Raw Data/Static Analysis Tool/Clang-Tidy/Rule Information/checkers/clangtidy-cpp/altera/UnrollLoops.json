{
  "name": "UnrollLoops",
  "language": "cpp",
  "description": ".. title:: clang-tidy - altera-unroll-loops",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 269,
  "branches": 62,
  "apis": 142,
  "test": [
    {
      "description": null,
      "expected-problems": 43,
      "expected-linenumbers": [
        14,
        24,
        33,
        39,
        48,
        54,
        75,
        89,
        103,
        118,
        131,
        137,
        144,
        150,
        156,
        162,
        168,
        174,
        187,
        207,
        217,
        227,
        237,
        245,
        253,
        262,
        271,
        281,
        292,
        302,
        312,
        323,
        331,
        337,
        343,
        443,
        452,
        462,
        473,
        485,
        498,
        504,
        511
      ],
      "code": "\n// RUN: %check_clang_tidy %s altera-unroll-loops %t -- -config=\"{CheckOptions: {altera-unroll-loops.MaxLoopIterations: 50}}\" -header-filter=.*\n// RUN: %check_clang_tidy -check-suffix=MULT %s altera-unroll-loops %t -- -config=\"{CheckOptions: {altera-unroll-loops.MaxLoopIterations: 5}}\" -header-filter=.* \"--\" -DMULT\n\n#ifdef MULT\n// For loops with *= and /= increments.\nvoid for_loop_mult_div_increments(int *A) {\n// *=\n#pragma unroll\n  for (int i = 2; i <= 32; i *= 2)\n    A[i]++; // OK\n\n#pragma unroll\n  for (int i = 2; i <= 64; i *= 2)\n    // CHECK-MESSAGES-MULT: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++; // Not OK\n\n// /=\n#pragma unroll\n  for (int i = 32; i >= 2; i /= 2)\n    A[i]++; // OK\n\n#pragma unroll\n  for (int i = 64; i >= 2; i /= 2)\n    // CHECK-MESSAGES-MULT: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++; // Not OK\n}\n#else\n// Cannot determine loop bounds for while loops.\nvoid while_loops(int *A) {\n  // Recommend unrolling loops that aren't already unrolled.\n  int j = 0;\n  while (j < 2000) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    A[1] += j;\n    j++;\n  }\n\n  do {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    A[2] += j;\n    j++;\n  } while (j < 2000);\n\n// If a while loop is fully unrolled, add a note recommending partial\n// unrolling.\n#pragma unroll\n  while (j < 2000) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: note: full unrolling requested, but loop bounds may not be known; to partially unroll this loop, use the '#pragma unroll <num>' directive\n    A[j]++;\n  }\n\n#pragma unroll\n  do {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: note: full unrolling requested, but loop bounds may not be known; to partially unroll this loop, use the '#pragma unroll <num>' directive\n    A[j]++;\n  } while (j < 2000);\n\n// While loop is partially unrolled, no action needed.\n#pragma unroll 4\n  while (j < 2000) {\n    A[j]++;\n  }\n\n#pragma unroll 4\n  do {\n    A[j]++;\n  } while (j < 2000);\n}\n\n// Range-based for loops.\nvoid cxx_for_loops(int *A, int vectorSize) {\n  // Loop with known array size should be unrolled.\n  int a[] = {0, 1, 2, 3, 4, 5};\n  for (int k : a) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    A[k]++;\n  }\n\n// Loop with known size correctly unrolled.\n#pragma unroll\n  for (int k : a) {\n    A[k]++;\n  }\n\n  // Loop with unknown size should be partially unrolled.\n  int b[vectorSize];\n#pragma unroll\n  for (int k : b) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    k++;\n  }\n\n// Loop with unknown size correctly unrolled.\n#pragma unroll 5\n  for (int k : b) {\n    k++;\n  }\n\n  // Loop with large size should be partially unrolled.\n  int c[51];\n#pragma unroll\n  for (int k : c) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[k]++;\n  }\n\n// Loop with large size correctly unrolled.\n#pragma unroll 5\n  for (int k : c) {\n    A[k]++;\n  }\n}\n\n// Simple for loops.\nvoid for_loops(int *A, int size) {\n  // Recommend unrolling loops that aren't already unrolled.\n  for (int i = 0; i < 2000; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    A[0] += i;\n  }\n\n// Loop with known size correctly unrolled.\n#pragma unroll\n  for (int i = 0; i < 50; ++i) {\n    A[i]++;\n  }\n\n// Loop with unknown size should be partially unrolled.\n#pragma unroll\n  for (int i = 0; i < size; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n#pragma unroll\n  for (;;) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[0]++;\n  }\n\n  int i = 0;\n#pragma unroll\n  for (; i < size; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n#pragma unroll\n  for (int i = 0;; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n#pragma unroll\n  for (int i = 0; i < size;) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n#pragma unroll\n  for (int i = size; i < 50; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n#pragma unroll\n  for (int i = 0; true; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n#pragma unroll\n  for (int i = 0; i == i; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n// Loop with unknown size correctly unrolled.\n#pragma unroll 5\n  for (int i = 0; i < size; ++i) {\n    A[i]++;\n  }\n\n// Loop with large size should be partially unrolled.\n#pragma unroll\n  for (int i = 0; i < 51; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n// Loop with large size correctly unrolled.\n#pragma unroll 5\n  for (int i = 0; i < 51; ++i) {\n    A[i]++;\n  }\n}\n\n// For loops with different increments.\nvoid for_loop_increments(int *A) {\n// ++\n#pragma unroll\n  for (int i = 0; i < 50; ++i)\n    A[i]++; // OK\n\n#pragma unroll\n  for (int i = 0; i < 51; ++i)\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++; // Not OK\n\n// --\n#pragma unroll\n  for (int i = 50; i > 0; --i)\n    A[i]++; // OK\n\n#pragma unroll\n  for (int i = 51; i > 0; --i)\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++; // Not OK\n\n// +=\n#pragma unroll\n  for (int i = 0; i < 100; i += 2)\n    A[i]++; // OK\n\n#pragma unroll\n  for (int i = 0; i < 101; i += 2)\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++; // Not OK\n\n// -=\n#pragma unroll\n  for (int i = 100; i > 0; i -= 2)\n    A[i]++; // OK\n\n#pragma unroll\n  for (int i = 101; i > 0; i -= 2)\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    A[i]++; // Not OK\n}\n\n// Inner loops should be unrolled.\nvoid nested_simple_loops(int *A) {\n  for (int i = 0; i < 1000; ++i) {\n    for (int j = 0; j < 2000; ++j) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[0] += i + j;\n    }\n  }\n\n  for (int i = 0; i < 1000; ++i) {\n    int j = 0;\n    while (j < 2000) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[1] += i + j;\n      j++;\n    }\n  }\n\n  for (int i = 0; i < 1000; ++i) {\n    int j = 0;\n    do {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[2] += i + j;\n      j++;\n    } while (j < 2000);\n  }\n\n  int i = 0;\n  while (i < 1000) {\n    for (int j = 0; j < 2000; ++j) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[3] += i + j;\n    }\n    i++;\n  }\n\n  i = 0;\n  while (i < 1000) {\n    int j = 0;\n    while (j < 2000) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[4] += i + j;\n      j++;\n    }\n    i++;\n  }\n\n  i = 0;\n  while (i < 1000) {\n    int j = 0;\n    do {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[5] += i + j;\n      j++;\n    } while (j < 2000);\n    i++;\n  }\n\n  i = 0;\n  do {\n    for (int j = 0; j < 2000; ++j) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[6] += i + j;\n    }\n    i++;\n  } while (i < 1000);\n\n  i = 0;\n  do {\n    int j = 0;\n    while (j < 2000) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[7] += i + j;\n      j++;\n    }\n    i++;\n  } while (i < 1000);\n\n  i = 0;\n  do {\n    int j = 0;\n    do {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n      A[8] += i + j;\n      j++;\n    } while (j < 2000);\n    i++;\n  } while (i < 1000);\n\n  for (int i = 0; i < 100; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    A[i]++;\n  }\n\n  i = 0;\n  while (i < 100) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    i++;\n  }\n\n  i = 0;\n  do {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: kernel performance could be improved by unrolling this loop with a '#pragma unroll' directive [altera-unroll-loops]\n    i++;\n  } while (i < 100);\n}\n\n// These loops are all correctly unrolled.\nvoid unrolled_nested_simple_loops(int *A) {\n  for (int i = 0; i < 1000; ++i) {\n#pragma unroll\n    for (int j = 0; j < 50; ++j) {\n      A[0] += i + j;\n    }\n  }\n\n  for (int i = 0; i < 1000; ++i) {\n    int j = 0;\n#pragma unroll 5\n    while (j < 50) {\n      A[1] += i + j;\n      j++;\n    }\n  }\n\n  for (int i = 0; i < 1000; ++i) {\n    int j = 0;\n#pragma unroll 5\n    do {\n      A[2] += i + j;\n      j++;\n    } while (j < 50);\n  }\n\n  int i = 0;\n  while (i < 1000) {\n#pragma unroll\n    for (int j = 0; j < 50; ++j) {\n      A[3] += i + j;\n    }\n    i++;\n  }\n\n  i = 0;\n  while (i < 1000) {\n    int j = 0;\n#pragma unroll 5\n    while (50 > j) {\n      A[4] += i + j;\n      j++;\n    }\n    i++;\n  }\n\n  i = 0;\n  while (1000 > i) {\n    int j = 0;\n#pragma unroll 5\n    do {\n      A[5] += i + j;\n      j++;\n    } while (j < 50);\n    i++;\n  }\n\n  i = 0;\n  do {\n#pragma unroll\n    for (int j = 0; j < 50; ++j) {\n      A[6] += i + j;\n    }\n    i++;\n  } while (i < 1000);\n\n  i = 0;\n  do {\n    int j = 0;\n#pragma unroll 5\n    while (j < 50) {\n      A[7] += i + j;\n      j++;\n    }\n    i++;\n  } while (i < 1000);\n\n  i = 0;\n  do {\n    int j = 0;\n#pragma unroll 5\n    do {\n      A[8] += i + j;\n      j++;\n    } while (j < 50);\n    i++;\n  } while (i < 1000);\n}\n\n// These inner loops are large and should be partially unrolled.\nvoid unrolled_nested_simple_loops_large_num_iterations(int *A) {\n  for (int i = 0; i < 1000; ++i) {\n#pragma unroll\n    for (int j = 0; j < 51; ++j) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n      A[0] += i + j;\n    }\n  }\n\n  int i = 0;\n  while (i < 1000) {\n#pragma unroll\n    for (int j = 0; j < 51; ++j) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n      A[3] += i + j;\n    }\n    i++;\n  }\n\n  i = 0;\n  do {\n#pragma unroll\n    for (int j = 0; j < 51; ++j) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n      A[6] += i + j;\n    }\n    i++;\n  } while (i < 1000);\n\n  i = 0;\n  do {\n    int j = 0;\n#pragma unroll\n    do {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: note: full unrolling requested, but loop bounds may not be known; to partially unroll this loop, use the '#pragma unroll <num>' directive\n      A[8] += i + j;\n      j++;\n    } while (j < 51);\n    i++;\n  } while (i < 1000);\n\n  i = 0;\n  int a[51];\n  do {\n#pragma unroll\n    for (int k : a) {\n      // CHECK-MESSAGES: :[[@LINE-1]]:5: warning: loop likely has a large number of iterations and thus cannot be fully unrolled; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n      A[k]++;\n    }\n  } while (i < 1000);\n}\n\n// These loops have unknown bounds and should be partially unrolled.\nvoid fully_unrolled_unknown_bounds(int vectorSize) {\n  int someVector[101];\n\n// There is no loop condition\n#pragma unroll\n  for (;;) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    someVector[0]++;\n  }\n\n#pragma unroll\n  for (int i = 0; 1 < 5; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    someVector[i]++;\n  }\n\n// Both sides are value-dependent\n#pragma unroll\n  for (int i = 0; i < vectorSize; ++i) {\n    // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: full unrolling requested, but loop bounds are not known; to partially unroll this loop, use the '#pragma unroll <num>' directive [altera-unroll-loops]\n    someVector[i]++;\n  }\n}\n#endif\n// There are no fix-its for this check"
    }
  ]
}