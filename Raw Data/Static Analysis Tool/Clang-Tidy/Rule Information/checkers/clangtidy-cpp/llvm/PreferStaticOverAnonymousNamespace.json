{
  "name": "PreferStaticOverAnonymousNamespace",
  "language": "cpp",
  "description": ".. title:: clang-tidy - llvm-prefer-static-over-anonymous-namespace",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 111,
  "branches": 17,
  "apis": 73,
  "test": [
    {
      "description": null,
      "expected-problems": 50,
      "expected-linenumbers": [
        14,
        24,
        27,
        30,
        34,
        38,
        41,
        44,
        51,
        54,
        57,
        63,
        65,
        72,
        74,
        79,
        83,
        86,
        89,
        92,
        95,
        98,
        102,
        106,
        110,
        117,
        119,
        126,
        128,
        131,
        138,
        142,
        146,
        150,
        154,
        158,
        161,
        164,
        172,
        177,
        187,
        189,
        196,
        198,
        203,
        230,
        232,
        239,
        241,
        244
      ],
      "code": "\n// RUN: %check_clang_tidy %s llvm-prefer-static-over-anonymous-namespace %t -- -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -check-suffixes=,VAR %s llvm-prefer-static-over-anonymous-namespace %t -- \\\n// RUN:   -config=\"{CheckOptions: { \\\n// RUN:     llvm-prefer-static-over-anonymous-namespace.AllowVariableDeclarations: false }, \\\n// RUN:   }\" -- -fno-delayed-template-parsing\n// RUN: %check_clang_tidy -check-suffixes=,MEM %s llvm-prefer-static-over-anonymous-namespace %t -- \\\n// RUN:   -config=\"{CheckOptions: { \\\n// RUN:     llvm-prefer-static-over-anonymous-namespace.AllowMemberFunctionsInClass: false }, \\\n// RUN:   }\" -- -fno-delayed-template-parsing\n\nnamespace {\n\nvoid regularFunction() {\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: function 'regularFunction' is declared in an anonymous namespace; prefer using 'static' for restricting visibility [llvm-prefer-static-over-anonymous-namespace]\n\n  int Variable = 42;\n  auto Lambda = []() { return 42; };\n  static int StaticVariable = 42;\n}\n\nvoid declaredFunction();\n\nstatic void staticFunction() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: place static function 'staticFunction' outside of an anonymous namespace\n\nint globalVariable = 42;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:5: warning: variable 'globalVariable' is declared in an anonymous namespace;\n\nstatic int staticVariable = 42;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:12: warning: place static variable 'staticVariable' outside of an anonymous namespace\n\ntypedef int MyInt;\nconst MyInt myGlobalVariable = 42;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:13: warning: variable 'myGlobalVariable' is declared in an anonymous namespace;\n\ntemplate<typename T>\nconstexpr T Pi = T(3.1415926);\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:13: warning: variable 'Pi' is declared in an anonymous namespace;\n\nvoid (*funcPtr)() = nullptr;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:8: warning: variable 'funcPtr' is declared in an anonymous namespace;\n\nauto lambda = []() { return 42; };\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:6: warning: variable 'lambda' is declared in an anonymous namespace;\n\nclass InstanceClass {\n  int member;\n};\n\nInstanceClass instance;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:15: warning: variable 'instance' is declared in an anonymous namespace;\n\nInstanceClass* instancePtr = nullptr;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:16: warning: variable 'instancePtr' is declared in an anonymous namespace;\n\nInstanceClass& instanceRef = instance;\n// CHECK-MESSAGES-VAR: :[[@LINE-1]]:16: warning: variable 'instanceRef' is declared in an anonymous namespace;\n\nclass MyClass {\npublic:\n  MyClass();\n  MyClass(const MyClass&) {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'MyClass' outside of an anonymous namespace\n  MyClass(MyClass&&) = default;\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'MyClass' outside of an anonymous namespace\n  MyClass& operator=(const MyClass&);\n  MyClass& operator=(MyClass&&);\n  bool operator<(const MyClass&) const;\n  void memberFunction();\n  static void staticMemberFunction();\n  void memberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'memberDefinedInClass' outside of an anonymous namespace\n  static void staticMemberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:15: warning: place definition of method 'staticMemberDefinedInClass' outside of an anonymous namespace\n  template <typename T>\n  void templateFunction();\n  template <typename T>\n  void templateFunctionInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'templateFunctionInClass' outside of an anonymous namespace\n};\n\nMyClass::MyClass() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:10: warning: place definition of method 'MyClass' outside of an anonymous namespace\n\nMyClass& MyClass::operator=(const MyClass&) { return *this; }\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: place definition of method 'operator=' outside of an anonymous namespace\n\nMyClass& MyClass::operator=(MyClass&&) = default;\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: place definition of method 'operator=' outside of an anonymous namespace\n\nbool MyClass::operator<(const MyClass&) const { return true; }\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: place definition of method 'operator<' outside of an anonymous namespace\n\nvoid MyClass::memberFunction() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: place definition of method 'memberFunction' outside of an anonymous namespace\n\nvoid MyClass::staticMemberFunction() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: place definition of method 'staticMemberFunction' outside of an anonymous namespace\n\ntemplate <typename T>\nvoid MyClass::templateFunction() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:15: warning: place definition of method 'templateFunction' outside of an anonymous namespace\n\ntemplate<typename T>\nvoid templateFunction(T Value) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: function 'templateFunction' is declared in an anonymous namespace; prefer using 'static' for restricting visibility\n\ntemplate<>\nvoid templateFunction<int>(int Value) {}\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: function 'templateFunction<int>' is declared in an anonymous namespace; prefer using 'static' for restricting visibility\n\ntemplate<typename T>\nclass TemplateClass {\npublic:\n  TemplateClass();\n  TemplateClass(const TemplateClass&) {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'TemplateClass<T>' outside of an anonymous namespace\n  TemplateClass(TemplateClass&&) = default;\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'TemplateClass<T>' outside of an anonymous namespace\n  TemplateClass& operator=(const TemplateClass&);\n  TemplateClass& operator=(TemplateClass&&);\n  bool operator<(const TemplateClass&) const;\n  void memberFunc();\n  T getValue() const;\n  void memberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'memberDefinedInClass' outside of an anonymous namespace\n  static void staticMemberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:15: warning: place definition of method 'staticMemberDefinedInClass' outside of an anonymous namespace\n  template <typename U>\n  void templateMethodInTemplateClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'templateMethodInTemplateClass' outside of an anonymous namespace\nprivate:\n  T Value;\n};\n\ntemplate<typename T>\nTemplateClass<T>::TemplateClass() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:19: warning: place definition of method 'TemplateClass<T>' outside of an anonymous namespace\n\ntemplate<typename T>\nTemplateClass<T>& TemplateClass<T>::operator=(const TemplateClass&) { return *this; }\n// CHECK-MESSAGES: :[[@LINE-1]]:37: warning: place definition of method 'operator=' outside of an anonymous namespace\n\ntemplate<typename T>\nTemplateClass<T>& TemplateClass<T>::operator=(TemplateClass&&) = default;\n// CHECK-MESSAGES: :[[@LINE-1]]:37: warning: place definition of method 'operator=' outside of an anonymous namespace\n\ntemplate<typename T>\nbool TemplateClass<T>::operator<(const TemplateClass&) const { return true; }\n// CHECK-MESSAGES: :[[@LINE-1]]:24: warning: place definition of method 'operator<' outside of an anonymous namespace\n\ntemplate<typename T>\nvoid TemplateClass<T>::memberFunc() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:24: warning: place definition of method 'memberFunc' outside of an anonymous namespace\n\ntemplate<typename T>\nT TemplateClass<T>::getValue() const { return Value; }\n// CHECK-MESSAGES: :[[@LINE-1]]:21: warning: place definition of method 'getValue' outside of an anonymous namespace\n\ninline void inlineFunction() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:13: warning: function 'inlineFunction' is declared in an anonymous namespace; prefer using 'static' for restricting visibility\n\nauto autoReturnFunction() -> int { return 42; }\n// CHECK-MESSAGES: :[[@LINE-1]]:6: warning: function 'autoReturnFunction' is declared in an anonymous namespace; prefer using 'static' for restricting visibility\n\nclass OuterClass {\npublic:\n  class NestedClass {\n  public:\n    void nestedMemberFunc();\n    void nestedMemberDefinedInClass() {}\n    // CHECK-MESSAGES-MEM: :[[@LINE-1]]:10: warning: place definition of method 'nestedMemberDefinedInClass' outside of an anonymous namespace\n  };\n};\n\nvoid OuterClass::NestedClass::nestedMemberFunc() {}\n// CHECK-MESSAGES: :[[@LINE-1]]:31: warning: place definition of method 'nestedMemberFunc' outside of an anonymous namespace\n\n} // namespace\n\nnamespace {\n\nclass MyClassOutOfAnon {\npublic:\n  MyClassOutOfAnon();\n  MyClassOutOfAnon(const MyClassOutOfAnon&) {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'MyClassOutOfAnon' outside of an anonymous namespace\n  MyClassOutOfAnon(MyClassOutOfAnon&&) = default;\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'MyClassOutOfAnon' outside of an anonymous namespace\n  MyClassOutOfAnon& operator=(const MyClassOutOfAnon&);\n  MyClassOutOfAnon& operator=(MyClassOutOfAnon&&);\n  bool operator<(const MyClassOutOfAnon&) const;\n  void memberFunction();\n  static void staticMemberFunction();\n  void memberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'memberDefinedInClass' outside of an anonymous namespace\n  static void staticMemberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:15: warning: place definition of method 'staticMemberDefinedInClass' outside of an anonymous namespace\n  template <typename T>\n  void templateFunction();\n  template <typename T>\n  void templateFunctionInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'templateFunctionInClass' outside of an anonymous namespace\n};\n\n} // namespace\n\nMyClassOutOfAnon::MyClassOutOfAnon() {}\n\nMyClassOutOfAnon& MyClassOutOfAnon::operator=(const MyClassOutOfAnon&) { return *this; }\n\nMyClassOutOfAnon& MyClassOutOfAnon::operator=(MyClassOutOfAnon&&) = default;\n\nbool MyClassOutOfAnon::operator<(const MyClassOutOfAnon&) const { return true; }\n\nvoid MyClassOutOfAnon::memberFunction() {}\n\nvoid MyClassOutOfAnon::staticMemberFunction() {}\n\ntemplate <typename T>\nvoid MyClassOutOfAnon::templateFunction() {}\n\nnamespace {\n\ntemplate<typename T>\nclass TemplateClassOutOfAnon {\n  public:\n  TemplateClassOutOfAnon();\n  TemplateClassOutOfAnon(const TemplateClassOutOfAnon&) {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'TemplateClassOutOfAnon<T>' outside of an anonymous namespace\n  TemplateClassOutOfAnon(TemplateClassOutOfAnon&&) = default;\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:3: warning: place definition of method 'TemplateClassOutOfAnon<T>' outside of an anonymous namespace\n  TemplateClassOutOfAnon& operator=(const TemplateClassOutOfAnon&);\n  TemplateClassOutOfAnon& operator=(TemplateClassOutOfAnon&&);\n  bool operator<(const TemplateClassOutOfAnon&) const;\n  void memberFunc();\n  T getValue() const;\n  void memberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'memberDefinedInClass' outside of an anonymous namespace\n  static void staticMemberDefinedInClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:15: warning: place definition of method 'staticMemberDefinedInClass' outside of an anonymous namespace\n  template <typename U>\n  void templateMethodInTemplateClass() {}\n  // CHECK-MESSAGES-MEM: :[[@LINE-1]]:8: warning: place definition of method 'templateMethodInTemplateClass' outside of an anonymous namespace\n  private:\n  T Value;\n};\n\n} // namespace\n\ntemplate<typename T>\nTemplateClassOutOfAnon<T>::TemplateClassOutOfAnon() {}\n\ntemplate<typename T>\nTemplateClassOutOfAnon<T>& TemplateClassOutOfAnon<T>::operator=(const TemplateClassOutOfAnon&) { return *this; }\n\ntemplate<typename T>\nTemplateClassOutOfAnon<T>& TemplateClassOutOfAnon<T>::operator=(TemplateClassOutOfAnon&&) = default;\n\ntemplate<typename T>\nbool TemplateClassOutOfAnon<T>::operator<(const TemplateClassOutOfAnon&) const { return true; }\n\ntemplate<typename T>\nvoid TemplateClassOutOfAnon<T>::memberFunc() {}\n\ntemplate<typename T>\nT TemplateClassOutOfAnon<T>::getValue() const { return Value; }\n\n\n#define DEFINE_FUNCTION(name) \\\n  namespace { \\\n    void name() {} \\\n  }\n\nDEFINE_FUNCTION(macroDefinedFunction)\n\n#define DECLARE_VAR(type, name, value) \\\n  namespace { \\\n    type name = value; \\\n  }\n\nDECLARE_VAR(int, macroVariable, 42)\n\nnamespace {\n\n#define INTERNAL_FUNC void internalMacroFunc() {}\n\nINTERNAL_FUNC\n\n} // namespace"
    }
  ]
}