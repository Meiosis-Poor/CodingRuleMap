{
  "name": "RedundantExpression",
  "language": "cpp",
  "description": ".. title:: clang-tidy - misc-redundant-expression",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 1477,
  "branches": 225,
  "apis": 919,
  "test": [
    {
      "description": null,
      "expected-problems": 217,
      "expected-linenumbers": [
        21,
        23,
        25,
        28,
        30,
        32,
        35,
        37,
        39,
        41,
        44,
        46,
        49,
        52,
        54,
        56,
        58,
        61,
        63,
        66,
        68,
        71,
        73,
        76,
        78,
        81,
        83,
        86,
        88,
        90,
        159,
        161,
        163,
        165,
        167,
        169,
        173,
        175,
        177,
        179,
        182,
        184,
        186,
        189,
        191,
        219,
        226,
        242,
        247,
        276,
        278,
        281,
        283,
        286,
        288,
        290,
        292,
        294,
        296,
        298,
        300,
        302,
        304,
        306,
        308,
        315,
        347,
        349,
        351,
        353,
        367,
        369,
        410,
        412,
        414,
        416,
        425,
        459,
        470,
        476,
        478,
        480,
        482,
        485,
        487,
        490,
        492,
        494,
        496,
        499,
        501,
        504,
        507,
        509,
        512,
        514,
        517,
        519,
        521,
        523,
        526,
        528,
        531,
        545,
        547,
        549,
        551,
        554,
        556,
        559,
        561,
        563,
        565,
        568,
        570,
        626,
        628,
        630,
        632,
        635,
        637,
        639,
        641,
        644,
        646,
        648,
        651,
        653,
        655,
        657,
        671,
        673,
        675,
        677,
        679,
        683,
        685,
        687,
        689,
        691,
        708,
        710,
        712,
        714,
        716,
        718,
        721,
        723,
        726,
        728,
        730,
        732,
        734,
        736,
        739,
        741,
        743,
        746,
        748,
        750,
        752,
        755,
        757,
        759,
        762,
        764,
        766,
        769,
        771,
        773,
        775,
        778,
        780,
        782,
        784,
        787,
        789,
        791,
        793,
        795,
        798,
        800,
        802,
        805,
        807,
        809,
        838,
        840,
        842,
        844,
        846,
        848,
        890,
        892,
        894,
        918,
        921,
        924,
        927,
        953,
        970,
        972,
        974,
        976,
        978,
        982,
        984,
        986,
        988,
        991,
        1001,
        1004,
        1007,
        1010,
        1013,
        1015,
        1073
      ],
      "code": "\n// RUN: %check_clang_tidy %s misc-redundant-expression %t -- -- -fno-delayed-template-parsing -Wno-array-compare-cxx26\n// RUN: %check_clang_tidy %s misc-redundant-expression %t -- -- -fno-delayed-template-parsing -Wno-array-compare-cxx26 -DTEST_MACRO\n\ntypedef __INT64_TYPE__ I64;\n\nstruct Point {\n  int x;\n  int y;\n  int a[5];\n} P;\n\nextern Point P1;\nextern Point P2;\n\nextern int foo(int x);\nextern int bar(int x);\nextern int bat(int x, int y);\n\nint TestSimpleEquivalent(int X, int Y) {\n  if (X - X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent [misc-redundant-expression]\n  if (X / X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X % X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n\n  if (X & X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X | X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X ^ X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n\n  if (X < X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X <= X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X > X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X >= X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n\n  if (X && X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (X || X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n\n  if (X != (((X)))) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n\n  if (X + 1 == X + 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (X + 1 != X + 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (X + 1 <= X + 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (X + 1 >= X + 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n\n  if ((X != 1 || Y != 1) && (X != 1 || Y != 1)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: both sides of operator are equivalent\n  if (P.a[X - P.x] != P.a[X - P.x]) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: both sides of operator are equivalent\n\n  if ((int)X < (int)X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n  if (int(X) < int(X)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n\n  if ( + \"dummy\" == + \"dummy\") return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: both sides of operator are equivalent\n  if (L\"abc\" == L\"abc\") return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n\n  if (foo(0) - 2 < foo(0) - 2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: both sides of operator are equivalent\n  if (foo(bar(0)) < (foo(bar((0))))) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: both sides of operator are equivalent\n\n  if (P1.x < P2.x && P1.x < P2.x) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: both sides of operator are equivalent\n  if (P2.a[P1.x + 2] < P2.x && P2.a[(P1.x) + (2)] < (P2.x)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:29: warning: both sides of operator are equivalent\n\n  if (X && Y && X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: operator has equivalent nested operands\n  if (X || (Y || X)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: operator has equivalent nested operands\n  if ((X ^ Y) ^ (Y ^ X)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: operator has equivalent nested operands\n\n  return 0;\n}\n\n#ifndef TEST_MACRO\n#define VAL_1 2\n#define VAL_3 3\n#else\n#define VAL_1 3\n#define VAL_3 2\n#endif\n\n#define VAL_2 2\n\n#ifndef TEST_MACRO\n#define VAL_4 2 + 1\n#define VAL_6 3 + 1\n#else\n#define VAL_4 3 + 1\n#define VAL_6 2 + 1\n#endif\n\n#define VAL_5 2 + 1\n\nstruct TestStruct\n{\n  int mA;\n  int mB;\n  int mC[10];\n};\n\nint TestDefineEquivalent() {\n\n  int int_val1 = 3;\n  int int_val2 = 4;\n  int int_val = 0;\n  const int cint_val2 = 4;\n\n  // Cases which should not be reported\n  if (VAL_1 != VAL_2)  return 0;\n  if (VAL_3 != VAL_2)  return 0;\n  if (VAL_1 == VAL_2)  return 0;\n  if (VAL_3 == VAL_2)  return 0;\n  if (VAL_1 >= VAL_2)  return 0;\n  if (VAL_3 >= VAL_2)  return 0;\n  if (VAL_1 <= VAL_2)  return 0;\n  if (VAL_3 <= VAL_2)  return 0;\n  if (VAL_1 < VAL_2)  return 0;\n  if (VAL_3 < VAL_2)  return 0;\n  if (VAL_1 > VAL_2)  return 0;\n  if (VAL_3 > VAL_2)  return 0;\n\n  if (VAL_4 != VAL_5)  return 0;\n  if (VAL_6 != VAL_5)  return 0;\n  if (VAL_6 == VAL_5)  return 0;\n  if (VAL_4 >= VAL_5)  return 0;\n  if (VAL_6 >= VAL_5)  return 0;\n  if (VAL_4 <= VAL_5)  return 0;\n  if (VAL_6 <= VAL_5)  return 0;\n  if (VAL_4 > VAL_5)  return 0;\n  if (VAL_6 > VAL_5)  return 0;\n  if (VAL_4 < VAL_5)  return 0;\n  if (VAL_6 < VAL_5)  return 0;\n\n  if (VAL_1 != 2)  return 0;\n  if (VAL_3 == 3)  return 0;\n\n  if (VAL_1 >= VAL_1)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (VAL_2 <= VAL_2)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (VAL_3 > VAL_3)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (VAL_4 < VAL_4)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (VAL_6 == VAL_6) return 2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (VAL_5 != VAL_5) return 2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n\n  // Test prefixes\n  if (+VAL_6 == +VAL_6) return 2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n  if (-VAL_6 == -VAL_6) return 2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n  if ((+VAL_6) == (+VAL_6)) return 2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: both sides of operator are equivalent\n  if ((-VAL_6) == (-VAL_6)) return 2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: both sides of operator are equivalent\n\n  if (1 >= 1)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of operator are equivalent\n  if (0xFF <= 0xFF)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:12: warning: both sides of operator are equivalent\n  if (042 > 042)  return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: both sides of operator are equivalent\n\n  int_val = (VAL_6 == VAL_6)?int_val1: int_val2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: both sides of operator are equivalent\n  int_val = (042 > 042)?int_val1: int_val2;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: both sides of operator are equivalent\n\n\n  // Ternary operator cases which should not be reported\n  int_val = (VAL_4 == VAL_5)? int_val1: int_val2;\n  int_val = (VAL_3 != VAL_2)? int_val1: int_val2;\n  int_val = (VAL_6 != 10)? int_val1: int_val2;\n  int_val = (VAL_6 != 3)? int_val1: int_val2;\n  int_val = (VAL_6 != 4)? int_val1: int_val2;\n  int_val = (VAL_6 == 3)? int_val1: int_val2;\n  int_val = (VAL_6 == 4)? int_val1: int_val2;\n\n  TestStruct tsVar1 = {\n    .mA = 3,\n    .mB = int_val,\n    .mC[0 ... VAL_2 - 2] = int_val + 1,\n  };\n\n  TestStruct tsVar2 = {\n    .mA = 3,\n    .mB = int_val,\n    .mC[0 ... cint_val2 - 2] = int_val + 1,\n  };\n\n  TestStruct tsVar3 = {\n    .mA = 3,\n    .mB = int_val,\n    .mC[0 ... VAL_3 - VAL_3] = int_val + 1,\n    // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: both sides of operator are equivalent\n  };\n\n  TestStruct tsVar4 = {\n    .mA = 3,\n    .mB = int_val,\n    .mC[0 ... 5 - 5] = int_val + 1,\n    // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: both sides of operator are equivalent\n  };\n\n  return 1 + int_val + sizeof(tsVar1) + sizeof(tsVar2) +\n         sizeof(tsVar3) + sizeof(tsVar4);\n}\n\n#define LOOP_DEFINE 1\n\nunsigned int testLoops(const unsigned int  arr1[LOOP_DEFINE])\n{\n  unsigned int localIndex;\n  for (localIndex = LOOP_DEFINE - 1; localIndex > 0; localIndex--)\n  {\n  }\n  for (localIndex = LOOP_DEFINE - 1; 10 > 10; localIndex--)\n  // CHECK-MESSAGES: :[[@LINE-1]]:41: warning: both sides of operator are equivalent\n  {\n  }\n\n  for (localIndex = LOOP_DEFINE - 1; LOOP_DEFINE > LOOP_DEFINE; localIndex--)\n  // CHECK-MESSAGES: :[[@LINE-1]]:50: warning: both sides of operator are equivalent\n  {\n  }\n\n  return localIndex;\n}\n\n#define getValue(a) a\n#define getValueM(a) a\n\nint TestParamDefine() {\n  int ret = 0;\n\n  // Negative cases\n  ret += getValue(VAL_6) == getValue(2);\n  ret += getValue(VAL_6) == getValue(3);\n  ret += getValue(VAL_5) == getValue(2);\n  ret += getValue(VAL_5) == getValue(3);\n  ret += getValue(1) > getValue( 2);\n  ret += getValue(VAL_1) == getValue(VAL_2);\n  ret += getValue(VAL_1) != getValue(VAL_2);\n  ret += getValue(VAL_1) == getValueM(VAL_1);\n  ret += getValue(VAL_1 + VAL_2) == getValueM(VAL_1 + VAL_2);\n  ret += getValue(1) == getValueM(1);\n  ret += getValue(false) == getValueM(false);\n  ret += -getValue(1) > +getValue( 1);\n\n  // Positive cases\n  ret += (+getValue(1)) > (+getValue( 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: both sides of operator are equivalent\n  ret += (-getValue(1)) > (-getValue( 1));\n  // CHECK-MESSAGES: :[[@LINE-1]]:25: warning: both sides of operator are equivalent\n\n  ret += +getValue(1) > +getValue( 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: both sides of operator are equivalent\n  ret += -getValue(1) > -getValue( 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: both sides of operator are equivalent\n\n  ret += getValue(1) > getValue( 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: both sides of operator are equivalent\n  ret += getValue(1) > getValue( 1  );\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: both sides of operator are equivalent\n  ret += getValue(1) > getValue(  1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: both sides of operator are equivalent\n  ret += getValue(     1) > getValue( 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:27: warning: both sides of operator are equivalent\n  ret += getValue( 1     ) > getValue( 1);\n  // CHECK-MESSAGES: :[[@LINE-1]]:28: warning: both sides of operator are equivalent\n  ret += getValue( VAL_5     ) > getValue(VAL_5);\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: both sides of operator are equivalent\n  ret += getValue( VAL_5     ) > getValue( VAL_5);\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: both sides of operator are equivalent\n  ret += getValue( VAL_5     ) > getValue( VAL_5  )  ;\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: both sides of operator are equivalent\n  ret += getValue(VAL_5) > getValue( VAL_5  )  ;\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: both sides of operator are equivalent\n  ret += getValue(VAL_1+VAL_2) > getValue(VAL_1 + VAL_2)  ;\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: both sides of operator are equivalent\n  ret += getValue(VAL_1)+getValue(VAL_2) > getValue(VAL_1) + getValue( VAL_2)  ;\n  // CHECK-MESSAGES: :[[@LINE-1]]:42: warning: both sides of operator are equivalent\n  ret += (getValue(VAL_1)+getValue(VAL_2)) > (getValue(VAL_1) + getValue( VAL_2) ) ;\n  // CHECK-MESSAGES: :[[@LINE-1]]:44: warning: both sides of operator are equivalent\n  return ret;\n}\n\ntemplate <int DX>\nint TestSimpleEquivalentDependent() {\n  if (DX > 0 && DX > 0) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n\n  return 0;\n}\n\nint Valid(int X, int Y) {\n  if (X != Y) return 1;\n  if (X == Y + 0) return 1;\n  if (P.x == P.y) return 1;\n  if (P.a[P.x] < P.a[P.y]) return 1;\n  if (P.a[0] < P.a[1]) return 1;\n\n  if (P.a[0] < P.a[0ULL]) return 1;\n  if (0 < 0ULL) return 1;\n  if ((int)0 < (int)0ULL) return 1;\n\n  if (++X != ++X) return 1;\n  if (P.a[X]++ != P.a[X]++) return 1;\n  if (P.a[X++] != P.a[X++]) return 1;\n  if (X && X++ && X) return 1;\n\n  if (\"abc\" == \"ABC\") return 1;\n  if (foo(bar(0)) < (foo(bat(0, 1)))) return 1;\n  return 0;\n}\n\n#define COND_OP_MACRO 9\n#define COND_OP_OTHER_MACRO 9\n#define COND_OP_THIRD_MACRO COND_OP_MACRO\nint TestConditional(int x, int y) {\n  int k = 0;\n  k += (y < 0) ? x : x;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: 'true' and 'false' expressions are equivalent\n  k += (y < 0) ? x + 1 : x + 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:24: warning: 'true' and 'false' expressions are equivalent\n  k += (y < 0) ? COND_OP_MACRO : COND_OP_MACRO;\n  // CHECK-MESSAGES: :[[@LINE-1]]:32: warning: 'true' and 'false' expressions are equivalent\n  k += (y < 0) ? COND_OP_MACRO + COND_OP_OTHER_MACRO : COND_OP_MACRO + COND_OP_OTHER_MACRO;\n  // CHECK-MESSAGES: :[[@LINE-1]]:54: warning: 'true' and 'false' expressions are equivalent\n\n  // Do not match for conditional operators with a macro and a const.\n  k += (y < 0) ? COND_OP_MACRO : 9;\n  // Do not match for conditional operators with expressions from different macros.\n  k += (y < 0) ? COND_OP_MACRO : COND_OP_OTHER_MACRO;\n  // Do not match for conditional operators when a macro is defined to another macro\n  k += (y < 0) ? COND_OP_MACRO : COND_OP_THIRD_MACRO;\n#undef COND_OP_THIRD_MACRO\n#define   COND_OP_THIRD_MACRO 8\n  k += (y < 0) ? COND_OP_MACRO : COND_OP_THIRD_MACRO;\n#undef COND_OP_THIRD_MACRO\n\n  k += (y < 0) ? sizeof(I64) : sizeof(I64);\n  // CHECK-MESSAGES: :[[@LINE-1]]:30: warning: 'true' and 'false' expressions are equivalent\n  k += (y < 0) ? sizeof(TestConditional(k,y)) : sizeof(TestConditional(k,y));\n  // CHECK-MESSAGES: :[[@LINE-1]]:47: warning: 'true' and 'false' expressions are equivalent\n  // No warning if the expression arguments are different.\n  k += (y < 0) ? sizeof(TestConditional(k,y)) : sizeof(Valid(k,y));\n\n  return k;\n}\n#undef COND_OP_MACRO\n#undef COND_OP_OTHER_MACRO\n\n// Overloaded operators that compare two instances of a struct.\nstruct MyStruct {\n  int x;\n  bool operator==(const MyStruct& rhs) const {return this->x == rhs.x; } // not modifing\n  bool operator>=(const MyStruct& rhs) const { return this->x >= rhs.x; } // not modifing\n  bool operator<=(MyStruct& rhs) const { return this->x <= rhs.x; }\n  bool operator&&(const MyStruct& rhs){ this->x++; return this->x && rhs.x; }\n} Q;\n\nbool operator!=(const MyStruct& lhs, const MyStruct& rhs) { return lhs.x == rhs.x; } // not modifing\nbool operator<(const MyStruct& lhs, const MyStruct& rhs) { return lhs.x < rhs.x; } // not modifing\nbool operator>(const MyStruct& lhs, MyStruct& rhs) { rhs.x--; return lhs.x > rhs.x; }\nbool operator||(MyStruct& lhs, const MyStruct& rhs) { lhs.x++; return lhs.x || rhs.x; }\n\nstruct MyStruct1 {\n  bool x;\n  MyStruct1(bool x) : x(x) {};\n  operator bool() { return x; }\n};\n\nMyStruct1 operator&&(const MyStruct1& lhs, const MyStruct1& rhs) { return lhs.x && rhs.x; }\nMyStruct1 operator||(MyStruct1& lhs, MyStruct1& rhs) { return lhs.x && rhs.x; }\n\nbool TestOverloadedOperator(MyStruct& S) {\n  if (S == Q) return false;\n\n  if (S <= S) return false;\n  if (S && S) return false;\n  if (S > S) return false;\n  if (S || S) return false;\n\n  if (S == S) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of overloaded operator are equivalent\n  if (S < S) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of overloaded operator are equivalent\n  if (S != S) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of overloaded operator are equivalent\n  if (S >= S) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: both sides of overloaded operator are equivalent\n\n  MyStruct1 U(false);\n  MyStruct1 V(true);\n\n  // valid because the operator is not const\n  if ((U || V) || U) return true;\n\n  if (U && V && U && V) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: overloaded operator has equivalent nested operands\n\n  return true;\n}\n\n#define LT(x, y) (void)((x) < (y))\n#define COND(x, y, z) ((x)?(y):(z))\n#define EQUALS(x, y) (x) == (y)\n\nint TestMacro(int X, int Y) {\n  LT(0, 0);\n  LT(1, 0);\n  LT(X, X);\n  LT(X+1, X + 1);\n  COND(X < Y, X, X);\n  EQUALS(Q, Q);\n  return 0;\n}\n\nint TestFalsePositive(int* A, int X, float F) {\n  // Produced by bison.\n  X = A[(2) - (2)];\n  X = A['a' - 'a'];\n\n  // Testing NaN.\n  if (F != F && F == F) return 1;\n  return 0;\n}\n\nint TestBannedMacros() {\n#define EAGAIN 3\n#define NOT_EAGAIN 3\n  if (EAGAIN == 0 | EAGAIN == 0) return 0;\n  if (NOT_EAGAIN == 0 | NOT_EAGAIN == 0) return 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: both sides of operator are equivalent\n  return 0;\n}\n\nstruct MyClass {\nstatic const int Value = 42;\n};\ntemplate <typename T, typename U>\nvoid TemplateCheck() {\n  static_assert(T::Value == U::Value, \"should be identical\");\n  static_assert(T::Value == T::Value, \"should be identical\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:26: warning: both sides of operator are equivalent\n}\nvoid TestTemplate() { TemplateCheck<MyClass, MyClass>(); }\n\nint TestArithmetic(int X, int Y) {\n  if (X + 1 == X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X + 1 != X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n  if (X - 1 == X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X - 1 != X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if (X + 1LL == X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (X + 1ULL == X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: logical expression is always false\n\n  if (X == X + 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always false\n  if (X != X + 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always true\n  if (X == X - 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always false\n  if (X != X - 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always true\n\n  if (X != X - 1U) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always true\n  if (X != X - 1LL) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always true\n\n  if ((X+X) != (X+X) - 1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if (X + 1 == X + 2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X + 1 != X + 2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if (X - 1 == X - 2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X - 1 != X - 2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if (X + 1 == X - -1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n  if (X + 1 != X - -1) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X + 1 == X - -2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X + 1 != X - -2) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if (X + 1 == X - (~0)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n  if (X + 1 == X - (~0U)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if (X + 1 == X - (~0ULL)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  // Should not match.\n  if (X + 0.5 == X) return 1;\n  if (X + 1 == Y) return 1;\n  if (X + 1 == Y + 1) return 1;\n  if (X + 1 == Y + 2) return 1;\n\n  return 0;\n}\n\nint TestBitwise(int X, int Y) {\n\n  if ((X & 0xFF) == 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n  if ((X & 0xFF) != 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always true\n  if ((X | 0xFF) == 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n  if ((X | 0xFF) != 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always true\n\n  if ((X | 0xFFULL) != 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: logical expression is always true\n  if ((X | 0xFF) != 0xF00ULL) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always true\n\n  if ((0xFF & X) == 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n  if ((0xFF & X) != 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always true\n  if ((0xFF & X) == 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n  if ((0xFF & X) != 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always true\n\n  if ((0xFFLL & X) == 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: logical expression is always false\n  if ((0xFF & X) == 0xF00ULL) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n\n  return 0;\n}\n\n// Overloaded operators that compare an instance of a struct and an integer\n// constant.\nstruct S {\n  S() { x = 1; }\n  int x;\n  // Overloaded comparison operators without any possible side effect.\n  bool operator==(const int &i) const { return x == i; } // not modifying\n  bool operator!=(int i) const { return x != i; } // not modifying\n  bool operator>(const int &i) const { return x > i; } // not modifying\n  bool operator<(int i) const { return x < i; } // not modifying\n};\n\nbool operator<=(const S &s, int i) { return s.x <= i; } // not modifying\nbool operator>=(const S &s, const int &i) { return s.x >= i; } // not modifying\n\nbool operator==(int i, const S &s) { return s == i; } // not modifying\nbool operator<(const int &i, const S &s) { return s > i; } // not modifying\nbool operator<=(const int &i, const S &s) { return s >= i; } // not modifying\nbool operator>(const int &i, const S &s) { return s < i; } // not modifying\n\nstruct S2 {\n  S2() { x = 1; }\n  int x;\n  // Overloaded comparison operators that are able to modify their params.\n  bool operator==(const int &i) {\n    this->x++;\n    return x == i;\n  }\n  bool operator!=(int i) { return x != i; }\n  bool operator>(const int &i) { return x > i; }\n  bool operator<(int i) {\n    this->x--;\n    return x < i;\n  }\n};\n\nbool operator>=(S2 &s, const int &i) { return s.x >= i; }\nbool operator<=(S2 &s, int i) {\n  s.x++;\n  return s.x <= i;\n}\n\nint TestLogical(int X, int Y){\n#define CONFIG 0\n  if (CONFIG && X) return 1;\n#undef CONFIG\n#define CONFIG 1\n  if (CONFIG || X) return 1;\n#undef CONFIG\n\n  if (X == 10 && X != 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (X == 10 && (X != 10)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (X == 10 && !(X == 10)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (!(X != 10) && !(X == 10)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n\n  if (X == 10ULL && X != 10ULL) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n  if (!(X != 10U) && !(X == 10)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: logical expression is always false\n  if (!(X != 10LL) && !(X == 10)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: logical expression is always false\n  if (!(X != 10ULL) && !(X == 10)) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:21: warning: logical expression is always false\n\n  if (X == 0 && X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n  if (X != 0 && !X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n  if (X && !X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: logical expression is always false\n\n  if (X && !!X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: equivalent expression on both sides of logical operator\n  if (X != 0 && X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: equivalent expression on both sides of logical operator\n  if (X != 0 && !!X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: equivalent expression on both sides of logical operator\n  if (X == 0 && !X) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: equivalent expression on both sides of logical operator\n\n  // Should not match.\n  if (X == 10 && Y == 10) return 1;\n  if (X != 10 && X != 12) return 1;\n  if (X == 10 || X == 12) return 1;\n  if (!X && !Y) return 1;\n  if (!X && Y) return 1;\n  if (!X && Y == 0) return 1;\n  if (X == 10 && Y != 10) return 1;\n\n  // Test for overloaded operators with constant params.\n  S s1;\n  if (s1 == 1 && s1 == 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: equivalent expression on both sides of logical operator\n  if (s1 == 1 || s1 != 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always true\n  if (s1 > 1 && s1 < 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n  if (s1 >= 1 || s1 <= 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always true\n  if (s1 >= 2 && s1 <= 0) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n\n  // Same test as above but with swapped LHS/RHS on one side of the logical operator.\n  if (1 == s1 && s1 == 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: equivalent expression on both sides of logical operator\n  if (1 == s1 || s1 != 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always true\n  if (1 < s1 && s1 < 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n  if (1 <= s1 || s1 <= 1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always true\n  if (2 < s1 && 0 > s1) return true;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n\n  // Test for absence of false positives (issue #54011).\n  if (s1 == 1 || s1 == 2) return true;\n  if (s1 > 1 && s1 < 3) return true;\n  if (s1 >= 2 || s1 <= 0) return true;\n\n  // Test for overloaded operators that may modify their params.\n  S2 s2;\n  if (s2 == 1 || s2 != 1) return true;\n  if (s2 == 1 || s2 == 1) return true;\n  if (s2 > 1 && s2 < 1) return true;\n  if (s2 >= 1 || s2 <= 1) return true;\n}\n\nint TestRelational(int X, int Y) {\n  if (X == 10 && X > 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (X == 10 && X < 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (X < 10 && X > 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n  if (X <= 10 && X > 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always false\n  if (X < 10 && X >= 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n  if (X < 10 && X == 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n\n  if (X > 5 && X <= 5) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always false\n  if (X > -5 && X <= -5) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always false\n\n  if (X < 10 || X >= 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always true\n  if (X <= 10 || X > 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always true\n  if (X <= 10 || X >= 11) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:15: warning: logical expression is always true\n  if (X != 7 || X != 14) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always true\n  if (X == 7 || X != 5) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X != 7 || X == 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: logical expression is always true\n\n  if (X < 7 && X < 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X < 7 && X < 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (X < 7 && X < 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: expression is redundant\n\n  if (X < 7 && X <= 5) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X < 7 && X <= 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: equivalent expression on both sides of logical operator\n  if (X < 7 && X <= 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: expression is redundant\n  if (X < 7 && X <= 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: expression is redundant\n\n  if (X <= 7 && X < 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X <= 7 && X < 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X <= 7 && X < 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: equivalent expression on both sides of logical operator\n\n  if (X >= 7 && X > 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: equivalent expression on both sides of logical operator\n  if (X >= 7 && X > 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X >= 7 && X > 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n\n  if (X <= 7 && X <= 5) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X <= 7 && X <= 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X <= 7 && X <= 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: both sides of operator are equivalent\n  if (X <= 7 && X <= 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: expression is redundant\n\n  if (X == 11 && X > 10) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: expression is redundant\n  if (X == 11 && X < 12) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:20: warning: expression is redundant\n  if (X > 10 && X == 11) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X < 12 && X == 11) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n\n  if (X != 11 && X == 42) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X != 11 && X > 11) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X != 11 && X < 11) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X != 11 && X < 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X != 11 && X > 14) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n\n  if (X < 7 || X < 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: expression is redundant\n  if (X < 7 || X < 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (X < 7 || X < 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n\n  if (X > 7 || X > 6) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X > 7 || X > 7) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: both sides of operator are equivalent\n  if (X > 7 || X > 8) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: expression is redundant\n\n  // Should not match.\n  if (X < 10 || X > 12) return 1;\n  if (X > 10 && X < 12) return 1;\n  if (X < 10 || X >= 12) return 1;\n  if (X > 10 && X <= 12) return 1;\n  if (X <= 10 || X > 12) return 1;\n  if (X >= 10 && X < 12) return 1;\n  if (X <= 10 || X >= 12) return 1;\n  if (X >= 10 && X <= 12) return 1;\n  if (X >= 10 && X <= 11) return 1;\n  if (X >= 10 && X < 11) return 1;\n  if (X > 10 && X <= 11) return 1;\n  if (X > 10 && X != 11) return 1;\n  if (X >= 10 && X <= 10) return 1;\n  if (X <= 10 && X >= 10) return 1;\n  if (X < 0 || X > 0) return 1;\n}\n\nint TestRelationalMacros(int X){\n#define SOME_MACRO 3\n#define SOME_MACRO_SAME_VALUE 3\n#define SOME_OTHER_MACRO 9\n  // Do not match for redundant relational macro expressions that can be\n  // considered intentional, and for some particular values, non redundant.\n\n  // Test cases for expressions with the same macro on both sides.\n  if (X < SOME_MACRO && X > SOME_MACRO) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: logical expression is always false\n  if (X < SOME_MACRO && X == SOME_MACRO) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: logical expression is always false\n  if (X < SOME_MACRO || X >= SOME_MACRO) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: logical expression is always true\n  if (X <= SOME_MACRO || X > SOME_MACRO) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:23: warning: logical expression is always true\n  if (X != SOME_MACRO && X > SOME_MACRO) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n  if (X != SOME_MACRO && X < SOME_MACRO) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:9: warning: expression is redundant\n\n  // Test cases for two different macros.\n  if (X < SOME_MACRO && X > SOME_OTHER_MACRO) return 1;\n  if (X != SOME_MACRO && X >= SOME_OTHER_MACRO) return 1;\n  if (X != SOME_MACRO && X != SOME_OTHER_MACRO) return 1;\n  if (X == SOME_MACRO || X == SOME_MACRO_SAME_VALUE) return 1;\n  if (X == SOME_MACRO || X <= SOME_MACRO_SAME_VALUE) return 1;\n  if (X == SOME_MACRO || X > SOME_MACRO_SAME_VALUE) return 1;\n  if (X < SOME_MACRO && X <= SOME_OTHER_MACRO) return 1;\n  if (X == SOME_MACRO && X > SOME_OTHER_MACRO) return 1;\n  if (X == SOME_MACRO && X != SOME_OTHER_MACRO) return 1;\n  if (X == SOME_MACRO && X != SOME_MACRO_SAME_VALUE) return 1;\n  if (X == SOME_MACRO_SAME_VALUE && X == SOME_MACRO ) return 1;\n\n  // Test cases for a macro and a const.\n  if (X < SOME_MACRO && X > 9) return 1;\n  if (X != SOME_MACRO && X >= 9) return 1;\n  if (X != SOME_MACRO && X != 9) return 1;\n  if (X == SOME_MACRO || X == 3) return 1;\n  if (X == SOME_MACRO || X <= 3) return 1;\n  if (X < SOME_MACRO && X <= 9) return 1;\n  if (X == SOME_MACRO && X != 9) return 1;\n  if (X == SOME_MACRO && X == 9) return 1;\n\n#undef SOME_OTHER_MACRO\n#undef SOME_MACRO_SAME_VALUE\n#undef SOME_MACRO\n  return 0;\n}\n\nint TestValidExpression(int X) {\n  if (X - 1 == 1 - X) return 1;\n  if (2 * X == X) return 1;\n  if ((X << 1) == X) return 1;\n\n  return 0;\n}\n\nenum Color { Red, Yellow, Green };\nint TestRelationalWithEnum(enum Color C) {\n  if (C == Red && C == Yellow) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: logical expression is always false\n  if (C == Red && C != Red) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: logical expression is always false\n  if (C != Red || C != Yellow) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: logical expression is always true\n\n  // Should not match.\n  if (C == Red || C == Yellow) return 1;\n  if (C != Red && C != Yellow) return 1;\n\n  return 0;\n}\n\ntemplate<class T>\nint TestRelationalTemplated(int X) {\n  // This test causes a corner case with |isIntegerConstantExpr| where the type\n  // is dependent. There is an assert failing when evaluating\n  // sizeof(<incomplet-type>).\n  if (sizeof(T) == 4 || sizeof(T) == 8) return 1;\n\n  if (X + 0 == -X) return 1;\n  if (X + 0 < X) return 1;\n\n  return 0;\n}\n\nint TestWithSignedUnsigned(int X) {\n  if (X + 1 == X + 1ULL) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:13: warning: logical expression is always true\n\n  if ((X & 0xFFU) == 0xF00) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: logical expression is always false\n\n  if ((X & 0xFF) == 0xF00U) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: logical expression is always false\n\n  if ((X & 0xFFU) == 0xF00U) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:19: warning: logical expression is always false\n\n  return 0;\n}\n\nint TestWithLong(int X, I64 Y) {\n  if (X + 0ULL == -X) return 1;\n  if (Y + 0 == -Y) return 1;\n  if (Y <= 10 && X >= 10LL) return 1;\n  if (Y <= 10 && X >= 10ULL) return 1;\n  if (X <= 10 || X > 12LL) return 1;\n  if (X <= 10 || X > 12ULL) return 1;\n  if (Y <= 10 || Y > 12) return 1;\n\n  return 0;\n}\n\nint TestWithMinMaxInt(int X) {\n  if (X <= X + 0xFFFFFFFFU) return 1;\n  if (X <= X + 0x7FFFFFFF) return 1;\n  if (X <= X + 0x80000000) return 1;\n\n  if (X <= 0xFFFFFFFFU && X > 0) return 1;\n  if (X <= 0xFFFFFFFFU && X > 0U) return 1;\n\n  if (X + 0x80000000 == X - 0x80000000) return 1;\n  // CHECK-MESSAGES: :[[@LINE-1]]:22: warning: logical expression is always true\n\n  if (X > 0x7FFFFFFF || X < ((-0x7FFFFFFF)-1)) return 1;\n  if (X <= 0x7FFFFFFF && X >= ((-0x7FFFFFFF)-1)) return 1;\n\n  return 0;\n}\n\n#define FLAG1 1\n#define FLAG2 2\n#define FLAG3 4\n#define FLAGS (FLAG1 | FLAG2 | FLAG3)\n#define NOTFLAGS !(FLAG1 | FLAG2 | FLAG3)\nint TestOperatorConfusion(int X, int Y, long Z)\n{\n  // Ineffective & expressions.\n  Y = (Y << 8) & 0xff;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: ineffective bitwise and operation\n  Y = (Y << 12) & 0xfff;\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: ineffective bitwise and\n  Y = (Y << 12) & 0xff;\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: ineffective bitwise and\n  Y = (Y << 8) & 0x77;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: ineffective bitwise and\n  Y = (Y << 5) & 0x11;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: ineffective bitwise and\n\n  // Tests for unmatched types\n  Z = (Z << 8) & 0xff;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: ineffective bitwise and operation\n  Y = (Y << 12) & 0xfffL;\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: ineffective bitwise and\n  Z = (Y << 12) & 0xffLL;\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: ineffective bitwise and\n  Y = (Z << 8L) & 0x77L;\n  // CHECK-MESSAGES: :[[@LINE-1]]:17: warning: ineffective bitwise and\n\n  Y = (Y << 8) & 0;\n  // CHECK-MESSAGES: :[[@LINE-1]]:16: warning: ineffective bitwise and\n\n  Y = (Y << 8) & -1;\n\n  // Effective expressions. Do not check.\n  Y = (Y << 4) & 0x15;\n  Y = (Y << 3) & 0x250;\n  Y = (Y << 9) & 0xF33;\n\n  int K = !(1 | 2 | 4);\n  // CHECK-MESSAGES: :[[@LINE-1]]:11: warning: ineffective logical negation operator used; did you mean '~'?\n  // CHECK-FIXES: {{^}}  int K = ~(1 | 2 | 4);{{$}}\n  K = !(FLAG1 & FLAG2 & FLAG3);\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: ineffective logical negation operator\n  // CHECK-FIXES: {{^}}  K = ~(FLAG1 & FLAG2 & FLAG3);{{$}}\n  K = !(3 | 4);\n  // CHECK-MESSAGES: :[[@LINE-1]]:7: warning: ineffective logical negation operator\n  // CHECK-FIXES: {{^}}  K = ~(3 | 4);{{$}}\n  int NotFlags = !FLAGS;\n  // CHECK-MESSAGES: :[[@LINE-1]]:18: warning: ineffective logical negation operator\n  // CHECK-FIXES: {{^}}  int NotFlags = ~FLAGS;{{$}}\n  NotFlags = NOTFLAGS;\n  // CHECK-MESSAGES: :[[@LINE-1]]:14: warning: ineffective logical negation operator\n  return !(1 | 2 | 4);\n  // CHECK-MESSAGES: :[[@LINE-1]]:10: warning: ineffective logical negation operator\n  // CHECK-FIXES: {{^}}  return ~(1 | 2 | 4);{{$}}\n}\n\ntemplate <int Shift, int Mask>\nint TestOperatorConfusionDependent(int Y) {\n  int r1 = (Y << Shift) & 0xff;\n  int r2 = (Y << 8) & Mask;\n}\n#undef FLAG1\n#undef FLAG2\n#undef FLAG3\n\nnamespace no_crash {\nstruct Foo {};\nbool operator<(const Foo&, const Foo&);\ntemplate <class T>\nstruct Bar {\n  static const Foo &GetFoo();\n  static bool Test(const T & maybe_foo, const Foo& foo) {\n    return foo < GetFoo() && foo < maybe_foo;\n  }\n};\n\ntemplate <class... Values>\nstruct Bar2 {\n  static_assert((... && (sizeof(Values) > 0)) == (... && (sizeof(Values) > 0)));\n  // FIXME: It's not clear that we should be diagnosing this. The `&&` operator\n  // here is unresolved and could resolve to an overloaded operator that might\n  // have side-effects on its operands. For other constructs with the same\n  // property (eg, the `S2` cases above) we suppress this diagnostic. This\n  // started failing when Clang started properly modeling the fold-expression as\n  // containing an unresolved operator name.\n  // FIXME-MESSAGES: :[[@LINE-1]]:47: warning: both sides of operator are equivalent [misc-redundant-expression]\n};\n\n} // namespace no_crash\n\nint TestAssignSideEffect(int i) {\n  int k = i;\n\n  if ((k = k + 1) != 1 || (k = k + 1) != 2)\n    return 0;\n\n  if ((k = foo(0)) != 1 || (k = foo(0)) != 2)\n    return 1;\n\n  return 2;\n}\n\nnamespace PR63096 {\n\nstruct alignas(sizeof(int)) X {\n  int x;\n};\n\nstatic_assert(alignof(X) == sizeof(X));\nstatic_assert(sizeof(X) == sizeof(X));\n// CHECK-MESSAGES: :[[@LINE-1]]:25: warning: both sides of operator are equivalent\n\n}\n\nnamespace PR35857 {\n  void test() {\n    int x = 0;\n    int y = 0;\n    decltype(x + y - (x + y)) z = 10;\n  }\n}"
    }
  ]
}