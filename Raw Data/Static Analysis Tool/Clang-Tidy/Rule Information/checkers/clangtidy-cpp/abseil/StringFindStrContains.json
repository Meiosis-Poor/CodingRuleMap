{
  "name": "StringFindStrContains",
  "language": "cpp",
  "description": ".. title:: clang-tidy - abseil-string-find-str-contains",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 109,
  "branches": 1,
  "apis": 88,
  "test": [
    {
      "description": null,
      "expected-problems": 36,
      "expected-linenumbers": [
        72,
        76,
        80,
        85,
        89,
        93,
        98,
        102,
        106,
        117,
        121,
        126,
        130,
        135,
        139,
        148,
        152,
        156,
        161,
        165,
        169,
        174,
        178,
        182,
        193,
        197,
        201,
        206,
        210,
        214,
        219,
        223,
        227,
        234,
        239,
        244
      ],
      "code": "\n// RUN: %check_clang_tidy %s abseil-string-find-str-contains %t --\n\nusing size_t = decltype(sizeof(int));\n\nnamespace std {\n\n// Lightweight standin for std::string.\ntemplate <typename C>\nclass basic_string {\npublic:\n  basic_string();\n  basic_string(const basic_string &);\n  basic_string(const C *);\n  ~basic_string();\n  int find(basic_string s, int pos = 0);\n  int find(const C *s, int pos = 0);\n  int find(const C *s, int pos, int n);\n  int find(char c, int pos = 0);\n  static constexpr size_t npos = -1;\n};\ntypedef basic_string<char> string;\n\n// Lightweight standin for std::string_view.\ntemplate <typename C>\nclass basic_string_view {\npublic:\n  basic_string_view();\n  basic_string_view(const basic_string_view &);\n  basic_string_view(const C *);\n  ~basic_string_view();\n  int find(basic_string_view s, int pos = 0);\n  int find(const C *s, int pos = 0);\n  int find(const C *s, int pos, int n);\n  int find(char c, int pos = 0);\n  static constexpr size_t npos = -1;\n};\ntypedef basic_string_view<char> string_view;\n\n} // namespace std\n\nnamespace absl {\n\n// Lightweight standin for absl::string_view.\nclass string_view {\npublic:\n  string_view();\n  string_view(const string_view &);\n  string_view(const char *);\n  ~string_view();\n  int find(string_view s, int pos = 0);\n  int find(const char *s, int pos = 0);\n  int find(const char *s, int pos, int n);\n  int find(char c, int pos = 0);\n  static constexpr size_t npos = -1;\n};\n\n} // namespace absl\n\n// Functions that take and return our various string-like types.\nstd::string foo_ss(std::string);\nstd::string_view foo_ssv(std::string_view);\nabsl::string_view foo_asv(absl::string_view);\nstd::string bar_ss();\nstd::string_view bar_ssv();\nabsl::string_view bar_asv();\n\n// Confirms that find==npos and find!=npos work for each supported type, when\n// npos comes from the correct type.\nvoid basic_tests() {\n  std::string ss;\n  ss.find(\"a\") == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of find() == npos\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ss, \"a\");{{$}}\n\n  ss.find(\"a\") != std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of find() != npos\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ss, \"a\");{{$}}\n\n  std::string::npos != ss.find(\"a\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ss, \"a\");{{$}}\n\n  std::string_view ssv;\n  ssv.find(\"a\") == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ssv, \"a\");{{$}}\n\n  ssv.find(\"a\") != std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ssv, \"a\");{{$}}\n\n  std::string_view::npos != ssv.find(\"a\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ssv, \"a\");{{$}}\n\n  absl::string_view asv;\n  asv.find(\"a\") == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(asv, \"a\");{{$}}\n\n  asv.find(\"a\") != absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(asv, \"a\");{{$}}\n\n  absl::string_view::npos != asv.find(\"a\");\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(asv, \"a\");{{$}}\n}\n\n// Confirms that it works even if you mix-and-match the type for find and for\n// npos.  (One of the reasons for this checker is to clean up cases that\n// accidentally mix-and-match like this.  absl::StrContains is less\n// error-prone.)\nvoid mismatched_npos() {\n  std::string ss;\n  ss.find(\"a\") == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ss, \"a\");{{$}}\n\n  ss.find(\"a\") != absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ss, \"a\");{{$}}\n\n  std::string_view ssv;\n  ssv.find(\"a\") == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ssv, \"a\");{{$}}\n\n  ssv.find(\"a\") != std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ssv, \"a\");{{$}}\n\n  absl::string_view asv;\n  asv.find(\"a\") == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(asv, \"a\");{{$}}\n\n  asv.find(\"a\") != std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(asv, \"a\");{{$}}\n}\n\n// Confirms that it works even when the needle or the haystack are more\n// complicated expressions.\nvoid subexpression_tests() {\n  std::string ss, ss2;\n  foo_ss(ss).find(ss2) == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(foo_ss(ss), ss2);{{$}}\n\n  ss.find(foo_ss(ss2)) != std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ss, foo_ss(ss2));{{$}}\n\n  foo_ss(bar_ss()).find(foo_ss(ss2)) != std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(foo_ss(bar_ss()), foo_ss(ss2));{{$}}\n\n  std::string_view ssv, ssv2;\n  foo_ssv(ssv).find(ssv2) == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(foo_ssv(ssv), ssv2);{{$}}\n\n  ssv.find(foo_ssv(ssv2)) != std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(ssv, foo_ssv(ssv2));{{$}}\n\n  foo_ssv(bar_ssv()).find(foo_ssv(ssv2)) != std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(foo_ssv(bar_ssv()), foo_ssv(ssv2));{{$}}\n\n  absl::string_view asv, asv2;\n  foo_asv(asv).find(asv2) == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(foo_asv(asv), asv2);{{$}}\n\n  asv.find(foo_asv(asv2)) != absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(asv, foo_asv(asv2));{{$}}\n\n  foo_asv(bar_asv()).find(foo_asv(asv2)) != absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}absl::StrContains(foo_asv(bar_asv()), foo_asv(asv2));{{$}}\n}\n\n// Confirms that it works with string literal, char* and const char* parameters.\nvoid string_literal_and_char_ptr_tests() {\n  char *c = nullptr;\n  const char *cc = nullptr;\n\n  std::string ss;\n  ss.find(\"c\") == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ss, \"c\");{{$}}\n\n  ss.find(c) == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ss, c);{{$}}\n\n  ss.find(cc) == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ss, cc);{{$}}\n\n  std::string_view ssv;\n  ssv.find(\"c\") == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ssv, \"c\");{{$}}\n\n  ssv.find(c) == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ssv, c);{{$}}\n\n  ssv.find(cc) == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ssv, cc);{{$}}\n\n  absl::string_view asv;\n  asv.find(\"c\") == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(asv, \"c\");{{$}}\n\n  asv.find(c) == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(asv, c);{{$}}\n\n  asv.find(cc) == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(asv, cc);{{$}}\n}\n\nvoid char_param_tests() {\n  std::string ss;\n  ss.find('c') == std::string::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ss, 'c');{{$}}\n\n  std::string_view ssv;\n  ssv.find('c') == std::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(ssv, 'c');{{$}}\n\n  absl::string_view asv;\n  asv.find('c') == absl::string_view::npos;\n  // CHECK-MESSAGES: :[[@LINE-1]]:3: warning: use !absl::StrContains instead of\n  // CHECK-FIXES: {{^[[:space:]]*}}!absl::StrContains(asv, 'c');{{$}}\n}\n\n#define FOO(a, b, c, d) ((a).find(b) == std::string::npos ? (c) : (d))\n\n// Confirms that it does not match when a macro would be \"torn\" by the fix.\nvoid no_tearing_macros() {\n  std::string h = \"helo\";\n  FOO(h, \"x\", 5, 6);\n}\n\n// Confirms that it does not match when the pos parameter is non-zero.\nvoid no_nonzero_pos() {\n  std::string ss;\n  ss.find(\"a\", 1) == std::string::npos;\n\n  std::string_view ssv;\n  ssv.find(\"a\", 2) == std::string_view::npos;\n\n  absl::string_view asv;\n  asv.find(\"a\", 3) == std::string_view::npos;\n}\n\n// Confirms that it does not match when the count parameter is present.\nvoid no_count() {\n  std::string ss;\n  ss.find(\"a\", 0, 1) == std::string::npos;\n\n  std::string_view ssv;\n  ssv.find(\"a\", 0, 1) == std::string_view::npos;\n\n  absl::string_view asv;\n  asv.find(\"a\", 0, 1) == std::string_view::npos;\n}\n\n// Confirms that it does not match when it's compared to something other than\n// npos, even if the value is the same as npos.\nvoid no_non_npos() {\n  std::string ss;\n  ss.find(\"a\") == 0;\n  ss.find(\"a\") == 1;\n  ss.find(\"a\") == -1;\n\n  std::string_view ssv;\n  ssv.find(\"a\") == 0;\n  ssv.find(\"a\") == 1;\n  ssv.find(\"a\") == -1;\n\n  absl::string_view asv;\n  asv.find(\"a\") == 0;\n  asv.find(\"a\") == 1;\n  asv.find(\"a\") == -1;\n}\n\n// Confirms that it does not match if the two operands are the same.\nvoid no_symmetric_operands() {\n  std::string ss;\n  ss.find(\"a\") == ss.find(\"a\");\n  std::string::npos == std::string::npos;\n}"
    }
  ]
}