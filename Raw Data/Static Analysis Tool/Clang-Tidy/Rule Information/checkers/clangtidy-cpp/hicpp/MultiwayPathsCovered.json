{
  "name": "MultiwayPathsCovered",
  "language": "cpp",
  "description": ".. title:: clang-tidy - hicpp-multiway-paths-covered",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 175,
  "branches": 55,
  "apis": 84,
  "test": [
    {
      "description": null,
      "expected-problems": 13,
      "expected-linenumbers": [
        16,
        22,
        33,
        37,
        46,
        53,
        62,
        70,
        78,
        88,
        107,
        120,
        126
      ],
      "code": "\n// RUN: %check_clang_tidy %s hicpp-multiway-paths-covered %t\n\nenum OS { Mac,\n          Windows,\n          Linux };\n\nstruct Bitfields {\n  unsigned UInt : 3;\n  int SInt : 1;\n};\n\nint return_integer() { return 42; }\n\nvoid bad_switch(int i) {\n  switch (i) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: switch with only one case; use an if statement\n  case 0:\n    break;\n  }\n  // No default in this switch\n  switch (i) {\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: potential uncovered code path; add a default label\n  case 0:\n    break;\n  case 1:\n    break;\n  case 2:\n    break;\n  }\n\n  // degenerate, maybe even warning\n  switch (i) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: switch statement without labels has no effect\n  }\n\n  switch (int j = return_integer()) {\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: potential uncovered code path; add a default label\n  case 0:\n  case 1:\n  case 2:\n    break;\n  }\n\n  // Degenerated, only default case.\n  switch (i) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: degenerated switch with default label only\n  default:\n    break;\n  }\n\n  // Degenerated, only one case label and default case -> Better as if-stmt.\n  switch (i) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: switch could be better written as an if/else statement\n  case 0:\n    break;\n  default:\n    break;\n  }\n\n  unsigned long long BigNumber = 0;\n  switch (BigNumber) {\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: potential uncovered code path; add a default label\n  case 0:\n  case 1:\n    break;\n  }\n\n  const int &IntRef = i;\n  switch (IntRef) {\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: potential uncovered code path; add a default label\n  case 0:\n  case 1:\n    break;\n  }\n\n  char C = 'A';\n  switch (C) {\n  // CHECK-MESSAGES: [[@LINE-1]]:3: warning: potential uncovered code path; add a default label\n  case 'A':\n    break;\n  case 'B':\n    break;\n  }\n\n  Bitfields Bf;\n  // UInt has 3 bits size.\n  switch (Bf.UInt) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: potential uncovered code path; add a default label\n  case 0:\n  case 1:\n    break;\n  }\n  // All paths explicitly covered.\n  switch (Bf.UInt) {\n  case 0:\n  case 1:\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n  case 6:\n  case 7:\n    break;\n  }\n  // SInt has 1 bit size, so this is somewhat degenerated.\n  switch (Bf.SInt) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: switch with only one case; use an if statement\n  case 0:\n    break;\n  }\n  // All paths explicitly covered.\n  switch (Bf.SInt) {\n  case 0:\n  case 1:\n    break;\n  }\n\n  bool Flag = false;\n  switch (Flag) {\n    // CHECK-MESSAGES:[[@LINE-1]]:3: warning: switch with only one case; use an if statement\n  case true:\n    break;\n  }\n\n  switch (Flag) {\n    // CHECK-MESSAGES: [[@LINE-1]]:3: warning: degenerated switch with default label only\n  default:\n    break;\n  }\n\n  // This `switch` will create a frontend warning from '-Wswitch-bool' but is\n  // ok for this check.\n  switch (Flag) {\n  case true:\n    break;\n  case false:\n    break;\n  }\n}\n\nvoid unproblematic_switch(unsigned char c) {\n  //\n  switch (c) {\n  case 0:\n  case 1:\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n  case 6:\n  case 7:\n  case 8:\n  case 9:\n  case 10:\n  case 11:\n  case 12:\n  case 13:\n  case 14:\n  case 15:\n  case 16:\n  case 17:\n  case 18:\n  case 19:\n  case 20:\n  case 21:\n  case 22:\n  case 23:\n  case 24:\n  case 25:\n  case 26:\n  case 27:\n  case 28:\n  case 29:\n  case 30:\n  case 31:\n  case 32:\n  case 33:\n  case 34:\n  case 35:\n  case 36:\n  case 37:\n  case 38:\n  case 39:\n  case 40:\n  case 41:\n  case 42:\n  case 43:\n  case 44:\n  case 45:\n  case 46:\n  case 47:\n  case 48:\n  case 49:\n  case 50:\n  case 51:\n  case 52:\n  case 53:\n  case 54:\n  case 55:\n  case 56:\n  case 57:\n  case 58:\n  case 59:\n  case 60:\n  case 61:\n  case 62:\n  case 63:\n  case 64:\n  case 65:\n  case 66:\n  case 67:\n  case 68:\n  case 69:\n  case 70:\n  case 71:\n  case 72:\n  case 73:\n  case 74:\n  case 75:\n  case 76:\n  case 77:\n  case 78:\n  case 79:\n  case 80:\n  case 81:\n  case 82:\n  case 83:\n  case 84:\n  case 85:\n  case 86:\n  case 87:\n  case 88:\n  case 89:\n  case 90:\n  case 91:\n  case 92:\n  case 93:\n  case 94:\n  case 95:\n  case 96:\n  case 97:\n  case 98:\n  case 99:\n  case 100:\n  case 101:\n  case 102:\n  case 103:\n  case 104:\n  case 105:\n  case 106:\n  case 107:\n  case 108:\n  case 109:\n  case 110:\n  case 111:\n  case 112:\n  case 113:\n  case 114:\n  case 115:\n  case 116:\n  case 117:\n  case 118:\n  case 119:\n  case 120:\n  case 121:\n  case 122:\n  case 123:\n  case 124:\n  case 125:\n  case 126:\n  case 127:\n  case 128:\n  case 129:\n  case 130:\n  case 131:\n  case 132:\n  case 133:\n  case 134:\n  case 135:\n  case 136:\n  case 137:\n  case 138:\n  case 139:\n  case 140:\n  case 141:\n  case 142:\n  case 143:\n  case 144:\n  case 145:\n  case 146:\n  case 147:\n  case 148:\n  case 149:\n  case 150:\n  case 151:\n  case 152:\n  case 153:\n  case 154:\n  case 155:\n  case 156:\n  case 157:\n  case 158:\n  case 159:\n  case 160:\n  case 161:\n  case 162:\n  case 163:\n  case 164:\n  case 165:\n  case 166:\n  case 167:\n  case 168:\n  case 169:\n  case 170:\n  case 171:\n  case 172:\n  case 173:\n  case 174:\n  case 175:\n  case 176:\n  case 177:\n  case 178:\n  case 179:\n  case 180:\n  case 181:\n  case 182:\n  case 183:\n  case 184:\n  case 185:\n  case 186:\n  case 187:\n  case 188:\n  case 189:\n  case 190:\n  case 191:\n  case 192:\n  case 193:\n  case 194:\n  case 195:\n  case 196:\n  case 197:\n  case 198:\n  case 199:\n  case 200:\n  case 201:\n  case 202:\n  case 203:\n  case 204:\n  case 205:\n  case 206:\n  case 207:\n  case 208:\n  case 209:\n  case 210:\n  case 211:\n  case 212:\n  case 213:\n  case 214:\n  case 215:\n  case 216:\n  case 217:\n  case 218:\n  case 219:\n  case 220:\n  case 221:\n  case 222:\n  case 223:\n  case 224:\n  case 225:\n  case 226:\n  case 227:\n  case 228:\n  case 229:\n  case 230:\n  case 231:\n  case 232:\n  case 233:\n  case 234:\n  case 235:\n  case 236:\n  case 237:\n  case 238:\n  case 239:\n  case 240:\n  case 241:\n  case 242:\n  case 243:\n  case 244:\n  case 245:\n  case 246:\n  case 247:\n  case 248:\n  case 249:\n  case 250:\n  case 251:\n  case 252:\n  case 253:\n  case 254:\n  case 255:\n    break;\n  }\n\n  // Some paths are covered by the switch and a default case is present.\n  switch (c) {\n  case 1:\n  case 2:\n  case 3:\n  default:\n    break;\n  }\n}\n\nOS return_enumerator() {\n  return Linux;\n}\n\n// Enumpaths are already covered by a warning, this is just to ensure, that there is\n// no interference or false positives.\n// -Wswitch warns about uncovered enum paths and each here described case is already\n// covered.\nvoid switch_enums(OS os) {\n  switch (os) {\n  case Linux:\n    break;\n  }\n\n  switch (OS another_os = return_enumerator()) {\n  case Linux:\n    break;\n  }\n\n  switch (os) {\n  }\n}\n\n/// All of these cases will not emit a warning per default, but with explicit activation.\n/// Covered in extra test file.\nvoid problematic_if(int i, enum OS os) {\n  if (i > 0) {\n    return;\n  } else if (i < 0) {\n    return;\n  }\n\n  if (os == Mac) {\n    return;\n  } else if (os == Linux) {\n    if (true) {\n      return;\n    } else if (false) {\n      return;\n    }\n    return;\n  } else {\n    /* unreachable */\n    if (true) // check if the parent would match here as well\n      return;\n  }\n\n  // Ok, because all paths are covered\n  if (i > 0) {\n    return;\n  } else if (i < 0) {\n    return;\n  } else {\n    /* error, maybe precondition failed */\n  }\n}"
    }
  ]
}