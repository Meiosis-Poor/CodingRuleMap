{
  "name": "BadComparable",
  "language": "java",
  "description": "Possible sign flip from narrowing conversion",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "java",
  "loc": 132,
  "branches": 14,
  "apis": 1,
  "test": [
    {
      "description": "positiveCase",
      "expected-problems": null,
      "expected-linenumbers": [
        32
      ],
      "code": "package com.google.errorprone.bugpatterns.testdata;\n\nimport java.io.File;\nimport java.util.Comparator;\n\n/**\n * @author irogers@google.com (Ian Rogers)\n */\npublic class BadComparablePositiveCases {\n  static class ComparableTest implements Comparable<ComparableTest> {\n    private final long value = 0;\n\n    public int compareTo(ComparableTest other) {\n      // BUG: Diagnostic contains: return Long.compare(value, other.value);\n      return (int) (value - other.value);\n    }\n  }\n\n  static class BoxedComparableTest implements Comparable<BoxedComparableTest> {\n    private final Long value = Long.valueOf(0);\n\n    public int compareTo(BoxedComparableTest other) {\n      // BUG: Diagnostic contains: return value.compareTo(other.value);\n      return (int) (value - other.value);\n    }\n  }\n\n  static final Comparator<Number> COMPARATOR_UNBOXED_INT_CAST =\n      new Comparator<Number>() {\n        public int compare(Number n1, Number n2) {\n          // BUG: Diagnostic contains: return Long.compare(n1.longValue(), n2.longValue())\n          return (int) (n1.longValue() - n2.longValue());\n        }\n      };\n\n  static final Comparator<Long> COMPARATOR_BOXED_INT_CAST =\n      new Comparator<Long>() {\n        public int compare(Long n1, Long n2) {\n          // BUG: Diagnostic contains: return n1.compareTo(n2)\n          return (int) (n1 - n2);\n        }\n      };\n\n  static final Comparator<File> COMPARATOR_FILE_INT_CAST =\n      new Comparator<File>() {\n        public int compare(File lhs, File rhs) {\n          // BUG: Diagnostic contains: return Long.compare(rhs.lastModified(), lhs.lastModified())\n          return (int) (rhs.lastModified() - lhs.lastModified());\n        }\n      };\n}\\"
    },
    {
      "description": "negativeCase",
      "expected-problems": null,
      "expected-linenumbers": [
        93
      ],
      "code": "package com.google.errorprone.bugpatterns.testdata;\n\n            import java.util.Comparator;\n\n            /**\n             * @author irogers@google.com (Ian Rogers)\n             */\n            public class BadComparableNegativeCases {\n              // The corrected cases of the PositiveCases test.\n              static class ComparableTest implements Comparable<ComparableTest> {\n                private final long value = 0;\n\n                public int compareTo(ComparableTest other) {\n                  return Long.compare(value, other.value);\n                }\n              }\n\n              static class BoxedComparableTest implements Comparable<BoxedComparableTest> {\n                private final Long value = Long.valueOf(0);\n\n                public int compareTo(BoxedComparableTest other) {\n                  return value.compareTo(other.value);\n                }\n              }\n\n              static final Comparator<Number> COMPARATOR_UNBOXED_INT_CAST =\n                  new Comparator<Number>() {\n                    public int compare(Number n1, Number n2) {\n                      return Long.compare(n1.longValue(), n2.longValue());\n                    }\n                  };\n\n              static final Comparator<Long> COMPARATOR_BOXED_INT_CAST =\n                  new Comparator<Long>() {\n                    public int compare(Long n1, Long n2) {\n                      return n1.compareTo(n2);\n                    }\n                  };\n\n              // Don't match non-Comparable or Comparator cases.\n              static class NonComparableTest {\n                private final long value = 0;\n\n                public int compareTo(ComparableTest other) {\n                  return (int) (value - other.value);\n                }\n              }\n\n              static final Object COMPARATOR_LIKE_INT_CAST =\n                  new Object() {\n                    public int compare(Long n1, Long n2) {\n                      return (int) (n1 - n2);\n                    }\n                  };\n\n              // Narrowing conversions that don't follow the long -> int pattern.\n              static final Comparator<Number> COMPARATOR_UNBOXED_NON_PATTERN_LONG_CAST =\n                  new Comparator<Number>() {\n                    // To match the Comparator API.\n                    @Override\n                    public int compare(Number n1, Number n2) {\n                      return (int) (n1.intValue() - n2.intValue());\n                    }\n\n                    public short compare(int n1, int n2) {\n                      return (short) (n1 - n2);\n                    }\n\n                    public byte compare(long n1, long n2) {\n                      return (byte) (n1 - n2);\n                    }\n                  };\n\n              // Not narrowing conversions.\n              static final Comparator<Number> COMPARATOR_UNBOXED_NON_NARROW_LONG_CAST =\n                  new Comparator<Number>() {\n                    // To match the Comparator API.\n                    @Override\n                    public int compare(Number n1, Number n2) {\n                      return (int) (n1.intValue() - n2.intValue());\n                    }\n\n                    public long compare(long n1, long n2) {\n                      return (long) (n1 - n2);\n                    }\n                  };\n\n              static final Comparator<Number> COMPARATOR_UNBOXED_NON_NARROW_INT_CAST =\n                  new Comparator<Number>() {\n                    public int compare(Number n1, Number n2) {\n                      return (int) (n1.intValue() - n2.intValue());\n                    }\n                  };\n\n              static final Comparator<Number> COMPARATOR_UNBOXED_NON_NARROW_SHORT_CAST =\n                  new Comparator<Number>() {\n                    // To match the Comparator API.\n                    @Override\n                    public int compare(Number n1, Number n2) {\n                      return (int) (n1.intValue() - n2.intValue());\n                    }\n\n                    public short compare(short n1, short n2) {\n                      return (short) (n1 - n2);\n                    }\n                  };\n\n              static final Comparator<Number> COMPARATOR_UNBOXED_NON_NARROW_BYTE_CAST =\n                  new Comparator<Number>() {\n                    // To match the Comparator API.\n                    @Override\n                    public int compare(Number n1, Number n2) {\n                      return (int) (n1.intValue() - n2.intValue());\n                    }\n\n                    public byte compare(byte n1, byte n2) {\n                      return (byte) (n1 - n2);\n                    }\n                  };\n\n              // Not signed conversions.\n              static final Comparator<Number> COMPARATOR_UNBOXED_NON_NARROW_CHAR_CAST =\n                  new Comparator<Number>() {\n                    @Override\n                    public int compare(Number n1, Number n2) {\n                      return (char) (n1.shortValue() - n2.shortValue());\n                    }\n\n                    public char compare(char n1, char n2) {\n                      return (char) (n1 - n2);\n                    }\n\n                    public char compare(byte n1, byte n2) {\n                      return (char) (n1 - n2);\n                    }\n                  };\n            }\\"
    }
  ]
}