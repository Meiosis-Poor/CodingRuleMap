{
  "name": "FutureReturnValueIgnored",
  "language": "java",
  "description": "Return value of methods returning Future must be checked. Ignoring returned Futures suppresses exceptions thrown from the code that completes the Future.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "java",
  "loc": 130,
  "branches": 9,
  "apis": 3,
  "test": [
    {
      "description": "positiveCases",
      "expected-problems": null,
      "expected-linenumbers": [
        33
      ],
      "code": "package com.google.errorprone.bugpatterns.testdata;\n\nimport static com.google.common.util.concurrent.Futures.immediateFuture;\n\nimport com.google.common.base.Function;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Future;\n\n/**\n * @author eaftan@google.com (Eddie Aftandilian)\n */\npublic class FutureReturnValueIgnoredPositiveCases {\n\n  IntValue intValue = new IntValue(0);\n\n  private static Future<Integer> increment(int bar) {\n    return null;\n  }\n\n  public <T extends Future> T returnFutureType(T input) {\n    return input;\n  }\n\n  public void testFutureGenerics() {\n    // BUG: Diagnostic contains: Future must be checked\n    returnFutureType(Futures.immediateCancelledFuture());\n  }\n\n  public void foo() {\n    int i = 1;\n    // BUG: Diagnostic contains: Future must be checked\n    increment(i);\n    System.out.println(i);\n  }\n\n  public void bar() {\n    // BUG: Diagnostic contains: Future must be checked\n    this.intValue.increment();\n  }\n\n  public void testIntValue() {\n    IntValue value = new IntValue(10);\n    // BUG: Diagnostic contains: Future must be checked\n    value.increment();\n  }\n\n  public void testFunction() {\n    new Function<Object, ListenableFuture<?>>() {\n      @Override\n      public ListenableFuture<?> apply(Object input) {\n        return immediateFuture(null);\n      }\n      // BUG: Diagnostic contains: Future must be checked\n    }.apply(null);\n  }\n\n  private class IntValue {\n\n    final int i;\n\n    public IntValue(int i) {\n      this.i = i;\n    }\n\n    public ListenableFuture<IntValue> increment() {\n      return immediateFuture(new IntValue(i + 1));\n    }\n\n    public void increment2() {\n      // BUG: Diagnostic contains: Future must be checked\n      this.increment();\n    }\n\n    public void increment3() {\n      // BUG: Diagnostic contains: Future must be checked\n      increment();\n    }\n  }\n\n  static <I, N extends Q, Q> ListenableFuture<Q> transform(\n      ListenableFuture<I> input, Function<? super I, ? extends N> function, Executor executor) {\n    return null;\n  }\n\n  static ListenableFuture<Integer> futureReturningMethod() {\n    return null;\n  }\n\n  static ListenableFuture<Integer> futureReturningMethod(Object unused) {\n    return null;\n  }\n\n  static void consumesFuture(Future<Object> future) {}\n\n  static void testIgnoredFuture() throws Exception {\n    ListenableFuture<String> input = null;\n    // BUG: Diagnostic contains: nested type\n    Future<?> output = transform(input, foo -> futureReturningMethod(), runnable -> runnable.run());\n\n    Future<?> otherOutput =\n        // BUG: Diagnostic contains: nested type\n        transform(\n            input,\n            new Function<String, ListenableFuture<Integer>>() {\n              @Override\n              public ListenableFuture<Integer> apply(String string) {\n                return futureReturningMethod();\n              }\n            },\n            runnable -> runnable.run());\n\n    // BUG: Diagnostic contains: nested type\n    transform(\n            input,\n            new Function<String, ListenableFuture<Integer>>() {\n              @Override\n              public ListenableFuture<Integer> apply(String string) {\n                return futureReturningMethod();\n              }\n            },\n            runnable -> runnable.run())\n        .get();\n\n    consumesFuture(\n        // BUG: Diagnostic contains: nested type\n        transform(\n            input,\n            new Function<String, ListenableFuture<Integer>>() {\n              @Override\n              public ListenableFuture<Integer> apply(String string) {\n                System.out.println(\"First generics\");\n                return futureReturningMethod();\n              }\n            },\n            runnable -> runnable.run()));\n\n    consumesFuture(\n        transform(\n            input,\n            new Function<String, Object>() {\n              @Override\n              public Object apply(String string) {\n                // BUG: Diagnostic contains: returned future may be ignored\n                return futureReturningMethod();\n              }\n            },\n            runnable -> runnable.run()));\n    consumesFuture(\n        transform(\n            input,\n            new Function<String, Object>() {\n              @Override\n              public Object apply(String string) {\n                Future<?> result = futureReturningMethod();\n                // BUG: Diagnostic contains: returned future may be ignored\n                return result;\n              }\n            },\n            runnable -> runnable.run()));\n\n    consumesFuture(\n        // BUG: Diagnostic contains: nested type\n        transform(input, foo -> futureReturningMethod(), runnable -> runnable.run()));\n\n    consumesFuture(\n        // BUG: Diagnostic contains: nested type\n        transform(\n            input,\n            foo -> {\n              return futureReturningMethod();\n            },\n            runnable -> runnable.run()));\n\n    consumesFuture(\n        // BUG: Diagnostic contains: nested type\n        transform(\n            input,\n            FutureReturnValueIgnoredPositiveCases::futureReturningMethod,\n            runnable -> runnable.run()));\n\n    ListenableFuture<Object> done =\n        transform(\n            // BUG: Diagnostic contains: nested type\n            transform(\n                input,\n                new Function<String, ListenableFuture<Integer>>() {\n                  @Override\n                  public ListenableFuture<Integer> apply(String string) {\n                    return futureReturningMethod();\n                  }\n                },\n                runnable -> runnable.run()),\n            new Function<Object, Object>() {\n              @Override\n              public Object apply(Object string) {\n                return new Object();\n              }\n            },\n            runnable -> runnable.run());\n  }\n}\\"
    },
    {
      "description": "negativeCase",
      "expected-problems": null,
      "expected-linenumbers": [
        246
      ],
      "code": "package com.google.errorprone.bugpatterns.testdata;\n\nimport static com.google.common.util.concurrent.Futures.immediateFuture;\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\nimport static org.junit.Assert.assertThrows;\nimport static org.mockito.Mockito.doAnswer;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Functions;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Ticker;\nimport com.google.common.reflect.AbstractInvocationHandler;\nimport com.google.common.util.concurrent.AbstractFuture;\nimport com.google.common.util.concurrent.AsyncFunction;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport io.netty.channel.ChannelFuture;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.RecursiveAction;\nimport java.util.concurrent.ScheduledExecutorService;\nimport org.junit.function.ThrowingRunnable;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/** */\npublic class FutureReturnValueIgnoredNegativeCases {\n\n  public FutureReturnValueIgnoredNegativeCases() {}\n\n  static ListenableFuture<Object> getFuture() {\n    return immediateFuture(null);\n  }\n\n  interface CanIgnoreMethod {\n    @CanIgnoreReturnValue\n    Future<Object> getFuture();\n  }\n\n  public static class CanIgnoreImpl implements CanIgnoreMethod {\n    @Override\n    public Future<Object> getFuture() {\n      return null;\n    }\n  }\n\n  static void callIgnoredInterfaceMethod() {\n    new CanIgnoreImpl().getFuture();\n  }\n\n  @CanIgnoreReturnValue\n  static ListenableFuture<Object> getFutureIgnore() {\n    return immediateFuture(null);\n  }\n\n  static void putInMap() {\n    Map<Object, Future<?>> map = new HashMap<>();\n    map.put(new Object(), immediateFuture(null));\n    Map map2 = new HashMap();\n    map2.put(new Object(), immediateFuture(null));\n  }\n\n  static void preconditions()\n      throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n    Preconditions.checkNotNull(getFuture());\n    Preconditions.checkNotNull(new Object());\n    FutureReturnValueIgnoredNegativeCases.class.getDeclaredMethod(\"preconditions\").invoke(null);\n  }\n\n  static void checkIgnore() {\n    getFutureIgnore();\n  }\n\n  void ignoreForkJoinTaskFork(ForkJoinTask<?> t) {\n    t.fork();\n  }\n\n  void ignoreForkJoinTaskFork_subclass(RecursiveAction t) {\n    t.fork();\n  }\n\n  void ignoreExecutorCompletionServiceSubmit(ExecutorCompletionService s) {\n    s.submit(() -> null);\n  }\n\n  void ignoreChannelFutureAddListener(ChannelFuture cf) {\n    cf.addListener((ChannelFuture f) -> {});\n  }\n\n  void ignoreChannelFutureAddListeners(ChannelFuture cf) {\n    cf.addListeners((ChannelFuture f) -> {}, (ChannelFuture f) -> {});\n  }\n\n  <V> ListenableFuture<V> ignoreVarArgs(\n      Callable<V> combiner, Executor executor, ListenableFuture<?>... futures) {\n    return combine(combiner, executor, Arrays.asList(futures));\n  }\n\n  public static <V> ListenableFuture<V> combine(\n      final Callable<V> combiner,\n      Executor executor,\n      Iterable<? extends ListenableFuture<?>> futures) {\n    return null;\n  }\n\n  private static final class TypedClass<T> {\n    ListenableFuture<Void> ignoreReturnTypeSetByInputFuture(T input) {\n      return returnsInputType(logAsyncInternal(input), 0);\n    }\n\n    protected ListenableFuture<Void> logAsyncInternal(T record) {\n      return null;\n    }\n\n    <V> ListenableFuture<V> returnsInputType(ListenableFuture<V> future, final int n) {\n      return null;\n    }\n  }\n\n  public static class RetryingFuture<T> extends AbstractFuture<T> {\n\n    /**\n     * Enables the user to receive notifications about state changes of a retrying future, and use\n     * them e.g. for logging.\n     */\n    public interface Interceptor<T> {}\n\n    /** Creates a builder for {@link RetryingFuture} instances. */\n    public static Builder<Object> builder() {\n      return new Builder<>();\n    }\n\n    /** A builder for {@link RetryingFuture} instances. */\n    public static final class Builder<T> {\n\n      private Builder() {}\n\n      /** Sets the {@link Executor} in which all tries and retries are performed. */\n      @CanIgnoreReturnValue\n      public Builder<T> setExecutor(Executor executor) {\n        return this;\n      }\n\n      /**\n       * Sets the {@link ScheduledExecutorService} used for scheduling retries after delay. It will\n       * also be used for tries and retries if {@link #setExecutor(Executor)} is not called.\n       */\n      @CanIgnoreReturnValue\n      public Builder<T> setScheduledExecutorService(\n          ScheduledExecutorService scheduledExecutorService) {\n        return this;\n      }\n\n      public <U extends T> Builder<U> setInterceptor(Interceptor<U> interceptor) {\n        // Safely limiting the kinds of RetryingFutures this builder can produce,\n        // based on the type of the interceptor.\n        @SuppressWarnings(\"unchecked\")\n        Builder<U> me = (Builder<U>) this;\n        return me;\n      }\n\n      public Builder<T> setTicker(Ticker ticker) {\n        return this;\n      }\n\n      public <U extends T> RetryingFuture<U> build(\n          Supplier<? extends ListenableFuture<U>> futureSupplier,\n          Predicate<? super Exception> shouldContinue) {\n        return new RetryingFuture<U>(\n            futureSupplier,\n            null,\n            shouldContinue,\n            null,\n            // We need to maintain Java 7 compatibility\n            null,\n            null,\n            null);\n      }\n\n      public <U extends T> RetryingFuture<U> build(\n          Supplier<? extends ListenableFuture<U>> futureSupplier,\n          Object strategy,\n          Predicate<? super Exception> shouldContinue) {\n        return new RetryingFuture<U>(\n            futureSupplier,\n            strategy,\n            shouldContinue,\n            null,\n            // We need to maintain Java 7 compatibility\n            null,\n            null,\n            null);\n      }\n    }\n\n    RetryingFuture(\n        Supplier<? extends ListenableFuture<T>> futureSupplier,\n        Object strategy,\n        Predicate<? super Exception> shouldContinue,\n        Executor executor,\n        ScheduledExecutorService scheduledExecutorService,\n        Ticker ticker,\n        final Interceptor<? super T> interceptor) {}\n\n    public static <T> RetryingFuture<T> retryingFuture(\n        Supplier<? extends ListenableFuture<T>> futureSupplier,\n        Object strategy,\n        Predicate<? super Exception> shouldContinue,\n        Executor executor,\n        Interceptor<? super T> interceptor) {\n      return builder()\n          .setInterceptor(interceptor)\n          .setExecutor(executor)\n          .build(futureSupplier, strategy, shouldContinue);\n    }\n  }\n\n  private static class TypedObject<T> {\n    public <O extends Object> ListenableFuture<O> transformAndClose(\n        Function<? super T, O> function, Executor executor) {\n      return null;\n    }\n\n    public ListenableFuture<T> close() {\n      return transformAndClose(Functions.identity(), directExecutor());\n    }\n  }\n\n  private static void mocking() {\n    doAnswer(invocation -> immediateFuture(null)).when(null);\n    doAnswer(\n            invocation -> {\n              return immediateFuture(null);\n            })\n        .when(null);\n    doAnswer(\n            new Answer() {\n              @Override\n              public Object answer(InvocationOnMock mock) {\n                return immediateFuture(null);\n              }\n            })\n        .when(null);\n  }\n\n  private static void throwing() {\n    assertThrows(RuntimeException.class, () -> immediateFuture(null));\n    assertThrows(\n        RuntimeException.class,\n        () -> {\n          immediateFuture(null);\n        });\n    assertThrows(\n        RuntimeException.class,\n        new ThrowingRunnable() {\n          @Override\n          public void run() throws Throwable {\n            immediateFuture(null);\n          }\n        });\n  }\n\n  private static AsyncFunction<String, String> provideAsyncFunction() {\n    return Futures::immediateFuture;\n  }\n\n  private static Runnable provideNonFutureInterface() {\n    return new FutureTask(null);\n  }\n\n  private static void invocation() {\n    new AbstractInvocationHandler() {\n      @Override\n      protected Object handleInvocation(Object o, Method method, Object[] params) {\n        return immediateFuture(null);\n      }\n    };\n  }\n}"
    },
    {
      "description": "classAnnotationButCanIgnoreReturnValue",
      "expected-problems": null,
      "expected-linenumbers": [
        549
      ],
      "code": "package lib;\n\n            public class Lib {\n              @com.google.errorprone.annotations.CanIgnoreReturnValue\n              public static java.util.concurrent.Future<?> f() {\n                return null;\n              }\n            }\n            \n\n            class Test {\n              void m() {\n                lib.Lib.f();\n              }\n            }"
    },
    {
      "description": "completableFutureReturnValue",
      "expected-problems": null,
      "expected-linenumbers": [
        576
      ],
      "code": "import java.util.concurrent.CompletableFuture;\n\n            class Test {\n              void f(CompletableFuture<?> cf) {\n                cf.exceptionally(t -> null);\n              }\n            }"
    },
    {
      "description": "completableFutureReturnValueJdk9",
      "expected-problems": null,
      "expected-linenumbers": [
        593
      ],
      "code": "import java.util.concurrent.CompletableFuture;\n            import static java.util.concurrent.TimeUnit.MILLISECONDS;\n\n            class Test {\n              void f(CompletableFuture<?> cf) {\n                cf.completeAsync(() -> null);\n                cf.completeAsync(() -> null, null);\n                cf.orTimeout(0, MILLISECONDS);\n                cf.completeOnTimeout(null, 0, MILLISECONDS);\n              }\n            }"
    }
  ]
}