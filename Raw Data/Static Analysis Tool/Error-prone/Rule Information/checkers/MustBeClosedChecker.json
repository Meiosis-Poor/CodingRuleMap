{
  "name": "MustBeClosedChecker",
  "language": "java",
  "description": "This method returns a resource which must be managed carefully, not just left for garbage collection. If it is a constant that will persist for the lifetime of your program, move it to a private static final field. Otherwise, you should use it in a try-with-resources.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "java",
  "loc": 147,
  "branches": 19,
  "apis": 1,
  "test": [
    {
      "description": "positiveCases",
      "expected-problems": null,
      "expected-linenumbers": [
        300
      ],
      "code": ""
    },
    {
      "description": "negativeCases",
      "expected-problems": null,
      "expected-linenumbers": [
        307
      ],
      "code": "package com.google.errorprone.bugpatterns.testdata;\n\nimport static java.io.InputStream.nullInputStream;\nimport static java.io.OutputStream.nullOutputStream;\nimport static java.io.Reader.nullReader;\nimport static java.io.Writer.nullWriter;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.errorprone.annotations.MustBeClosed;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n@SuppressWarnings({\"UnnecessaryCast\", \"LambdaToMemberReference\"})\npublic class MustBeClosedCheckerNegativeCases {\n\n  class Closeable implements AutoCloseable {\n\n    @Override\n    public void close() {}\n  }\n\n  class Foo {\n\n    void bar() {}\n\n    @MustBeClosed\n    Closeable mustBeClosedAnnotatedMethod() {\n      return new Closeable();\n    }\n  }\n\n  class MustBeClosedAnnotatedConstructor extends Closeable {\n\n    @MustBeClosed\n    MustBeClosedAnnotatedConstructor() {}\n  }\n\n  @SuppressWarnings(\"MustBeClosedChecker\")\n  void respectsSuppressWarnings_onMethod() {\n    new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  void respectsSuppressWarnings_onLocal() {\n    @SuppressWarnings(\"MustBeClosedChecker\")\n    var unused = new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  void negativeCase3() {\n    try (Closeable closeable = new Foo().mustBeClosedAnnotatedMethod()) {}\n  }\n\n  void negativeCase4() {\n    Foo foo = new Foo();\n    try (Closeable closeable = foo.mustBeClosedAnnotatedMethod()) {}\n  }\n\n  void negativeCase5() {\n    new Foo().bar();\n  }\n\n  void negativeCase6() {\n    try (MustBeClosedAnnotatedConstructor foo = new MustBeClosedAnnotatedConstructor()) {}\n  }\n\n  void negativeCase7() {\n    try (MustBeClosedAnnotatedConstructor foo = new MustBeClosedAnnotatedConstructor();\n        Closeable closeable = new Foo().mustBeClosedAnnotatedMethod()) {}\n  }\n\n  @MustBeClosed\n  Closeable positiveCase8() {\n    // This is fine since the caller method is annotated.\n    return new MustBeClosedAnnotatedConstructor();\n  }\n\n  @MustBeClosed\n  Closeable positiveCase7() {\n    // This is fine since the caller method is annotated.\n    return new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  @MustBeClosed\n  Closeable ternary(boolean condition) {\n    return condition ? new Foo().mustBeClosedAnnotatedMethod() : null;\n  }\n\n  @MustBeClosed\n  Closeable cast() {\n    // TODO(b/241012760): remove the following line after the bug is fixed.\n    // BUG: Diagnostic contains:\n    return (Closeable) new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  void tryWithResources() {\n    Foo foo = new Foo();\n    Closeable closeable = foo.mustBeClosedAnnotatedMethod();\n    try {\n    } finally {\n      closeable.close();\n    }\n  }\n\n  void mockitoWhen(Foo mockFoo) {\n    when(mockFoo.mustBeClosedAnnotatedMethod()).thenReturn(null);\n    doReturn(null).when(mockFoo).mustBeClosedAnnotatedMethod();\n  }\n\n  void testException() {\n    try {\n      ((Foo) null).mustBeClosedAnnotatedMethod();\n      fail();\n    } catch (NullPointerException e) {\n    }\n  }\n\n  abstract class ParentWithNoArgument implements AutoCloseable {\n    @MustBeClosed\n    ParentWithNoArgument() {}\n  }\n\n  abstract class ParentWithArgument implements AutoCloseable {\n    @MustBeClosed\n    ParentWithArgument(int i) {}\n  }\n\n  abstract class ChildOfParentWithArgument extends ParentWithArgument {\n    @MustBeClosed\n    ChildOfParentWithArgument() {\n      super(0);\n    }\n  }\n\n  interface ResourceFactory {\n    @MustBeClosed\n    MustBeClosedAnnotatedConstructor getResource();\n  }\n\n  void consumeCloseable(ResourceFactory factory) {\n    try (Closeable c = factory.getResource()) {}\n  }\n\n  void expressionLambdaReturningCloseable() {\n    consumeCloseable(() -> new MustBeClosedAnnotatedConstructor());\n  }\n\n  void statementLambdaReturningCloseable() {\n    consumeCloseable(\n        () -> {\n          return new MustBeClosedAnnotatedConstructor();\n        });\n  }\n\n  void methodReferenceReturningCloseable() {\n    consumeCloseable(MustBeClosedAnnotatedConstructor::new);\n  }\n\n  void ternaryFunctionalExpressionReturningCloseable(boolean condition) {\n    consumeCloseable(\n        condition\n            ? () -> new MustBeClosedAnnotatedConstructor()\n            : MustBeClosedAnnotatedConstructor::new);\n  }\n\n  void inferredFunctionalExpressionReturningCloseable(ResourceFactory factory) {\n    ImmutableList.of(\n            factory,\n            () -> new MustBeClosedAnnotatedConstructor(),\n            MustBeClosedAnnotatedConstructor::new)\n        .forEach(this::consumeCloseable);\n  }\n\n  @MustBeClosed\n  <C extends AutoCloseable> C mustBeClosed(C c) {\n    return c;\n  }\n\n  void closedByDecorator() throws IOException {\n    try (var in = new BufferedInputStream(mustBeClosed(nullInputStream()))) {}\n    try (var out = new BufferedOutputStream(mustBeClosed(nullOutputStream()))) {}\n\n    try (var in = new BufferedInputStream(mustBeClosed(nullInputStream()), 1024)) {}\n    try (var out = new BufferedOutputStream(mustBeClosed(nullOutputStream()), 1024)) {}\n\n    try (var r = new InputStreamReader(mustBeClosed(nullInputStream()))) {}\n    try (var w = new OutputStreamWriter(mustBeClosed(nullOutputStream()))) {}\n\n    try (var r = new BufferedReader(mustBeClosed(nullReader()))) {}\n    try (var w = new BufferedWriter(mustBeClosed(nullWriter()))) {}\n  }\n}"
    },
    {
      "description": "refactoring",
      "expected-problems": null,
      "expected-linenumbers": [
        515
      ],
      "code": "package com.google.errorprone.bugpatterns.testdata;\n\nimport static java.io.OutputStream.nullOutputStream;\n\nimport com.google.errorprone.annotations.MustBeClosed;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\nimport java.util.zip.GZIPOutputStream;\n\n@SuppressWarnings({\"UnusedNestedClass\", \"UnusedVariable\"})\nclass MustBeClosedCheckerPositiveCases {\n\n  class DoesNotImplementAutoCloseable {\n    @MustBeClosed\n    // BUG: Diagnostic contains: MustBeClosed should only annotate constructors of AutoCloseables.\n    DoesNotImplementAutoCloseable() {}\n\n    @MustBeClosed\n    // BUG: Diagnostic contains: MustBeClosed should only annotate methods that return an\n    // AutoCloseable.\n    void doesNotReturnAutoCloseable() {}\n  }\n\n  class Closeable implements AutoCloseable {\n\n    @Override\n    public void close() {}\n\n    public int method() {\n      return 1;\n    }\n  }\n\n  class Foo {\n\n    @MustBeClosed\n    Closeable mustBeClosedAnnotatedMethod() {\n      return new Closeable();\n    }\n\n    void sameClass() {\n      // BUG: Diagnostic contains:\n      try (var closeable = mustBeClosedAnnotatedMethod()) {}\n    }\n  }\n\n  class MustBeClosedAnnotatedConstructor extends Closeable {\n\n    @MustBeClosed\n    MustBeClosedAnnotatedConstructor() {}\n\n    void sameClass() {\n      // BUG: Diagnostic contains:\n      try (var mustBeClosedAnnotatedConstructor = new MustBeClosedAnnotatedConstructor()) {}\n    }\n  }\n\n  void positiveCase1() {\n    // BUG: Diagnostic contains:\n    try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {}\n  }\n\n  void positiveCase2() {\n    // BUG: Diagnostic contains:\n    try (Closeable closeable = new Foo().mustBeClosedAnnotatedMethod()) {}\n  }\n\n  void positiveCase3() {\n    try {\n      // BUG: Diagnostic contains:\n      try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {}\n    } finally {\n    }\n  }\n\n  void positiveCase4() {\n    try (Closeable c = new Foo().mustBeClosedAnnotatedMethod()) {\n      // BUG: Diagnostic contains:\n      try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {}\n    }\n  }\n\n  void positiveCase5() {\n    // BUG: Diagnostic contains:\n    try (var mustBeClosedAnnotatedConstructor = new MustBeClosedAnnotatedConstructor()) {}\n  }\n\n  @MustBeClosed\n  Closeable positiveCase6() {\n    // BUG: Diagnostic contains:\n    return new MustBeClosedAnnotatedConstructor();\n  }\n\n  @MustBeClosed\n  Closeable positiveCase7() {\n    // BUG: Diagnostic contains:\n    return new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  int existingDeclarationUsesVar() {\n    // Bug: Diagnostic contains:\n    try (var result = new Foo().mustBeClosedAnnotatedMethod()) {\n      return 0;\n    }\n  }\n\n  boolean twoCloseablesInOneExpression() {\n    // BUG: Diagnostic contains:\n    try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {\n      try (var closeable2 = new Foo().mustBeClosedAnnotatedMethod()) {\n        return closeable == closeable2;\n      }\n    }\n  }\n\n  void voidLambda() {\n    // Lambda has a fixless finding because no reasonable fix can be suggested.\n    // BUG: Diagnostic contains:\n    Runnable runnable = () -> new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  void expressionLambda() {\n    Supplier<Closeable> supplier =\n        () ->\n            // BUG: Diagnostic contains:\n            new Foo().mustBeClosedAnnotatedMethod();\n  }\n\n  void statementLambda() {\n    Supplier<Closeable> supplier =\n        () -> {\n          // BUG: Diagnostic contains:\n          return new Foo().mustBeClosedAnnotatedMethod();\n        };\n  }\n\n  void methodReference() {\n    Supplier<Closeable> supplier =\n        // TODO(b/218377318): BUG: Diagnostic contains:\n        new Foo()::mustBeClosedAnnotatedMethod;\n  }\n\n  void anonymousClass() {\n    new Foo() {\n      @MustBeClosed\n      @Override\n      public Closeable mustBeClosedAnnotatedMethod() {\n        // BUG: Diagnostic contains:\n        return new MustBeClosedAnnotatedConstructor();\n      }\n    };\n  }\n\n  void subexpression() {\n    // BUG: Diagnostic contains:\n    try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {\n      closeable.method();\n    }\n  }\n\n  void ternary(boolean condition) {\n    // BUG: Diagnostic contains:\n    int result;\n    try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {\n      result = condition ? closeable.method() : 0;\n    }\n  }\n\n  int variableDeclaration() {\n    // BUG: Diagnostic contains:\n    int result;\n    try (var closeable = new Foo().mustBeClosedAnnotatedMethod()) {\n      result = closeable.method();\n    }\n    return result;\n  }\n\n  void tryWithResources_nonFinal() {\n    Foo foo = new Foo();\n    // BUG: Diagnostic contains:\n    try (Closeable closeable = foo.mustBeClosedAnnotatedMethod()) {\n      try {\n        closeable = null;\n      } finally {\n        closeable.close();\n      }\n    }\n  }\n\n  void tryWithResources_noClose() {\n    Foo foo = new Foo();\n    // BUG: Diagnostic contains:\n    try (Closeable closeable = foo.mustBeClosedAnnotatedMethod()) {\n      try {\n      } finally {\n      }\n    }\n  }\n\n  class CloseableFoo implements AutoCloseable {\n\n    @MustBeClosed\n    CloseableFoo() {}\n\n    // Doesn't autoclose Foo on Stream close.\n    Stream<String> stream() {\n      return null;\n    }\n\n    @Override\n    public void close() {}\n  }\n\n  void twrStream() {\n    // BUG: Diagnostic contains:\n    try (CloseableFoo closeableFoo = new CloseableFoo();\n        Stream<String> stream = closeableFoo.stream()) {}\n  }\n\n  void constructorsTransitivelyRequiredAnnotation() {\n    abstract class Parent implements AutoCloseable {\n      @MustBeClosed\n      Parent() {}\n\n      // BUG: Diagnostic contains: Invoked constructor is marked @MustBeClosed\n      @MustBeClosed\n      Parent(int i) {\n        this();\n      }\n    }\n\n    // BUG: Diagnostic contains: Implicitly invoked constructor is marked @MustBeClosed\n    abstract class ChildDefaultConstructor extends Parent {}\n\n    abstract class ChildExplicitConstructor extends Parent {\n      // BUG: Diagnostic contains: Invoked constructor is marked @MustBeClosed\n      @MustBeClosed\n      ChildExplicitConstructor() {}\n\n      // BUG: Diagnostic contains: Invoked constructor is marked @MustBeClosed\n      @MustBeClosed\n      ChildExplicitConstructor(int a) {\n        super();\n      }\n    }\n  }\n\n  @MustBeClosed\n  OutputStream mustBeClosedOutputStream() {\n    return nullOutputStream();\n  }\n\n  void decoratorConstructorThrows() throws IOException {\n    // BUG: Diagnostic contains:\n    try (OutputStream outputStream = mustBeClosedOutputStream();\n        var s = new GZIPOutputStream(outputStream)) {}\n  }\n\n  void notClosedByDecorator() throws IOException {\n    class NotFilterOutputStream extends ByteArrayOutputStream {\n      NotFilterOutputStream(OutputStream out) {}\n    }\n    // BUG: Diagnostic contains:\n    try (OutputStream outputStream = mustBeClosedOutputStream();\n        var s = new NotFilterOutputStream(outputStream)) {}\n  }\n\n  @MustBeClosed\n  OutputStream decoratorMustBeClosed() {\n    class MustBeClosedFilter extends FilterOutputStream {\n      @MustBeClosed\n      MustBeClosedFilter(OutputStream out) {\n        super(out);\n      }\n    }\n    // BUG: Diagnostic contains:\n    return new MustBeClosedFilter(\n        // handled above\n        mustBeClosedOutputStream());\n  }\n}"
    },
    {
      "description": "enumInitializer",
      "expected-problems": null,
      "expected-linenumbers": [
        812
      ],
      "code": "import com.google.errorprone.annotations.MustBeClosed;\n            import java.io.Closeable;\n\n            enum Test {\n              A;\n\n              interface Foo extends Closeable {}\n\n              @MustBeClosed\n              static Foo createResource() {\n                return null;\n              }\n\n              private final Foo resource;\n              private final Foo resource2 = createResource();\n\n              Test() {\n                this.resource = createResource();\n              }\n            }"
    },
    {
      "description": "forLoop",
      "expected-problems": null,
      "expected-linenumbers": [
        842
      ],
      "code": "import com.google.errorprone.annotations.MustBeClosed;\n\n            class Test {\n              class Closeable implements AutoCloseable {\n                @Override\n                public void close() {}\n\n                public int method() {\n                  return 1;\n                }\n              }\n\n              class Foo {\n                @MustBeClosed\n                Closeable mustBeClosedMethod() {\n                  return null;\n                }\n              }\n\n              void forLoopCondition() {\n                for (int i = 0; i < new Foo().mustBeClosedMethod().method(); ++i) {}\n              }\n            }\n            \n\n            import com.google.errorprone.annotations.MustBeClosed;\n\n            class Test {\n              class Closeable implements AutoCloseable {\n                @Override\n                public void close() {}\n\n                public int method() {\n                  return 1;\n                }\n              }\n\n              class Foo {\n                @MustBeClosed\n                Closeable mustBeClosedMethod() {\n                  return null;\n                }\n              }\n\n              void forLoopCondition() {\n                try (var closeable = new Foo().mustBeClosedMethod()) {\n                  for (int i = 0; i < closeable.method(); ++i) {}\n                }\n              }\n            }"
    },
    {
      "description": "forLoopUnfixable",
      "expected-problems": null,
      "expected-linenumbers": [
        905
      ],
      "code": "import com.google.errorprone.annotations.MustBeClosed;\n\n            class Test {\n              class Closeable implements AutoCloseable {\n                @Override\n                public void close() {}\n\n                public int method() {\n                  return 1;\n                }\n              }\n\n              class Foo {\n                @MustBeClosed\n                Closeable mustBeClosedMethod() {\n                  return null;\n                }\n              }\n\n              void forLoopInitialization() {\n                for (int i = new Foo().mustBeClosedMethod().method(); i > 0; --i) {}\n              }\n\n              void forLoopUpdate() {\n                for (int i = 0; i < 100; i += new Foo().mustBeClosedMethod().method()) {}\n              }\n            }"
    },
    {
      "description": "localVariableTypeInference",
      "expected-problems": null,
      "expected-linenumbers": [
        943
      ],
      "code": "class Closeable implements AutoCloseable {\n              @Override\n              public void close() {}\n\n              public int method() {\n                return 1;\n              }\n            }\n            \n\n            import com.google.errorprone.annotations.MustBeClosed;\n\n            class Foo {\n              @MustBeClosed\n              Closeable mustBeClosedMethod() {\n                return null;\n              }\n            }\n            \n\n            class Test {\n              void test(Foo foo) {\n                var bar = foo.mustBeClosedMethod().method();\n              }\n            }\n            \n\n            class Test {\n              void test(Foo foo) {\n                int bar;\n                try (var closeable = foo.mustBeClosedMethod()) {\n                  bar = closeable.method();\n                }\n              }\n            }"
    }
  ]
}