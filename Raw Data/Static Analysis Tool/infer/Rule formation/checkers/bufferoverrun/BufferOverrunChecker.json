{
  "name": "BufferOverrunChecker",
  "language": [
    "clang",
    "java"
  ],
  "description": "InferBO is a detector for out-of-bounds array accesses.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "OCaml",
  "loc": 413,
  "branches": 21,
  "apis": 49,
  "test": [
    {
      "testname": "arith.c",
      "testlanguage": "c",
      "expected-problems": 218,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdint.h>\n\nvoid modulo_signed_Bad(int i) {\n  char arr[5];\n  arr[i % 5] = 123;\n}\n\nvoid modulo_signed_Good(int i) {\n  char arr[5];\n  if (i >= 0) {\n    arr[i % 5] = 123;\n  }\n}\n\nvoid modulo_signed_neg_Bad(int i) {\n  char arr[5];\n  arr[i % -5] = 123;\n}\n\nvoid modulo_signed_neg_Good(int i) {\n  char arr[5];\n  if (i >= 0) {\n    arr[i % -5] = 123;\n  }\n}\n\nvoid modulo_signed_Good2(int i) {\n  char arr[5];\n  int j = i % 5;\n  if (j >= 0) {\n    arr[j] = 123;\n  }\n}\n\nvoid modulo_unsigned_Good(unsigned int i) {\n  char arr[5];\n  arr[i % 5] = 123;\n}\n\nvoid modulo_unsigned_short_Good(uint16_t i) {\n  char arr[5];\n  arr[i % 5] = 123;\n}\n\nvoid modulo_signed_var_Bad_FN(unsigned int len, int i) {\n  char arr[len];\n  arr[i % len] = 123;\n}\n\nvoid modulo_unsigned_var_Good(unsigned int len, unsigned int i) {\n  char arr[len];\n  arr[i % len] = 123;\n}\n\nunsigned int modulo_unsigned(unsigned int a, unsigned int b) { return a % b; }\n\nvoid modulo_call_Good(unsigned int len, unsigned int i) {\n  char arr[len];\n  arr[modulo_unsigned(i, len)] = 123;\n}\n\nint modulo_signed(int a, int b) { return a % b; }\n\nvoid modulo_call_Bad_FN(unsigned int len, int i) {\n  char arr[len];\n  arr[modulo_signed(i, len)] = 123;\n}\n\nint division_of_zero_Good(int x) {\n  int i = 4 * x;\n  i /= 2;\n  i /= 2;\n  return i;\n}\n\n/* While the most precise return value is\n   - \"2*i+1\"    if 0 <= i < 10,\n   - \"0\"        o.w.\n   Inferbo returns [1+min(-1,s0),10+max(-10,s1)] where i is [s0,s1]. */\nint plus_linear_min(int i) { /* i |-> [s0,s1] */\n  int linear = i + 1; /* linear |-> [s0+1,s1+1] */\n  if (i >= 0 && i < 10) { /* i |-> [max(0,s0),min(9,s1)] */\n    return linear + i; /* return |-> [s0+1,s1+10] */\n  }\n  return 0;\n}\n\nvoid plus_linear_min_Good() {\n  int a[20];\n  a[plus_linear_min(9)] = 1;\n}\n\nvoid plus_linear_min_Bad() {\n  int a[19];\n  a[plus_linear_min(9)] = 1;\n}\n\nvoid plus_linear_min2_Good_FP() {\n  int a[10];\n  a[plus_linear_min(4)] = 1;\n}\n\nvoid plus_linear_min3_Good_FP() {\n  int a[20];\n  a[plus_linear_min(15)] = 1;\n}\n\nvoid integer_overflow_by_addition_Bad() {\n  char arr[10];\n  int32_t x = 2000000000;\n  int32_t y = 2000000000;\n  int32_t z = x + y; // z is a negative number.\n  if (z < 10) {\n    arr[z] = 0;\n  }\n}\n\nvoid integer_overflow_by_addition_l2_Bad(int x) {\n  int32_t y;\n  if (x) {\n    y = 0;\n  } else {\n    y = 2000000000;\n  }\n  y = y + y;\n}\n\nvoid integer_overflow_by_subtraction_Bad() {\n  char arr[10];\n  int32_t x = -2000000000;\n  int32_t y = 2000000000;\n  int32_t z = x - y; // z is a big positive number.\n  if (z >= 0) {\n    arr[z] = 0;\n  }\n}\n\nvoid integer_overflow_by_multiplication_Bad() {\n  char arr[10];\n  int32_t x = 300000;\n  int32_t y = 300000;\n  int32_t z = x * y; // z is a negative number.\n  if (z < 10) {\n    arr[z] = 0;\n  }\n}\n\nvoid use_int64_max_Good() {\n  char arr[10];\n  int64_t x = INT64_MAX;\n  int64_t y = INT64_MAX - 5;\n  arr[x - y] = 0;\n}\n\nvoid use_int64_max_Bad() {\n  char arr[10];\n  int64_t x = INT64_MAX;\n  int64_t y = INT64_MAX - 15;\n  arr[x - y] = 0;\n}\n\nvoid use_uint64_max_Good() {\n  char arr[10];\n  uint64_t x = UINT64_MAX;\n  uint64_t y = UINT64_MAX - 5;\n  arr[x - y] = 0;\n}\n\nvoid use_uint64_max_Bad() {\n  char arr[10];\n  uint64_t x = UINT64_MAX;\n  uint64_t y = UINT64_MAX - 15;\n  arr[x - y] = 0;\n}\n\nuint64_t unknown_uint();\n\nvoid muliply_one_Good() {\n  uint64_t x = unknown_uint();\n  uint64_t y = x * 1;\n}\n\nvoid muliply_two_Bad() {\n  uint64_t x = unknown_uint();\n  uint64_t y = x * 2;\n}\n\nvoid minus_one_Good() {\n  uint64_t x = unknown_uint();\n  if (x > 0) {\n    uint64_t y = x - 1;\n  }\n}\n\nvoid minus_one_Bad() {\n  uint64_t x = unknown_uint();\n  if (x >= 0) {\n    uint64_t y = x - 1;\n  }\n}\n\nint64_t unknown_int();\n\nvoid plus_one_Good() {\n  int64_t x = unknown_int();\n  if (x < INT64_MAX) {\n    int64_t y = x + 1;\n  }\n}\n\nvoid plus_one_Bad() {\n  int64_t x = unknown_int();\n  if (x <= INT64_MAX) {\n    int64_t y = x + 1;\n  }\n}\n\nvoid minus_minimum_Good() {\n  int64_t x = -1;\n  int64_t y = x - INT64_MIN;\n}\n\nvoid minus_minimum_Bad() {\n  int64_t x = 0;\n  int64_t y = x - INT64_MIN;\n}\n\nvoid mult_minimum_Good() {\n  int64_t x = 1;\n  int64_t y = x * INT64_MIN;\n}\n\nvoid mult_minimum_Bad() {\n  int64_t x = -1;\n  int64_t y = x * INT64_MIN;\n}\n\nvoid unsigned_prune_zero1_Good(unsigned int x) {\n  if (x != 0) {\n    unsigned int y = x - 1;\n  }\n}\n\nvoid call_unsigned_prune_zero1_Good() { unsigned_prune_zero1_Good(0); }\n\nvoid unsigned_prune_zero2_Good(unsigned int y) {\n  unsigned int x = y;\n  for (; x; --x) {\n  }\n}\n\nvoid call_unsigned_prune_zero2_Good() { unsigned_prune_zero2_Good(0); }\n\nvoid unsigned_prune_ge1_Good(unsigned int x, unsigned int y) {\n  if (x >= y) {\n    unsigned int z = x - y;\n  }\n}\n\nvoid call_unsigned_prune_ge1_Good() { unsigned_prune_ge1_Good(0, 1); }\n\nvoid unsigned_prune_ge2_Good(unsigned int x, unsigned int y) {\n  if (y > 0) {\n    if (x >= y) {\n      unsigned int z = x - 1;\n    }\n  }\n}\n\nvoid call_unsigned_prune_ge2_Good() { unsigned_prune_ge2_Good(0, 1); }\n\nvoid unsigned_prune_ge3_Good(unsigned int x, unsigned int y) {\n  if (y > 0) {\n    if (x >= y + 1) {\n      unsigned int z = x - 1;\n    }\n  }\n}\n\nvoid call_unsigned_prune_ge3_Good() { unsigned_prune_ge3_Good(0, 1); }\n\nvoid unsigned_prune_gt(unsigned int x, unsigned int y) {\n  if (x > 0) {\n    unsigned int z = x - y;\n  }\n}\n\nvoid call_unsigned_prune_gt_Good() { unsigned_prune_gt(0, 3); }\n\nvoid minmax_div_const_Good(int n) {\n  int a[9];\n  if (0 < n && n < 65) {\n    int x = a[n / 8];\n  }\n}\n\nvoid minmax_div_const_Bad(int n) {\n  int a[7];\n  if (0 < n && n < 65) {\n    int x = a[n / 8];\n  }\n}\n\nvoid div_const_Good() {\n  int a[3];\n  int x = 5 / 2;\n  a[x] = 0;\n}\n\nvoid div_const_Bad() {\n  int a[2];\n  int x = 5 / 2;\n  a[x] = 0;\n}\n\nvoid div_const2_FP(int n) {\n  int a[1];\n  int x = (n * 2 + 1) / 2;\n  a[x] = 0;\n}\n\nvoid minmax_div_const2_Good() {\n  div_const2(-1);\n  div_const2(0);\n}\n\nvoid minmax_div_const2_Bad_FN() {\n  div_const2(1);\n  div_const2(-2);\n}\n\nuint32_t unknown_nat() {\n  uint32_t x = unknown_function();\n  if (x >= 0) {\n    return x;\n  } else {\n    return 0;\n  }\n}\n\nvoid two_safety_conditions2_Bad(uint32_t s) {\n  uint32_t x = unknown_nat();\n  uint32_t y, z;\n\n  if (unknown_function()) {\n    y = 0;\n  } else {\n    y = 80;\n  }\n  z = x + y; // integer overflow L5: [0, +oo] + [0, 80]\n\n  if (s >= 10 && s <= 20) {\n    z = x + s; // [0, +oo] + [max(10, s.lb), min(20, s.ub)]\n  }\n}\n\nvoid call_two_safety_conditions2_Bad() {\n  two_safety_conditions2_Bad(15); // integer overflow L5: [0, +oo] + 15\n}\n\nvoid band_positive_constant_Good() {\n  char a[3];\n  int x = 6 & 2; // y is 2\n  a[x] = 0;\n}\n\nvoid band_positive_constant_Bad() {\n  char a[2];\n  int x = 6 & 2; // y is 2\n  a[x] = 0;\n}\n\nvoid band_negative_constant_Good() {\n  char a[1];\n  int x = (-3) & (-2); // x is -4\n  a[x + 4] = 0;\n}\n\nvoid band_negative_constant_Bad() {\n  char a[1];\n  int x = (-3) & (-2); // x is -4\n  a[x + 5] = 0;\n}\n\nvoid band_constant_Good() {\n  char a[2];\n  int x = (-3) & 1; // x is 1\n  a[x] = 0;\n}\n\nvoid band_constant_Bad() {\n  char a[1];\n  int x = (-3) & 1; // x is 1\n  a[x] = 0;\n}\n\nvoid band_positive_Good() {\n  char a[9];\n  int x = unknown_nat();\n  int y = unknown_nat();\n  if (x <= 10 && y <= 8) {\n    int z = x & y; // z is [0, 8]\n    a[z] = 0;\n  }\n}\n\nvoid band_positive_Bad() {\n  char a[5];\n  int x = unknown_nat();\n  int y = unknown_nat();\n  if (x <= 10 && y <= 8) {\n    int z = x & y; // z is [0, 8]\n    a[z] = 0;\n  }\n}\n\nvoid band_negative_Good() {\n  char a[3];\n  int x = unknown_function();\n  int y = unknown_function();\n  if (x <= -3 && y <= -2) {\n    int z = x & y; // z is [-oo, -3]\n    z = z + 5; // z is [-oo, 2]\n    if (z >= 0) {\n      a[z] = 0;\n    }\n  }\n}\n\nvoid band_negative_Bad() {\n  char a[2];\n  int x = unknown_function();\n  int y = unknown_function();\n  if (x <= -3 && y <= -2) {\n    int z = x & y; // z is [-oo, -3]\n    z = z + 5; // z is [-oo, 2]\n    if (z >= 0) {\n      a[z] = 0;\n    }\n  }\n}\n\n#define FOUR_GIGABYTES 0xFFFFFFFF\n#define ALMOST_FOUR_GIGABYTES (85 * FOUR_GIGABYTES / 100)\n\nvoid simple_overflow_Bad() { auto x = ALMOST_FOUR_GIGABYTES; }\n\nunsigned int unused_integer_underflow_Good_FP() {\n  unsigned int n = 0;\n  if (n-- == 0) {\n    return 0;\n  } else {\n    return n;\n  }\n}\n\nunsigned int unused_integer_underflow_Bad() {\n  unsigned int n = 0;\n  if (n-- == 0) {\n    return n;\n  } else {\n    return n;\n  }\n}\n\nunsigned int unused_integer_underflow2_Good_FP() {\n  unsigned int n = 0;\n  return n--;\n}\n\nunsigned int unused_integer_underflow2_Bad() {\n  unsigned int n = 0;\n  return --n;\n}\n\nvoid recover_integer_underflow_Good_FP() {\n  for (unsigned int i = 0; i < 10; i++) {\n    if (unknown_function()) {\n      i--; // right after this, i++ will be called.\n    }\n  }\n}\n\nvoid recover_integer_underflow_Bad() {\n  for (unsigned int i = 0; i < 10; i++) {\n    if (unknown_function()) {\n      i -= 2;\n    }\n  }\n}\n\nunsigned long scan_hex_Good(char* cp) {\n  unsigned long num_digits = 0, digit, val = 0;\n  while (1) {\n    digit = *cp;\n    if ((digit - '0') <= 9)\n      digit -= '0';\n    else if ((digit - 'a') < 6)\n      digit -= 'a' - 10;\n    else if ((digit - 'A') < 6)\n      digit -= 'A' - 10;\n    else\n      break;\n    val = (val << 4) | digit;\n    ++cp;\n  }\n  return val;\n}\n\nvoid call_scan_hex_Good_FP() {\n  char* cp = \"\\0\";\n  scan_hex_Good(cp);\n}\n\nvoid call_scan_hex2_Good_FP() {\n  char* cp = \"0aA\";\n  scan_hex_Good(cp);\n}\n\nint check_addition_overflow_Good(unsigned int x, unsigned int y) {\n  if (((unsigned int)-1) - x < y) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nvoid shift_right_zero_Good(int x) {\n  int arr[1];\n  arr[0 >> x] = 1;\n}\n\nvoid shift_right_zero_Bad(int x) {\n  int arr[1];\n  arr[1 + (0 >> x)] = 1;\n}\n\n#define INTENDED_INTEGER_UNDERFLOW (0ULL - 2)\n\nvoid use_intended_integer_underflow_Good() {\n  unsigned long long x = INTENDED_INTEGER_UNDERFLOW;\n}\n\nvoid ptr_band1_Bad(int x, int* q) {\n  int a[5];\n  int* p;\n  if (x) {\n    p = q;\n  } else {\n    p = 0;\n  }\n  if ((int)p & x) {\n    a[10] = 0;\n  }\n}\n\nvoid ptr_band2_Bad(int x, int* q) {\n  int a[5];\n  int* p;\n  if (x) {\n    p = q;\n  } else {\n    p = 0;\n  }\n  if ((int)p & x) {\n  }\n  a[10] = 0;\n}\n\nvoid do_not_prune_float_Good_FP() {\n  int a[5];\n  float f = 0.5;\n  if (f > 1.0 && f < 1.0) {\n    a[10] = 0;\n  }\n}\n\nvoid do_not_prune_float_Bad() {\n  int a[5];\n  float f = 0.5;\n  if (f > 0.0 && f < 1.0) {\n    a[10] = 0;\n  }\n}\n"
    },
    {
      "testname": "array_content.c",
      "testlanguage": "c",
      "expected-problems": 106,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdio.h>\n\nint check_sorted_arr_good(int a[], int length) {\n  for (int i = 1; i < length; i++) {\n    if (a[i] < a[i - 1]) { // should not report CONDITION_ALWAYS_FALSE\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint check_sorted_arr10_good(int a[10], int length) {\n  for (int i = 1; i < length; i++) {\n    if (a[i] < a[i - 1]) { // should not report CONDITION_ALWAYS_FALSE\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint check_sorted_ptr_good(int* a, int length) {\n  for (int i = 1; i < length; i++) {\n    if (a[i] < a[i - 1]) { // should not report CONDITION_ALWAYS_FALSE\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint array_min_index_from_one(int* a, int length) {\n  int index_min = 1;\n  for (int i = 2; i < length; i++) {\n    if (a[i] < a[index_min]) { // should not report CONDITION_ALWAYS_FALSE\n      index_min = i;\n    } else {\n      index_min = i;\n    }\n  }\n  return index_min;\n}\n\n/*\n  We need either a narrowing or a relational domain to prove that\n  index_min < length\n*/\nvoid call_array_min_index_from_one_good() {\n  int a[2];\n  a[array_min_index_from_one(a, 2) - 1] = 0;\n}\n\nvoid weak_update_Good_FP() {\n  int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 15};\n  a[a[3]] = 3;\n}\n\nvoid weak_update_Bad() {\n  int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  if (a[0] == 0) {\n    a[15] = 1;\n  }\n}\n\nvoid strong_update_malloc_Good() {\n  int a[10];\n  int* x = (int*)malloc(sizeof(int));\n  *x = 10;\n  *x = 0;\n  a[*x] = 0;\n}\n\nvoid strong_update_malloc_Bad() {\n  int a[10];\n  int* x = (int*)malloc(sizeof(int));\n  *x = 0;\n  *x = 10;\n  a[*x] = 0;\n}\n\nvoid weak_update_malloc_Good_FP() {\n  int a[10];\n  int* x = (int*)malloc(sizeof(int) * 2);\n  x[0] = 0;\n  x[1] = 10;\n  a[x[0]] = 0;\n}\n\nvoid weak_update_malloc_Bad() {\n  int a[10];\n  int* x = (int*)malloc(sizeof(int) * 2);\n  x[0] = 0;\n  x[1] = 10;\n  a[x[1]] = 0;\n}\n\nvoid weak_update_malloc2_Bad_FN() {\n  int a[10];\n  int* x = (int*)malloc(sizeof(int) * 2);\n  x[0] = 0;\n  a[x[1]] = 0;\n}\n\nvoid literal_string_Good() {\n  int a[1];\n  char* s = \"hello\";\n  for (int i = 0; i < 5; i++) {\n    if (s[i] > 'o') {\n      a[s[i]] = 0;\n    }\n  }\n}\n\nvoid literal_string_bad() {\n  int a[1];\n  char* s = \"hello\";\n  for (int i = 0; i < 5; i++) {\n    if (s[i] > 'n') {\n      a[s[i]] = 0;\n    }\n  }\n}\n\nvoid literal_string2_Good() {\n  int a[1];\n  char s[] = \"hello\";\n  for (int i = 0; i < 5; i++) {\n    if (s[i] > 'o') {\n      a[s[i]] = 0;\n    }\n  }\n}\n\nvoid literal_string2_bad() {\n  int a[1];\n  char s[] = \"hello\";\n  for (int i = 0; i < 5; i++) {\n    if (s[i] > 'n') {\n      a[s[i]] = 0;\n    }\n  }\n}\n\nvoid literal_string_parameter(char* s) {\n  int a[112]; // 'o' is 111, 'p' is 112\n  a[s[0]] = 0;\n}\n\nvoid call_literal_string_parameter1_Good() {\n  char* s = \"hello\";\n  literal_string_parameter(s);\n}\n\nvoid call_literal_string_parameter1_Bad() {\n  char* s = \"hellp\";\n  literal_string_parameter(s);\n}\n\nvoid call_literal_string_parameter2_Good() {\n  literal_string_parameter(\"hello\");\n}\n\nvoid call_literal_string_parameter2_Bad() { literal_string_parameter(\"hellp\"); }\n\nvoid strlen_constant_Good() {\n  int a[10];\n  char* s = \"hello\";\n  a[strlen(s)] = 0;\n}\n\nvoid strlen_constant_Bad() {\n  int a[5];\n  char* s = \"hello\";\n  a[strlen(s)] = 0;\n}\n\nvoid strlen_malloc_Good() {\n  int a[10];\n  char* s = (char*)malloc(sizeof(char) * 6);\n  s[0] = 'h';\n  s[1] = 'e';\n  s[2] = 'l';\n  s[3] = 'l';\n  s[4] = 'o';\n  s[5] = '\\0';\n  a[strlen(s)] = 0;\n}\n\nvoid strlen_malloc_Bad() {\n  int a[5];\n  char* s = (char*)malloc(sizeof(char) * 6);\n  s[0] = 'h';\n  s[1] = 'e';\n  s[2] = 'l';\n  s[3] = 'l';\n  s[4] = 'o';\n  s[5] = '\\0';\n  a[strlen(s)] = 0;\n}\n\nvoid strlen_malloc_2_Good_FP() {\n  int a[5];\n  char* s = (char*)malloc(sizeof(char) * 6);\n  s[0] = 'h';\n  s[1] = 'e';\n  s[2] = '\\0';\n  s[3] = 'l';\n  s[4] = 'o';\n  s[5] = '\\0';\n  a[strlen(s)] = 0;\n}\n\nvoid fgets_null_check_Good() {\n  char line[100];\n  while (fgets(line, 100, stdin)) {\n    line[strlen(line) - 1] = 0;\n  }\n}\n\nvoid fgets_null_check_Bad() {\n  char line[100];\n  while (fgets(line, 100, stdin)) {\n    line[strlen(line) - 2] = 0;\n  }\n}\n\nstatic char file_buf[] = \"foo\";\n\nvoid fgets_may_not_change_str_Good_FP() {\n  FILE* stream = fmemopen(file_buf, strlen(file_buf), \"r\");\n  fgetc(stream);\n  fgetc(stream);\n  fgetc(stream);\n  char buf[6] = \"aaaaa\";\n  // end-of-file is encountered, thus [buf] should not change.\n  fgets(buf, 6, stream);\n  int a[5];\n  a[9 - strlen(buf)] = 0;\n}\n\nvoid fgets_may_not_change_str_Bad() {\n  FILE* stream = fmemopen(file_buf, strlen(file_buf), \"r\");\n  fgetc(stream);\n  fgetc(stream);\n  fgetc(stream);\n  char buf[6] = \"aaaaa\";\n  // end-of-file is encountered, thus [buf] should not change.\n  fgets(buf, 6, stream);\n  int a[5];\n  a[strlen(buf)] = 0;\n}\n"
    },
    {
      "testname": "array_dynlength.c",
      "testlanguage": "c",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid init_variable_array(int len) {\n  int x = 2 * len;\n  int a[len + x + 1];\n  a[len + x + 1] = 0;\n}\n"
    },
    {
      "testname": "array_field.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstruct S1 {\n  int f[2];\n};\n\nvoid array_field_access_Good(struct S1 x, struct S1 y) {\n  int a[10];\n  x.f[0] = 1;\n  y.f[0] = 20;\n  a[x.f[0]] = 0;\n}\n\nvoid array_field_access_Bad(struct S1 x, struct S1 y) {\n  int a[10];\n  y.f[0] = 20;\n  x.f[0] = 1;\n  a[y.f[0]] = 0;\n}\n\nvoid decreasing_pointer_Good(struct S1* x) {\n  int* p = &(x->f[1]);\n  p--;\n  *p = 0;\n}\n\nvoid decreasing_pointer_Bad(struct S1* x) {\n  int* p = &(x->f[1]);\n  p--;\n  p--;\n  *p = 0;\n}\n"
    },
    {
      "testname": "array_multidim.c",
      "testlanguage": "c",
      "expected-problems": 28,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid multidim_arr1_Good() {\n  int a[2][3];\n  a[1][0] = 0;\n}\n\nvoid multidim_arr1_Bad() {\n  int a[2][3];\n  a[2][0] = 0;\n}\n\nvoid multidim_arr2_Good() {\n  int a[2][3];\n  a[1][2] = 0;\n}\n\nvoid multidim_arr2_Bad() {\n  int a[2][3];\n  a[1][3] = 0;\n}\n\nvoid multidim_arr3_Good() {\n  int a[3][2] = {\n      {0, 1},\n      {0, 2},\n      {0, 3},\n  };\n}\n\nvoid multidim_arr4_Good() {\n  int a[3][2];\n  int* p = a;\n  *(p + 5) = 0;\n}\n\nvoid multidim_arr4_Bad() {\n  int a[3][2];\n  int* p = a;\n  *(p + 6) = 0;\n}\n\nvoid multidim_arr5_Good() {\n  int a[1][10];\n  a[0][0] = 0;\n  a[0][5] = 0;\n}\n\nvoid multidim_arr5_Bad() {\n  int a[1][10];\n  a[0][0] = 0;\n  a[0][10] = 0;\n}\n\nvoid multidim_arr6_Good() {\n  int a[3][2];\n  int b[10];\n  int* p = a;\n  *p = 5;\n  b[a[0][0]] = 1;\n}\n\nvoid multidim_arr6_Bad_FN() {\n  int a[3][2];\n  int b[5];\n  int* p = a;\n  *p = 5;\n  b[a[0][0]] = 1;\n}\n"
    },
    {
      "testname": "big_array.c",
      "testlanguage": "c",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#define CHARS_21 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,\n#define CHARS_147 CHARS_21 CHARS_21 CHARS_21 CHARS_21 CHARS_21 CHARS_21 CHARS_21\n#define CHARS_882 CHARS_147 CHARS_147 CHARS_147 CHARS_147 CHARS_147 CHARS_147\n#define CHARS_5292 CHARS_882 CHARS_882 CHARS_882 CHARS_882 CHARS_882 CHARS_882\n#define CHARS_26460 CHARS_5292 CHARS_5292 CHARS_5292 CHARS_5292 CHARS_5292\n\nunsigned char* big_array() {\n  const unsigned char bytes[] = {CHARS_26460};\n  return bytes;\n}\n\nvoid use_big_array_bad() {\n  unsigned char* b = big_array();\n  b[999999999] = 'Y';\n}\n"
    },
    {
      "testname": "break_continue_return.c",
      "testlanguage": "c",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nint break_continue_return() {\n  int i = 0;\n  char a[10];\n\n  while (1) {\n    i++;\n    if (i >= 10)\n      break;\n    if (i < 2)\n      continue;\n    a[i] = 'a'; /* SAFE */\n  }\n  i = 0;\n  while (1) {\n    if (i > 10)\n      return 0;\n    a[i] = 'a'; /* BUG */\n    i++;\n  }\n  return 0;\n}\n"
    },
    {
      "testname": "calloc.c",
      "testlanguage": "c",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid calloc_ok1() {\n  int* arr = (int*)calloc(10, sizeof(int));\n  arr[0] = 0;\n  arr[9] = 0;\n}\n\nvoid calloc_bad1() {\n  int* arr = (int*)calloc(10, sizeof(int));\n  arr[-1] = 0;\n  arr[10] = 0;\n}\n"
    },
    {
      "testname": "cast.c",
      "testlanguage": "c",
      "expected-problems": 32,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdint.h>\n\nvoid cast_Good() {\n  char arr[5];\n  *(int32_t*)(arr + 1) = 123;\n}\n\nvoid cast_Bad_FN() {\n  char arr[1];\n  *(int32_t*)arr = 123;\n}\n\nvoid cast2_Good() {\n  int32_t arr[4];\n  *(((char*)arr) + 4) = 123;\n}\n\nvoid cast2_Bad() {\n  int32_t arr[4];\n  *(((char*)arr) + 20) = 123;\n}\n\nvoid cast_unsigned_to_signed_Good() {\n  char arr[10];\n  uint32_t x = 15;\n  int32_t y = (int32_t)x;\n  if (y < 10) {\n    arr[y] = 0;\n  }\n}\n\nvoid cast_unsigned_to_signed_Bad_FN() {\n  char arr[10];\n  uint32_t x = 4294967295;\n  int32_t y = (int32_t)x; // y is -1.\n  if (y < 10) {\n    arr[y] = 0;\n  }\n}\n\nvoid cast_signed_to_unsigned_Good() {\n  char arr[10];\n  int32_t x = 15;\n  uint32_t y = (uint32_t)x;\n  if (y < 10) {\n    arr[y] = 0;\n  }\n}\n\nvoid cast_signed_to_unsigned_Bad() {\n  char arr[10];\n  int32_t x = -1;\n  uint32_t y = (uint32_t)x;\n  if (y > 0) {\n    arr[y] = 0;\n  }\n}\n\nvoid cast_signed_to_unsigned2_Bad_FN() {\n  char arr[10];\n  int32_t x = -2;\n  uint32_t y = (uint32_t)x;\n  if (y > 0) {\n    arr[y] = 0;\n  }\n}\n\nvoid cast_float_to_int_Good_FP() {\n  char arr[10];\n  float x = 15.0;\n  int32_t y = (int32_t)x;\n  if (y < 10) {\n    arr[y] = 0;\n  }\n}\n\nvoid cast_float_to_int_Bad() {\n  char arr[10];\n  float x = 15000000000.0;\n  int32_t y = (int32_t)x; // y is -2147483648.\n  if (y < 10) {\n    arr[y] = 0;\n  }\n}\n\n/*\n  Testing that the analyzer doesn't run infinitely on these cases\n*/\ntypedef struct s_cast {\n  char* data;\n  struct s_cast* another;\n  char* data2;\n} t_cast;\n\nchar cast_field_to_struct(struct s_cast* s, int i0) {\n  for (int i = i0; i > 0; i--) {\n    s = (struct s_cast*)(&s->data);\n  }\n  s = s->another;\n  for (int i = i0; i > 0; i--) {\n    s = (struct s_cast*)(&s->data);\n    s = (struct s_cast*)((unsigned char*)(void*)(s->data2) -\n                         offsetof(s->data2));\n  }\n  return *s->data;\n}\n"
    },
    {
      "testname": "do_while.c",
      "testlanguage": "c",
      "expected-problems": 16,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid do_while_sub(char* a, int len) {\n  int i = 0;\n  do {\n    a[i] = i;\n    i++;\n  } while (i < len);\n}\n\nvoid do_while_Good() {\n  char* a = malloc(10);\n  do_while_sub(a, 10); /* SAFE */\n}\n\nvoid do_while_Bad() {\n  char* a = malloc(10);\n  do_while_sub(a, 11); /* BUG */\n}\n\nvoid do_while_2_Good() {\n  int count = 10;\n  int a[count];\n  int i = 0;\n  do {\n    a[i] = 0;\n  } while (++i < count);\n}\n\nvoid do_while_2_Bad() {\n  int count = 10;\n  int a[count];\n  int i = 0;\n  do {\n    a[i] = 0;\n  } while (i++ < count);\n}\n"
    },
    {
      "testname": "duplicates.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid two_accesses(int* arr) {\n  if (arr[1] < 0) {\n    arr[0] = 0;\n  }\n}\n\nvoid one_alarm_is_enough() {\n  int arr[1];\n  two_accesses(arr);\n}\n\nvoid two_symbolic_accesses(int n) {\n  int arr[1];\n  arr[n] = 0;\n  arr[n - 2] = 0; // Do not remove the associated condition\n}\n\nvoid tsa_one_alarm_Bad() { two_symbolic_accesses(3); }\n\nvoid tsa_two_alarms_Bad() { two_symbolic_accesses(1); }\n"
    },
    {
      "testname": "external.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nextern char** lib();\n\nvoid extern_bad() {\n  int arr[10];\n  char** p = lib();\n  if (p != 0)\n    arr[10] = 0;\n  char* q = *p;\n  if (q != 0)\n    arr[20] = 0;\n  int r = *q;\n  if (r != 0)\n    arr[30] = 0;\n}\n"
    },
    {
      "testname": "flexible_array.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct s {\n  int useless_field_because_flexible_array_members_are_not_allowed_in_otherwise_empty_struct;\n  int arr[];\n};\n\nvoid access_to_incomplete_array_type(struct s* a, int i) { a->arr[i] = 0; }\n\nvoid call_access_to_incomplete_array_type_Good() {\n  struct s* x = malloc(sizeof(struct s) + sizeof(int));\n  access_to_incomplete_array_type(x, 0);\n}\n\nvoid call_access_to_incomplete_array_type_Bad_FN() {\n  struct s* x = malloc(sizeof(struct s) + sizeof(int));\n  access_to_incomplete_array_type(x, 1);\n}\n\n// For tests with last field of size 0 or 1, see class.cpp\n"
    },
    {
      "testname": "for_loop.c",
      "testlanguage": "c",
      "expected-problems": 45,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nchar* safealloc(int n) {\n  char* x;\n  if (n > 0)\n    x = malloc(n);\n  else\n    x = malloc(10);\n\n  if (!x)\n    return x;\n  else\n    exit(1);\n}\n\nvoid for_loop() {\n  char* a;\n  int i;\n\n  a = safealloc(10);\n  for (i = 0; i < 10; i++) {\n    a[i] = 'a'; /* SAFE */\n  }\n  a = safealloc(5);\n  for (i = 0; i < 10; i++) {\n    a[i] = 'a'; /* BUG */\n  }\n}\n\nvoid no_op() { int k = 0; }\n\nint two_loops(int m) {\n  for (int i = 0; i < m; i++) {\n    no_op();\n  }\n  for (int j = 0; j < m; j++) {\n    no_op();\n  }\n  return m;\n}\n\nvoid call_two_loops_Good() {\n  int a[10];\n  int m = 5;\n  a[two_loops(m)] = 1;\n}\n\nvoid call_two_loops_Bad() {\n  int a[10];\n  int m = 15;\n  a[two_loops(m)] = 1;\n}\n\nstruct payload {\n  int count;\n  int payload[];\n};\n\n#define COUNT 10\n\n// memleak but no array out of bounds error\nvoid malloc_sizeof_value_leak_good() {\n  struct payload* x;\n  x = malloc(sizeof(*x) + COUNT * sizeof(x->payload[0]));\n  if (x == NULL) {\n    return 1;\n  }\n  x->count = COUNT;\n  for (int i = 0; i < COUNT; i++) {\n    x->payload[i] = i;\n  }\n  /* missing free(x) */\n}\n\nvoid initialize_arr(int* arr, int count) {\n  for (int i = 0; i < count; ++i) {\n    arr[i] = 0;\n  }\n}\n\nvoid call_initialize_arr_Good() {\n  int arr[10];\n  initialize_arr(arr, 5);\n}\n\nvoid call_initialize_arr_Bad() {\n  int arr[10];\n  initialize_arr(arr, 20);\n}\n\nvoid threshold_by_comparison_1_Good() {\n  int arr[100];\n  for (int i = 0; i != 100; i++) {\n    arr[i] = 0;\n  }\n}\n\nvoid threshold_by_comparison_1_Bad() {\n  int arr[50];\n  for (int i = 0; i != 100; i++) {\n    arr[i] = 0;\n  }\n}\n\nvoid threshold_by_comparison_2_Good() {\n  int arr[100];\n  int j = 0;\n  while (1) { // widening threshold for j should be 99, not 100\n    j++;\n    if (j == 100) {\n      j = 0;\n    }\n    arr[j] = 0;\n  }\n}\n\nvoid threshold_by_comparison_2_Bad() {\n  int arr[50];\n  int j = 0;\n  while (1) { // widening threshold for j should be 99, not 100\n    j++;\n    if (j == 100) {\n      j = 0;\n    }\n    arr[j] = 0;\n  }\n}\n\nvoid infinite_for_loop_Good() {\n  int arr[5];\n  int x = 0;\n  for (x;;) {\n  }\n  arr[10] = 0;\n}\n"
    },
    {
      "testname": "function_call.c",
      "testlanguage": "c",
      "expected-problems": 71,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n#include <stdarg.h>\n\nstruct S {\n  int field;\n};\n\nvoid arr_access(int* arr, char* p, int i) {\n  int x = arr[0];\n  arr[x] = 1; /* BUG */\n  *(p + i) = 'a'; /* BUG */\n}\n\nvoid function_call() {\n  int arr[10];\n  arr[0] = 100;\n  char* p = malloc(10);\n  arr_access(arr, p, 20);\n}\n\nvoid ptr_set_to_zero(int* x) { *x = 0; }\n\nvoid struct_ptr_set_to_zero(struct S* s) { s->field = 0; }\n\nvoid call_by_ptr_good() {\n  int arr[10];\n  int i = 99;\n  ptr_set_to_zero(&i);\n  arr[i] = 123;\n}\n\nvoid call_by_arr_good() {\n  int arr[10];\n  ptr_set_to_zero(&arr);\n  arr[arr[0]] = 123;\n}\n\nvoid call_by_struct_ptr_good() {\n  int arr[10];\n  struct S* s = (struct S*)malloc(sizeof(struct S));\n  s->field = 99;\n  struct_ptr_set_to_zero(s);\n  arr[s->field] = 123;\n}\n\nvoid call_by_ptr_bad() {\n  int arr[10];\n  int i = 5;\n  ptr_set_to_zero(&i);\n  arr[i - 1] = 123;\n}\n\nvoid call_by_arr_bad() {\n  int arr[10];\n  ptr_set_to_zero(&arr);\n  arr[arr[0] - 1] = 123;\n}\n\nvoid call_by_struct_ptr_bad() {\n  int arr[10];\n  struct S* sp = (struct S*)malloc(sizeof(struct S));\n  sp->field = 5;\n  struct_ptr_set_to_zero(sp);\n  arr[sp->field - 1] = 123;\n}\n\nint ret_zero() { return 0; }\n\nvoid call_function_ptr_good() {\n  int (*func_ptr)(void) = &ret_zero;\n  int arr[10];\n  if ((*func_ptr)() != 0) {\n    // unreacheable\n    arr[10] = 1;\n  }\n}\n\nvoid call_function_ptr_bad1() {\n  int (*func_ptr)(void) = &ret_zero;\n  int arr[10];\n  if ((*func_ptr)() == 0) {\n    arr[10] = 1;\n  }\n}\n\nvoid access_index_1(int* arr) { arr[1] = 0; }\nvoid access_index_4(int* arr) { arr[4] = 0; }\n\nvoid call_access_index_1_on_local_array_Good() {\n  int arr[4];\n  access_index_1(arr);\n}\n\nvoid call_access_index_4_on_local_array_Bad() {\n  int arr[4];\n  access_index_4(arr);\n}\n\nvoid call_access_index_1_on_malloced_array_Good() {\n  int* ptr = malloc(sizeof(int) * 4);\n  access_index_1(ptr);\n}\n\nvoid call_access_index_4_on_malloced_array_Bad() {\n  int* ptr = malloc(sizeof(int) * 4);\n  access_index_4(ptr);\n}\n\nstruct S2 {\n  int arr[4];\n};\n\nvoid call_access_index_1_on_S2_Good(struct S2* s) { access_index_1(s->arr); }\n\nvoid FN_call_access_index_4_on_S2_Bad(struct S2* s) { access_index_4(s->arr); }\n\nstruct S3 {\n  int* ptr;\n};\n\nvoid call_access_index_1_on_S3(struct S3* s) { access_index_1(s->ptr); }\n\nvoid call_access_index_4_on_S3(struct S3* s) { access_index_4(s->ptr); }\n\nvoid call_call_access_index_1_on_S3_Good() {\n  struct S3 s;\n  s.ptr = malloc(sizeof(int) * 4);\n  call_access_index_1_on_S3(&s);\n}\n\nvoid call_call_access_index_4_on_S3_Bad() {\n  struct S3 s;\n  s.ptr = malloc(sizeof(int) * 4);\n  call_access_index_4_on_S3(&s);\n}\n\nvoid va_arg_int(int* a, ...) {\n  va_list args;\n  va_start(args, a);\n  int i = va_arg(args, int);\n  a[i] = 0;\n  va_end(args);\n}\n\nvoid call_va_arg_int_Good_FP() {\n  int a[10];\n  va_arg_int(a, 5);\n}\n\nvoid call_va_arg_int_Bad() {\n  int a[10];\n  va_arg_int(a, 10);\n}\n\nstruct S* id_S(struct S* r) {\n  return r;\n}\n\nvoid call_id_S_Good_FP(struct S p) {\n  int a[10];\n  struct S* q = id_S(&p);\n  if (q == 0) {\n    a[10] = 0; // should be unreachable\n  }\n}\n\nvoid call_id_S_Bad(struct S p) {\n  int a[10];\n  struct S* q = id_S(&p);\n  if (q != 0) {\n    a[10] = 0; // should be reachable\n  }\n}\n"
    },
    {
      "testname": "get_field.c",
      "testlanguage": "c",
      "expected-problems": 21,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"my_typedef.h\"\n\nstruct st {\n  int field;\n};\n\nint get_field(t* x) { return x->field; }\n\nvoid call_get_field_cond_Bad() {\n  int a[5];\n  t x = {0};\n  if (get_field_wrapper(&x)) {\n    a[10] = 0;\n  } else {\n    a[10] = 0;\n  }\n}\n\nvoid call_get_field_Good() {\n  int a[5];\n  t x = {0};\n  a[get_field_wrapper(&x)] = 0;\n}\n\nvoid call_get_field_Bad() {\n  int a[5];\n  t x = {10};\n  a[get_field_wrapper(&x)] = 0;\n}\n\nstruct List {\n  struct List* next;\n  struct List* prev;\n  int v;\n};\n\nint get_v(struct List* l) { return l->next->prev->v; }\n\nint call_get_v_Good() {\n  int a[10];\n  struct List* l = (struct List*)malloc(sizeof(struct List));\n  struct List* next = (struct List*)malloc(sizeof(struct List));\n  l->next = next;\n  next->prev = l;\n  l->v = 0;\n  next->v = 10;\n  a[get_v(l)] = 0;\n}\n\nint call_get_v_Bad() {\n  int a[10];\n  struct List* l = (struct List*)malloc(sizeof(struct List));\n  struct List* next = (struct List*)malloc(sizeof(struct List));\n  l->next = next;\n  next->prev = l;\n  l->v = 10;\n  next->v = 0;\n  a[get_v(l)] = 0;\n}\n\n// [l->next->prev->next->prev->v] is abstracted in [l->next->prev.*.v].\nint get_v2(struct List* l) { return l->next->prev->next->prev->v; }\n\nint call_get_v2_Good_FP() {\n  int a[10];\n  struct List* l = (struct List*)malloc(sizeof(struct List));\n  struct List* next = (struct List*)malloc(sizeof(struct List));\n  l->next = next;\n  next->prev = l;\n  l->v = 0;\n  next->v = 10;\n  a[get_v2(l)] = 0;\n}\n\nint call_get_v2_Bad() {\n  int a[10];\n  struct List* l = (struct List*)malloc(sizeof(struct List));\n  struct List* next = (struct List*)malloc(sizeof(struct List));\n  l->next = next;\n  next->prev = l;\n  l->v = 10;\n  next->v = 0;\n  a[get_v2(l)] = 0;\n}\n\nstruct t1 {\n  struct t1* a;\n  struct t1* b;\n  struct t1* c;\n  struct t1* d;\n  struct t1* e;\n  struct t1* f;\n  struct t1* g;\n  struct t1* h;\n  struct t1* i;\n  struct t1* j;\n};\n\nint unknown;\n\n// The analysis should be terminated within a reasonable amount of time.\nvoid make_many_locations(struct t1* x) {\n  while (1) {\n    switch (unknown) {\n      case 0:\n        x = x->a;\n        break;\n      case 1:\n        x = x->b;\n        break;\n      case 2:\n        x = x->c;\n        break;\n      case 3:\n        x = x->d;\n        break;\n      case 4:\n        x = x->e;\n        break;\n      case 5:\n        x = x->f;\n        break;\n      case 6:\n        x = x->g;\n        break;\n      case 7:\n        x = x->h;\n        break;\n      case 8:\n        x = x->i;\n        break;\n      default:\n        x = x->j;\n        break;\n    }\n  }\n}\n"
    },
    {
      "testname": "get_field_wrapper.c",
      "testlanguage": "c",
      "expected-problems": 1,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"my_typedef.h\"\n\nint get_field_wrapper(t* x) { return get_field(x); }\n"
    },
    {
      "testname": "global.c",
      "testlanguage": "c",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nint global;\n\nvoid compare_global_variable_bad() {\n  char arr[10];\n  if (global < 10)\n    arr[10] = 1;\n}\n\nconst int global_const_zero = 0;\n\nenum { global_const = global_const_zero };\n\nvoid compare_global_const_enum_Bad() {\n  char arr[10];\n  if (global_const < 10)\n    arr[10] = 1;\n}\n\nvoid compare_global_const_enum_Good_FP() {\n  char arr[10];\n  if (global_const > 10)\n    arr[10] = 1;\n}\n\nconst int global_const_ten = 10;\n\nvoid use_global_const_ten_Good() {\n  char arr[20];\n  arr[global_const_ten] = 0;\n}\n\nvoid use_global_const_ten_Bad() {\n  char arr[5];\n  arr[global_const_ten] = 0;\n}\n\nstatic const char global_arr[] = {1, 0, 1};\n\nstatic void copyfilter_Good_FP(const char* s, const char* z, int b) {\n  int i;\n  int n = strlen(s);\n  for (i = 0; z[i]; i++) { // We need to infer that z[i] means i < strlen(z)\n    if (global_arr[z[i]] || // We need a weak update here\n        (z[i] == s[0] && (n == 1 || memcmp(z, s, n) == 0))) {\n      i = 0;\n      break;\n    }\n  }\n}\n\nstatic const char* global_string_array[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n\n#define ISSUE949_SIZE 50\n\nint issue949_arr[ISSUE949_SIZE];\n\nvoid issue949_bad_FN() {\n  for (int i = 0; i <= ISSUE949_SIZE; i++) {\n    issue949_arr[i] = 1;\n  }\n}\n"
    },
    {
      "testname": "goto_loop.c",
      "testlanguage": "c",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid goto_loop() {\n  int i = 0;\n  char a[10];\n\nloop_start:\n  if (i >= 10)\n    goto loop_end;\n  a[i] = 'a'; /* SAFE */\n  i++;\n  goto loop_start;\nloop_end:\n  a[i] = 'a'; /* BUG */\n}\n\nvoid goto_infinite_loop() {\n  int i = 0;\nL1:\n  i++;\n  if (i >= 0) { // Always true\n    goto L2;\n  } else {\n    goto L2;\n  }\nL2:\n  i++;\n  if (i >= 0) { // Always true\n    goto L1;\n  } else {\n    goto L1;\n  }\n  // Exit node not reachable\n}\n"
    },
    {
      "testname": "inf_loop.c",
      "testlanguage": "c",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid inf_loop() {\n  int i = 0;\n  char a[10];\n\n  while (1) {\n    if (i >= 10)\n      i = 0;\n    a[i] = 'a'; /* SAFE */\n    i++;\n  }\n}\n"
    },
    {
      "testname": "issue_kinds.c",
      "testlanguage": "c",
      "expected-problems": 127,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nint zero_or_ten(int ten) {\n  if (ten) {\n    return 10;\n  } else {\n    return 0;\n  }\n}\n\nint zero_to_infty() {\n  int r = 0;\n  for (int i = 0; i < zero_or_ten(0); i++) {\n    r++;\n  }\n  return r;\n}\n\nvoid l1_concrete_overrun_Bad() {\n  int a[10];\n  a[10] = 0;\n}\n\nvoid l1_concrete_underrun_Bad() {\n  int a[10];\n  a[-1] = 0;\n}\n\nvoid l1_symbolic_overrun_Bad(int i) {\n  int a[10];\n  if (i >= 10) {\n    a[i] = 0;\n  }\n}\n\nvoid l1_symbolic_overrun2_Bad(int n) {\n  int a[n];\n  a[n] = 0;\n}\n\nvoid l1_symbolic_underrun_Bad(int i) {\n  int a[10];\n  if (i < 0) {\n    a[i] = 0;\n  }\n}\n\nint less_than(int i, int n) { return i < n; }\n\nvoid l1_symbolic_widened_Bad(int n) {\n  int a[n];\n  for (int i = n; less_than(i, 2 * n); i++) {\n    a[i] = 0;\n  }\n}\n\nvoid l1_symbolic_widened_Good(int n) {\n  int a[n];\n  for (int i = n; less_than(i, n); i++) {\n    a[i] = 0;\n  }\n}\n\nvoid l2_concrete_overrun_Bad() {\n  int a[10];\n  a[zero_or_ten(1)] = 0;\n}\n\nvoid l2_concrete_underrun_Bad() {\n  int a[9];\n  a[zero_or_ten(0) - 1] = 0;\n}\n\nvoid l2_concrete_no_overrun_Good_FP() {\n  int a[10];\n  a[zero_or_ten(0)] = 0;\n}\n\nvoid l2_concrete_no_underrun_Good_FP() {\n  int a[9];\n  a[zero_or_ten(1) - 1] = 0;\n}\n\nvoid l2_symbolic_overrun_Bad(int* n) {\n  int a[*n];\n  a[*n] = 0;\n}\n\nvoid l2_symbolic_no_overrun_Good(int n) {\n  int a[n];\n  if (n > 0) {\n    a[n - 1] = 0;\n  }\n}\n\nvoid l3_concrete_overrun_Bad() {\n  int a[zero_or_ten(0) + 5];\n  a[zero_or_ten(1)] = 0;\n}\n\nvoid l3_concrete_underrun_Bad() {\n  int a[10];\n  a[zero_or_ten(0) - 1] = 0;\n}\n\nvoid l3_concrete_no_overrun_Good_FP() {\n  int a[zero_or_ten(1) + 5];\n  a[zero_or_ten(1)] = 0;\n}\n\nvoid l3_concrete_no_underrun_Good_FP() {\n  int a[10];\n  a[zero_or_ten(1) - 1] = 0;\n}\n\nvoid l4_widened_overrun_Bad() {\n  int a[10];\n  for (int i = 0; less_than(i, 11); i++) {\n    a[i] = 0;\n  }\n}\n\nvoid l4_widened_no_overrun_Good_FP() {\n  int a[10];\n  for (int i = 0; less_than(i, 10); i++) {\n    a[i] = 0;\n  }\n}\n\nint unknown_function();\n\nvoid l5_external_Warn_Bad() {\n  int a[10];\n  a[unknown_function()] = 0;\n}\n\nvoid s2_symbolic_widened_Bad(int* n) {\n  int a[*n];\n  for (int i = *n; less_than(i, 2 * *n); i++) {\n    a[i] = 0;\n  }\n}\n\nvoid s2_symbolic_widened_Good_FP(int* n) {\n  int a[*n];\n  for (int i = *n; less_than(i, *n); i++) {\n    a[i] = 0;\n  }\n}\n\n// Do not report as it was already reported in the callee with the same issue\n// type\nvoid FP_call_s2_symbolic_widened_Silenced(int* m) {\n  s2_symbolic_widened_Bad(m);\n}\n\nvoid l1_call_to_s2_symbolic_widened_Bad() {\n  int x = 1;\n  s2_symbolic_widened_Bad(&x);\n}\n\nvoid may_underrun_symbolic_Nowarn_Good(int n) {\n  int a[n];\n  a[n - 1] = 0;\n}\n\nvoid may_over_or_underrun_symbolic_Nowarn_Good(int n) {\n  int a[10];\n  a[n] = 0;\n}\n\nvoid may_over_or_underrun_symbolic2_Nowarn_Good(int n) {\n  int a[n];\n  a[1] = 0;\n}\n\nvoid alloc_is_negative_Bad() { malloc(-2); }\n\nvoid alloc_may_be_negative_Bad() { malloc(zero_or_ten(0) - 5); }\n\nvoid alloc_may_be_negative_Good_FP() { malloc(zero_or_ten(1) - 5); }\n\nvoid alloc_is_zero_Bad() { malloc(0 * sizeof(int)); }\n\nvoid alloc_is_big_Bad() { malloc(2 * 1000 * 1000 * 1000); }\n\nvoid alloc_may_be_big_Bad() { malloc(zero_or_ten(1) * 100 * 1000 * 1000 + 1); }\n\n// Non-symbolic, should not be propagated\nvoid call_to_alloc_may_be_big_Good() { alloc_may_be_big_Bad(); }\n\nvoid alloc_may_be_big_Good_FP() {\n  malloc(zero_or_ten(1) * 100 * 1000 * 1000 + 1);\n}\n\n/*\n  When the upper bound is infinity and the lower bound unknown,\n  we don't report but still propagate the error.\n*/\nvoid alloc_may_be_big2_Silenced(int n) { malloc(n + zero_to_infty()); }\n\n// Now that we have a lower bound, we can report it\nvoid call_to_alloc_may_be_big2_is_big_Bad() {\n  alloc_may_be_big2_Silenced(100 * 1000 * 1000);\n}\n\nvoid l1_unknown_function_Bad() {\n  int a[5];\n  int idx = unknown_function() * 10;\n  if (10 <= idx) {\n    if (idx <= 10) {\n      a[idx] = 0;\n    }\n  }\n}\n\n/*\n  We do not report the underrun here, in case the loop never runs (length <= 0).\n  But we should report it anyway.\n*/\nvoid loop_underrun_Bad_FN(int length) {\n  int i;\n  char a[length];\n\n  for (i = length - 1; i >= 0; i--) {\n    a[i - 1] = 'U';\n  }\n}\n\nvoid l2_loop_overflow_Bad(int length) {\n  int i;\n  char a[length];\n\n  for (i = length - 1; i >= 0; i--) {\n    a[i + 1] = 'O';\n  }\n}\n\nvoid l2_loop_overflow2_Bad(int length) {\n  int i;\n  char a[length];\n\n  for (i = length - 1; i >= 0; i--) {\n    a[length - i] = 'O';\n  }\n}\n\n/* Inferbo raises U5 alarm because\n   - the pair of offset:[10,10] and size:[5,+oo] is belong to L3\n   - the offset value is from an unknown function\n   - there is at least one infinity bound (in size).\n   However, it should ideally raise L3, because the infinity is not\n   from the unknown function. */\nvoid False_Issue_Type_l3_unknown_function_Bad() {\n  int* a = (int*)malloc((zero_to_infty() + 5) * sizeof(int));\n  int idx = unknown_function() * 10;\n  if (10 <= idx) {\n    if (idx <= 10) {\n      a[idx] = 0;\n    }\n  }\n}\n\nint mone_to_one() {\n  int x = unknown_function();\n  if (x >= -1 && x <= 1) {\n    return x;\n  } else {\n    return 0;\n  }\n}\n\nvoid two_safety_conditions(int n) {\n  char a[10];\n  int y = mone_to_one();\n  if (unknown_function()) {\n    a[n] = 0; // should be L1 when n=10\n  } else {\n    a[n + y] = 0; // should be L2 when n=10\n  }\n}\n\nvoid call_two_safety_conditions_l1_and_l2_Bad() { two_safety_conditions(10); }\n\n/* issue1 and issue2 are deduplicated since the offset of issue2\n   ([10,+oo]) subsumes that of issue1 ([10,10]). */\nvoid deduplicate_issues_1_Bad() {\n  int a[10];\n  int x = 10;\n  a[x] = 0; // issue1: [10,10] < [10,10]\n  x = unknown_function();\n  if (x >= 10) {\n    a[x] = 0; // issue2: [10,+oo] < [10,10]\n  }\n}\n\n/* issue1 and issue2 are not deduplicated since they have different\n   conditions to reach. */\nvoid deduplicate_issues_2_Bad(int y) {\n  int a[10];\n  int x = 10;\n  a[x] = 0; // issue1: [10,10] < [10,10]\n  x = unknown_function();\n  if (x >= 10 && y >= 0) {\n    a[x] = 0; // issue2: [10,+oo] < [10,10]\n  }\n}\n"
    },
    {
      "testname": "minmax.c",
      "testlanguage": "c",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nint exact_min_minus_min_linear_CAF(int x) {\n  int size1[1];\n  int y = 28;\n  if (x < 5)\n    y = x + 10;\n  // y = [10 + min(18, x), 28]\n  if (y > 28) {\n    size1[-1] = 0;\n  }\n  return y;\n}\n\nint underapprox_min_minus_min_linear_CAF(int x) {\n  int size1[1];\n  int y = 10;\n  if (x < 5)\n    y = x + 20;\n  // y = [20 + min(-10, x), 24]\n  if (y > 24) {\n    size1[-1] = 0;\n  }\n  return y;\n}\n\nvoid exact_min_plus_min_plus_min_UNDERRUN(int x, int b) {\n  int size1[1];\n  int y = exact_min_minus_min_linear_CAF(x);\n  if (b)\n    y = underapprox_min_minus_min_linear_CAF(x);\n  y -= 29;\n  // [-19 + min(0, x), -1]\n  size1[y] = 0;\n}\n\nint random();\n\nint exact_minmax_sym(int x) {\n  if (random()) {\n    if (x > 1) {\n      x = 1;\n    } // [min(1, x), 1]\n    x = x + 1; // [1 + min(1, x), 2]\n  } // [min(2, x), max(2, x)]\n  return x;\n}\n\nvoid call_exact_minmax_sym_Good() {\n  int x = 5;\n  int a[x];\n  a[exact_minmax_sym(x) - 1] = 0;\n}\n\nvoid call_exact_minmax_sym_Bad() {\n  int x = 5;\n  int a[x];\n  a[exact_minmax_sym(x)] = 0;\n}\n"
    },
    {
      "testname": "models.c",
      "testlanguage": "c",
      "expected-problems": 232,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid exit_bo_good_unreachable_bad() {\n  int arr[1];\n  exit(1);\n  // unreachable so no buffer overrun\n  arr[42] = 42;\n}\n\nvoid fgetc_m1_bad(FILE* f) {\n  int arr[10000];\n  int c = fgetc(f);\n  arr[c] = 42;\n}\n\nvoid fgetc_255_bad(FILE* f) {\n  int arr[255];\n  int c = fgetc(f);\n  if (c >= 0) {\n    arr[c] = 42;\n  }\n}\n\nvoid fgetc_256_good(FILE* f) {\n  int arr[256];\n  int c = fgetc(f);\n  if (c >= 0) {\n    arr[c] = 42;\n  }\n}\n\nvoid fgetc_256_bad(FILE* f) {\n  int arr[256];\n  int c = fgetc(f);\n  arr[c + 1] = 42;\n}\n\nvoid fgetc_257_good(FILE* f) {\n  int arr[257];\n  int c = fgetc(f);\n  arr[c + 1] = 42;\n}\n\nvoid memcpy_bad1() {\n  int arr1[10];\n  int arr2[20];\n  memcpy(arr1, arr2, 44);\n}\n\nvoid memcpy_bad2() {\n  int arr1[10];\n  int arr2[20];\n  memcpy(arr2, arr1, 44);\n}\n\nvoid memcpy_bad3() {\n  int arr1[10];\n  int arr2[20];\n  memcpy(arr1, arr2, -1);\n}\n\nvoid memcpy_bad4() {\n  int src[1];\n  int buff[1];\n  int* dst = &buff[0];\n  memcpy(dst, src, sizeof(dst));\n}\n\nvoid memcpy_good1() {\n  int arr1[10];\n  int arr2[20];\n  memcpy(arr2, arr1, 40);\n}\n\nvoid memcpy_good2() {\n  int arr1[10];\n  int arr2[20];\n  memcpy(arr2, arr1, 0);\n}\n\nvoid memcpy_good3() {\n  int arr1[10];\n  int arr2[20];\n  memcpy(arr2, arr1, 20);\n}\n\nvoid memcpy_good4() {\n  int src[3];\n  int dst[3];\n  memcpy(dst, src, sizeof(dst));\n}\n\nvoid memcpy_len_Good(size_t len) {\n  char dst[len];\n  char src[len];\n  memcpy(dst, src, len);\n}\n\nvoid call_memcpy_len1_Good() { memcpy_len_Good(40); }\n\nextern size_t unknown_uint();\n\nvoid call_memcpy_len2_Good() {\n  size_t x = unknown();\n  memcpy_len_Good(x);\n}\n\nvoid memmove_bad1() {\n  int arr1[10];\n  int arr2[20];\n  memmove(arr1, arr2, 44);\n}\n\nvoid memmove_bad2() {\n  int arr1[10];\n  int arr2[20];\n  memmove(arr2, arr1, 44);\n}\n\nvoid memmove_bad3() {\n  int arr1[10];\n  int arr2[20];\n  memmove(arr1, arr2, -1);\n}\n\nvoid memmove_bad4() {\n  int src[1];\n  int buff[1];\n  int* dst = &buff[0];\n  memmove(dst, src, sizeof(dst));\n}\n\nvoid memmove_good1() {\n  int arr1[10];\n  int arr2[20];\n  memmove(arr2, arr1, 40);\n}\n\nvoid memmove_good2() {\n  int arr1[10];\n  int arr2[20];\n  memmove(arr2, arr1, 0);\n}\n\nvoid memmove_good3() {\n  int arr1[10];\n  int arr2[20];\n  memmove(arr2, arr1, 20);\n}\n\nvoid memmove_good4() {\n  int src[3];\n  int dst[3];\n  memmove(dst, src, sizeof(dst));\n}\n\nvoid memset_bad1() {\n  int arr[10];\n  memset(arr, 0, 44);\n}\n\nvoid memset_bad2() {\n  int arr[10];\n  memset(arr, 0, -1);\n}\n\nvoid memset_bad3() {\n  int arr[1];\n  int* dst = &arr[0];\n  memset(dst, 0, sizeof(dst));\n}\n\nvoid memset_good1() {\n  int arr[10];\n  memset(arr, 0, 40);\n}\n\nvoid memset_good2() {\n  int arr[10];\n  memset(arr, 0, 0);\n}\n\nvoid memset_good3() {\n  int arr[10];\n  memset(arr, 0, 20);\n}\n\nvoid memset_good4() {\n  int arr[10];\n  memset(arr, 0, sizeof(arr));\n}\n\nvoid strncpy_bad1() {\n  int arr1[10];\n  int arr2[20];\n  strncpy(arr1, arr2, 44);\n}\n\nvoid strncpy_bad2() {\n  int arr1[10];\n  int arr2[20];\n  strncpy(arr2, arr1, 44);\n}\n\nvoid strncpy_bad3() {\n  int arr1[10];\n  int arr2[20];\n  strncpy(arr1, arr2, -1);\n}\n\nvoid strncpy_bad4() {\n  int src[1];\n  int buff[1];\n  int* dst = &buff[0];\n  strncpy(dst, src, sizeof(dst));\n}\n\nvoid strncpy_good1() {\n  int arr1[10];\n  int arr2[20];\n  strncpy(arr2, arr1, 40);\n}\n\nvoid strncpy_good2() {\n  int arr1[10];\n  int arr2[20];\n  strncpy(arr2, arr1, 0);\n}\n\nvoid strncpy_good3() {\n  int arr1[10];\n  int arr2[20];\n  strncpy(arr2, arr1, 20);\n}\n\nvoid strncpy_good4() {\n  int src[3];\n  int dst[3];\n  strncpy(dst, src, sizeof(dst));\n}\n\nvoid strncpy_good5_FP() {\n  char src[5] = \"test\";\n  char dst[5];\n  strncpy(dst, src, 10);\n}\n\nvoid memcpy_contents_Good() {\n  int src[3] = {5, 5, 5};\n  int dst[3];\n  memcpy(dst, src, sizeof(dst));\n  int a[6];\n  a[dst[0]] = 0;\n}\n\nvoid memcpy_contents_Bad() {\n  int src[3] = {5, 5, 5};\n  int dst[3];\n  memcpy(dst, src, sizeof(dst));\n  int a[5];\n  a[dst[0]] = 0;\n}\n\nvoid memcpy_integer_Good() {\n  int src = 5;\n  int dst;\n  memcpy(&dst, &src, sizeof(int));\n  int a[10];\n  a[dst] = 0;\n}\n\nvoid memcpy_integer_Bad() {\n  int src = 5;\n  int dst;\n  memcpy(&dst, &src, sizeof(int));\n  int a[5];\n  a[dst] = 0;\n}\n\nvoid strncpy_contents_Good() {\n  char src[5] = \"test\";\n  char dst[10];\n  strncpy(dst, src, 5);\n  int a[5];\n  a[strlen(dst)] = 0;\n}\n\nvoid strncpy_contents_Bad() {\n  char src[5] = \"test\";\n  char dst[10];\n  strncpy(dst, src, 5);\n  int a[4];\n  a[strlen(dst)] = 0;\n}\n\nvoid strncpy_no_null_1_Bad_FN() {\n  char src[5] = \"test\";\n  src[4] = 'a';\n  char dst[10];\n  strncpy(dst, src, 5); // [dst] may not have null character.\n  int a[10];\n  a[strlen(dst)] = 0;\n}\n\nvoid strncpy_no_null_2_Bad() {\n  char src[5] = \"test\";\n  src[4] = 'a';\n  char dst[10];\n  strncpy(dst, src, 5); // [dst] may not have null character.\n  int a[5];\n  a[strlen(dst)] = 0;\n}\n\nvoid strncpy_no_null_3_Bad_FN() {\n  char src[15] = \"test.test.test\";\n  char dst[10];\n  strncpy(dst, src, 10); // [dst] does not have null character.\n  int a[20];\n  a[strlen(dst)] = 0;\n}\n\nvoid strncpy_no_null_4_Bad() {\n  char src[15] = \"test.test.test\";\n  char dst[10];\n  strncpy(dst, src, 10); // [dst] does not have null character.\n  int a[10];\n  a[strlen(dst)] = 0;\n}\n\nvoid strndup_1_Good() {\n  char s1[] = \"Hello Infer!\";\n  int len = strlen(s1);\n  char* s2 = strndup(s1, len);\n  for (int i = 0; i < len; i++) {\n    s2[i] = 'a';\n  }\n}\n\nvoid strndup_1_Bad() {\n  char s1[] = \"Hello Infer!\";\n  int len = 100;\n  char* s2 = strndup(s1, len);\n  for (int i = 0; i < len; i++) {\n    s2[i] = 'a';\n  }\n}\n\nvoid strndup_2_Good() {\n  char s1[] = \"Hello Infer!\";\n  int len = strlen(s1);\n  s1[5] = '\\0';\n  char* s2 = strndup(s1, len);\n  for (int i = 0; i < strlen(s2); i++) {\n    s2[i] = 'a';\n  }\n}\n\nvoid strndup_2_Bad() {\n  char s1[] = \"Hello Infer!\";\n  int len = strlen(s1);\n  s1[5] = '\\0';\n  char* s2 = strndup(s1, len);\n  for (int i = 0; i < len; i++) {\n    s2[i] = 'a';\n  }\n}\n\nvoid strndup_3_Good() {\n  int size = unknown();\n  if (size >= 10) {\n    char* s1 = (char*)malloc(sizeof(char) * size);\n    s1[5] = '\\0';\n    char* s2 = strndup(s1, size - 1);\n    for (int i = 0; i < strlen(s2); i++) {\n      s2[i] = 'a';\n    }\n  }\n}\n\nvoid strndup_3_Bad() {\n  int size = unknown();\n  if (size >= 10) {\n    char* s1 = (char*)malloc(sizeof(char) * size);\n    s1[5] = '\\0';\n    char* s2 = strndup(s1, size - 1);\n    for (int i = 0; i < size - 1; i++) {\n      s2[i] = 'a';\n    }\n  }\n}\n\nvoid strcpy_Good() {\n  char src[5] = \"test\";\n  char dst[10];\n  strcpy(dst, src);\n}\n\nvoid strcpy_Bad() {\n  char src[5] = \"test\";\n  char dst[4];\n  strcpy(dst, src);\n}\n\nvoid strcpy_literal_string_Good() {\n  char dst[10];\n  strcpy(dst, \"test\");\n}\n\nvoid strcpy_literal_string_Bad() {\n  char dst[4];\n  strcpy(dst, \"test\");\n}\n\nvoid strcpy_strlen_Good() {\n  char src[5] = \"test\";\n  char dst[10];\n  strcpy(dst, src);\n  int a[5];\n  a[strlen(dst)] = 0;\n}\n\nvoid strcpy_strlen_Bad() {\n  char src[5] = \"test\";\n  char dst[10];\n  strcpy(dst, src);\n  int a[4];\n  a[strlen(dst)] = 0;\n}\n\nvoid strcpy_contents_Good() {\n  char src[5] = \"aaaa\";\n  char dst[5];\n  strcpy(dst, src);\n  char c = dst[0];\n  if (c >= 'a') {\n    int a[5];\n    a[c - 'a' + 4] = 0;\n  }\n}\n\nvoid strcpy_contents_Bad() {\n  char src[5] = \"aaaa\";\n  char dst[5];\n  strcpy(dst, src);\n  char c = dst[0];\n  if (c >= 'a') {\n    int a[5];\n    a[c - 'a' + 5] = 0;\n  }\n}\n\nvoid strcpy_no_null_Bad() {\n  char src[5] = \"test\";\n  src[4] = 'a';\n  char dst[10];\n  strcpy(dst, src);\n}\n\nvoid strcat_Good() {\n  char str[8];\n  strcpy(str, \"abc\");\n  strcat(str, \"defg\");\n}\n\nvoid strcat_Bad() {\n  char str[8];\n  strcpy(str, \"abc\");\n  strcat(str, \"defgh\");\n}\n\nvoid strcat_strlen_Good() {\n  char str[8];\n  strcpy(str, \"abc\");\n  strcat(str, \"defg\");\n  int a[8];\n  a[strlen(str)] = 0;\n}\n\nvoid strcat_strlen_Bad() {\n  char str[20];\n  strcpy(str, \"abc\");\n  strcat(str, \"defgh\");\n  int a[8];\n  a[strlen(str)] = 0;\n}\n"
    },
    {
      "testname": "nested_loop.c",
      "testlanguage": "c",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid nested_loop() {\n  int i, j;\n  char a[10];\n\n  for (i = 0; i < 10; i++) {\n    a[i] = 'a'; /* SAFE */\n    for (j = 0; j <= 10; j++) {\n      a[j] = 'a'; /* BUG */\n    }\n  }\n}\n\nvoid nested_loop2_Ok() {\n  double arr[10];\n\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 5; j < 15; j++) {\n      arr[i] = 0.0;\n      arr[j - 5] = 0.0;\n    }\n  }\n}\n\nvoid nested_loop3_Bad() {\n  double arr[10];\n\n  int i, j;\n  for (i = 0; i <= 10; i++) {\n    for (j = 5; j < 15; j++) {\n      arr[i] = 0.0;\n    }\n  }\n}\n\nvoid nested_loop4_Bad() {\n  double arr[10];\n\n  int i, j;\n  for (i = 0; i < 10; i++) {\n    for (j = 5; j <= 15; j++) {\n      arr[j - 5] = 0.0;\n    }\n  }\n}\n\nvoid nested_loop_narrowing_Good() {\n  int i = 0;\n  int a[10];\n\n  while (1) {\n    while (1) {\n      a[i] = 0;\n      for (i = 0; i < 5; i++) {\n      }\n    }\n  }\n}\n\nvoid nested_loop_narrowing_Bad() {\n  int i = 0;\n  int a[10];\n\n  while (1) {\n    while (1) {\n      a[i] = 0;\n      for (i = 0; i < 10; i++) {\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "nested_loop_with_label.c",
      "testlanguage": "c",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid nested_loop_with_label() {\n  int i, j = 0;\n  char a[10];\n\n  for (i = 0; i < 10; i++) {\n  outer_loop:\n    a[j] = 'a'; /* BUG */\n    for (j = 0; j <= 10; j++) { // Loop condition always true\n      if (j >= 10)\n        goto outer_loop;\n    }\n  }\n}\n"
    },
    {
      "testname": "pointer_arith.c",
      "testlanguage": "c",
      "expected-problems": 31,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid pointer_arith_bad() {\n  char arr[10];\n  int x = 0;\n  if (&x - 1 == 0)\n    arr[10] = 1;\n}\n\nvoid array_pointer_arith_Bad() {\n  int arr[10];\n  int* p = &arr[5];\n  p[5] = 1;\n}\n\nvoid pointer_arith2_Ok(int x) {\n  int len = 5;\n  char p[5];\n  (p + x)[3 - x] = 0;\n}\n\nvoid call_pointer_arith2_Ok() { pointer_arith2_Ok(100); }\n\nvoid pointer_arith3(char* p, int x) {\n  int len = 5;\n  (p + x)[10 - x] = 0;\n}\n\nvoid call_pointer_arith3_Bad() {\n  char p[5];\n  pointer_arith3(p, 100);\n}\n\nvoid pointer_arith4_Bad(int x) {\n  int len = 5;\n  char p[5];\n  (p + x)[10 - x] = 0;\n}\n\n/* It is better to raise an alarm here, rather than returning a safety\n   condition, since the buffer overrun occurs always without regard to\n   the input x.  Using symbols for variables, not only for bounds,\n   would help in this case. */\nvoid FN_pointer_arith4_Bad(int* x) {\n  int len = 5;\n  char p[5];\n  (p + *x)[10 - *x] = 0;\n}\n\nvoid call_pointer_arith4_Bad() {\n  int x = 100;\n  FN_pointer_arith4_Bad(&x);\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid FP_pointer_arith5_Ok() {\n  char buf[1024];\n  fgets(buf, 1024, stdin);\n  size_t len = strlen(buf);\n  if (len < sizeof(buf) - 3) {\n    (buf + len)[sizeof(buf) - len - 1] = '\\0';\n  }\n}\n\nvoid pointer_arith5_Bad() {\n  char buf[1024];\n  fgets(buf, 1024, stdin);\n  size_t len = strlen(buf);\n  if (len < sizeof(buf) - 3) {\n    (buf + len)[sizeof(buf) - len] = '\\0';\n  }\n}\n"
    },
    {
      "testname": "prune_alias.c",
      "testlanguage": "c",
      "expected-problems": 150,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvoid prune_alias_le_Ok(int x) {\n  int a[1];\n\n  if (x <= x) {\n    a[0] = 0;\n  } else {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_ge_Ok(int x) {\n  int a[1];\n\n  if (x >= x) {\n    a[0] = 0;\n  } else {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_eq_Ok(int x) {\n  int a[1];\n\n  if (x == x) {\n    a[0] = 0;\n  } else {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_lt_Ok(int x) {\n  int a[1];\n\n  if (x < x) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_gt_Ok(int x) {\n  int a[1];\n\n  if (x > x) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_ne_Ok(int x) {\n  int a[1];\n\n  if (x != x) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_not_Ok(int x) {\n  int a[1];\n\n  if (!(x == x)) {\n    a[1] = 0;\n  }\n\n  if (!(x <= x)) {\n    a[1] = 0;\n  }\n\n  if (!(x >= x)) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_and_Ok(int x) {\n  int a[1];\n\n  if (x == x && x != x) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_or_Ok(int x, int y) {\n  int a[1];\n\n  if (x != x || y != y) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_exp_Ok(int x) {\n  int a[1];\n\n  if (x + 1 != x + 1) {\n    a[1] = 0;\n  }\n}\n\nvoid prune_alias_exp2_CAF(int x) {\n  int a[1];\n\n  if (x + 1 != 1 + x) { // Condition always false\n    a[1] = 0;\n  }\n}\n\nvoid FP_prune_alias_exp_Ok(int* x) {\n  int a[1];\n\n  if (*x + 1 != 1 + *x) {\n    a[1] = 0;\n  }\n}\n\n#include <stdlib.h>\n\nvoid prune_arrblk_ne_CAT(int* x) {\n  int* y = x + 10;\n\n  if (x != y) { // always true\n    x[5] = 1;\n  }\n}\n\nvoid call_prune_arrblk_ne_Ok() {\n  int* x = (int*)malloc(sizeof(int) * 10);\n  prune_arrblk_ne_CAT(x);\n}\n\nvoid call_prune_arrblk_ne_Bad() {\n  int* x = (int*)malloc(sizeof(int) * 5);\n  prune_arrblk_ne_CAT(x);\n}\n\nvoid prune_arrblk_eq_CAF(int* x) {\n  int* y = x + 10;\n\n  if (x == y) { // always false\n    x[5] = 1; /* unreachable */\n  }\n}\n\nvoid call_prune_arrblk_eq_Ok() {\n  int* x = (int*)malloc(sizeof(int) * 5);\n  prune_arrblk_eq_CAF(x);\n}\n\nvoid prune_minmax1_Ok(unsigned int x, unsigned int y) {\n  if (x > 0) {\n    if (y >= x + 1) {\n      unsigned int z = y - 1;\n    }\n  }\n}\n\nvoid call_prune_minmax1_Ok() { prune_minmax1_Ok(0, 0); }\n\nvoid prune_minmax2_Ok(unsigned int x, unsigned int y) {\n  if (x > y) {\n    unsigned int z = x - y;\n  }\n}\n\nvoid call_prune_minmax2_Ok() { prune_minmax2_Ok(0, 2); }\n\nvoid loop_prune_Good(int length, int j) {\n  int i;\n  char a[length];\n\n  for (i = length - 1; i >= 0; i--) {\n    if (j >= 0 && j < i) {\n      /* here we always have i >= 1 */\n      a[length - i] = 'Z';\n    }\n  }\n}\n\nvoid loop_prune2_Good_FP(int length, int j) {\n  int i;\n  char a[length];\n\n  for (i = length - 1; i >= 0; i--) {\n    /* need a relational domain */\n    if (j < i && j >= 0) {\n      /* here we always have i >= 1 */\n      a[length - i] = 'Z';\n    }\n  }\n}\n\nvoid nested_loop_prune_Good(int length) {\n  int i, j;\n  char a[length];\n\n  for (i = length - 1; i >= 0; i--) {\n    for (j = 0; j < i; j++) {\n      /* here we always have i >= 1 */\n      a[length - i] = 'Z';\n    }\n  }\n}\n\nvoid bad_if_alias(int* x, int* y) {\n  char a[1];\n  if (x == y) {\n    a[1] = 'A';\n  }\n}\n\nvoid call_bad_if_alias_Bad_AlreadyReported() {\n  int x;\n  bad_if_alias(x, x);\n}\n\nvoid call_bad_if_alias_Good() {\n  int x, y;\n  bad_if_alias(x, y);\n}\n\nvoid bad_if_not_alias(int* x, int* y) {\n  char a[1];\n  if (x != y) {\n    a[1] = 'B';\n  }\n}\n\nvoid call_bad_if_not_alias_Good() {\n  int x;\n  bad_if_not_alias(x, x);\n}\n\nvoid call_bad_if_not_alias_Bad_AlreadyReported() {\n  int x, y;\n  bad_if_not_alias(x, y);\n}\n\nint unknown_function();\n\nvoid latest_prune_join(int* a, int n) {\n  int x;\n  if (unknown_function()) {\n    if (n < 4) {\n      x = 1;\n    } else {\n      x = 0;\n    }\n  } else {\n    if (n < 5) {\n      x = 1;\n    } else {\n      return;\n    }\n  }\n  if (x) {\n    a[n] = 0;\n  }\n}\n\nvoid call_latest_prune_join_1_Good() {\n  int a[5];\n  latest_prune_join(a, 3);\n}\n\nvoid call_latest_prune_join_2_Good() {\n  int a[5];\n  latest_prune_join(a, 10);\n}\n\nvoid call_latest_prune_join_3_Bad() {\n  int a[2];\n  latest_prune_join(a, 3);\n}\n\nvoid forget_locs_latest_prune(unsigned int n) {\n  int x;\n  int* a[5];\n  if (n < 5) {\n    x = 1;\n  } else {\n    x = 0;\n    x = 2;\n  }\n  if (x) {\n    a[n] = 0;\n  }\n}\n\nvoid call_forget_locs_latest_prune_Bad() { forget_locs_latest_prune(10); }\n\nvoid not_prune_multiple1_Bad() {\n  int a[5];\n  int m[2] = {0, 10};\n  if (m[0] < 5) {\n    a[m[1]] = 0;\n  }\n}\n\nvoid not_prune_multiple2(int* m) {\n  int a[5];\n  if (m[0] < 5) {\n    a[m[1]] = 0;\n  }\n}\n\nvoid call_not_prune_multiple2_Good() {\n  int m[2] = {0, 4};\n  not_prune_multiple2(m);\n}\n\nvoid call_not_prune_multiple2_Bad_FN() {\n  int m[2] = {0, 10};\n  not_prune_multiple2(m);\n}\n\nvoid not_prune_multiple3_Bad() {\n  int a[5];\n  int* m = (int*)malloc(sizeof(int) * 2);\n  m[0] = 0;\n  m[1] = 10;\n  if (*m < 5) {\n    m++;\n    a[*m] = 0;\n  }\n}\n\nvoid not_prune_multiple4(int* m) {\n  int a[5];\n  if (*m < 5) {\n    m++;\n    a[*m] = 0;\n  }\n}\n\nvoid call_not_prune_multiple4_Good() {\n  int m[2] = {0, 4};\n  not_prune_multiple4(m);\n}\n\nvoid call_not_prune_multiple4_Bad_FN() {\n  int m[2] = {0, 10};\n  not_prune_multiple4(m);\n}\n\nint* unknown1();\nint* unknown2();\n\nvoid unknown_alias_Good() {\n  int* x = unknown1();\n  int* y = unknown2();\n\n  if (*x < *y) {\n    int a[10]; // Here should be reachable.\n    a[5] = 0;\n  }\n}\n\nvoid unknown_alias_Bad() {\n  int* x = unknown1();\n  int* y = unknown2();\n\n  if (*x < *y) {\n    int a[10]; // Here should be reachable.\n    a[10] = 0;\n  }\n}\n\nvoid prune_linear_by_minmax(size_t s, size_t t) {\n  if (s > 0 && s < 1000) {\n    if (t >= s + 1) {\n      size_t u = t - 2;\n    }\n  }\n}\n\nvoid call_prune_linear_by_minmax_Good() {\n  prune_linear_by_minmax(unknown_function(), unknown_function());\n}\n\nvoid prune_int_by_pointer_Bad(int* p) {\n  int* x = (int*)100;\n  if (x == p) {\n  }\n  int a[5];\n  a[5] = 0;\n}\n"
    },
    {
      "testname": "prune_constant.c",
      "testlanguage": "c",
      "expected-problems": 76,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvoid prune_constant_true_Ok() {\n  int a[1];\n\n  if (1) {\n    a[0] = 0;\n  } else {\n    a[1] = 0;\n  }\n}\n\nvoid prune_constant_false_Ok() {\n  int a[1];\n\n  if (0) {\n    a[1] = 0;\n  } else {\n    a[0] = 0;\n  }\n}\n\nvoid prune_constant_value_Ok(int x) {\n  int a[1];\n  if (-1 < x && x < 1) {\n    if (x) {\n      a[1] = 0;\n    } else {\n      a[0] = 0;\n    }\n  }\n}\n\nvoid prune_constant_not_Bad() {\n  int x = 0;\n  int a[1];\n  if (!x) {\n    a[x + 1] = 0;\n  }\n}\n\nint fromHex(char c) {\n  if (c < '0' || (c > '9' && (c < 'a' || c > 'f'))) {\n    return -1; // invalid not 0-9a-f hex char\n  }\n  if (c <= '9') {\n    return c - '0';\n  }\n  return c - 'a' + 10;\n}\n\nvoid call_fromHex_sym_Good(char c) {\n  char arr[16];\n  int idx = fromHex(c);\n  if (idx >= 0) {\n    arr[idx] = 'H';\n  }\n}\n\nvoid call_fromHex_200_Good() {\n  char arr[16];\n  int idx = fromHex(200);\n  if (idx >= 0) {\n    arr[idx] = 'H';\n  }\n}\n\nvoid call_fromHex2_sym_Good_FP(char c) {\n  char arr[17];\n  int idx = fromHex(c);\n  arr[idx + 1] = 'H';\n}\n\nvoid call_fromHex2_200_Good_FP() {\n  char arr[17];\n  int idx = fromHex(200);\n  arr[idx + 1] = 'H';\n}\n\nvoid prune_add1(unsigned int x) {\n  int a[10];\n  if (x + 1 < 11) {\n    a[x] = 0;\n  }\n}\n\nvoid call_prune_add1_1_Good() { prune_add1(5); }\n\nvoid call_prune_add1_2_Good() { prune_add1(10); }\n\nvoid prune_add2(unsigned int x) {\n  int a[10];\n  if (x + 1 < 12) {\n    a[x] = 0;\n  }\n}\n\nvoid call_prune_add2_1_Good() { prune_add2(5); }\n\nvoid call_prune_add2_2_Bad() { prune_add2(10); }\n\nvoid call_prune_add2_3_Good() { prune_add2(100); }\n\nvoid prune_sub1(unsigned int x) {\n  int a[10];\n  if (9 > x - 1) {\n    a[x] = 0;\n  }\n}\n\nvoid call_prune_sub1_1_Good() { prune_sub1(5); }\n\nvoid call_prune_sub1_2_Good() { prune_sub1(10); }\n\nvoid prune_sub2(unsigned int x) {\n  int a[10];\n  if (10 > x - 1) {\n    a[x] = 0;\n  }\n}\n\nvoid call_prune_sub2_1_Good() { prune_sub2(5); }\n\nvoid call_prune_sub2_2_Bad() { prune_sub2(10); }\n\nvoid call_prune_sub2_3_Good() { prune_sub2(100); }\n\nvoid null_pruning1_Good(int* p) {\n  if (p == 0) {\n    if (p != 0) {\n      int a[5];\n      a[10] = 1;\n    }\n  }\n}\n\nvoid null_pruning1_Bad(int* p) {\n  if (p == 0) {\n    if (p == 0) {\n      int a[5];\n      a[10] = 1;\n    }\n  }\n}\n\nvoid null_pruning2_Good_FP(int* p) {\n  if (p != 0) {\n    if (p == 0) {\n      int a[5];\n      a[10] = 1;\n    }\n  }\n}\n\nvoid null_pruning2_Bad(int* p) {\n  if (p != 0) {\n    if (p != 0) {\n      int a[5];\n      a[10] = 1;\n    }\n  }\n}\n\nint greater_than(unsigned int x, unsigned int y) { return (x > y); }\n\nvoid call_greater_than_Good() {\n  unsigned int idx = 0;\n  if (greater_than(idx, 0)) {\n    idx = idx - 1;\n  }\n}\n\nvoid null_pruning_symbols(unsigned int a, unsigned int b) {\n  unsigned int c = a + b;\n  if (c > 0) {\n    char result[c];\n    result[c - 1] = 0;\n  }\n}\n\nvoid call_null_pruning_symbols_1_Good() { null_pruning_symbols(10, 20); }\n\nvoid call_null_pruning_symbols_2_Good() { null_pruning_symbols(0, 0); }\n\nint unknown_function();\n\nvoid call_null_pruning_symbols_3_Good_FP() {\n  unsigned int c;\n  if (unknown_function()) {\n    c = 0;\n  } else {\n    c = 10;\n  }\n  null_pruning_symbols(c, 0);\n}\n"
    },
    {
      "testname": "relation.c",
      "testlanguage": "c",
      "expected-problems": 17,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvoid array_access_Ok(int x, int y) {\n  int a[1];\n  if (x + y == 1) {\n    a[x + y - 1] = 0;\n  }\n}\n\nvoid call_array_access_Ok() { array_access_Ok(0, 0); }\n\nvoid FP_array_access2_Ok(int x, int y) {\n  int a[1];\n  if (x + y == 1) {\n    if (x + y != 1) {\n      a[3] = 0;\n    }\n  }\n}\n\nvoid FP_array_access3_Ok(int x, int* y) {\n  int a[1];\n  *y = x + 1;\n  if (x + 1 == 1) {\n    if (*y != 1) {\n      a[3] = 0;\n    }\n  }\n}\n\nvoid FP_array_access4_Ok(int x, int* y) {\n  int a[1];\n  *y = x * 3 + 1;\n  if (x * 3 + 1 == 1) {\n    if (*y != 1) {\n      a[3] = 0;\n    }\n  }\n}\n"
    },
    {
      "testname": "sizeof.c",
      "testlanguage": "c",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid eval_sizeof_bad() {\n  if (sizeof(long long) < 10000) {\n    // always true\n    int a[0];\n    a[1]; // report\n  }\n}\n\nstruct some_struct {\n  int x0;\n  int x1;\n};\n\nvoid static_stride_bad() {\n  struct some_struct a[10];\n  char *x, *y;\n  x = (char*)&(a[5]);\n  y = (char*)&(a[4]);\n  if (sizeof(struct some_struct) == x - y) {\n    int a[0];\n    a[1]; // report\n  }\n}\n\nvoid sizeof_char_good(int i) {\n  char b[10];\n  b[sizeof(b) - 1] = 123;\n}\n"
    },
    {
      "testname": "struct_copy.c",
      "testlanguage": "c",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct s {\n  int a;\n  int b;\n};\n\nvoid struct_copy_Ok() {\n  int a[5];\n  struct s x, y;\n  x.a = 3;\n  x.b = 5;\n  y = x;\n  a[y.a] = 0;\n}\n\nvoid struct_copy_Bad() {\n  int a[3];\n  struct s x, y;\n  x.a = 3;\n  x.b = 5;\n  y = x;\n  a[y.b] = 0;\n}\n\nstruct t {\n  struct s s;\n  int c;\n};\n\nvoid nested_struct_copy_Ok() {\n  int a[7];\n  struct t x, y;\n  x.s.a = 3;\n  x.s.b = 5;\n  x.c = 7;\n  y = x;\n  a[y.s.a] = 0;\n}\n\nvoid nested_struct_copy_Bad() {\n  int a[3];\n  struct t x, y;\n  x.s.a = 3;\n  x.s.b = 5;\n  x.c = 7;\n  y = x;\n  a[y.s.b] = 0;\n}\n\nstruct s get_struct() {\n  struct s x;\n  x.a = 3;\n  x.b = 5;\n  return x;\n}\n\nvoid struct_copy_from_function_call_Ok() {\n  int a[5];\n  struct s x;\n  x = get_struct();\n  a[x.a] = 0;\n}\n\nvoid struct_copy_from_function_call_Bad_FN() {\n  int a[3];\n  struct s x;\n  x = get_struct();\n  a[x.b] = 0;\n}\n\nstruct s get_struct_wrapper() {\n  return get_struct();\n}\n\nvoid struct_copy_from_wrapper_call_Ok() {\n  int a[5];\n  struct s x;\n  x = get_struct_wrapper();\n  a[x.a] = 0;\n}\n\nvoid struct_copy_from_wrapper_call_Bad_FN() {\n  int a[3];\n  struct s x;\n  x = get_struct_wrapper();\n  a[x.b] = 0;\n}\n\nvoid struct_copy_decl_Ok() {\n  int a[5];\n  struct s x;\n  x.a = 3;\n  x.b = 5;\n  struct s y = x;\n  a[y.a] = 0;\n}\n\nvoid struct_copy_decl_Bad() {\n  int a[3];\n  struct s x;\n  x.a = 3;\n  x.b = 5;\n  struct s y = x;\n  a[y.b] = 0;\n}\n\nvoid struct_copy_decl_by_function_Ok() {\n  int a[5];\n  struct s x = get_struct();\n  a[x.a] = 0;\n}\n\nvoid struct_copy_decl_by_function_Bad() {\n  int a[3];\n  struct s x = get_struct();\n  a[x.b] = 0;\n}\n"
    },
    {
      "testname": "trivial.c",
      "testlanguage": "c",
      "expected-problems": 17,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid trivial_Bad() {\n  int a[10];\n  a[10] = 0; /* BUG */\n}\n\nvoid malloc_zero_Bad() {\n  char* x;\n  x = malloc(0);\n  x = malloc(1);\n}\n\nint unknown_function();\n\nvoid differentiate_array_info_Good() {\n  int* p;\n  if (unknown_function()) {\n    p = (int*)malloc(sizeof(int) * 5);\n  } else {\n    p = (int*)malloc(sizeof(int) * 10);\n    p = p + 5;\n  }\n  p[4] = 0;\n}\n\nvoid differentiate_array_info_Bad() {\n  int* p;\n  if (unknown_function()) {\n    p = (int*)malloc(sizeof(int) * 5);\n  } else {\n    p = (int*)malloc(sizeof(int) * 10);\n    p = p + 5;\n  }\n  p[5] = 0;\n}\n"
    },
    {
      "testname": "unreachable.c",
      "testlanguage": "c",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nint __infer_nondet_int() {\n  int ret;\n  return ret;\n}\n\nvoid nop() {}\n\nvoid condition_always_true_bad() {\n  if (1) {\n    nop();\n  }\n}\n\nvoid condition_always_false_bad() {\n  if (0) {\n    nop();\n  }\n}\n\nvoid condition_always_true_with_else_bad() {\n  if (1) {\n    nop();\n  } else {\n    nop();\n  }\n}\n\nvoid exit_at_end_of_if_good() {\n  if (__infer_nondet_int()) {\n    exit(4);\n  }\n}\n\nvoid exit_at_end_of_proc_good() {\n  nop();\n  exit(5);\n}\n\nvoid exit_at_end_of_proc_good_local_var() {\n  int a = 57;\n  exit(5);\n}\n\nvoid FN_useless_else_bad() {\n  if (__infer_nondet_int()) {\n    exit(0);\n  } else {\n    nop();\n  }\n}\n\nvoid never_loops_bad() {\n  while (0) {\n    nop();\n  }\n}\n\nvoid infinite_loop_bad() {\n  while (1) {\n    nop();\n  }\n}\n\nvoid FP_loop_with_break_good() {\n  while (1) {\n    if (__infer_nondet_int()) {\n      break;\n    }\n  }\n}\n\nvoid FP_loop_with_return_good() {\n  while (1) {\n    if (__infer_nondet_int()) {\n      return;\n    }\n  }\n}\n\nvoid FP_loop_with_exit_good() {\n  while (1) {\n    if (__infer_nondet_int()) {\n      exit(1);\n    }\n  }\n}\n\nvoid FP_loop_with_unreachable_good() {\n  while (1) {\n    if (__infer_nondet_int()) {\n      infinite_loop_bad();\n    }\n  }\n}\n\nvoid FP_loop_once_intentional_good() {\n  do {\n    nop();\n  } while (0);\n}\n\nvoid FN_loop_once_break_bad() {\n  while (__infer_nondet_int()) {\n    break;\n  }\n}\n\nvoid FN_loop_once_return_bad() {\n  while (__infer_nondet_int()) {\n    return;\n  }\n}\n\nvoid FN_loop_once_exit_bad() {\n  while (__infer_nondet_int()) {\n    exit(2);\n  }\n}\n\nvoid FN_loop_once_unreachable_bad() {\n  while (__infer_nondet_int()) {\n    infinite_loop_bad();\n  }\n}\n\nvoid FN_unreachable_statement_call_bad() {\n  infinite_loop_bad();\n  nop();\n}\n\nvoid FN_unreachable_statement_exit_bad() {\n  exit(2);\n  nop();\n}\n\nvoid FN_unreachable_statement_return_bad() {\n  return;\n  nop();\n}\n\nvoid FN_unreachable_statement_break_bad() {\n  while (__infer_nondet_int()) {\n    if (__infer_nondet_int()) {\n      break;\n      nop();\n    }\n  }\n}\n\nvoid FN_unreachable_statement_continue_bad() {\n  while (__infer_nondet_int()) {\n    continue;\n    nop();\n  }\n}\n"
    },
    {
      "testname": "unrolling.c",
      "testlanguage": "c",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid do_two_times_Good(int n) {\n  char a[1];\n  for (int i = 0; i < n; i++) {\n    n = 1;\n    a[i] = 3;\n  }\n}\n\nvoid do_two_times2_Good(int n) {\n  char a[1];\n  int k = n;\n  for (int i = 0; i < k; i++) {\n    k = 1;\n    a[i] = 3;\n  }\n}\n\nvoid call_do_two_times_Good_FP() { do_two_times_Good(5); }\n\nvoid call_do_two_times2_Good_FP() { do_two_times2_Good(5); }\n"
    },
    {
      "testname": "while_loop.c",
      "testlanguage": "c",
      "expected-problems": 21,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid while_loop() {\n  int i = 0;\n  char* a = malloc(10);\n  while (*(a + i) && i < 10) /* BUG */\n    a[i++] = 1; /* SAFE */\n}\n\nstruct S {\n  struct S* f;\n};\n\nvoid dummy_func(struct S* x) {}\n\nvoid diverge_on_narrowing() {\n  struct S* x;\n  while (1) {\n    dummy_func(0);\n    x = x->f;\n  }\n}\n\nvoid join_minmax_with_sum_unsigned_Good(unsigned int x, unsigned int y) {\n  char a[x + y + 1];\n  int i = 0;\n  while (i < x + y) {\n    if (i > 5) {\n      y = 0;\n    }\n    i++;\n  }\n  a[i] = 2;\n}\n\nvoid call_join_minmax_with_sum_unsigned_Good() {\n  join_minmax_with_sum_unsigned_Good(15, 50);\n}\n\nvoid join_minmax_with_sum_signed_Good_FP(int x, int y) {\n  int s = x + y;\n  if (s < 0)\n    s = 0;\n  char a[s + 1];\n  int i = 0;\n  while (i < x + y) {\n    if (i > 5) {\n      y = 0;\n    }\n    i++;\n  }\n  a[i] = 2;\n}\n\nvoid preciser_widen_Good(int x) {\n  int idx = 0;\n  int arr[10];\n  while (idx < 10) {\n    arr[idx] = 0;\n    if (unknown()) {\n      idx = x;\n    }\n  }\n}\n"
    },
    {
      "testname": "arith.cpp",
      "testlanguage": "c++",
      "expected-problems": 31,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cstdint>\n#include <cstdlib>\n\nvoid sizeof_bool_Good() {\n  int a[2];\n  int z = sizeof(bool); // z is 1 (byte)\n  a[z] = 0;\n}\n\nvoid sizeof_bool_Bad() {\n  int a[1];\n  int z = sizeof(bool); // z is 1 (byte)\n  a[z] = 0;\n}\n\n// FP due to incomplete frontend translation of casting\nvoid range_bool_Good_FP() {\n  int a[2];\n  bool x = true + true; // x is 1 (true)\n  a[x] = 0;\n}\n\nvoid range_bool_Bad() {\n  int a[1];\n  bool x = true + false; // x is 1 (true)\n  a[x] = 0;\n}\n\nvoid bool_overflow_Good_FP() {\n  int a[10];\n  if (((bool)-1) - 1) {\n    a[10] = 0;\n  } else {\n    a[5] = 0;\n  }\n}\n\nvoid bool_overflow_Bad() {\n  int a[10];\n  if (((bool)-1) - 1) {\n    a[10] = 0;\n  } else {\n    a[15] = 0;\n  }\n}\n\nvoid bool_overflow2_Good_FP() {\n  int a[10];\n  if (((bool)-2) - 1) {\n    a[10] = 0;\n  } else {\n    a[5] = 0;\n  }\n}\n\nclass RG {\n public:\n  RG(uint32_t init) {\n    seed = init;\n    x = init;\n  }\n\n  inline uint32_t integer_overflow_rand() {\n    uint32_t max = 4294967295;\n    return (seed = seed * max);\n  }\n\n  inline uint32_t integer_overflow_x() {\n    uint32_t max = 4294967295;\n    return (x = x * max);\n  }\n\n private:\n  uint32_t seed;\n  uint32_t x;\n};\n\nuint32_t call_integer_overflow_rand_Good() {\n  RG generator(4294967295);\n  return generator.integer_overflow_rand();\n}\n\nuint32_t call_integer_overflow_x_Bad() {\n  RG generator(4294967295);\n  return generator.integer_overflow_x();\n}\n\nstruct S_prng_lfsr {\n  uint32_t prng_lfsr;\n};\n\nvoid integer_overflow_field_Good(struct S_prng_lfsr* c) {\n  c->prng_lfsr = 1;\n  c->prng_lfsr = 0 - c->prng_lfsr;\n}\n\nstruct S_x {\n  uint32_t x;\n};\n\nvoid integer_overflow_field_Bad(struct S_x* c) {\n  c->x = 1;\n  c->x = 0 - c->x;\n}\n\nuint32_t integer_overflow_param_1(uint32_t seed) { return seed - 1; }\n\nvoid call_integer_overflow_param_1_Good() { integer_overflow_param_1(0); }\n\nuint32_t integer_overflow_param_2(uint32_t x) { return x - 1; }\n\nvoid call_integer_overflow_param_2_Bad() { integer_overflow_param_2(0); }\n\n// \"HaSh\" (not \"hash\") is fot checking case-insensitive comparison.\nvoid allow_listed_HaSh_Good() {\n  uint32_t x = -1;\n  uint32_t y = x * 8;\n}\n\nvoid mod_ub(const char* msg, size_t leng) {\n  size_t rem = leng % 32;\n  if (rem == 15) {\n    char d = msg[14]; // Good\n  }\n  if (rem == 10) {\n    char d = msg[14]; // Bad\n  }\n}\n\nvoid call_mod_ub_1_Good() { mod_ub(\"ab\", 2); }\n\nvoid call_mod_ub_2_Good() { mod_ub(\"abcdefghijklmno\", 15); }\n\nvoid call_mod_ub_Bad() { mod_ub(\"abcdefghij\", 10); }\n"
    },
    {
      "testname": "class.cpp",
      "testlanguage": "c++",
      "expected-problems": 152,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass my_class {\n  int idx;\n  int arr[10];\n\n  void set_a(int n) { idx = n; }\n\n  int id(int n) { return n; }\n\n public:\n  int access_Bad() {\n    set_a(10);\n    return arr[idx];\n  }\n\n  int access2_Bad() {\n    int n = 10;\n    return arr[id(n)];\n  }\n\n  int access_nth(int n) { return arr[n]; }\n};\n\nvoid access_after_new_Good() {\n  my_class* x = new my_class();\n  x->access_nth(5);\n}\n\nvoid access_after_new_Bad() {\n  my_class* x = new my_class();\n  x->access_nth(15);\n}\n\n#include <stdlib.h>\n\nclass my_class2 {\n public:\n  int a[5];\n};\n\nvoid array_member_malloc_Good() {\n  my_class2* x = (my_class2*)malloc(sizeof(my_class2));\n  x->a[0] = 0;\n}\n\nvoid array_member_malloc_Bad() {\n  my_class2* x = (my_class2*)malloc(sizeof(my_class2));\n  x->a[10] = 0;\n}\n\nclass my_class3 {\n public:\n  my_class2 b;\n};\n\nvoid array_member_malloc2_Bad() {\n  my_class3* x = (my_class3*)malloc(sizeof(my_class3));\n  x->b.a[10] = 0;\n}\n\n#include <new>\n\nvoid new_nothrow_Good() {\n  my_class2* x = new (std::nothrow) my_class2();\n  x->a[0] = 0;\n}\n\nvoid new_nothrow_Bad() {\n  my_class2* x = new (std::nothrow) my_class2();\n  x->a[10] = 0;\n}\n\nvoid placement_new_Good() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (mem) my_class2();\n  x->a[0] = 0;\n}\n\nvoid placement_new_Bad() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (mem) my_class2();\n  x->a[10] = 0;\n}\n\nenum class DummyClass {};\ninline void* operator new(std::size_t, DummyClass, void* p) { return p; }\ninline void* operator new(std::size_t, void* p, DummyClass) { return p; }\n\nvoid placement_new_overload1_Good() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (DummyClass{}, mem) my_class2();\n  x->a[0] = 0;\n}\n\nvoid placement_new_overload1_Bad() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (DummyClass{}, mem) my_class2();\n  x->a[10] = 0;\n}\n\nvoid placement_new_overload2_Good() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (mem, DummyClass{}) my_class2();\n  x->a[0] = 0;\n}\n\nvoid placement_new_overload2_Bad() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (mem, DummyClass{}) my_class2();\n  x->a[10] = 0;\n}\n\nstruct DummyStruct {};\ninline void* operator new(std::size_t, DummyStruct, void* p) { return p; }\ninline void* operator new(std::size_t, void* p, DummyStruct) { return p; }\n\nvoid placement_new_overload3_Good() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (DummyStruct{}, mem) my_class2();\n  x->a[0] = 0;\n}\n\nvoid placement_new_overload4_Good() {\n  char* mem = (char*)malloc(sizeof(my_class2));\n  my_class2* x = new (mem, DummyStruct{}) my_class2();\n  x->a[0] = 0;\n}\n\nstruct Allocator {\n  void* allocate(std::size_t size) { return malloc(size); }\n};\n\nvoid* operator new(std::size_t size, Allocator& allocator) {\n  return allocator.allocate(size);\n}\n\nvoid user_defined_new_Bad_FN() {\n  Allocator allocator;\n  my_class2* x = new (allocator) my_class2();\n  x->a[10] = 0;\n}\n\nclass my_class4 {\n public:\n  int a[3];\n  int c[3];\n  int b[1];\n};\n\nvoid flexible_array1_Good() {\n  char* mem = (char*)malloc(sizeof(my_class4) + 4 * sizeof(int));\n  my_class4* x = new (mem) my_class4();\n  x->b[4] = 0;\n}\n\nvoid flexible_array1_Bad() {\n  char* mem = (char*)malloc(sizeof(my_class4) + 4 * sizeof(int));\n  my_class4* x = new (mem) my_class4();\n  x->b[5] = 0;\n}\n\nvoid flexible_array2_Bad_FN() {\n  char* mem = (char*)malloc(4 * sizeof(int) + sizeof(my_class4));\n  my_class4* x = new (mem) my_class4();\n  x->b[5] = 0;\n}\n\nvoid flexible_array3_Bad_FN() {\n  char* mem = (char*)malloc(sizeof(my_class4) + sizeof(int) * 4);\n  my_class4* x = new (mem) my_class4();\n  x->b[5] = 0;\n}\n\nvoid* operator new(std::size_t s1, std::size_t s2) { return malloc(s1 + s2); }\nvoid* operator new(std::size_t s1, std::size_t s2, bool) {\n  return malloc(s1 + s2);\n}\n\nvoid flexible_array_new_overload1_Good() {\n  my_class4* x = new (5 * sizeof(int)) my_class4();\n  x->b[5] = 0;\n}\n\nvoid flexible_array_new_overload1_Bad() {\n  my_class4* x = new (5 * sizeof(int)) my_class4();\n  x->b[10] = 0;\n}\n\nvoid flexible_array_new_overload2_Good() {\n  my_class4* x = new (5 * sizeof(int), true) my_class4();\n  x->b[5] = 0;\n}\n\nvoid flexible_array_new_overload2_Bad() {\n  my_class4* x = new (5 * sizeof(int), true) my_class4();\n  x->b[10] = 0;\n}\n\nclass my_class5 {\n public:\n  int d[3];\n  int f[3];\n  my_class4 e;\n};\n\nvoid flexible_array4_Good() {\n  char* mem = (char*)malloc(sizeof(my_class5) + 4 * sizeof(int));\n  my_class5* x = new (mem) my_class5();\n  x->e.b[4] = 0;\n}\n\nvoid flexible_array4_Bad() {\n  char* mem = (char*)malloc(sizeof(my_class5) + 4 * sizeof(int));\n  my_class5* x = new (mem) my_class5();\n  x->e.b[5] = 0;\n}\n\nclass Tree {\n private:\n  unsigned int children_num;\n\n  Tree(unsigned int children_num) : children_num(children_num) {}\n\n public:\n  void set_child(Tree* child, unsigned int nth) { children[nth] = child; }\n\n  static Tree* NewNode(unsigned int children_num) {\n    char* mem =\n        (char*)malloc(sizeof(Tree) + (children_num - 1) * sizeof(Tree*));\n    return new (mem) Tree(children_num);\n  }\n\n  static Tree* NewLeaf() { return new Tree(0); }\n\n private:\n  Tree* children[1];\n};\n\nvoid flexible_array5_Good() {\n  Tree* t = Tree::NewNode(3);\n  t->set_child(Tree::NewLeaf(), 0);\n  t->set_child(Tree::NewLeaf(), 1);\n  t->set_child(Tree::NewLeaf(), 2);\n}\n\nvoid flexible_array5_Bad() {\n  Tree* t = Tree::NewNode(3);\n  t->set_child(Tree::NewLeaf(), 5);\n}\n\nvoid flexible_array_param_access(my_class4* x) { x->b[3] = 0; }\n\nvoid flexible_array_param_Good() {\n  my_class4* x = (my_class4*)malloc(sizeof(my_class4) + 4 * sizeof(int));\n  flexible_array_param_access(x);\n}\n\nvoid flexible_array_param_Bad() {\n  my_class4* x = (my_class4*)malloc(sizeof(my_class4) + 2 * sizeof(int));\n  flexible_array_param_access(x);\n}\n\nchar* my_malloc() { return (char*)malloc(sizeof(my_class4) + 4 * sizeof(int)); }\n\nvoid return_class_Good() {\n  my_class4* x = (my_class4*)my_malloc();\n  x->b[3] = 0;\n}\n\nvoid return_class_Bad() {\n  my_class4* x = (my_class4*)my_malloc();\n  x->b[5] = 0;\n}\n\nstruct S {\n  static constexpr unsigned int x = 32;\n};\n\nvoid use_global_Good() {\n  int a[50];\n  a[S::x] = 0;\n}\n\nvoid use_global_Bad() {\n  int a[30];\n  a[S::x] = 0;\n}\n\nconst unsigned int S::x;\n\nvoid use_global_2_Good() {\n  int a[50];\n  a[S::x] = 0;\n}\n\nvoid use_global_2_Bad() {\n  int a[30];\n  a[S::x] = 0;\n}\n\nclass my_class6 {\n  int* x;\n\n  void dummy_function() {}\n\n  void set_x_two_Good() {\n    int arr[5];\n    *x = 0;\n    dummy_function();\n    arr[*x] = 0;\n  }\n\n  void set_x_two_Bad() {\n    int arr[5];\n    *x = 5;\n    dummy_function();\n    arr[*x] = 0;\n  }\n\n  void set_x_three() { *x = 3; }\n\n  void call_set_x_three_Good() {\n    int arr[5];\n    set_x_three();\n    arr[*x] = 0;\n  }\n\n  void call_set_x_three_Bad() {\n    int arr[3];\n    set_x_three();\n    arr[*x] = 0;\n  }\n};\n"
    },
    {
      "testname": "conditional_proof_obligation.cpp",
      "testlanguage": "c++",
      "expected-problems": 76,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stddef.h>\n#include <stdexcept>\n\nvoid conditional_buffer_access(int* ptr, unsigned int size) {\n  int i;\n  if (size < 1) {\n  } else if (size < 2) {\n    i = *(ptr++);\n  } else if (size < 3) {\n    i = *(ptr++);\n    i = *(ptr++);\n  } else if (size < 4) {\n    i = *(ptr++);\n    i = *(ptr++);\n    i = *(ptr++);\n  } else if (size < 5) {\n    i = *(ptr++);\n    i = *(ptr++);\n    i = *(ptr++);\n    i = *(ptr++);\n  }\n}\n\nvoid call_conditional_buffer_access_Good() {\n  int a[1];\n  conditional_buffer_access(a, 1);\n}\n\nvoid call_conditional_buffer_access_Bad() {\n  int a[1];\n  conditional_buffer_access(a, 3);\n}\n\nvoid conditional_buffer_access2(unsigned int n) {\n  int a[n];\n  conditional_buffer_access(a, n);\n}\n\nvoid call_conditional_buffer_access2_1_Good() { conditional_buffer_access2(1); }\n\nvoid call_conditional_buffer_access2_2_Good() { conditional_buffer_access2(3); }\n\nvoid conditional_minus(int* ptr, unsigned int size) {\n  int i = 0;\n  if (ptr != NULL && (i < size - 1)) {\n  }\n}\n\nvoid call_conditional_minus_1_Good() { conditional_minus(NULL, 0); }\n\nvoid call_conditional_minus_2_Good() {\n  int a[3];\n  conditional_minus(a, 3);\n}\n\nvoid call_conditional_minus_2_Bad() {\n  int a[3];\n  conditional_minus(a, 0);\n}\n\nunsigned int conditional_minus2(int* ptr, unsigned int size) {\n  if (ptr != NULL) {\n    return (size - 1);\n  }\n}\n\nvoid call_conditional_minus2_1_Good() { conditional_minus2(NULL, 0); }\n\nvoid call_conditional_minus2_2_Good() {\n  int a[3];\n  conditional_minus2(a, 3);\n}\n\nvoid call_conditional_minus2_2_Bad() {\n  int a[3];\n  conditional_minus2(a, 0);\n}\n\nenum E {\n  E_SIZEONE = 0,\n  E_SIZETWO = 1,\n};\n\nvoid conditional_buffer_access3(int* ptr, int size) {\n  int i;\n  switch (ptr[0]) {\n    case E_SIZETWO:\n      i = ptr[size - 2];\n      i = ptr[size - 1];\n      break;\n\n    case E_SIZEONE:\n      i = ptr[size - 1];\n      break;\n  }\n}\n\nvoid call_conditional_buffer_access3_1_Good() {\n  int a[2];\n  a[0] = E_SIZETWO;\n  conditional_buffer_access3(a, 2);\n}\n\nvoid call_conditional_buffer_access3_2_Good() {\n  int a[1];\n  a[0] = E_SIZEONE;\n  conditional_buffer_access3(a, 1);\n}\n\nvoid call_conditional_buffer_access3_Bad() {\n  int a[1];\n  a[0] = E_SIZETWO;\n  conditional_buffer_access3(a, 1);\n}\n\nvoid conditional_inequality(int idx) {\n  int a[5];\n  if (idx == 5) {\n  } else {\n    a[idx] = 0;\n  }\n}\n\nvoid call_conditional_inequality_Good() { conditional_inequality(5); }\n\nvoid call_conditional_inequality_Bad() { conditional_inequality(6); }\n\nvoid conditional_inequality_join1(int idx) {\n  int a[5];\n  if (idx == 5) {\n  } else {\n    // pruning exp is \"idx != 5\"\n  L:\n    // joined pruning exp is \"Unknown\"\n    a[idx] = 0;\n  }\n\n  if (idx == 6) {\n    // pruning exp is \"idx == 6\"\n    goto L;\n  }\n}\n\nvoid call_conditional_inequality_join1_Good_FP() {\n  conditional_inequality_join1(5);\n}\n\nvoid call_conditional_inequality_join1_Bad() {\n  conditional_inequality_join1(6);\n}\n\nvoid conditional_inequality_join2(int idx) {\n  int a[5];\n  if (idx == 5) {\n  } else {\n    // pruning exp is \"idx != 5\"\n  L:\n    // joined pruning exp is \"idx != [5, 6]\"\n    a[idx] = 0;\n  }\n\n  if (idx != 6) {\n    // pruning exp is \"idx != 6\"\n    goto L;\n  }\n}\n\nvoid call_conditional_inequality_join2_1_Bad() {\n  conditional_inequality_join2(5);\n}\n\nvoid call_conditional_inequality_join2_2_Bad() {\n  conditional_inequality_join2(6);\n}\n\nvoid conditional_inequality_depth2(int i) {\n  int a[5];\n  if (i != 1) {\n    a[i] = 0;\n  }\n}\n\nvoid conditional_inequality_depth1(int i) {\n  if (i != 5) {\n    conditional_inequality_depth2(i);\n  }\n}\n\nvoid call_conditional_inequality_depth1_1_Good() {\n  conditional_inequality_depth1(5);\n}\n\nvoid call_conditional_inequality_depth1_2_Good() {\n  conditional_inequality_depth1(1);\n}\n\nvoid call_conditional_inequality_depth1_3_Bad() {\n  conditional_inequality_depth1(6);\n}\n\nclass MyString {\n  char* _data = \"\";\n  size_t _size = 0;\n\n public:\n  size_t size() { return _size; }\n\n  char* data() { return _data; }\n};\n\nvoid set_fourth_idx(char* p) { p[3] = '0'; }\n\nvoid set_fourth_idx_safe(MyString* input) {\n  if (input->size() < 4) {\n    return;\n  }\n  set_fourth_idx(input->data());\n}\n\nvoid call_set_fourth_idx_safe_Good() {\n  MyString* s = new MyString();\n  set_fourth_idx_safe(s);\n}\n\nvoid throw_exception(int i) {\n  int a[10];\n  if (i >= 10) {\n    throw std::runtime_error(\"throw exception\");\n  }\n  a[i] = 0;\n}\n\nvoid call_throw_exception_Good() { throw_exception(15); }\n\nvoid call_throw_exception_Bad() { throw_exception(-5); }\n"
    },
    {
      "testname": "cpp_is_tricky.cpp",
      "testlanguage": "c++",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <vector>\n\nnamespace CppIsTricky {\nvoid vector_size_Bad() {\n  const auto vec = std::vector<int>{1, 2, 3};\n  const int numExpectedElements = 1;\n  const auto delta = numExpectedElements - vec.size();\n}\n\nvoid minus1_Bad_FN() {\n  const unsigned long i2 = 18446744073709551614u;\n  const unsigned long i1 = 446744073709551614u;\n  const int d1 = i2 - i1;\n}\nvoid minus2_Bad_FN() {\n  const unsigned long i2 = 18446744073709551614u;\n  const unsigned long i1 = 446744073709551614u;\n  const long d2 = i2 - i1;\n}\nvoid minus3_Good() {\n  const unsigned long i2 = 18446744073709551614u;\n  const unsigned long i1 = 446744073709551614u;\n  const auto d3 = i2 - i1;\n}\n} // namespace CppIsTricky\n"
    },
    {
      "testname": "external.cpp",
      "testlanguage": "c++",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nextern char** lib();\n\nvoid extern_bad() {\n  int arr[10];\n  char** p = lib();\n  if (p != 0)\n    arr[10] = 0;\n  char* q = *p;\n  if (q != 0)\n    arr[20] = 0;\n  int r = *q;\n  if (r != 0)\n    arr[30] = 0;\n}\n"
    },
    {
      "testname": "folly_memory_UninitializedMemoryHacks.cpp",
      "testlanguage": "c++",
      "expected-problems": 31,
      "code": "/*\n * Copyright 2017 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace {\n// This struct is different in every translation unit.  We use template\n// instantiations to define inline freestanding methods.  Since the\n// methods are inline it is fine to define them in multiple translation\n// units, but the instantiation itself would be an ODR violation if it is\n// present in the program more than once.  By tagging the instantiations\n// with this struct, we avoid ODR problems for the instantiation while\n// allowing the resulting methods to be inline-able.  If you think that\n// seems hacky keep reading...\nstruct FollyMemoryDetailTranslationUnitTag {};\n} // namespace\nnamespace folly {\nnamespace detail {\nvoid unsafeStringSetLargerSize(std::string& s, std::size_t n);\ntemplate <typename T>\nvoid unsafeVectorSetLargerSize(std::vector<T>& v, std::size_t n);\n} // namespace detail\n\n/*\n * This file provides helper functions resizeWithoutInitialization()\n * that can resize std::string or std::vector without constructing or\n * initializing new elements.\n *\n * IMPORTANT: These functions can be unsafe if used improperly.  If you\n * don't write to an element with index >= oldSize and < newSize, reading\n * the element can expose arbitrary memory contents to the world, including\n * the contents of old strings.  If you're lucky you'll get a segfault,\n * because the kernel is only required to fault in new pages on write\n * access.  MSAN should be able to catch problems in the common case that\n * the string or vector wasn't previously shrunk.\n *\n * Pay extra attention to your failure paths.  For example, if you try\n * to read directly into a caller-provided string, make sure to clear\n * the string when you get an I/O error.\n *\n * You should only use this if you have profiling data from production\n * that shows that this is not a premature optimization.  This code is\n * designed for retroactively optimizing code where touching every element\n * twice (or touching never-used elements once) shows up in profiling,\n * and where restructuring the code to use fixed-length arrays or IOBuf-s\n * would be difficult.\n *\n * NOTE: Just because .resize() shows up in your profile (probably\n * via one of the intrinsic memset implementations) doesn't mean that\n * these functions will make your program faster.  A lot of the cost\n * of memset comes from cache misses, so avoiding the memset can mean\n * that the cache miss cost just gets pushed to the following code.\n * resizeWithoutInitialization can be a win when the contents are bigger\n * than a cache level, because the second access isn't free in that case.\n * It can be a win when the memory is already cached, so touching it\n * doesn't help later code.  It can also be a win if the final length\n * of the string or vector isn't actually known, so the suffix will be\n * chopped off with a second call to .resize().\n */\n\n/**\n * Like calling s.resize(n), but when growing the string does not\n * initialize new elements.  It is undefined behavior to read from\n * any element added to the string by this method unless it has been\n * written to by an operation that follows this call.\n *\n * IMPORTANT: Read the warning at the top of this header file.\n */\ninline void resizeWithoutInitialization(std::string& s, std::size_t n) {\n  if (n <= s.size()) {\n    s.resize(n);\n  } else {\n    // careful not to call reserve unless necessary, as it causes\n    // shrink_to_fit on many platforms\n    if (n > s.capacity()) {\n      s.reserve(n);\n    }\n    detail::unsafeStringSetLargerSize(s, n);\n  }\n}\n\n/**\n * Like calling v.resize(n), but when growing the vector does not construct\n * or initialize new elements.  It is undefined behavior to read from any\n * element added to the vector by this method unless it has been written\n * to by an operation that follows this call.\n *\n * Use the FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT(T) macro to\n * declare (and inline define) the internals required to call\n * resizeWithoutInitialization for a std::vector<T>.  This must\n * be done exactly once in each translation unit that wants to call\n * resizeWithoutInitialization(std::vector<T>&,size_t).  char and unsigned\n * char are provided by default.  If you don't do this you will get linker\n * errors about folly::detail::unsafeVectorSetLargerSize.  Requiring that\n * T be trivially_destructible is only an approximation of the property\n * required of T.  In fact what is required is that any random sequence of\n * bytes may be safely reinterpreted as a T and passed to T's destructor.\n *\n * std::vector<bool> has specialized internals and is not supported.\n *\n * IMPORTANT: Read the warning at the top of this header file.\n */\ntemplate <typename T,\n          typename = typename std::enable_if<\n              std::is_trivially_destructible<T>::value &&\n              !std::is_same<T, bool>::value>::type>\nvoid resizeWithoutInitialization(std::vector<T>& v, std::size_t n) {\n  if (n <= v.size()) {\n    v.resize(n);\n  } else {\n    if (n > v.capacity()) {\n      v.reserve(n);\n    }\n    detail::unsafeVectorSetLargerSize(v, n);\n  }\n}\n\nnamespace detail {\n\n#if defined(_LIBCPP_STRING)\n// libc++\n\n} // namespace detail\n} // namespace folly\ntemplate void std::string::__set_size(std::size_t);\nnamespace folly {\nnamespace detail {\n\ntemplate <typename Tag, typename T, typename A, A Ptr__set_size>\nstruct MakeUnsafeStringSetLargerSize {\n  friend void unsafeStringSetLargerSize(std::basic_string<T>& s,\n                                        std::size_t n) {\n    // s.__set_size(n);\n    (s.*Ptr__set_size)(n);\n    (&s[0])[n] = '\\0';\n  }\n};\ntemplate struct MakeUnsafeStringSetLargerSize<\n    FollyMemoryDetailTranslationUnitTag,\n    char,\n    void (std::string::*)(std::size_t),\n    &std::string::__set_size>;\n\n#elif defined(_GLIBCXX_USE_FB)\n// FBString\n\ntemplate <typename Tag, typename T, typename A, A Ptrstore_>\nstruct MakeUnsafeStringSetLargerSize {\n  friend void unsafeStringSetLargerSize(std::basic_string<T>& s,\n                                        std::size_t n) {\n    // s.store_.expandNoinit(n - s.size(), false);\n    (s.*Ptrstore_).expandNoinit(n - s.size(), false);\n  }\n};\ntemplate struct MakeUnsafeStringSetLargerSize<\n    FollyMemoryDetailTranslationUnitTag,\n    char,\n    std::fbstring_core<char>(std::string::*),\n    &std::string::store_>;\n\n#elif defined(_GLIBCXX_STRING) && _GLIBCXX_USE_CXX11_ABI\n// libstdc++ new implementation with SSO\n\n} // namespace detail\n} // namespace folly\ntemplate void std::string::_M_set_length(std::size_t);\nnamespace folly {\nnamespace detail {\n\ntemplate <typename Tag, typename T, typename A, A Ptr_M_set_length>\nstruct MakeUnsafeStringSetLargerSize {\n  friend void unsafeStringSetLargerSize(std::basic_string<T>& s,\n                                        std::size_t n) {\n    // s._M_set_length(n);\n    (s.*Ptr_M_set_length)(n);\n  }\n};\ntemplate struct MakeUnsafeStringSetLargerSize<\n    FollyMemoryDetailTranslationUnitTag,\n    char,\n    void (std::string::*)(std::size_t),\n    &std::string::_M_set_length>;\n\n#elif defined(_GLIBCXX_STRING)\n// libstdc++ old implementation\n\n} // namespace detail\n} // namespace folly\ntemplate std::string::_Rep* std::string::_M_rep() const;\ntemplate void std::string::_Rep::_M_set_length_and_sharable(std::size_t);\nnamespace folly {\nnamespace detail {\n\ntemplate <typename Tag,\n          typename T,\n          typename A,\n          A Ptr_M_rep,\n          typename B,\n          B Ptr_M_set_length_and_sharable>\nstruct MakeUnsafeStringSetLargerSize {\n  friend void unsafeStringSetLargerSize(std::basic_string<T>& s,\n                                        std::size_t n) {\n    // s._M_rep()->_M_set_length_and_sharable(n);\n    auto rep = (s.*Ptr_M_rep)();\n    (rep->*Ptr_M_set_length_and_sharable)(n);\n  }\n};\ntemplate struct MakeUnsafeStringSetLargerSize<\n    FollyMemoryDetailTranslationUnitTag,\n    char,\n    std::string::_Rep* (std::string::*)() const,\n    &std::string::_M_rep,\n    void (std::string::_Rep::*)(std::size_t),\n    &std::string::_Rep::_M_set_length_and_sharable>;\n\n#elif defined(_MSC_VER)\n// MSVC\n\ninline void unsafeStringSetLargerSize(std::string& s, std::size_t n) {\n  s._Eos(n);\n}\n\n#else\n#warnin \"No implementation for resizeWithoutInitialization of std::string\"\n#endif\n\n// This machinery bridges template expansion and macro expansion\n#define FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT_IMPL(TYPE)              \\\n  namespace folly {                                                      \\\n  namespace detail {                                                     \\\n  void unsafeVectorSetLargerSizeImpl(std::vector<TYPE>& v, std::size_t); \\\n  template <>                                                            \\\n  inline void unsafeVectorSetLargerSize<TYPE>(std::vector<TYPE> & v,     \\\n                                              std::size_t n) {           \\\n    unsafeVectorSetLargerSizeImpl(v, n);                                 \\\n  }                                                                      \\\n  }                                                                      \\\n  }\n\n#if defined(_GLIBCXX_VECTOR)\n   // libstdc++\n\ntemplate <typename Tag,\n          typename T,\n          typename A,\n          A Ptr_M_impl,\n          typename B,\n          B Ptr_M_finish>\nstruct MakeUnsafeVectorSetLargerSize : std::vector<T> {\n  friend void unsafeVectorSetLargerSizeImpl(std::vector<T>& v, std::size_t n) {\n    // v._M_impl._M_finish += (n - v.size());\n    (v.*Ptr_M_impl).*Ptr_M_finish += (n - v.size());\n  }\n};\n\n#define FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT(TYPE)          \\\n  template struct folly::detail::MakeUnsafeVectorSetLargerSize< \\\n      FollyMemoryDetailTranslationUnitTag,                      \\\n      TYPE,                                                     \\\n      std::vector<TYPE>::_Vector_impl(                          \\\n          std::_Vector_base<TYPE, std::allocator<TYPE>>::*),    \\\n      &std::vector<TYPE>::_M_impl,                              \\\n      TYPE*(std::vector<TYPE>::_Vector_impl::*),                \\\n      &std::vector<TYPE>::_Vector_impl::_M_finish>;             \\\n  FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT_IMPL(TYPE)\n\n#elif defined(_MSC_VER)\n// MSVC\n\n#define FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT(TYPE)                   \\\n  extern inline void unsafeVectorSetLargerSizeImpl(std::vector<TYPE>& v, \\\n                                                   std::size_t n) {      \\\n    v._Mylast() += (n - v.size());                                       \\\n  }                                                                      \\\n  FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT_IMPL(TYPE)\n\n#else\n#warning \"No implementation for resizeWithoutInitialization of std::vector\"\n#endif\n\n} // namespace detail\n} // namespace folly\n\n#if defined(FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT)\nFOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT(char)\nFOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT(unsigned char)\n#endif\n\nnamespace infer_test {\nvoid foo_string(std::string& s, std::size_t n) {\n  folly::resizeWithoutInitialization(s, n);\n}\nvoid foo_vector(std::vector<int>& v, std::size_t n) {\n  folly::resizeWithoutInitialization(v, n);\n}\n} // namespace infer_test\n"
    },
    {
      "testname": "folly_split.cpp",
      "testlanguage": "c++",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <vector>\n#include <string>\n\nnamespace folly {\n\ntemplate <class T>\nclass fbvector;\n\ntemplate <class T>\nstruct Optional;\n\nclass fbstring;\nclass StringPiece;\n\ntemplate <class Delim, class String, class OutputType>\nvoid split(const Delim& delimiter,\n           const String& input,\n           std::vector<OutputType>& out,\n           const bool ignoreEmpty = false);\n\ntemplate <class Delim, class String, class OutputType>\nvoid split(const Delim& delimiter,\n           const String& input,\n           folly::fbvector<OutputType>& out,\n           const bool ignoreEmpty = false);\n\ntemplate <class OutputValueType,\n          class Delim,\n          class String,\n          class OutputIterator>\nvoid splitTo(const Delim& delimiter,\n             const String& input,\n             OutputIterator out,\n             const bool ignoreEmpty = false);\n\n} // namespace folly\n\nnamespace folly_split {\nstd::string do_not_ignore_empty_Good(const std::string& s) {\n  std::vector<std::string> v;\n  folly::split(\"delimiter\", s, v);\n  return v[0];\n}\n\nstd::string do_not_ignore_empty2_Good(const std::string& s) {\n  std::vector<std::string> v;\n  folly::split(\"delimiter\", s, v, false);\n  return v[0];\n}\n\nstd::string do_not_ignore_empty_Bad(const std::string& s) {\n  std::vector<std::string> v;\n  folly::split(\"delimiter\", s, v, true);\n  return v[0];\n}\n} // namespace folly_split\n"
    },
    {
      "testname": "function_call.cpp",
      "testlanguage": "c++",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct S {\n  int field;\n};\n\nvoid ref_set_to_zero(int& x) { x = 0; }\n\nvoid struct_ref_set_to_zero(struct S& s) { s.field = 0; }\n\nvoid call_by_ref_good() {\n  int arr[10];\n  int i = 99;\n  ref_set_to_zero(i);\n  arr[i] = 123;\n}\n\nvoid call_by_ref_bad() {\n  int arr[10];\n  int i = 5;\n  ref_set_to_zero(i);\n  arr[i - 1] = 123;\n}\n\nstruct S init_S(int x) {\n  struct S s = {x};\n  return s;\n}\n\nint loop_with_init_S(int length) {\n  int i = 0;\n  while (i < length) {\n    struct S s = init_S(i + 1);\n    i = s.field;\n  }\n  return i;\n}\n\nvoid call_loop_with_init_S_Good() {\n  int a[10];\n  a[loop_with_init_S(5)] = 0;\n}\n\nvoid call_loop_with_init_S_Bad() {\n  int a[10];\n  a[loop_with_init_S(10)] = 0;\n}\n"
    },
    {
      "testname": "global.cpp",
      "testlanguage": "c++",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstatic constexpr int ConstantGlobal[] = {5};\n\nvoid access_constant_global_Bad() {\n  int a[5];\n  a[ConstantGlobal[0]] = 3;\n}\n\nvoid access_via_assignment_constant_global_Bad() {\n  int a[5];\n  const int* arr = ConstantGlobal;\n  a[arr[0]] = 3;\n}\n\nstatic int StaticGlobal[][3] = {\n    {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};\n\nvoid access_static_global1_Bad() { int* p = StaticGlobal[10]; }\n\nvoid access_static_global2_Bad() { int a = StaticGlobal[0][10]; }\n\nclass Foo {\n\n public:\n  int p;\n  Foo(int x) { p = x; }\n};\n\nstatic const Foo ConstantGlobalFoos[] = {{8}};\n\nvoid access_via_class_field_assignment_constant_global_Bad() {\n  int a[5];\n  const Foo foo = ConstantGlobalFoos[0];\n  a[foo.p] = 3;\n}\n\nvoid access_via_class_field_constant_global_Bad() {\n  int a[5];\n  a[ConstantGlobalFoos[0].p] = 3;\n}\n"
    },
    {
      "testname": "realloc.cpp",
      "testlanguage": "c++",
      "expected-problems": 40,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cstdlib>\n\nvoid realloc_Good() {\n  int* buf1 = (int*)malloc(2 * sizeof(int));\n  buf1[0] = 3;\n  int* buf2 = (int*)realloc(buf1, 5 * sizeof(int));\n  buf2[buf2[0]] = 0;\n}\n\nvoid realloc_Bad() {\n  int* buf1 = (int*)malloc(2 * sizeof(int));\n  buf1[0] = 5;\n  int* buf2 = (int*)realloc(buf1, 5 * sizeof(int));\n  buf2[buf2[0]] = 0;\n}\n\nvoid realloc2_Good() {\n  int* buf1 = (int*)malloc(2 * sizeof(int));\n  for (int i = 0; i < 2; i++) {\n    buf1[i] = 3;\n  }\n  int* buf2 = (int*)realloc(buf1, 5 * sizeof(int));\n  buf2[buf2[0]] = 0;\n}\n\nstruct S1 {\n  int x[2];\n};\n\nvoid realloc_struct1_Good() {\n  struct S1* buf1 = (struct S1*)malloc(2 * sizeof(struct S1));\n  buf1[0].x[0] = 3;\n  struct S1* buf2 = (struct S1*)realloc(buf1, 5 * sizeof(struct S1));\n  buf2[buf2[0].x[0]].x[0] = 0;\n}\n\nvoid realloc_struct1_Bad() {\n  struct S1* buf1 = (struct S1*)malloc(2 * sizeof(struct S1));\n  buf1[0].x[0] = 5;\n  struct S1* buf2 = (struct S1*)realloc(buf1, 5 * sizeof(struct S1));\n  buf2[buf2[0].x[0]].x[0] = 0;\n}\n\nstruct S2 {\n  int x;\n};\n\nstruct S3 {\n  struct S2 s;\n};\n\nvoid realloc_struct2_Good() {\n  struct S3* buf1 = (struct S3*)malloc(2 * sizeof(struct S3));\n  buf1[0].s.x = 3;\n  struct S3* buf2 = (struct S3*)realloc(buf1, 5 * sizeof(struct S3));\n  buf2[buf2[0].s.x].s.x = 0;\n}\n\nvoid realloc_struct2_Bad() {\n  struct S3* buf1 = (struct S3*)malloc(2 * sizeof(struct S3));\n  buf1[0].s.x = 5;\n  struct S3* buf2 = (struct S3*)realloc(buf1, 5 * sizeof(struct S3));\n  buf2[buf2[0].s.x].s.x = 0;\n}\n\nstruct S4 {\n  int a[3];\n  int c[3];\n  int b[1];\n};\n\nstruct S5 {\n public:\n  int d[3];\n  int f[3];\n  S4 e;\n};\n\nvoid realloc_flexible_array_Good() {\n  struct S5* buf1 = (struct S5*)malloc(sizeof(struct S5) + 4 * sizeof(int));\n  struct S5* buf2 =\n      (struct S5*)realloc(buf1, sizeof(struct S5) + 9 * sizeof(int));\n  buf2->e.b[7] = 0;\n}\n\nvoid realloc_flexible_array_Bad() {\n  struct S5* buf1 = (struct S5*)malloc(sizeof(struct S5) + 9 * sizeof(int));\n  struct S5* buf2 =\n      (struct S5*)realloc(buf1, sizeof(struct S5) + 4 * sizeof(int));\n  buf2->e.b[7] = 0;\n}\n"
    },
    {
      "testname": "relation.cpp",
      "testlanguage": "c++",
      "expected-problems": 46,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cstdlib>\n\nvoid minus_params_Ok(int x, int y) {\n  int a[5];\n  if (0 <= x - y && x - y < 5) {\n    a[x - y] = 0;\n  }\n}\n\nvoid call1_minus_params_Ok() { minus_params_Ok(5, 2); }\n\nvoid call2_minus_params_Ok() { minus_params_Ok(10, 2); }\n\nvoid plus_params(int x, int y) {\n  int a[5];\n  if (x + y > 0) {\n    a[x + y - 1] = 0;\n  }\n}\n\nvoid call1_plus_params_Ok() { plus_params(1, 2); }\n\nvoid call2_plus_params_Bad() { plus_params(10, 2); }\n\nvoid call3_plus_params_Ok() { plus_params(0, 0); }\n\nvoid plus_params2(int x, int y) {\n  int a[5];\n  if (-x < y) {\n    a[x + y - 1] = 0;\n  }\n}\n\nvoid call1_plus_params2_Ok() { plus_params2(1, 2); }\n\nvoid call2_plus_params2_Bad() { plus_params2(10, 2); }\n\nvoid call3_plus_params2_Ok() { plus_params2(0, 0); }\n\nvoid loop(char* arr, int len) {\n  while (len > 0) {\n    arr[0] = 0;\n    arr += 1;\n    len -= 1;\n  }\n}\n\nvoid FP_call1_loop_Ok() {\n  char arr[5];\n  loop(arr, 5);\n}\n\nvoid call2_loop_Bad() {\n  char arr[5];\n  loop(arr, 10);\n}\n\nvoid FP_loop2_Ok() {\n  int len = 12;\n  char* arr = (char*)malloc(len * sizeof(char));\n  while (len >= 4) {\n    arr += 4;\n    len -= 4;\n  }\n  switch (len) {\n    case 3:\n      arr[2] = 0;\n    case 2:\n      arr[1] = 0;\n    case 1:\n      arr[0] = 0;\n  };\n}\n\nvoid loop_with_type_casting(void* data, int len) {\n  char* arr = (char*)data;\n  while (len >= 4) {\n    int k = *(int*)arr;\n    arr += 4;\n    len -= 4;\n  }\n  switch (len) {\n    case 3:\n      arr[2] = 0;\n    case 2:\n      arr[1] = 0;\n    case 1:\n      arr[0] = 0;\n  };\n}\n\ntypedef struct s {\n  int a;\n  int b;\n} s_t;\n\nvoid FP_call_loop_with_type_casting_Ok() {\n  s_t* c = (s_t*)malloc(sizeof(s_t));\n  loop_with_type_casting(c, 8);\n}\n\nsize_t id(size_t s) {\n  if (s == 0) {\n    return 0;\n  } else {\n    return s;\n  }\n}\n\nvoid FP_call_id_Ok() {\n  size_t s1 = 5;\n  size_t s2 = id(1 + s1);\n  char* arr = (char*)malloc(s2 * sizeof(char));\n  arr[s1] = 0;\n}\n"
    },
    {
      "testname": "remove_temps.cpp",
      "testlanguage": "c++",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <vector>\n\nstruct S {\n  std::vector<int> l;\n  S* next;\n  std::atomic<void*> ptr;\n};\n\nclass C {\n  void foo_Bad();\n  void goo();\n  S head_;\n};\n\nvoid C::foo_Bad() {\n  while (1) {\n    S* t = head_.next;\n    int x = t->l.size();\n    void* ptr = t->ptr;\n    int a[5];\n    a[10] = 1;\n  }\n}\n\nvoid C::goo() {\n  while (1) {\n    S* t = head_.next;\n    int x = t->l.size();\n    void* ptr = t->ptr;\n  }\n}\n"
    },
    {
      "testname": "repro1.cpp",
      "testlanguage": "c++",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n\nint __infer_nondet_int();\n\n#define ASSERT(x) assert(x)\n#define xh(h)                                        \\\n  ({                                                 \\\n    const uint64_t* u1 = (const uint64_t*)(h);       \\\n    const uint64_t* u2 = (const uint64_t*)((h) + 8); \\\n    *u1 ^ *u2;                                       \\\n  })\n#define alo(a) aloi2(a, 0)\n#define aloi2(a, i2) ((lo){i1tl(a.i), (i2)})\n#define i1tl(i1) (__infer_nondet_int() ? xh((i1).h) : (i1).i)\n#define HL (sizeof(char) * 16)\n\nenum class TLOR { S, F };\n\nuint32_t MH2(const void* k) { return (int64_t)k ^ __infer_nondet_int(); }\n\nuint32_t th(const void* k) { return MH2(k); }\n\ntypedef int BI;\nconstexpr BI kBN = 0;\n\ntypedef uint64_t ft;\n\nstruct it {\n  ft i{0};\n  char h[HL];\n  it() : i(0) { ::memset(h, '\\0', sizeof(h)); }\n  explicit it(ft f) : i(f) { ::memset(h, '\\0', sizeof(h)); }\n};\n\nstruct ai {\n  it i;\n  ai() {}\n  ai(it i_) : i(i_) {}\n};\n\nstruct lo {\n  uint64_t i1;\n  uint64_t i2;\n};\n\nstruct lt {\n  BI bI;\n};\n\ntemplate <typename T>\nstruct LMB {\n  TLOR lO(const lo& o) {\n    auto r = TLOR::S;\n    if (__infer_nondet_int()) {\n      r = TLOR::F;\n    }\n    return r;\n  }\n  void u(const lo& o) {}\n};\n\ntemplate <typename T>\nstruct LM {\n  typedef LMB<T> B;\n  void l(lt& t, const lo& o) { lI_FP(t, o); }\n  void tL(lt& t, const lo& o) { lI_FP(t, o); }\n  void u(lt& t, const lo& o) {\n    ASSERT(fB_FP(o) == t.bI);\n    if (t.bI == kBN) {\n      return;\n    }\n    uI(t.bI, o);\n    t.bI = kBN;\n  }\n\n private:\n  BI fB_FP(const lo& o) { return (BI)th((const void*)&o) % b.size() + 1; }\n  void lI_FP(lt& t, const lo& o) {\n    auto bi = fB_FP(o);\n    auto r = b[bi - 1]->lO(o);\n    if (r != TLOR::S) {\n      t.bI = kBN;\n      return;\n    }\n    t.bI = bi;\n  }\n  void uI(BI bi, const lo& o) { b[bi - 1]->u(o); }\n  std::vector<std::unique_ptr<B>> b;\n};\n\nclass TFM {};\n\ntypedef TFM LMDM;\n\nstatic LM<LMDM>* al;\n\nstatic inline void ral_good(lt* t, ai a) {\n  ASSERT(t);\n  lo o = alo(a);\n  al->u(*t, o);\n}\n\nstatic inline void gal_FP(lt* t, ai a) {\n  ASSERT(t);\n  lo o = alo(a);\n  if (__infer_nondet_int()) {\n    al->tL(*t, o);\n  } else {\n    al->l(*t, o);\n  }\n}\n\ninline ai aft(ft i) { return ai(it(i)); }\n\nstruct im {\n private:\n  char e[];\n\n public:\n  const char* gKPC() const noexcept { return e; }\n};\n\nstruct arh {\n  ft i1;\n};\n\nstatic void am_Good_FP(im* it) {\n  const arh* ch = (const arh*)it->gKPC();\n  const ai a = aft(ch->i1);\n  lt at;\n  gal_FP(&at, a);\n  ral_good(&at, a);\n}\n"
    },
    {
      "testname": "simple_vector.cpp",
      "testlanguage": "c++",
      "expected-problems": 16,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cstdlib>\n\nclass int_vector {\n  unsigned int _size;\n\n public:\n  // FAILS TO RELATE output field _size to argument size, NEED STRONG UPDATE\n  int_vector(int size) : _size(size) {}\n  // FAILS TO SET output field _size to 0\n  int_vector() : int_vector(0) {}\n\n  void access_at(int i) {\n    int* dummy_array = (int*)malloc(sizeof(int) * _size);\n    int dummy_value = dummy_array[i];\n    free(dummy_array);\n  }\n  unsigned int size() { return _size; }\n\n  void resize(int newsize) { _size = newsize; }\n};\n\nvoid my_vector_oob_Bad(int_vector& v) {\n  unsigned int n = v.size();\n  v.access_at(n);\n}\n\n// We expect the error to be throw in my_vector_oob_Bad already\nvoid instantiate_my_vector_oob_Ok() {\n  int_vector v;\n  v.resize(42);\n  my_vector_oob_Bad(v);\n}\n"
    },
    {
      "testname": "smart_ptr.cpp",
      "testlanguage": "c++",
      "expected-problems": 36,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n#include <string>\n\nclass smart_ptr {\n public:\n  class my_class {\n   public:\n    my_class(int i) {\n      int a[5];\n      a[i] = 0;\n    }\n\n    my_class(int i, int j) {\n      int a[10];\n      a[i + j] = 0;\n    }\n\n    my_class(const std::string& str, int i) {\n      int a[5];\n      a[i] = 0;\n    }\n\n    int i;\n\n    void set_i(int n) { i = n; }\n\n    void array_access() {\n      int a[5];\n      a[i] = 0;\n    }\n  };\n\n  void use_shared_ptr1_Good() {\n    int i = 3;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(i);\n  }\n\n  void use_shared_ptr1_Bad_FN() {\n    int i = 8;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(i);\n  }\n\n  void use_shared_ptr2_Good() {\n    int i = 3;\n    int j = 5;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(i, j);\n  }\n\n  void use_shared_ptr2_Bad_FN() {\n    int i = 8;\n    int j = 8;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(i, j);\n  }\n\n  void shared_ptr_with_std_string_Good() {\n    std::string str = \"abc\";\n    int i = 3;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(str, i);\n  }\n\n  void shared_ptr_with_std_string_Bad_FN() {\n    std::string str = \"abc\";\n    int i = 8;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(str, i);\n  }\n\n  void shared_ptr_with_const_int_Good() {\n    const int i = 3;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(i);\n  }\n\n  void shared_ptr_with_const_int_Bad_FN() {\n    const int i = 8;\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(i);\n  }\n\n  void call_method_Good() {\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(0);\n    p->set_i(3);\n    p->array_access();\n  }\n\n  void call_method_Bad() {\n    std::shared_ptr<my_class> p = std::make_shared<my_class>(0);\n    p->set_i(8);\n    p->array_access();\n  }\n};\n"
    },
    {
      "testname": "std_array.cpp",
      "testlanguage": "c++",
      "expected-problems": 45,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <array>\n\nint std_array_bo_Bad() {\n  std::array<int, 42> a;\n  return a[42];\n}\n\nint normal_array_bo() {\n  int b[42];\n  return b[42];\n}\n\nvoid new_char_Good() {\n  uint64_t len = 13;\n  char* dst;\n  dst = new char[len];\n}\n\nvoid new_int1_Bad() {\n  uint64_t len = 4611686018427387903; // (1 << 62) - 1\n  int32_t* dst;\n  dst = new int32_t[len];\n}\n\nvoid new_int2_Bad() {\n  uint64_t len = 9223372036854775807; // (1 << 63) - 1\n  int32_t* dst;\n  dst = new int32_t[len];\n}\n\nvoid new_int3_Bad() {\n  uint64_t len = 18446744073709551615; // (1 << 64) - 1\n  int32_t* dst;\n  dst = new int32_t[len];\n}\n\nvoid std_array_contents_Good() {\n  std::array<int, 10> a;\n  a[0] = 5;\n  a[a[0]] = 0;\n}\n\nvoid std_array_contents_Bad() {\n  std::array<int, 10> a;\n  a[0] = 10;\n  a[a[0]] = 0;\n}\n\nvoid array_iter1_Good() {\n  std::array<int, 11> a;\n  for (auto it = a.begin(); it < a.end(); ++it) {\n    *it = 10;\n  }\n  a[a[0]] = 0;\n}\n\nvoid array_iter1_Bad() {\n  std::array<int, 5> a;\n  for (auto it = a.begin(); it < a.end(); ++it) {\n    *it = 10;\n  }\n  a[a[0]] = 0;\n}\n\nvoid array_iter2_Good() {\n  std::array<int, 11> a;\n  for (auto it = a.begin(); it != a.end(); ++it) {\n    *it = 10;\n  }\n  a[a[0]] = 0;\n}\n\nvoid array_iter2_Bad() {\n  std::array<int, 5> a;\n  for (auto it = a.begin(); it != a.end(); ++it) {\n    *it = 10;\n  }\n  a[a[0]] = 0;\n}\n\nvoid array_iter3_Good() {\n  std::array<int, 11> a = {10};\n  for (auto it = a.cbegin(); it < a.cend(); ++it) {\n    a[*it] = 10;\n  }\n}\n\nvoid array_iter3_Bad() {\n  std::array<int, 5> a = {10};\n  for (auto it = a.cbegin(); it < a.cend(); ++it) {\n    a[*it] = 10;\n  }\n}\n\nvoid array_iter_front_Good() {\n  std::array<int, 11> a;\n  a.front() = 10;\n  a[a[0]] = 0;\n}\n\nvoid array_iter_front_Bad() {\n  std::array<int, 5> a;\n  a.front() = 10;\n  a[a[0]] = 0;\n}\n\nvoid array_iter_back_Good() {\n  std::array<int, 11> a;\n  a.back() = 10;\n  a[a[0]] = 0;\n}\n\nvoid array_iter_back_Bad() {\n  std::array<int, 5> a;\n  a.back() = 10;\n  a[a[0]] = 0;\n}\n\nvoid array_rev_iter_Good() {\n  std::array<int, 11> a;\n  for (auto it = a.rbegin(); it < a.rend(); ++it) {\n    *it = 10;\n  }\n  a[a[0]] = 0;\n}\n\nvoid array_rev_iter_Bad_FN() {\n  std::array<int, 5> a;\n  for (auto it = a.rbegin(); it < a.rend(); ++it) {\n    *it = 10;\n  }\n  a[a[0]] = 0;\n}\n\nvoid malloc_zero_Bad() { int* a = (int*)malloc(sizeof(int) * 0); }\n\nvoid new_array_zero_Good() { int* a = new int[0]; }\n"
    },
    {
      "testname": "std_string.cpp",
      "testlanguage": "c++",
      "expected-problems": 75,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cstdarg>\n#include <string>\n\nchar last_char1_Bad(char* s, int i) {\n  char buf[1024];\n  int n = snprintf(buf, sizeof(buf), \"%s%d\", s, i);\n  return buf[n - 1];\n}\n\nchar last_char1_Good(char* s, int i) {\n  char buf[1024];\n  int n = snprintf(buf, sizeof(buf), \"%s%d\", s, i);\n  if (n > 0 && n <= sizeof(buf)) {\n    return buf[n - 1];\n  } else {\n    return '\\0';\n  }\n}\n\nchar last_char2_Bad(const char* fmt, ...) {\n  char buf[1024];\n  va_list args;\n  va_start(args, fmt);\n  int n = vsnprintf(buf, sizeof(buf), fmt, args);\n  va_end(args);\n  return buf[n - 1];\n}\n\nstd::string to_string1_Bad(char* s, int i) {\n  char buf[1024];\n  int n = snprintf(buf, sizeof(buf), \"%s%d\", s, i);\n  return std::string(buf, n);\n}\n\nstd::string to_string1_Good(char* s, int i) {\n  char buf[1024];\n  int n = snprintf(buf, sizeof(buf), \"%s%d\", s, i);\n  if (n < 0) {\n    return NULL;\n  } else if (n > sizeof(buf)) {\n    n = sizeof(buf);\n  }\n  return std::string(buf, n);\n}\n\nstd::string to_string2_Bad(const char* fmt, ...) {\n  char buf[1024];\n  va_list args;\n  va_start(args, fmt);\n  int n = vsnprintf(buf, sizeof(buf), fmt, args);\n  va_end(args);\n  return std::string(buf, n);\n}\n\nstd::string to_string2_Good(const char* fmt, ...) {\n  char buf[1024];\n  va_list args;\n  va_start(args, fmt);\n  int n = vsnprintf(buf, sizeof(buf), fmt, args);\n  va_end(args);\n  if (n < 0) {\n    return NULL;\n  } else if (n > sizeof(buf)) {\n    n = sizeof(buf);\n  }\n  return std::string(buf, n);\n}\n\n/* Inferbo's model ignores the encoding errors for less noise of\n   analysis results.  While [vsnprintf] returns a nagative number when\n   an encoding error, it is less likely to lead to a security\n   problem.  */\nstd::string to_string3_Bad_FN(const char* fmt, ...) {\n  char buf[1024];\n  va_list args;\n  va_start(args, fmt);\n  int n = vsnprintf(buf, sizeof(buf), fmt, args);\n  va_end(args);\n  if (n > sizeof(buf)) {\n    n = sizeof(buf);\n  }\n  return std::string(buf, n);\n}\n\nvoid empty_Good(std::string s) {\n  if (s.empty()) {\n    if (!s.empty()) {\n      int a[10];\n      a[10] = 0;\n    }\n  }\n}\n\nvoid empty_Bad(std::string s) {\n  if (s.empty()) {\n    int a[10];\n    a[10] = 0;\n  }\n}\n\nvoid length_Good() {\n  std::string s(\"hello\");\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid length_Bad() {\n  std::string s(\"hellohello\");\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid length2_Good() {\n  const char* c = \"hello\";\n  std::string s(c);\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid length2_Bad() {\n  const char* c = \"hellohello\";\n  std::string s(c);\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid length3_Good() {\n  char* c = \"hello\";\n  std::string s(c);\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid length3_Bad() {\n  char* c = \"hellohello\";\n  std::string s(c);\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid length4(char* c) {\n  std::string s(c);\n  int a[10];\n  a[s.length()] = 0;\n}\n\nvoid call_length4_1_Good() {\n  char* c = \"hello\";\n  length4(c);\n}\n\nvoid call_length4_1_Bad() {\n  char* c = \"hellohello\";\n  length4(c);\n}\n\nvoid call_length4_2_Good() { length4(\"hello\"); }\n\nvoid call_length4_2_Bad() { length4(\"hellohello\"); }\n\nvoid size_Good() {\n  std::string s(\"hello\");\n  int a[10];\n  a[s.size()] = 0;\n}\n\nvoid size_Bad() {\n  std::string s(\"hellohello\");\n  int a[10];\n  a[s.size()] = 0;\n}\n\nvoid compare_Good_FP(std::string s) {\n  if (s.compare(0, s.size(), s) != 0) {\n    int a[10];\n    a[10] = 0;\n  }\n}\n\nvoid compare_Bad(std::string s) {\n  if (s.compare(0, s.size(), s) == 0) {\n    int a[10];\n    a[10] = 0;\n  }\n}\n\nvoid equal_Good_FP(std::string s) {\n  if (s != s) {\n    int a[10];\n    a[10] = 0;\n  }\n}\n\nvoid equal_Bad() {\n  std::string s1(\"hello\");\n  std::string s2(\"hello\");\n  if (s1 == s2) {\n    int a[10];\n    a[10] = 0;\n  }\n}\n\nconstexpr char const_s[] = \"const_s\";\n\nvoid equal2_Good_FP() {\n  std::string s(const_s);\n  if (s != const_s) {\n    int a[10];\n    a[10] = 0;\n  }\n}\n"
    },
    {
      "testname": "symb_arr.cpp",
      "testlanguage": "c++",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstruct symb_arr_alloc {\n  char h[10];\n  void symb_arr_access_ok() { h[9] = '\\0'; }\n  void symb_arr_access_bad() { h[10] = '\\0'; }\n};\n"
    },
    {
      "testname": "this.cpp",
      "testlanguage": "c++",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass CThis {\n  unsigned int n;\n  void access_Good() {\n    char a[this->n + 1];\n    a[this->n] = 0;\n  }\n  void access_Bad() {\n    char a[this->n + 1];\n    a[this->n + 1] = 0;\n  }\n};\n"
    },
    {
      "testname": "trivial.cpp",
      "testlanguage": "c++",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) 2016-present, Programming Research Laboratory (ROPAS)\n *                             Seoul National University, Korea\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid trivial() {\n  int a[10];\n  a[10] = 0; /* BUG */\n}\n"
    },
    {
      "testname": "vector.cpp",
      "testlanguage": "c++",
      "expected-problems": 104,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <vector>\n#include <list>\n#include <assert.h>\n\nvoid out_of_bound_Bad(std::vector<int> v) {\n  unsigned int n = v.size();\n  v[n] = 1;\n}\n\nvoid simple_size_Good() {\n  std::vector<int> v(3);\n  v[v.size() - 1] = 2;\n}\n\nvoid simple_size_Bad() {\n  std::vector<int> v(3);\n  v[v.size()] = 2;\n}\n\nvoid constructor_overload1_Good() {\n  std::vector<int> v(1);\n  v[0] = 2;\n}\n\nvoid constructor_overload1_Bad() {\n  std::vector<int> v(1);\n  v[3] = 2;\n}\n\nvoid constructor_overload2_Good() {\n  std::vector<int> v = {1};\n  v[0] = 2;\n}\n\nvoid constructor_overload2_Bad() {\n  std::vector<int> v = {1, 2, 3};\n  v[v[2]] = 2;\n}\n\nvoid push_back_Good() {\n  std::vector<int> v;\n  v.push_back(1);\n  v[0] = 2;\n}\n\nvoid push_back_Bad() {\n  std::vector<int> v;\n  v.push_back(1);\n  v[1] = 2;\n}\n\nvoid emplace_back_Good() {\n  std::vector<int> v;\n  v.emplace_back(1);\n  v[0] = 2;\n}\n\nvoid emplace_back_Bad() {\n  std::vector<int> v;\n  v.emplace_back(1);\n  v[1] = 2;\n}\n\nvoid insert_overload1_Good() {\n  std::vector<int> v;\n  v.insert(v.begin(), 1);\n  v[0] = 2;\n}\n\nvoid insert_overload1_Bad() {\n  std::vector<int> v;\n  v.insert(v.begin(), 1);\n  v[1] = 2;\n}\n\nvoid insert_overload2_Good() {\n  std::vector<int> v;\n  v.insert(v.begin(), 10, 1);\n  v[9] = 2;\n}\n\nvoid insert_overload2_Bad() {\n  std::vector<int> v;\n  v.insert(v.begin(), 10, 1);\n  v[10] = 2;\n}\n\nvoid insert_overload3_Good() {\n  std::vector<int> v;\n  v.insert(v.begin(), {0, 1, 2});\n  v[v[0]] = 2;\n}\n\nvoid insert_overload3_Bad() {\n  std::vector<int> v;\n  v.insert(v.begin(), {1, 2, 3});\n  v[v[2]] = 2;\n}\n\nvoid reserve_Good() {\n  std::vector<int> v;\n  v.reserve(42);\n  v.push_back(1);\n  v[0] = 2;\n}\n\nvoid reserve_Bad() {\n  std::vector<int> v;\n  v.reserve(42);\n  v[0] = 2;\n}\n\nvoid safe_access(std::vector<int> v) {\n  if (v.size() >= 10) {\n    v[9] = 1;\n  }\n}\n\nvoid call_safe_access_Good_FP() {\n  std::vector<int> v(5, 0);\n  safe_access(v);\n}\n\nvoid safe_access2(std::vector<int> v) {\n  if (v.empty()) {\n    return;\n  }\n\n  unsigned int a[v.size()];\n  for (unsigned int i = 0; i < v.size(); i++) {\n    a[i] = 0;\n  }\n}\n\nvoid call_safe_access2_Good() {\n  std::vector<int> v;\n  safe_access2(v);\n}\n\nvoid safe_access3_Good() {\n  std::vector<int> v;\n  if (!v.empty()) {\n    v[0] = 1;\n  }\n}\n\nvoid safe_access4(std::vector<int> v) {\n  if (!v.empty()) {\n    v[0] = 1;\n  }\n}\n\nvoid call_safe_access4_Good() {\n  std::vector<int> v;\n  safe_access4(v);\n}\n\nvoid safe_access5(std::vector<int> v) {\n  if (v.empty()) {\n  } else {\n    v[0] = 1;\n  }\n}\n\nvoid call_safe_access5_Good() {\n  std::vector<int> v;\n  safe_access5(v);\n}\n\nvoid safe_access6(std::vector<int> v) {\n  std::vector<int> v2(2);\n  v2[v.empty()];\n}\n\nvoid call_safe_access6_Good() {\n  std::vector<int> v;\n  safe_access6(v);\n}\n\nvoid data_Good() {\n  std::vector<int> v(5);\n  int* p = v.data();\n  p[4] = 1;\n}\n\nvoid data_Bad() {\n  std::vector<int> v(5);\n  int* p = v.data();\n  p[4] = 10;\n  p[v[4]] = 1;\n}\n\nvoid assert_Good() {\n  std::vector<int> v;\n  for (int i = 0; i < 5; i++) {\n    v.push_back(1);\n  }\n  assert(v.size() == 5);\n  v[4] = 1;\n}\n\nvoid assert_Good_2(int x) {\n  std::vector<int> v;\n  for (int i = 0; i < 5; i++) {\n    v.push_back(1);\n  }\n  assert(((v.size() == 5) ? 1 : 0) ? 1 : 0);\n  v[4] = 1;\n}\n\nvoid assert_Bad() {\n  std::vector<int> v;\n  for (int i = 0; i < 5; i++) {\n    v.push_back(1);\n  }\n  assert(v.size() == 5);\n  v[6] = 1;\n}\n\nclass CharVector {\n public:\n  CharVector(char* init) : a(init) {}\n\n  char& operator[](int idx) { return a[idx]; }\n\n private:\n  char* a;\n};\n\nvoid access_in_sixth(int count, CharVector v) {\n  assert(count >= 0);\n  assert(count < 5);\n  v[count + 1] = '0';\n}\n\nvoid access_minus_one(int count, CharVector v) {\n  assert(count >= 0);\n  v[count - 1] = '0';\n}\n\nvoid precise_subst_Good() {\n  char a[10];\n  CharVector v(a);\n  access_in_sixth(0, v);\n}\n\nvoid precise_subst_Good_FP() {\n  char a[10];\n  CharVector v(a);\n  access_minus_one(1, v);\n}\n\nvoid precise_subst_Bad() {\n  char a[10];\n  CharVector v(a);\n  access_minus_one(0, v);\n}\n\nvoid resize_Good() {\n  std::vector<int> v;\n  v.resize(1);\n  v[0] = 0;\n}\n\nvoid resize_Bad() {\n  std::vector<int> v;\n  v.resize(1);\n  v[1] = 0;\n}\n\nvoid iterate_rvalue_ref(std::vector<int>&& v) {\n  [&]() {\n    /* In SIL, the type iterator becomes a pointer to another pointer, i.e. an\n       rvalue reference to vector. Inferbo should not raise an internal error in\n       that case. */\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) {\n    }\n  };\n}\n"
    },
    {
      "testname": "void_ptr.cpp",
      "testlanguage": "c++",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <cstdint>\n\nvoid casting_void_ptr(void* p) {\n  uint8_t* q = (uint8_t*)p;\n  q[14] = 0;\n}\n\nvoid FP_call_casting_void_ptr_Ok() {\n  uint64_t p[2];\n  casting_void_ptr(p);\n}\n"
    },
    {
      "testname": "Array.java",
      "testlanguage": "java",
      "expected-problems": 33,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\npackage codetoanalyze.java.bufferoverrun;\n\nimport java.util.ArrayList;\n\nclass Array {\n  private ArrayList a = new ArrayList<>();\n\n  void collection_add_zero_Good() {\n    a.add(0, 100);\n  }\n\n  ArrayList collection_remove_from_empty_Bad() {\n    ArrayList b = new ArrayList<>();\n    b.remove(0);\n    return b;\n  }\n\n  void null_pruning1_Good() {\n    if (a == null) {\n      if (a != null) {\n        int[] arr = {1, 2, 3, 4, 5};\n        arr[10] = 1;\n      }\n    }\n  }\n\n  void null_pruning1_Bad() {\n    if (a == null) {\n      if (a == null) {\n        int[] arr = {1, 2, 3, 4, 5};\n        arr[10] = 1;\n      }\n    }\n  }\n\n  void null_pruning2_Good_FP() {\n    if (a != null) {\n      if (a == null) {\n        int[] arr = {1, 2, 3, 4, 5};\n        arr[10] = 1;\n      }\n    }\n  }\n\n  void null_pruning2_Bad() {\n    if (a != null) {\n      if (a != null) {\n        int[] arr = {1, 2, 3, 4, 5};\n        arr[10] = 1;\n      }\n    }\n  }\n\n  void negative_alloc_Bad() {\n    a = new ArrayList<>(-1);\n  }\n\n  void zero_alloc_Good() {\n    a = new ArrayList<>(0);\n  }\n\n  void positive_alloc_Good() {\n    a = new ArrayList<>(10);\n  }\n\n  void iterate_collection_Good(ArrayList<Integer> a) {\n    if (a.size() > 10) {\n      int x = a.get(9);\n    }\n  }\n\n  void call_iterate_collection_Good() {\n    ArrayList<Integer> x = new ArrayList<Integer>();\n    x.add(0);\n    x.add(0);\n    x.add(0);\n    x.add(0);\n    x.add(0);\n    this.iterate_collection_Good(x);\n  }\n\n  void iterate_collection_Bad(ArrayList<Integer> a) {\n    if (a.size() >= 5) {\n      int x = a.get(5);\n    }\n  }\n\n  void call_iterate_collection_Bad() {\n    ArrayList<Integer> x = new ArrayList<Integer>();\n    x.add(0);\n    x.add(0);\n    x.add(0);\n    x.add(0);\n    x.add(0);\n    this.iterate_collection_Bad(x);\n  }\n\n  boolean b;\n\n  int zero_to_five() {\n    return b ? 0 : 5;\n  }\n\n  void prune_assign_exp_Good() {\n    int idx;\n    int[] arr = new int[5];\n    if ((idx = zero_to_five()) != 5) {\n      arr[idx] = 0;\n    }\n  }\n\n  void prune_assign_exp_Bad() {\n    int idx;\n    int[] arr = new int[3];\n    if ((idx = zero_to_five()) != 5) {\n      arr[idx] = 0;\n    }\n  }\n\n  enum MyEnum {\n    MyEnumA\n  };\n\n  void array_length_Bad() {\n    int[] arr = new int[5];\n    if (MyEnum.values().length == 0) {\n      arr[10] = 0;\n    } else {\n      arr[10] = 0;\n    }\n  }\n}\n"
    },
    {
      "testname": "ArrayListTest.java",
      "testlanguage": "java",
      "expected-problems": 64,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport java.util.ArrayList;\n\nclass ArrayListTest {\n\n  void alloc_is_negative_bad() {\n    // initial capacity cannot be negative\n    ArrayList<Integer> x = new ArrayList<Integer>(-1);\n  }\n\n  void alloc_is_ok() {\n    // initial capacity cannot be negative\n    ArrayList<Integer> x = new ArrayList<Integer>(9);\n  }\n\n  void add_in_loop_ok() {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (int i = 0; i < 5; i++) {\n      a.add(0);\n    }\n    int j = a.get(3);\n  }\n\n  void add_in_loop_bad() {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (int i = 0; i < 5; i++) {\n      a.add(0);\n    }\n    int j = a.get(6);\n  }\n\n  void add_in_loop_by_param_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (int i = 0; i < b.size(); i++) {\n      a.add(0);\n    }\n    int j = a.get(b.size() - 1);\n  }\n\n  void add_in_loop_by_param_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (int i = 0; i < b.size(); i++) {\n      a.add(0);\n    }\n    int j = a.get(b.size() + 1);\n  }\n\n  boolean unknown_bool;\n\n  void add_in_loop_by_param2_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (int i = 0; i < b.size(); i++) {\n      if (unknown_bool) {\n        a.add(0);\n      }\n    } // a.size should be [0, b.size]\n    if (a.size() > 0) {\n      int j = b.get(a.size() - 1);\n    }\n  }\n\n  void add_in_loop_by_param2_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (int i = 0; i < b.size(); i++) {\n      if (unknown_bool) {\n        a.add(0);\n      }\n    } // a.size should be [0, b.size]\n    int j = b.get(a.size());\n  }\n\n  void add_in_loop_by_param3_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    if (b.size() > 0) {\n      for (int i = 1; i < b.size(); i++) {\n        a.add(0);\n      }\n      int j = a.get(b.size() - 2);\n    }\n  }\n\n  void add_in_loop_by_param3_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    if (b.size() > 0) {\n      for (int i = 1; i < b.size(); i++) {\n        a.add(0);\n      }\n      int j = a.get(b.size() - 1);\n    }\n  }\n\n  void add_in_loop_by_param4_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    a.add(0);\n    if (b.size() > 0) {\n      for (int i = 1; i < b.size(); i++) {\n        a.add(0);\n      } // a.size = b.size\n      int j = a.get(b.size() - 1);\n    }\n  }\n\n  void add_in_loop_by_param4_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    a.add(0);\n    if (b.size() > 0) {\n      for (int i = 1; i < b.size(); i++) {\n        a.add(0);\n      } // a.size = b.size\n      int j = a.get(b.size() + 1);\n    }\n  }\n\n  void add_in_loop_iterator_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (Integer i : b) {\n      a.add(i);\n    }\n    int j = a.get(b.size() - 1);\n  }\n\n  void add_in_loop_iterator_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (Integer i : b) {\n      a.add(i);\n    }\n    int j = a.get(b.size() + 1);\n  }\n\n  void remove_in_loop_iterator_good(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (Integer i : b) {\n      a.add(i);\n    }\n    for (Integer i : b) {\n      a.remove(i);\n    }\n    /* a.size is analyzed to 0, but it is coincidence.  Since it abstracts all members as one\n    abstract value (array smashing), it cannot follow the added/removed elements precisely. */\n    if (a.size() < 0) {\n      int j = b.get(b.size());\n    }\n  }\n\n  void remove_in_loop_iterator_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (Integer i : b) {\n      a.add(i);\n    }\n    for (Integer i : b) {\n      a.remove(i);\n    } // a.size should be 0\n    int j = a.get(0);\n  }\n\n  void add_in_loop_iterator2_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (Integer i : b) {\n      if (unknown_bool) {\n        a.add(i);\n      }\n    } // a.size should be [0, b.size]\n    if (a.size() > 0) {\n      int j = b.get(a.size() - 1);\n    }\n  }\n\n  void add_in_loop_iterator2_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a = new ArrayList<>();\n    for (Integer i : b) {\n      if (unknown_bool) {\n        a.add(i);\n      }\n    } // a.size should be [0, b.size]\n    int j = b.get(a.size());\n  }\n\n  void add_and_remove_ok(ArrayList<Integer> a) {\n    ArrayList<Integer> b = new ArrayList<Integer>();\n    b.add(0);\n    for (Integer i : a) {\n      b.add(0);\n      b.remove(0);\n    } // b.size is one here\n    int j = b.get(0);\n  }\n\n  void add_and_remove_bad(ArrayList<Integer> a) {\n    ArrayList<Integer> b = new ArrayList<Integer>();\n    for (Integer i : a) {\n      b.add(0);\n      b.remove(0);\n    } // b.size is zero here\n    int j = b.get(0);\n  }\n\n  void multi_adds_in_loop_iterator_ok(ArrayList<Integer> b) {\n    ArrayList<Integer> a1 = new ArrayList<>();\n    ArrayList<Integer> a2 = new ArrayList<>();\n    for (Integer i : b) {\n      a1.add(i);\n      a2.add(i);\n    }\n    int j;\n    j = a1.get(b.size() - 1);\n    j = a2.get(b.size() - 1);\n  }\n\n  void multi_adds_in_loop_iterator_bad(ArrayList<Integer> b) {\n    ArrayList<Integer> a1 = new ArrayList<>();\n    ArrayList<Integer> a2 = new ArrayList<>();\n    for (Integer i : b) {\n      a1.add(i);\n      a2.add(i);\n    }\n    int j;\n    j = a1.get(b.size() + 1);\n    j = a2.get(b.size() + 1);\n  }\n\n  void alias_join_bad() {\n    int i;\n    ArrayList<Integer> a = new ArrayList<>();\n    ArrayList<Integer> b = new ArrayList<>();\n    if (unknown_bool) {\n      a.add(0);\n      i = 0; // i = size of b\n    } else {\n      b.add(0);\n      b.add(0);\n      i = 0; // i = size of a\n    }\n    if (i == 0) {\n      b.get(0); // size of b should be [0, 2]\n    }\n  }\n\n  interface MyI {\n    public ArrayList<Integer> mk_unknown();\n  }\n\n  boolean unknown_bool2;\n  ArrayList<Integer> unknown_array_list1;\n  ArrayList<Integer> unknown_array_list2;\n\n  void loop_on_unknown_iterator_FN(MyI x, int j) {\n    ArrayList<Integer> a = new ArrayList<>();\n    ArrayList<Integer> b;\n    if (unknown_bool) {\n      b = a;\n    } else {\n      b = x.mk_unknown();\n    }\n    // `b` points to an zero-sized array and `Unknown` pointer.  Thus, the size of array list should\n    // be evaluated to [0,+oo] in a sound design.  However, this would harm overall analysis\n    // precision with introducing a lot of FPs.  To avoie that, we ignore the size of `Unknown`\n    // array list here, instead we get some FNs.\n    for (Integer i : b) {\n      // Since size of `b` is evaluted to [0,0], here is unreachable.\n      if (a.size() <= -1) {\n        int[] c = new int[5];\n        c[5] = 0;\n      } else {\n        int[] c = new int[10];\n        c[10] = 0;\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "ArrayMember.java",
      "testlanguage": "java",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\npackage codetoanalyze.java.bufferoverrun;\n\npublic class ArrayMember {\n  public int[] buf;\n\n  public void load_array_member_Good() {\n    int[] a = new int[10];\n    int x = buf[0];\n    if (x == 9) {\n      a[x] = 0;\n    }\n  }\n\n  public void load_array_member_Bad() {\n    int[] a = new int[10];\n    int x = buf[0];\n    if (x == 10) {\n      a[x] = 0;\n    }\n  }\n}\n"
    },
    {
      "testname": "CompressedData.java",
      "testlanguage": "java",
      "expected-problems": 16,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\npackage codetoanalyze.java.bufferoverrun;\n\n/* Mimics https://fburl.com/f61h6rbl */\nclass CompressedData {\n  class C {\n    public static final int CCI = 4;\n  }\n\n  class DI {\n    int s;\n  }\n\n  class D {\n    final DI[] cci = new DI[C.CCI];\n    int cis;\n  }\n\n  int yy;\n\n  int decompressData(D d) {\n    int output = 0;\n    DI di;\n    final int cis = d.cis;\n\n    for (int y = 0; y < yy; ++y) {\n      for (int ci = 0; ci < cis; ++ci) {\n        di = d.cci[ci];\n        final int s = di.s;\n        output = y * s;\n      }\n    }\n    return output;\n  }\n}\n"
    },
    {
      "testname": "External.java",
      "testlanguage": "java",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport external.library.SomeExternalClass;\n\npublic class External {\n  /* This function should raise deduplicated issues because the symbolic value of external method\n   * should be instantiated to top. */\n  void external_function_Bad(SomeExternalClass v) {\n    int i = (int) (v.externalMethod1()) + 1 + (int) (v.externalMethod1()) + 1;\n  }\n\n  /* This function should have no proof obilgation. */\n  void call_external_function_Good(SomeExternalClass v) {\n    external_function_Bad(v);\n  }\n}\n"
    },
    {
      "testname": "InheritanceTest.java",
      "testlanguage": "java",
      "expected-problems": 29,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass InheritanceTest {\n  interface MyInterface {\n    public int foo();\n  }\n\n  class UniqueImpl implements MyInterface {\n    public int foo() {\n      return 5;\n    }\n  }\n\n  public void call_interface_method_Good_FP(MyInterface x) {\n    int a[] = new int[10];\n    a[x.foo()] = 0;\n  }\n\n  public void call_interface_method_Bad(MyInterface x) {\n    int a[] = new int[5];\n    a[x.foo()] = 0;\n  }\n\n  interface MyInterface2 {\n    public int foo();\n  }\n\n  abstract class AbsImpl implements MyInterface2 {\n    public abstract int foo();\n  }\n\n  class Impl1 extends AbsImpl {\n    @Override\n    public int foo() {\n      return 10;\n    }\n  }\n\n  class Impl2 extends AbsImpl {\n    @Override\n    public int foo() {\n      return 5;\n    }\n  }\n\n  /* By heuristics, [Impl1.foo] is selected. It is hard to say good or bad. */\n  public void call_interface_method2(MyInterface2 x) {\n    int a[] = new int[10];\n    a[x.foo()] = 0;\n  }\n}\n"
    },
    {
      "testname": "StringTest.java",
      "testlanguage": "java",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass StringTest {\n  void constant_Good() {\n    String s = \"hello\";\n    char c = s.charAt(4);\n  }\n\n  void constant_Bad() {\n    String s = \"hello\";\n    char c = s.charAt(5);\n  }\n\n  void constant_explicit_constructor_Good() {\n    String s = new String(\"hello\");\n    char c = s.charAt(4);\n  }\n\n  void constant_explicit_constructor_Bad() {\n    String s = new String(\"hello\");\n    char c = s.charAt(5);\n  }\n\n  void copy_constructor_Good() {\n    String s = new String(\"hello\");\n    String t = new String(s);\n    char c = t.charAt(4);\n  }\n\n  void copy_constructor_Bad() {\n    String s = new String(\"hello\");\n    String t = new String(s);\n    char c = t.charAt(5);\n  }\n}\n"
    }
  ]
}