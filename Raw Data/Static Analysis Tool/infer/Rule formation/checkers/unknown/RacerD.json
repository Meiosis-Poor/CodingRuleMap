{
  "name": "RacerD",
  "language": [
    "clang",
    "java"
  ],
  "description": "Thread safety analysis.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "OCaml",
  "loc": 0,
  "branches": 0,
  "apis": 0,
  "test": [
    {
      "testname": "basics.cpp",
      "testlanguage": "c++",
      "expected-problems": 36,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace basics {\n\nclass Basic {\n public:\n  Basic() {}\n\n  void set_not_guarded_ok(int new_value) { not_guarded = new_value; }\n\n  int get_not_guarded_ok() { return not_guarded; }\n\n  void set_well_guarded_ok(int new_value) {\n    mutex_.lock();\n    well_guarded = new_value;\n    mutex_.unlock();\n  }\n\n  int get_well_guarded_ok() {\n    int result;\n    mutex_.lock();\n    result = well_guarded;\n    mutex_.unlock();\n    return result;\n  }\n\n  void set_suspiciously_read_bad(int new_value) {\n    mutex_.lock();\n    suspiciously_read = new_value;\n    mutex_.unlock();\n  }\n\n  int get_suspiciously_read_bad() { return suspiciously_read; }\n\n  void set_suspiciously_written_ok(int new_value) {\n    mutex_.lock();\n    mutex_.unlock();\n    suspiciously_written = new_value;\n  }\n\n  int get_suspiciously_written_ok() {\n    int result;\n    mutex_.lock();\n    result = suspiciously_written;\n    mutex_.unlock();\n    return result;\n  }\n\n  void write_array_under_lock_ok(char* arr1) {\n    mutex_.lock();\n    arr1[2] = 'c';\n    mutex_.unlock();\n  }\n\n  int read_array_outside_lock_ok(char* arr2, int i) { return arr2[i]; }\n\n  void set_double_lock_guarded_ok(int new_value) {\n    mutex_.lock();\n    mutex_2.lock();\n    double_lock_guarded = new_value;\n    mutex_2.unlock();\n    mutex_.unlock();\n  }\n\n  int read_double_lock_guarded_ok() {\n    int result;\n    mutex_2.lock();\n    result = double_lock_guarded;\n    mutex_2.unlock();\n    return result;\n  }\n\n  void set_double_suspiciously_read_bad(int new_value) {\n    mutex_.lock();\n    mutex_2.lock();\n    single_lock_suspiciously_read = new_value;\n    mutex_2.unlock();\n    mutex_.unlock();\n  }\n\n  int read_double_suspiciously_read_bad() {\n    return single_lock_suspiciously_read;\n  }\n\n private:\n  int well_guarded;\n  int suspiciously_read;\n  int suspiciously_written;\n  int not_guarded;\n  int double_lock_guarded;\n  int single_lock_suspiciously_read;\n  std::mutex mutex_;\n  std::mutex mutex_2;\n\n  int get_private_suspiciously_read_ok() { return suspiciously_read; }\n};\n} // namespace basics\n"
    },
    {
      "testname": "basics_no_mutex.cpp",
      "testlanguage": "c++",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nnamespace basics {\n\nclass BasicsNoMutex {\n public:\n  BasicsNoMutex() {}\n\n  void set_ok(int new_value) {\n    field_1 = new_value;\n    field_2 = new_value;\n  }\n\n  int get_field1_ok() { return field_1; }\n\n private:\n  int field_1;\n  int field_2;\n};\n} // namespace basics\n"
    },
    {
      "testname": "conditional.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nclass Conditional {\n public:\n  Conditional() {}\n\n  int get_x() { return x; }\n\n  bool owns() {\n    // temporary is properly destroyed and lock released\n    return std::unique_lock<std::mutex>(mutex_).owns_lock();\n  }\n\n  void run_ok() {\n    if (owns()) {\n    }\n\n    x = 0;\n  }\n\n  int get_y() { return y; }\n\n  void run_FP() {\n    // temporary not destroyed, so lock stays acquired at store to [x]\n    if (std::unique_lock<std::mutex>(mutex_).owns_lock()) {\n    }\n\n    y = 0;\n  }\n\n private:\n  int x;\n  int y;\n  std::mutex mutex_;\n};\n"
    },
    {
      "testname": "constructor_formals.cpp",
      "testlanguage": "c++",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace constructor_formals {\nclass Basic {\n public:\n  // there can be a race here between the initializer read and the set function\n  // below\n  Basic(Basic& other) : field_(other.field_) {}\n\n  void FN_set_under_lock_bad(int value) {\n    mutex_.lock();\n    field_ = value;\n    mutex_.unlock();\n  }\n\n private:\n  std::mutex mutex_;\n  int field_;\n};\n} // namespace constructor_formals\n"
    },
    {
      "testname": "containers.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n#include <map>\n\nnamespace containers {\n\nstruct A {\n  int value;\n};\n\nstruct B {\n\n  void FN_write_container_bad(int key, int value) {\n    mutex_.lock();\n    map[key].value = value;\n    mutex_.unlock();\n  }\n\n  int FN_get_bad(int key) { return map[key].value; }\n\n  int FN_size_bad() { return map.size(); }\n\n private:\n  std::map<int, A> map;\n  std::mutex mutex_;\n};\n} // namespace containers\n"
    },
    {
      "testname": "dereferencing.cpp",
      "testlanguage": "c++",
      "expected-problems": 35,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace dereferencing {\n\nstruct B {\n  int c;\n};\n\nstruct A {\n  B b;\n};\n\nstruct X {\n  int w;\n  int u;\n  X* x1;\n  X** x2;\n  A a;\n};\n\nclass Basic {\n public:\n  Basic() {}\n\n  void FN_pointer_deref_bad(int b) {\n    if (b) {\n      pointer_deref(&p);\n    } else {\n      mutex_.lock();\n      pointer_deref(&p);\n      mutex_.unlock();\n    }\n  }\n\n  void pointer_arith_ok(int b) {\n    if (b) {\n      pointer_arith(&q);\n    } else {\n      mutex_.lock();\n      pointer_arith(&q);\n      mutex_.unlock();\n    }\n  }\n\n  void value_ok(int b) {\n    if (b) {\n      value(h);\n    } else {\n      mutex_.lock();\n      value(h);\n      mutex_.unlock();\n    }\n  }\n\n  void FN_field_bad(int b) {\n    if (b) {\n      field(g);\n    } else {\n      mutex_.lock();\n      field(g);\n      mutex_.unlock();\n    }\n  }\n\n  void deref_w_bad(int b) {\n    if (b) {\n      deref_w(x);\n    } else {\n      mutex_.lock();\n      deref_w(x);\n      mutex_.unlock();\n    }\n  }\n\n  void deref_u_bad(int b) {\n    if (b) {\n      deref_u(x);\n    } else {\n      mutex_.lock();\n      deref_u(x);\n      mutex_.unlock();\n    }\n  }\n\n  void deref_abc_bad(int b) {\n    if (b) {\n      deref_abc(x);\n    } else {\n      mutex_.lock();\n      deref_abc(x);\n      mutex_.unlock();\n    }\n  }\n\n private:\n  void pointer_deref(int* v1) { (*v1)++; } // HIL: *(v1) := *(v1) + 1\n\n  void pointer_arith(int* v2) { v2++; } // HIL: v2 := v2 + 1\n\n  void value(int v3) { v3++; } // HIL: v3 := v3 + 1\n\n  void field(int& f) { f++; } // HIL: *(f) := *(f) + 1\n\n  void deref_w(X& xparam) {\n    xparam.x1->w++; // HIL: xparam->x1->w := xparam->x1->w + 1\n  }\n\n  void deref_u(X& xparam) {\n    (*xparam.x1).u++; // HIL: xparam->x1->u := xparam->x1->u + 1\n  }\n\n  void deref_abc(X& xparam) {\n    (**xparam.x2).a.b.c++; // HIL:*(xparam->x2)->a.b.c:= *(xparam->x2)->a.b.c+1\n  }\n\n  int g;\n  int h;\n  int p;\n  int q;\n  X x;\n  std::mutex mutex_;\n};\n} // namespace dereferencing\n"
    },
    {
      "testname": "lambdas.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nclass Lambdas {\n public:\n  void race_in_lambda_even_without_call_ok() {\n    auto lambda_with_sync = [&]() {\n      mutex_.lock();\n      f = 0;\n      mutex_.unlock();\n      return f;\n    };\n  }\n\n  // access propagation to callees does not currently work\n  int FN_race_in_lambda_bad() {\n    auto lambda_with_sync = [&]() { return g; };\n\n    return lambda_with_sync();\n  }\n\n  void set_under_lock(int value) {\n    mutex_.lock();\n    g = value;\n    mutex_.unlock();\n  }\n\n private:\n  int f;\n  int g;\n  std::mutex mutex_;\n};\n"
    },
    {
      "testname": "locals_char_array.cpp",
      "testlanguage": "c++",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace locals_char_array {\n\nvoid f() {\n  char line[1024];\n  int x;\n  line[0] = line[1];\n  x = 0;\n}\n\nstruct A {\n  void locals_ok(int b) {\n    if (b) {\n      f();\n    } else {\n      mutex_.lock();\n      f();\n      mutex_.unlock();\n    }\n  }\n\n  std::mutex mutex_;\n};\n\n} // namespace locals_char_array\n"
    },
    {
      "testname": "locals_ownership.cpp",
      "testlanguage": "c++",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace locals {\n\nstruct X {\n  int f;\n};\n\nclass Ownership {\n public:\n  Ownership() {}\n\n  int struct_ok() {\n    X x;\n    mutex_.lock();\n    x.f = 7;\n    mutex_.unlock();\n    return x.f;\n  }\n\n  int ptr_to_struct_ok() {\n    X* x = new X();\n    mutex_.lock();\n    x->f = 7;\n    mutex_.unlock();\n    return x->f;\n  }\n\n  int copy_constructor_ok() {\n    X x = current; // copy constructor\n    mutex_.lock();\n    x.f = 7;\n    mutex_.unlock();\n    return x.f;\n  }\n\n  int FN_ptr_to_field_struct_bad() {\n    X* x = &current;\n    mutex_.lock();\n    x->f = 7;\n    mutex_.unlock();\n    return x->f;\n  }\n\n  int copy_formal_ok(X xformal) {\n    X x = xformal; // copy constructor\n    mutex_.lock();\n    x.f = 7;\n    mutex_.unlock();\n    return x.f;\n  }\n\n  int FN_ptr_to_formal_bad(X* xformal) {\n    X* x = xformal;\n    mutex_.lock();\n    x->f = 7;\n    mutex_.unlock();\n    return x->f;\n  }\n\n private:\n  X current;\n  std::mutex mutex_;\n};\n} // namespace locals\n"
    },
    {
      "testname": "lock_guard_with_scope.cpp",
      "testlanguage": "c++",
      "expected-problems": 19,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace basics {\n\nclass LockGuardWithScope {\n public:\n  LockGuardWithScope() {}\n\n  void not_guarded_ok(int b, int new_value) {\n    if (b) {\n      not_guarded = new_value;\n    } else {\n      return not_guarded;\n    }\n  }\n\n  void well_guarded_ok(int b, int new_value) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (b) {\n      well_guarded = new_value;\n    } else {\n      return well_guarded;\n    }\n  }\n\n  void suspiciously_read_bad(int b, int new_value) {\n    if (b) {\n      std::lock_guard<std::mutex> lock(mutex_);\n      suspiciously_read = new_value;\n    } else {\n      return suspiciously_read;\n    }\n  }\n\n  void suspiciously_written_ok(int b, int new_value) {\n    if (b) {\n      suspiciously_written = new_value;\n    } else {\n      std::lock_guard<std::mutex> lock(mutex_);\n      return suspiciously_written;\n    }\n  }\n\n private:\n  int well_guarded;\n  int suspiciously_read;\n  int suspiciously_written;\n  int not_guarded;\n  std::mutex mutex_;\n};\n} // namespace basics\n"
    },
    {
      "testname": "noreturn.cpp",
      "testlanguage": "c++",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nclass Noreturn {\n public:\n  Noreturn() {}\n\n  int get_x_without_lock() { return x; }\n\n  void write_not_under_lock() {\n    { std::unique_lock<std::mutex> g(mutex_); }\n    x = 0;\n  }\n\n  [[noreturn]] void never_returns();\n\n  void indirectly_never_returns() { never_returns(); }\n\n  void may_not_return(bool b) {\n    if (b)\n      never_returns();\n  }\n\n  void never_returns_under_lock() {\n    std::unique_lock<std::mutex> g(mutex_);\n    never_returns();\n  }\n\n  void write_after_never_returns_under_lock() {\n    never_returns_under_lock();\n    x = 0;\n  }\n\n  void write_after_indirect_never_returns_under_lock() {\n    std::unique_lock<std::mutex> g(mutex_);\n    indirectly_never_returns();\n    x = 0;\n  }\n\n  int get_y_without_lock() { return y; }\n\n  void write_after_call_to_may_never_return_under_lock_bad(bool b) {\n    std::unique_lock<std::mutex> g(mutex_);\n    may_not_return(b);\n    y = 0;\n  }\n\n private:\n  int x;\n  int y;\n  std::mutex mutex_;\n};\n"
    },
    {
      "testname": "scoped_lock.cpp",
      "testlanguage": "c++",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nclass ScopedLock {\n public:\n  ScopedLock() {}\n\n  void store_x(int xx) {\n    std::scoped_lock<std::mutex> g(mutex_);\n    x = xx;\n  }\n\n  int get_x() {\n    std::scoped_lock<std::mutex> g(mutex_);\n    return x;\n  }\n\n  void store_y(int yy) {\n    std::scoped_lock<std::mutex> g(mutex_);\n    y = yy;\n  }\n\n  int get_y_bad() { return y; }\n\n  void store_z(int zz) { z = zz; }\n\n  int get_z() {\n    std::scoped_lock<std::mutex> g(mutex_);\n    return z;\n  }\n\n private:\n  int x, y, z;\n  std::mutex mutex_;\n};\n"
    },
    {
      "testname": "std_lock.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace basics {\n\nclass StdLock {\n public:\n  StdLock() {}\n\n  void set_ok(StdLock* other) {\n    std::lock(mutex_, other->mutex_);\n    guarded = other->guarded;\n  }\n\n  int get_ok() {\n    mutex_.lock();\n    return guarded;\n  }\n\n  void set_bad(StdLock* other) {\n    std::lock(mutex_, other->mutex_);\n    not_guarded = other->not_guarded;\n  }\n\n  int get_bad() { return not_guarded; }\n\n private:\n  int guarded;\n  int not_guarded;\n  std::mutex mutex_;\n};\n} // namespace basics\n"
    },
    {
      "testname": "unique_lock.cpp",
      "testlanguage": "c++",
      "expected-problems": 35,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace basics {\n\nclass UniqueLock {\n public:\n  UniqueLock() {}\n\n  int well_guarded1_ok(int b, int new_value) {\n    if (b) {\n      std::unique_lock<std::mutex> g(mutex_);\n      well_guarded1 = new_value;\n      return 0;\n    } else {\n      std::lock_guard<std::mutex> lock(mutex_);\n      return well_guarded1;\n    }\n  }\n\n  int well_guarded2_deferred_ok(int b, int new_value) {\n    if (b) {\n      std::unique_lock<std::mutex> g(mutex_, std::defer_lock);\n      g.lock();\n      well_guarded2 = new_value;\n      g.unlock();\n      return 0;\n    } else {\n      std::unique_lock<std::mutex> g(mutex_);\n      return well_guarded2;\n    }\n  }\n\n  int not_guarded1_ok(int b, int new_value) {\n    if (b) {\n      not_guarded1 = new_value;\n      return 0;\n    } else {\n      return not_guarded1;\n    }\n  }\n\n  int not_guarded2_ok(int b, int new_value) {\n    if (b) {\n      std::unique_lock<std::mutex> g(mutex_);\n      g.unlock();\n      not_guarded2 = new_value;\n      return 0;\n    } else {\n      std::unique_lock<std::mutex> g(mutex_);\n      g.unlock();\n      return not_guarded2;\n    }\n  }\n\n  int suspiciously_read1_bad(int b, int new_value) {\n    if (b) {\n      std::unique_lock<std::mutex> g(mutex_);\n      suspiciously_read1 = new_value;\n      return 0;\n    } else {\n      return suspiciously_read1;\n    }\n  }\n\n  int suspiciously_written_ok(int b, int new_value) {\n    if (b) {\n      suspiciously_written = new_value;\n      return 0;\n    } else {\n      std::unique_lock<std::mutex> g(mutex_);\n      return suspiciously_written;\n    }\n  }\n\n  int suspiciously_read2_trylock_bad(int b, int new_value) {\n    if (b) {\n      std::unique_lock<std::mutex> g(mutex_);\n      suspiciously_read2 = new_value;\n      return 0;\n    } else {\n      std::unique_lock<std::mutex> lock(mutex_, std::try_to_lock);\n      if (lock.owns_lock()) {\n        return 0;\n      } else {\n        return suspiciously_read2;\n      }\n    }\n  }\n\n  int suspiciously_read3_deferlock_bad(int b, int new_value) {\n    if (b) {\n      std::unique_lock<std::mutex> g(mutex_);\n      suspiciously_read3 = new_value;\n      return 0;\n    } else {\n      std::unique_lock<std::mutex> lock(mutex_, std::defer_lock);\n      if (lock.try_lock()) {\n        return 0;\n      } else {\n        return suspiciously_read3;\n      }\n    }\n  }\n\n private:\n  int well_guarded1;\n  int well_guarded2;\n  int suspiciously_read1;\n  int suspiciously_read2;\n  int suspiciously_read3;\n  int suspiciously_written;\n  int not_guarded1;\n  int not_guarded2;\n  std::mutex mutex_;\n};\n} // namespace basics\n"
    },
    {
      "testname": "without_mutex.cpp",
      "testlanguage": "c++",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <mutex>\n\nnamespace without_mutex {\n\nclass WithoutMutex {\n public:\n  WithoutMutex() {}\n\n  int get_bad() { return field; }\n\n  int set_bad(std::mutex& mutex, int data) {\n    std::lock_guard<std::mutex> lock(mutex);\n    field = data;\n  }\n\n private:\n  int field;\n};\n} // namespace without_mutex\n"
    },
    {
      "testname": "AbstractOwnership.java",
      "testlanguage": "java",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport com.facebook.infer.annotation.ReturnsOwnership;\nimport javax.annotation.concurrent.ThreadSafe;\n\n// no races should be reported here\n// abstract getThis should get a default summary returning conditional ownership\n\n@ThreadSafe\nabstract class Component {\n  abstract static class Builder<T extends Builder<T>> {\n    abstract T getThis();\n\n    private int i;\n\n    public T set(int i) {\n      this.i = i;\n      return getThis();\n    }\n\n    public T background() {\n      return getThis();\n    }\n\n    @ReturnsOwnership\n    abstract Component build();\n  }\n}\n\n@ThreadSafe\nclass Column extends Component {\n  static Component onCreateLayoutOk() {\n    Component.Builder<?> builder = ColumnBuilder.create().background();\n    return builder.set(0).build();\n  }\n\n  static class ColumnBuilder extends Component.Builder<ColumnBuilder> {\n    static ColumnBuilder create() {\n      return new ColumnBuilder();\n    }\n\n    @Override\n    ColumnBuilder getThis() {\n      return this;\n    }\n\n    @Override\n    Column build() {\n      return new Column();\n    }\n  }\n}\n"
    },
    {
      "testname": "Alias.java",
      "testlanguage": "java",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport javax.annotation.concurrent.ThreadSafe;\n\n@ThreadSafe\nclass Alias {\n  A a, b;\n\n  public void foo() {\n    int x;\n    synchronized (this) {\n      a = b;\n      a.f = 101;\n    }\n    x = b.f; // may_alias\n  }\n\n  public void bar(A a, A b) {\n    int x;\n    synchronized (this) {\n      a.f = 101;\n    }\n    x = b.f; // no may_alias needed, argument treatment suffices\n  }\n}\n\nclass A {\n  int f = 0;\n}\n"
    },
    {
      "testname": "AndroidModels.java",
      "testlanguage": "java",
      "expected-problems": 19,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.os.IBinder;\nimport android.os.IInterface;\nimport android.util.DisplayMetrics;\nimport android.view.View;\nimport javax.annotation.concurrent.ThreadSafe;\n\n// aidl generated classes implementing this interface are automatically threadsafe\ninterface AidlInterface extends IInterface {}\n\nclass MyActivity extends Activity {}\n\nclass MyResources extends Resources {\n\n  public MyResources(AssetManager assets, DisplayMetrics metrics, Configuration config) {\n    super(assets, metrics, config);\n  }\n}\n\nclass MyView extends View {\n\n  boolean mField;\n\n  public MyView(Context c) {\n    super(c);\n  }\n}\n\n@ThreadSafe\npublic class AndroidModels {\n\n  Resources mResources;\n  MyResources mMyResources;\n\n  Object mField;\n\n  // assume that some Resources methods are annotated with @Functional\n  public void resourceMethodFunctionalOk() {\n    mField = mResources.getString(0);\n  }\n\n  // and subclasses of Resources too\n  public void customResourceMethodFunctionalOk() {\n    mField = mResources.getString(0);\n  }\n\n  // but not all of them\n  public void someResourceMethodsNotFunctionalBad() {\n    // configuration can change whenever the device rotates\n    mField = mResources.getConfiguration();\n  }\n\n  public void findViewByIdOk1(MyView view) {\n    MyView subview = (MyView) view.findViewById(-1);\n    subview.mField = true; // ok;\n  }\n\n  public void findViewByIdOk2(MyActivity activity) {\n    MyView view = (MyView) activity.findViewById(-1);\n    view.mField = true; // ok;\n  }\n\n  public IBinder safeByDefaultInterfaceCallOk(AidlInterface i) {\n    return i.asBinder();\n  }\n}\n"
    },
    {
      "testname": "Annotations.java",
      "testlanguage": "java",
      "expected-problems": 124,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport android.support.annotation.UiThread;\nimport com.facebook.infer.annotation.Functional;\nimport com.facebook.infer.annotation.Initializer;\nimport com.facebook.infer.annotation.ReturnsOwnership;\nimport com.facebook.infer.annotation.SynchronizedCollection;\nimport com.facebook.infer.annotation.ThreadConfined;\nimport com.facebook.infer.annotation.ThreadSafe;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/** tests for classes and method annotations that are meaningful w.r.t thread-safety */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface OnBind {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface OnEvent {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface OnMount {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface OnUnbind {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface OnUnmount {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface MyThreadSafeAlias1 {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface MyThreadSafeAlias2 {}\n\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.CLASS)\n@interface InjectProp {}\n\ninterface Interface {\n\n  @Functional\n  Object functionalMethod();\n\n  @ReturnsOwnership\n  Obj returnsOwnershipMethod();\n}\n\n@ThreadSafe(enableChecks = false)\nclass AssumedThreadSafe {\n\n  Object field;\n\n  public void writeOk() {\n    this.field = new Object();\n  }\n}\n\n// this annotation is defined as an alias for @ThreadSafe in .inferconfig\nclass ThreadSafeAlias {\n  Object field;\n\n  @MyThreadSafeAlias1\n  void threadSafeAliasBad1() {\n    this.field = new Object();\n  }\n\n  @MyThreadSafeAlias2\n  void threadSafeAliasBad2() {\n    this.field = new Object();\n  }\n}\n\n@ThreadSafe\nclass Annotations implements Interface {\n  Object f;\n  boolean b;\n\n  @UiThread\n  public void setF(Object newF) {\n    this.f = newF; // shouldn't report here\n  }\n\n  public void callSetFOnMethodOk(Annotations obj) {\n    obj.setF(new Object()); // or here\n  }\n\n  public void mutateOffUiThreadBad() {\n    this.f = new Object();\n  }\n\n  // anything annotated with OnEvent is modeled as running on the UI thread, should not warn\n  @OnEvent\n  public void onClick() {\n    this.f = new Object();\n  }\n\n  Confined con;\n\n  public void confinedCallerOk() {\n    con.foo();\n  }\n\n  public void writeFieldOfConfinedClassOk() {\n    con.x = 7;\n  }\n\n  @ThreadConfined(ThreadConfined.UI)\n  class Confined {\n    Integer x;\n\n    void foo() {\n      x = 22;\n    }\n  }\n\n  @ThreadConfined(ThreadConfined.ANY)\n  Obj encapsulatedField;\n\n  public void mutateConfinedFieldDirectlyOk() {\n    this.encapsulatedField = new Obj();\n  }\n\n  public static void mutateConfinedFieldIndirectlyOk(Annotations a) {\n    a.encapsulatedField = new Obj();\n  }\n\n  public void mutateSubfieldOfConfinedBad() {\n    this.encapsulatedField.f = new Object();\n  }\n\n  Integer zz;\n\n  @ThreadConfined(\"some_custom_string\")\n  public void threadConfinedMethodOk() {\n    this.f = new Object();\n    zz = 22;\n  }\n\n  public void read_from_non_confined_method_Bad() {\n    Integer i;\n    i = zz;\n  }\n\n  /* Like in RaceWithMainThread.java with assertMainThread() */\n  void conditional1_ok(boolean b) {\n    if (b) {\n      write_on_main_thread_ok();\n    }\n  }\n\n  Integer ii;\n\n  @ThreadConfined(ThreadConfined.UI)\n  void write_on_main_thread_ok() {\n    ii = 22;\n  }\n\n  void conditional2_bad(boolean b) {\n    if (b) {\n      write_on_main_thread_ok();\n    } else {\n      ii = 99; // this might or might not run on the main thread; warn\n    }\n  }\n\n  @OnBind\n  public void onBindMethodOk() {\n    this.f = new Object();\n  }\n\n  public void read_off_UI_thread_Bad() {\n    Object o = f;\n  }\n\n  @OnMount\n  public void onMountMethodOk() {\n    this.f = new Object();\n  }\n\n  @OnUnmount\n  public void onUnmountMethodOk() {\n    this.f = new Object();\n  }\n\n  @OnUnbind\n  public void onUnbindMethodOk() {\n    this.f = new Object();\n  }\n\n  @ThreadSafe(enableChecks = false)\n  public void assumeThreadSafeOk() {\n    this.f = new Object();\n  }\n\n  @Functional\n  native Object returnFunctional1();\n\n  @Functional\n  Object returnFunctional2() {\n    return null;\n  }\n  // marked @Functional in interface\n  @Override\n  public Object functionalMethod() {\n    return null;\n  }\n\n  Object mAssignToFunctional;\n\n  public Object functionalOk1() {\n    if (mAssignToFunctional == null) {\n      mAssignToFunctional = returnFunctional1();\n    }\n    return mAssignToFunctional;\n  }\n\n  public Object functionalOk2() {\n    if (mAssignToFunctional == null) {\n      mAssignToFunctional = returnFunctional2();\n    }\n    return mAssignToFunctional;\n  }\n\n  public Object functionalOk3() {\n    if (mAssignToFunctional == null) {\n      mAssignToFunctional = functionalMethod();\n    }\n    return mAssignToFunctional;\n  }\n\n  @Functional\n  native double returnDouble();\n\n  @Functional\n  native long returnLong();\n\n  double mDouble;\n  long mLong;\n\n  int mInt1;\n  int mInt2;\n\n  public int functionalAcrossUnboxingAndCast1Ok() {\n    if (b) {\n      mInt1 = (int) returnDouble();\n    }\n    return 0;\n  }\n\n  public int functionalAcrossUnboxingAndCast2Ok() {\n    if (b) {\n      mInt2 = (int) returnLong();\n    }\n    return 0;\n  }\n\n  // writes to doubles are not atomic on all platforms, so this is not a benign race\n  public double functionalDoubleBad() {\n    if (b) {\n      mDouble = returnDouble();\n    }\n    return 0.0;\n  }\n\n  // writes to longs are not atomic on all platforms, so this is not a benign race\n  public long functionaLongBad() {\n    if (b) {\n      mLong = returnLong();\n    }\n    return 2;\n  }\n\n  Boolean mBoxedBool;\n\n  @Functional\n  native boolean returnBool();\n\n  public boolean functionalAcrossBoxingOk() {\n    if (b) {\n      mBoxedBool = returnBool();\n    }\n    return b;\n  }\n\n  boolean mBool;\n\n  @Functional\n  native Boolean returnBoxedBool();\n\n  boolean mBool2;\n\n  public boolean FP_functionalAcrossUnboxingOk() {\n    if (b) {\n      mBool2 = returnBoxedBool();\n    }\n    return b;\n  }\n\n  Long mBoxedLong;\n\n  @Functional\n  native Long returnBoxedLong();\n\n  public int functionalBoxedLongOk() {\n    if (b) {\n      mBoxedLong = returnBoxedLong();\n    }\n    return 22;\n  }\n\n  long mLong2;\n\n  public int functionalAcrossUnboxingLongBad() {\n    if (b) {\n      mLong2 = returnBoxedLong();\n    }\n    return 2;\n  }\n\n  long mBoxedLong2;\n\n  public int FP_functionalAcrossBoxingLongOk() {\n    if (b) {\n      mBoxedLong2 = returnLong();\n    }\n    return 2;\n  }\n\n  public boolean propagateFunctional() {\n    return returnBool();\n  }\n\n  // show that we can handle indirect returns of procedures marked @Functional\n  public void propagateFunctionalOk() {\n    boolean returnedFunctional = propagateFunctional();\n    mBool = returnedFunctional;\n  }\n\n  @Functional\n  native int returnInt();\n\n  int mInt;\n\n  public void functionalAcrossLogicalOpsOk() {\n    boolean functionalBool = returnBool();\n    int functionalInt = returnInt();\n    boolean propagated = functionalBool && true || 2 < returnInt() && 3 == functionalInt;\n    mBool = propagated;\n  }\n\n  public void functionalAcrossArithmeticOpsOk() {\n    int functional = returnInt();\n    int propagated = functional + 1 - returnInt() * 7 % 2;\n    mInt = functional;\n  }\n\n  native int returnNonFunctionalInt();\n\n  public void functionalAndNonfunctionalBad() {\n    mInt = returnNonFunctionalInt() + returnInt();\n  }\n\n  @ReturnsOwnership\n  native Obj returnsOwned();\n\n  @Override\n  public native Obj returnsOwnershipMethod(); // marked @ReturnsOwnership in interface\n\n  void mutateAnnotatedOwnedOk() {\n    Obj owned = returnsOwned();\n    owned.f = new Object();\n  }\n\n  void mutateAnnotatedOverrideOwnedOk() {\n    Obj owned = returnsOwnershipMethod();\n    owned.f = new Object();\n  }\n\n  public void writeToAssumedThreadSafeClassOk(AssumedThreadSafe c) {\n    c.writeOk();\n  }\n\n  @SynchronizedCollection\n  private final Map<Object, Object> mSynchronizedMap = Collections.synchronizedMap(new HashMap());\n\n  public void synchronizedMapOk1() {\n    mSynchronizedMap.put(new Object(), new Object());\n  }\n\n  public void synchronizedMapOk2(Annotations a) {\n    a.mSynchronizedMap.put(new Object(), new Object());\n  }\n\n  public void injectPropOk(@InjectProp Obj o) {\n    o.f = 7;\n  }\n\n  Object onlyUpdatedInInitializer;\n\n  @Initializer\n  public void setOnlyUpdatedInInitializerOk(Object o) {\n    onlyUpdatedInInitializer = o;\n  }\n\n  public synchronized Object getOnlyUpdatedInInitializerOk() {\n    return onlyUpdatedInInitializer;\n  }\n}\n\n@UiThread\n@ThreadSafe\nclass AllMethodsOnUiThread {\n  int f;\n\n  void fooOk() {\n    f = 5;\n  }\n\n  int bar() {\n    return f;\n  }\n}\n\nclass ExtendsClassOnUiThread extends AllMethodsOnUiThread {\n  @Override\n  void fooOk() {\n    f = 9;\n  }\n\n  @Override\n  int bar() {\n    return super.bar();\n  }\n}\n\n// NOT All annotations that start with \"On\" are on the main thread\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\n@interface OnXYZ {}\n\n@ThreadSafe\nclass WeirdAnnotation {\n  int f;\n\n  @OnXYZ\n  void fooBad() {\n    f = 0;\n  }\n}\n"
    },
    {
      "testname": "Arrays.java",
      "testlanguage": "java",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport javax.annotation.concurrent.ThreadSafe;\n\n// Test may_alias treatment of arrays\n// two arrays of types in a subtype relation may alias, and race\n\n@ThreadSafe\nclass Parent {}\n\n@ThreadSafe\nclass Child extends Parent {}\n\n@ThreadSafe\nclass Arrays {\n  Child[] childArr = new Child[5];\n  Parent[] parentArr = childArr; // actual aliasing not required, but for documentation\n  final String[] strArr1 = new String[5];\n  final String[] strArr2 = new String[5];\n\n  void arrayParameterWriteBad(int[] name1) {\n    name1[2] = 4;\n  }\n\n  // although name1 and name2 may alias, we have no reason to think that they will. don't report\n  int FN_arrayParameterReadBad(int[] name2) {\n    return name2[2];\n  }\n\n  int arrayParameterLiteralReadOk() {\n    return (new int[] {2, 3})[1];\n  }\n\n  public void writeWriteRaceBad(String s) {\n    strArr1[2] = s;\n  }\n\n  // same array\n  public String readWriteRaceBad(String s) {\n    synchronized (this) {\n      strArr1[2] = s;\n    }\n    return strArr1[2];\n  }\n\n  // arrays are same type, but can't alias\n  public String notReadWriteRace1Ok(String s) {\n    synchronized (this) {\n      strArr1[0] = s;\n    }\n    return strArr2[0];\n  }\n\n  // arrays are compatible types and can alias\n  public Child FN_readWriteAliasRaceBad() {\n    synchronized (this) {\n      parentArr[3] = null;\n    }\n    return childArr[3];\n  }\n\n  String[] type1Arr[];\n  Parent[] type2Arr;\n\n  // arrays are different types and thus cannot alias\n  public Parent noRaceOk() {\n    synchronized (this) {\n      type1Arr[3] = null;\n    }\n\n    return type2Arr[3];\n  }\n}\n"
    },
    {
      "testname": "Builders.java",
      "testlanguage": "java",
      "expected-problems": 31,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport com.facebook.infer.annotation.ThreadSafe;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableList.Builder;\n\npublic class Builders {\n\n  static class Obj {\n    final String f;\n    String g;\n\n    public Obj(String f, String g) {\n      this.f = f;\n      this.g = g;\n    }\n\n    public static class Builder {\n      String f;\n      String g;\n\n      public Builder setFromObj(Obj input) {\n        this.f = input.f;\n        this.g = input.g;\n        return this;\n      }\n\n      public Obj build() {\n        return new Obj(f, g);\n      }\n\n      public Builder setF(String f) {\n        this.f = f;\n        return this;\n      }\n\n      public Builder setG(String g) {\n        this.g = g;\n        return this;\n      }\n    }\n  }\n\n  @ThreadSafe\n  public void guavaBuilderOk() {\n    ImmutableList.Builder<String> builder = new ImmutableList.Builder();\n    builder.add(\"foo\");\n    builder.build();\n  }\n\n  @ThreadSafe\n  public Obj customBuilderOk1() {\n    Obj.Builder builder = new Obj.Builder();\n    builder.setF(\"f\");\n    builder.setG(\"g\");\n    return builder.build();\n  }\n\n  @ThreadSafe\n  public Obj customBuilderOk2() {\n    Obj.Builder builder = new Obj.Builder();\n    return builder.setF(\"f\").setG(\"g\").build();\n  }\n\n  @ThreadSafe\n  public Obj customBuilderOk3() {\n    Obj obj = new Obj(\"a\", \"b\");\n    Obj.Builder builder = new Obj.Builder();\n    return builder.setFromObj(obj).build();\n  }\n\n  @ThreadSafe\n  public Obj mutateBad(Obj o) {\n    o.g = \"\";\n    return o;\n  }\n\n  @ThreadSafe\n  public Obj buildThenMutateBad(Obj input) {\n    Obj.Builder builder = new Obj.Builder();\n    Obj output = builder.setFromObj(input).build();\n    input.g = \"\";\n    return output;\n  }\n}\n\n@ThreadSafe\nclass TopLevelBuilder {\n  public String g;\n\n  public void setG(String g) {\n    this.g = g; // still want to warn if the builder is annotated ThreadSafe\n  }\n}\n\nclass MyBuilder {\n  Obj mObj;\n\n  public static MyBuilder create() {\n    return new MyBuilder();\n  }\n\n  public MyBuilder setNestedPath(int i) {\n    this.mObj.f = i;\n    return this;\n  }\n\n  @ThreadSafe\n  static void setNestedPathOk(int i) {\n    MyBuilder.create().setNestedPath(1);\n  }\n}\n"
    },
    {
      "testname": "Constructors.java",
      "testlanguage": "java",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport javax.annotation.concurrent.ThreadSafe;\n\n@ThreadSafe\npublic class Constructors {\n  int field;\n  static Object staticField;\n\n  public Constructors(int i) {\n    field = i; // ok\n  }\n\n  public Constructors() {\n    staticField = new Object(); // not ok;\n  }\n\n  private Constructors(Object o) {\n    staticField = o; // ok because this is private\n  }\n\n  public Constructors(Constructors o) {\n    o.field = 42; // not ok\n  }\n\n  public Constructors(String s) {\n    calledFromConstructorOk(); // ok\n  }\n\n  private void calledFromConstructorOk() {\n    this.field = 7;\n  }\n\n  public static synchronized Constructors singleton1Ok() {\n    // ok because lock is held during write to static field in constructor\n    return new Constructors(new Object());\n  }\n\n  private static Constructors sSingleton1;\n\n  public static Constructors FP_singleton2Ok() {\n    synchronized (Constructors.class) {\n      if (sSingleton1 != null) {\n        sSingleton1 = new Constructors(0);\n      }\n    }\n    return sSingleton1; // not currently smart enough to understand that this read is ok\n  }\n\n  public static Constructors singleton1Bad() {\n    // not ok because no lock is held\n    return new Constructors(new Object());\n  }\n\n  private static Constructors sSingleton2;\n\n  public static Constructors singleton2Bad() {\n    if (sSingleton2 == null) {\n      sSingleton2 = new Constructors(0);\n    }\n    return sSingleton2;\n  }\n}\n"
    },
    {
      "testname": "Containers.java",
      "testlanguage": "java",
      "expected-problems": 90,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport android.support.v4.util.Pools;\nimport android.support.v4.util.Pools.SimplePool;\nimport android.support.v4.util.Pools.SynchronizedPool;\nimport android.support.v4.util.SimpleArrayMap;\nimport android.support.v4.util.SparseArrayCompat;\nimport android.util.SparseArray;\nimport com.google.common.collect.Sets;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport javax.annotation.concurrent.ThreadSafe;\nimport javax.crypto.Mac;\n\nclass ContainerWrapper {\n  private final List<Object> children = new ArrayList<Object>();\n\n  public Object write(Object v) {\n    return _write(v);\n  }\n\n  private Object _write(Object node) {\n    children.add(node);\n    return this;\n  }\n}\n\n@ThreadSafe\nclass Containers {\n\n  List<String> mList;\n  Map<String, String> mMap;\n\n  // lists\n  void listAddBad1(String s) {\n    mList.add(s);\n  }\n\n  void listAddBad2(int index, String s) {\n    mList.add(index, s);\n  }\n\n  void listAddAllBad(Collection<String> c) {\n    mList.addAll(c);\n  }\n\n  void listClearBad() {\n    mList.clear();\n  }\n\n  void listRemoveBad1(int index) {\n    mList.remove(index);\n  }\n\n  void listRemoveBad2(String s) {\n    mList.remove(s);\n  }\n\n  void listRemoveAllBad(Collection<String> c) {\n    mList.removeAll(c);\n  }\n\n  void listSetBad(int index, String s) {\n    mList.set(index, s);\n  }\n\n  void listSubclassWriteBad(ArrayList<String> list, int index) {\n    list.remove(index);\n  }\n\n  List mListNobodyWrites;\n\n  void listReadOk(int index, String s) {\n    mListNobodyWrites.contains(s);\n    mListNobodyWrites.get(index);\n    mListNobodyWrites.isEmpty();\n    mListNobodyWrites.size();\n  }\n\n  List mListSyncWrites;\n\n  synchronized void listSyncAddBad(String s) {\n    mListSyncWrites.add(s);\n  }\n\n  boolean listReadBad(String s) {\n    return mListSyncWrites.contains(s);\n  }\n\n  void accessSafeListOk(CopyOnWriteArrayList list, int index) {\n    list.remove(index);\n  }\n\n  // maps\n  void mapPutBad(String key, String value) {\n    mMap.put(key, value);\n  }\n\n  void mapRemoveBad(String key) {\n    mMap.remove(key);\n  }\n\n  void mapClearBad() {\n    mMap.clear();\n  }\n\n  void mapPutAllBad(Map<String, String> otherMap) {\n    mMap.putAll(otherMap);\n  }\n\n  Map<String, String> mMapNobodyWrites;\n\n  void mapReadsOk(String s) {\n    mMapNobodyWrites.containsKey(s);\n    mMapNobodyWrites.containsValue(s);\n    mMapNobodyWrites.entrySet();\n    mMapNobodyWrites.hashCode();\n    mMapNobodyWrites.isEmpty();\n    mMapNobodyWrites.keySet();\n    mMapNobodyWrites.size();\n    mMapNobodyWrites.values();\n  }\n\n  // make sure we still warn on subtypes of Map\n  void mapSubclassWriteBad(HashMap<String, String> m, String key) {\n    m.remove(key);\n  }\n\n  synchronized void synchronizedWriteOk1(String key) {\n    mMap.remove(key);\n  }\n\n  void synchronizedWriteOk2(String key, String lock) {\n    synchronized (lock) {\n      mMap.remove(key);\n    }\n  }\n\n  void accessToSychronizedMapsOk(\n      String key,\n      ConcurrentMap<String, String> concurrentMap,\n      ConcurrentHashMap<String, String> concurrentHashMap) {\n\n    concurrentMap.remove(key);\n    concurrentHashMap.remove(key);\n  }\n\n  public void containerWrapperOwnedWriteOk(Object o) {\n    ContainerWrapper wrapper = new ContainerWrapper();\n    wrapper.write(o);\n  }\n\n  ContainerWrapper mContainerWrapper;\n\n  public void containerWrapperUnownedWriteBad(Object o) {\n    mContainerWrapper.write(o);\n  }\n\n  static SynchronizedPool<Obj> sPool;\n\n  void poolAcquireOk() {\n    Obj obj = sPool.acquire();\n    obj.f = new Object();\n  }\n\n  void poolAcquireThenNullCheckOk() {\n    Obj obj = sPool.acquire();\n    if (obj == null) {\n      obj = new Obj();\n    }\n    obj.f = new Object();\n  }\n\n  static boolean sUsePooling;\n\n  private Obj poolWrapper1() {\n    Obj obj = sUsePooling ? sPool.acquire() : null;\n    if (obj == null) {\n      obj = new Obj();\n    }\n\n    return obj;\n  }\n\n  void poolWrapperOk1() {\n    Obj obj = poolWrapper1();\n    obj.f = new Object();\n  }\n\n  private Pools.Pool<Obj> mPool;\n  private boolean mIsSync;\n\n  private Obj poolWrapper2() {\n    Obj item;\n    if (mIsSync) {\n      synchronized (this) {\n        item = mPool.acquire();\n      }\n    } else {\n      item = mPool.acquire();\n    }\n    return item;\n  }\n\n  void poolWrapperOk2() {\n    Obj obj = poolWrapper2();\n    obj.f = new Object();\n  }\n\n  // need to understand semantics of release to get this one\n  void FN_poolReleaseThenWriteBad() {\n    Obj obj = sPool.acquire();\n    sPool.release(obj);\n    obj.f = new Object(); // should flag\n  }\n\n  void release(Obj o) {\n    sPool.release(o);\n  }\n\n  // we won't catch this without a fancier ownership domain\n  void FN_poolReleaseThenWriteInterprocBad() {\n    Obj obj = sPool.acquire();\n    release(obj);\n    obj.f = new Object(); // should flag\n  }\n\n  private static List addOrCreateList(List list) {\n    if (list == null) {\n      list = new ArrayList<>();\n    }\n    // we get list |->  ({ OwnedIf (0) } |_| { Owned }) here, which simplifies to list |-> {} due\n    // to limitations in AttributeMapDomain (join is just simple intersection)\n    list.add(new Object());\n    return list;\n  }\n\n  public void addToNullListOk() {\n    List list = null;\n    addOrCreateList(list);\n  }\n\n  void addToSparseArrayCompatOk() {\n    SparseArrayCompat sparseArray = new SparseArrayCompat();\n    sparseArray.put(0, new Object());\n  }\n\n  public void addToSparseArrayCompatBad(SparseArrayCompat sparseArray) {\n    sparseArray.put(0, new Object());\n  }\n\n  public void addToSparseArrayOk() {\n    SparseArray sparseArray = new SparseArray();\n    sparseArray.put(0, new Object());\n  }\n\n  public void addToSparseArrayBad(SparseArray sparseArray) {\n    sparseArray.put(0, new Object());\n  }\n\n  SimpleArrayMap<Integer, Integer> si_map = new SimpleArrayMap<Integer, Integer>();\n\n  public synchronized void addToSimpleArrayMapOk() {\n    si_map.put(1, 1);\n  }\n\n  public void addToSimpleArrayMapBad(SimpleArrayMap<Integer, Integer> map) {\n    map.put(1, 1);\n  }\n\n  // this should be a read/write race with addToSimpleArrayMapOk\n  public int readSimpleArrayMap() {\n    return si_map.get(1);\n  }\n\n  SimplePool<Integer> simplePool = new SimplePool<Integer>(10);\n\n  public synchronized Integer getFromPoolOK() {\n    return simplePool.acquire();\n  }\n\n  public void poolBad() {\n    Integer a;\n    synchronized (this) {\n      a = simplePool.acquire();\n    }\n    simplePool.release(a);\n  }\n\n  Map<String, String> mAliasedMap;\n\n  // won't report here because the read happens through an alias\n  public String FN_AliasedMapBad() {\n    synchronized (this) {\n      mAliasedMap.put(\"a\", \"b\");\n    }\n    Map<String, String> alias = mAliasedMap;\n    return alias.get(\"a\");\n  }\n\n  Map<String, String> mConcurrentMap = new ConcurrentHashMap<String, String>();\n\n  void dynamicallyTypedConcurrentMapPutOk(String key, String value) {\n    mConcurrentMap.put(key, value);\n  }\n\n  List<String> mSomeList = new ArrayList<String>();\n\n  void addToUnsynchronizedListBad(String value) {\n    mSomeList.add(value);\n  }\n\n  List<String> mSomeOtherList = new ArrayList<String>();\n\n  int getListSizeBad() {\n    return mSomeOtherList.size();\n  }\n\n  synchronized void raceWithSizeBad(String value) {\n    mSomeOtherList.remove(value);\n  }\n\n  Map<String, String> mSomeMap = new HashMap<String, String>();\n\n  int getMapSizeBad() {\n    return mSomeMap.size();\n  }\n\n  synchronized void raceWithMapSizeBad(String value) {\n    mSomeMap.remove(value);\n  }\n\n  Map<String, String> mSomeOtherMap = new Hashtable<String, String>();\n\n  void writeToHashtableOk(String value) {\n    mSomeOtherMap.remove(value);\n  }\n\n  Set<String> mConcurrentSet = new ConcurrentSkipListSet<String>();\n\n  void dynamicallyTypedConcurrentSetAddOk(String value) {\n    mConcurrentSet.add(value);\n  }\n\n  List<String> mWrappedList = Collections.synchronizedList(new ArrayList<String>());\n\n  void wrappedListAddOk(String value) {\n    mWrappedList.add(value);\n  }\n\n  Set<String> mGoogleSynchronizedSet = Sets.newConcurrentHashSet();\n\n  void googleSynchronizedSetAddOk(String value) {\n    mGoogleSynchronizedSet.add(value);\n  }\n\n  Mac mac = null;\n\n  void raceOnMacInitBad(Key key) throws InvalidKeyException {\n    mac.init(key);\n  }\n\n  void raceOnMacUpdateBad(byte[] bytes) {\n    mac.update(bytes);\n  }\n\n  byte[] raceOnMacDoFinalBad() {\n    return mac.doFinal();\n  }\n\n  static Set<Integer> staticSyncSet = new ConcurrentSkipListSet<Integer>();\n\n  static void staticAddToSyncIntegerSetOk(int s) {\n    staticSyncSet.add(s);\n  }\n\n  ConcurrentLinkedDeque<Object> deque;\n\n  void addToDequeOk(Object o) {\n    deque.add(o);\n  }\n\n  Object popDequeOk() {\n    return deque.pop();\n  }\n}\n"
    },
    {
      "testname": "DeepOwnership.java",
      "testlanguage": "java",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport com.facebook.infer.annotation.ThreadSafe;\n\n@ThreadSafe\nclass DeepOwnership {\n  DeepOwnership next;\n  static DeepOwnership global;\n\n  void globalNotOwnedBad() {\n    global.next = null;\n  }\n\n  void FN_reassignBaseToGlobalBad() {\n    DeepOwnership x = new DeepOwnership();\n    x = global;\n    x.next = null;\n  }\n\n  void FN_reassignPathToGlobalBad() {\n    DeepOwnership x = new DeepOwnership();\n    x.next = global;\n    x.next.next = null;\n  }\n\n  void deepIntraOk() {\n    DeepOwnership x = new DeepOwnership();\n    x.next.next = null; // doesn't warn here\n  }\n\n  void deepInterOk() {\n    DeepOwnership x = new DeepOwnership();\n    deepPrivate(x.next);\n  }\n\n  private void deepPrivate(DeepOwnership y) {\n    y.next = null;\n  }\n\n  DeepOwnership deepFromOwnedThisOk() {\n    return new DeepOwnership();\n  }\n\n  DeepOwnership arr[];\n\n  DeepOwnership() {\n    next.next = null;\n    arr[0] = null;\n  }\n\n  private void loseOwnershipOfNext() {\n    synchronized (this) {\n      this.next = global;\n    }\n  }\n\n  void FN_loseOwnershipInCalleeBad() {\n    DeepOwnership x = new DeepOwnership();\n    x.next = new DeepOwnership();\n    loseOwnershipOfNext();\n    x.next.next = null; // doesn't warn here\n  }\n}\n"
    },
    {
      "testname": "Dispatch.java",
      "testlanguage": "java",
      "expected-problems": 39,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport com.facebook.infer.annotation.ThreadConfined;\nimport com.facebook.infer.annotation.ThreadSafe;\n\ninterface UnannotatedInterface {\n  public void foo();\n}\n\n@ThreadSafe\ninterface AnnotatedInterface {\n  public void foo();\n}\n\ninterface AnnotatedInterfaceMethod {\n\n  @ThreadSafe\n  public void foo();\n}\n\nclass NotThreadSafe {\n  void notThreadSafeOk(UnannotatedInterface i) {\n    i.foo(); // ok\n  }\n}\n\n@ThreadConfined(ThreadConfined.ANY)\ninterface ThreadConfinedInterface {\n  void foo();\n}\n\ninterface ThreadConfinedMethod {\n\n  @ThreadConfined(ThreadConfined.ANY)\n  void foo();\n}\n\n@ThreadSafe\npublic class Dispatch {\n\n  void callUnannotatedInterfaceBad(UnannotatedInterface i) {\n    i.foo();\n  }\n\n  void callUnannotatedInterfaceIndirectBad(NotThreadSafe s, UnannotatedInterface i) {\n    s.notThreadSafeOk(i);\n  }\n\n  synchronized void callUnannotatedInterfaceUnderLockOk(NotThreadSafe s, UnannotatedInterface i) {\n    s.notThreadSafeOk(i);\n  }\n\n  void callAnnotatedInterfaceOk(AnnotatedInterface i) {\n    i.foo();\n  }\n\n  void callAnnotatedInterfaceMethodOk(AnnotatedInterfaceMethod i) {\n    i.foo();\n  }\n\n  void callThreadConfinedInterfaceOk(ThreadConfinedInterface t) {\n    t.foo();\n  }\n\n  void callThreadConfinedInterfaceMethodOk(ThreadConfinedMethod t) {\n    t.foo();\n  }\n\n  public void callUnderLock(AnnotatedInterface i) {\n    synchronized (this) {\n      i.foo();\n    }\n  }\n\n  private void privateCallUnnanotatedInterfaceOk(UnannotatedInterface i) {\n    i.foo();\n  }\n\n  public void callOwnedUnnanotatedInterfaceOk() {\n    UnannotatedInterface owned = new UnannotadedImplementation();\n    privateCallUnnanotatedInterfaceOk(owned);\n  }\n\n  UnannotatedInterface mUnannotated;\n\n  private void privateCallOk() {\n    mUnannotated.foo();\n  }\n\n  public void publicCallBad() {\n    privateCallOk();\n  }\n\n  public Dispatch() {\n    // this is OK even though public, since the object is owned\n    privateCallOk();\n  }\n}\n\nclass Some {\n\n  void callFromElsewhere(Dispatch d, AnnotatedInterface i) {\n    d.callUnderLock(i);\n  }\n}\n\n@ThreadSafe\nclass ThreadConfinedField {\n  @ThreadConfined(ThreadConfined.ANY)\n  UnannotatedInterface mThreadConfined;\n\n  UnannotatedInterface mNormal;\n\n  void interfaceCallOnThreadConfinedFieldOk() {\n    mThreadConfined.foo();\n  }\n\n  void interfaceCallOnNormalFieldBad() {\n    mNormal.foo();\n  }\n}\n\nclass UnannotadedImplementation implements UnannotatedInterface {\n  public void foo() {}\n}\n"
    },
    {
      "testname": "DoNotReport.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage com.racerd.donotreport;\n\nimport com.facebook.infer.annotation.ThreadSafe;\n\n@ThreadSafe\nclass DoNotReport {\n\n  int mFld;\n\n  // normally we would report this, but we won't because com.racerd.donotreport is block listed in\n  // .inferconfig\n  void obviousRaceBad(int i) {\n    mFld = i;\n  }\n}\n"
    },
    {
      "testname": "Escape.java",
      "testlanguage": "java",
      "expected-problems": 41,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\n@ThreadSafe\npublic class Escape {\n\n  private Obj mField;\n  private static Obj sGlobal;\n\n  // this can race with unsafe writes to mField.f\n  public synchronized Object racyRead1() {\n    return mField.f;\n  }\n\n  // this can race with unsafe writes to mField.f\n  public synchronized Object racyRead2() {\n    return sGlobal.f;\n  }\n\n  public void FN_fieldEscapeBad() {\n    Obj o = new Obj();\n    synchronized (this) {\n      mField = o;\n    }\n    o.f = new Object(); // not safe\n  }\n\n  public void FN_globalEscapeBad() {\n    Obj o = new Obj();\n    synchronized (Escape.class) {\n      sGlobal = o;\n    }\n    o.f = new Object(); // not safe\n  }\n\n  public synchronized void escapeInCallee(Obj o) {\n    mField = o;\n  }\n\n  public void FN_escapeInCalleeBad() {\n    Obj o = new Obj();\n    escapeInCallee(o);\n    o.f = new Object();\n  }\n\n  public void aliasOk() {\n    Obj o = new Obj(); // though there's two pointers to this address, neither escapes\n    Obj alias = o;\n    o.f = null;\n    alias.f = null;\n  }\n\n  public void nonAliasReadOk() {\n    Obj o = new Obj();\n    String s = o + \"a\";\n    o.f = null; // ok\n  }\n\n  public void FN_escapeViaAliasBad1() {\n    Obj o = new Obj();\n    Obj alias = o;\n    escapeInCallee(alias);\n    o.f = null; // bad\n    alias.f = null; // bad\n  }\n\n  public void FN_escapeViaAliasBad2() {\n    Obj o = new Obj();\n    Obj alias = o;\n    escapeInCallee(o);\n    o.f = null; // bad\n    alias.f = null; // bad\n  }\n\n  public Obj id(Obj o) {\n    return o;\n  }\n\n  public void FN_aliasViaReturnBad1() {\n    Obj o = new Obj();\n    Obj alias = id(o);\n    escapeInCallee(alias);\n    o.f = null; // bad\n    alias.f = null; // bad\n  }\n\n  public void FN_aliasViaReturnBad2() {\n    Obj o = new Obj();\n    Obj alias = id(o);\n    escapeInCallee(o);\n    o.f = null; // bad\n    alias.f = null; // bad\n  }\n\n  private void twoParamsOneEscapes(Obj o1, Obj o2) {\n    synchronized (Escape.class) {\n      sGlobal = o1;\n    }\n    o1.f = null; // only safe if o1/o2 not aliased\n  }\n\n  public void FN_aliasedParamsBad() {\n    Obj o = new Obj();\n    twoParamsOneEscapes(o, o); // should report racy write in callee\n    o.f = null; // bad\n  }\n\n  public void nonAliasedParamsOk() {\n    Obj o1 = new Obj();\n    Obj o2 = new Obj();\n    twoParamsOneEscapes(o1, o2);\n    o2.f = null; // ok\n  }\n}\n\n@ThreadSafe\nclass Leaky {\n\n  Leaky mLeak;\n  Object mField;\n  Object sGlobal;\n\n  public Leaky() {\n    mLeak = this;\n  }\n\n  public void FN_leakyConstructorBad() {\n    Leaky l = new Leaky();\n    synchronized (Leaky.class) {\n      sGlobal = l.mLeak; // oops, this leaks l\n    }\n    l.mField = 1; // bad\n  }\n}\n"
    },
    {
      "testname": "GuardedByTests.java",
      "testlanguage": "java",
      "expected-problems": 56,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport com.facebook.infer.annotation.ThreadSafe;\nimport com.google.common.annotations.VisibleForTesting;\nimport javax.annotation.concurrent.GuardedBy;\n\npublic class GuardedByTests {\n  private Object mlock = new Object();\n\n  @GuardedBy(\"mLock\")\n  private int a;\n\n  public GuardedByTests() {\n    // don't warn on reads or writes of Guarded fields in constructor\n    a = 0;\n  }\n\n  public void lockedWriteOk() {\n    synchronized (mlock) {\n      a = 0;\n    }\n  }\n\n  @GuardedBy(\"mLock\")\n  private int b;\n\n  public void unlockedWriteBad() {\n    b = 0;\n  }\n\n  @GuardedBy(\"mLock\")\n  private int c;\n\n  public int unlockedReadOk() {\n    return c;\n  }\n\n  public int lockedReadOk() {\n    synchronized (mlock) {\n      return c;\n    }\n  }\n\n  @GuardedBy(\"mLock\")\n  private int d;\n\n  private void privateUnlockedWriteOk() {\n    d = 0;\n  }\n\n  public void interprocUnlockedWriteBad() {\n    privateUnlockedWriteOk();\n  }\n\n  @GuardedBy(\"mLock\")\n  private int e;\n\n  private int privateUnlockedReadOk() {\n    return e;\n  }\n\n  public int interprocUnlockedReadOk() {\n    return privateUnlockedReadOk();\n  }\n\n  @GuardedBy(\"mLock\")\n  private int f;\n\n  // NB ThreadSafe annotation disables GuardedBy check too\n  @ThreadSafe(enableChecks = false)\n  void suppressedWrite() {\n    f = 0;\n  }\n\n  @GuardedBy(\"mLock\")\n  private int h;\n\n  @VisibleForTesting\n  public void visibleForTestingOk() {\n    h = 0;\n  }\n\n  static Object slock = new Object();\n\n  @GuardedBy(\"slock\")\n  static int sf;\n\n  static {\n    // don't warn on class initializer\n    sf = 0;\n  }\n\n  @GuardedBy(\"this\")\n  int i;\n\n  synchronized void syncWriteOk() {\n    i = 5;\n  }\n\n  synchronized int syncReadOk() {\n    return i;\n  }\n\n  GuardedByOther o;\n\n  void accessThroughMemberObjectOk() {\n    o.accessBad();\n  }\n\n  void accessIndirectOk(GuardedByOther o) {\n    o.accessBad();\n  }\n}\n\nclass GuardedByOther {\n  @GuardedBy(\"bla\")\n  int x;\n\n  void accessBad() {\n    x = 0;\n  }\n}\n\nclass GuardedByUiThread {\n  @GuardedBy(\"UiThReAd\")\n  int a;\n\n  @GuardedBy(\"ui-thread\")\n  int b;\n\n  @GuardedBy(\"UI thread\")\n  int c;\n\n  @GuardedBy(\"UI_THREAD\")\n  int d;\n\n  void uithreadOk() {\n    a = b = c = d = 0;\n  }\n}\n"
    },
    {
      "testname": "Ignored.java",
      "testlanguage": "java",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\npackage codetoanalyze.java.racerd;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\n@ThreadSafe\nclass Ignored {\n  IgnoredSub s;\n\n  void zeroOk() {\n    s.zeroOk();\n  }\n}\n\n@ThreadSafe\nclass IgnoredSub {\n  int i;\n\n  void zeroOk() {\n    i = 0;\n  }\n\n  int getOk() {\n    return i;\n  }\n}\n"
    },
    {
      "testname": "Inference.java",
      "testlanguage": "java",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\n// test that we can infer when code needs to be thread-safe even without annotations\npublic class Inference {\n\n  int mField1;\n\n  synchronized void writeUnderLock1Ok() {\n    mField1 = 1;\n  }\n\n  // should report because there's a write in a method that we think can run on multiple threads\n  int unprotectedRead1Bad() {\n    int ret = mField1;\n    return ret;\n  }\n\n  int mField2;\n\n  void writeUnderLock2Ok() {\n    synchronized (this) {\n      mField2 = 2;\n    }\n  }\n\n  int unprotectedRead2Bad() {\n    int ret = mField2;\n    return ret;\n  }\n\n  // TODO: handle these casely separately, since assuming that any method whose (transitive) callee\n  // uses a lock can run on multiple threads may cause a lot of false positives\n  int mField3;\n\n  // empty call that uses a lock\n  private synchronized void useLock() {}\n\n  int useLockInCalleeThenReadBad() {\n    useLock();\n    return mField3;\n  }\n\n  void FN_writeToFieldWrittenInLockUsingMethodBad() {\n    mField3 = 3;\n  }\n\n  int mField4;\n  int mField5;\n\n  synchronized int readInsideSyncCoincidentally() {\n    mField4 = 4; // we will assume this needs to be protected...\n    int ret = mField5; // ...but not this\n    return ret;\n  }\n\n  int read4OutsideSyncBad() {\n    int ret = mField4; // report\n    return ret;\n  }\n\n  void write5OutsideSyncOk() {\n    mField5 = 5; // don't report\n  }\n}\n"
    },
    {
      "testname": "Locks.java",
      "testlanguage": "java",
      "expected-problems": 94,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport javax.annotation.concurrent.ThreadSafe;\n\n@ThreadSafe\npublic class Locks {\n  Integer f;\n\n  Lock mLock;\n  ReadWriteLock mReadWriteLock;\n  ReentrantLock mReentrantLock;\n  ReentrantReadWriteLock mReentrantReadWriteLock;\n\n  // we allow this for now\n  public void FN_lockInOneBranchBad(boolean b) {\n    if (b) {\n      mLock.lock();\n    }\n    f = 24;\n    if (b) {\n      mLock.unlock();\n    }\n  }\n\n  public void afterUnlockBad() {\n    mLock.lock();\n    mLock.unlock();\n    f = 42;\n  }\n\n  public void afterReentrantLockUnlockBad() {\n    mReentrantLock.lock();\n    mReentrantLock.unlock();\n    f = 42;\n  }\n\n  public void afterWriteLockUnlockBad() {\n    mReentrantReadWriteLock.writeLock().lock();\n    mReentrantReadWriteLock.writeLock().unlock();\n    f = 42;\n  }\n\n  public void lockOk() {\n    mLock.lock();\n    f = 42;\n    mLock.unlock();\n  }\n\n  public void lockBothBranchesOk(boolean b) {\n    if (b) {\n      mLock.lock();\n    } else {\n      mLock.lock();\n    }\n    f = 42;\n    mLock.unlock();\n  }\n\n  public void reentrantLockOk() {\n    mReentrantLock.lock();\n    f = 42;\n    mReentrantLock.unlock();\n  }\n\n  public void normalLockTryLockOk() {\n    if (mLock.tryLock()) {\n      f = 42;\n      mLock.unlock();\n    }\n  }\n\n  public void reentrantLockTryLockOk() {\n    if (mReentrantLock.tryLock()) {\n      f = 42;\n      mReentrantLock.unlock();\n    }\n  }\n\n  public void tryLockNoCheckBad() {\n    mReentrantLock.tryLock(); // might return false\n    f = 42;\n  }\n\n  public void tryLockWrongBranchBad() {\n    if (mReentrantLock.tryLock()) {\n    } else {\n      f = 42;\n    }\n  }\n\n  public void tryLockPropagateOk() {\n    boolean result = mReentrantLock.tryLock();\n    boolean copy = result;\n    if (copy) {\n      f = 42;\n    }\n  }\n\n  public void negatedReentrantLockTryLockBad() {\n    if (!mReentrantLock.tryLock()) {\n      f = 42;\n    }\n  }\n\n  public void negatedReentrantLockTryLockOk() {\n    if (!mReentrantLock.tryLock()) {\n\n    } else {\n      f = 42;\n    }\n  }\n\n  // we could catch this by invalidating the choice predicates whenever we update the lock domain\n  public void FN_tryLockStaleBad() {\n    boolean result = mReentrantLock.tryLock();\n    mReentrantLock.unlock();\n    if (result) {\n      f = 42; // oops, actually not safe\n    }\n  }\n\n  public void reentrantLockInterruptiblyOk() throws InterruptedException {\n    mReentrantLock.lockInterruptibly();\n    f = 42;\n    mReentrantLock.unlock();\n  }\n\n  private void acquireLock() {\n    mLock.lock();\n  }\n\n  public void acquireLockInCalleeOk() {\n    acquireLock();\n    f = 42;\n    mLock.unlock();\n  }\n\n  public void writeLockOk() {\n    mReadWriteLock.writeLock().lock();\n    f = 42;\n    mReadWriteLock.writeLock().unlock();\n  }\n\n  public void reentrantWriteLockOk() {\n    mReentrantReadWriteLock.writeLock().lock();\n    f = 42;\n    mReentrantReadWriteLock.writeLock().unlock();\n  }\n\n  private void releaseLock() {\n    mLock.unlock();\n  }\n\n  void nested1Ok() {\n    synchronized (this) {\n      synchronized (this) {\n      }\n      // a bad abstraction of locks will treat this as unlocked...\n      f = 32;\n    }\n  }\n\n  void nested2Ok() {\n    synchronized (this) {\n      synchronized (this) {\n        f = 32;\n      }\n    }\n  }\n\n  void nested3Ok() {\n    synchronized (this) {\n      f = 32;\n      synchronized (this) {\n      }\n    }\n  }\n\n  void nested1Bad() {\n    synchronized (this) {\n      synchronized (this) {\n      }\n    }\n    f = 32;\n  }\n\n  void nested2Bad() {\n    synchronized (this) {\n    }\n    f = 32;\n    synchronized (this) {\n    }\n  }\n\n  void nested3Bad() {\n    synchronized (this) {\n    }\n    synchronized (this) {\n    }\n    f = 32;\n  }\n\n  void useLock() {\n    synchronized (this) {\n    }\n  }\n\n  void useLockInCalleeBad() {\n    useLock();\n    f = 32;\n  }\n\n  void lockInLoopOk(int i) {\n    while (i > 0) {\n      i++;\n      mLock.lock();\n    }\n    f = 32;\n  }\n\n  void unlockInLoopOk(int i) {\n    mLock.lock();\n    while (i > 0) {\n      i++;\n      mLock.unlock();\n    }\n    f = 32;\n  }\n\n  void lockInLoopLexicalBad(int i) {\n    while (i > 0) {\n      i++;\n      synchronized (this) {\n      }\n    }\n    f = 32;\n  }\n\n  void lockInLoopLexicalOk(int i) {\n    while (i > 0) {\n      i++;\n      synchronized (this) {\n        f = 32;\n      }\n    }\n  }\n\n  void loopInLockLexicalBad(int i) {\n    synchronized (this) {\n      while (i > 0) {\n        i++;\n      }\n      f = 32;\n    }\n  }\n\n  public void unlockOneLockOk() {\n    mLock.lock();\n    mReentrantLock.lock();\n    mReentrantLock.unlock();\n    f = 42;\n    mLock.unlock();\n  }\n\n  // ... or here\n  public void FN_releaseLockInCalleeBad() {\n    mLock.lock();\n    releaseLock();\n    f = 42;\n  }\n\n  // we shouldn't be able to write when holding a readLock\n  public void FN_readLockOk() {\n    mReentrantReadWriteLock.readLock().lock();\n    f = 42;\n    mReentrantReadWriteLock.readLock().unlock();\n  }\n\n  boolean mField;\n\n  boolean readUnderLockOk() {\n    synchronized (this) {\n      return mField;\n    }\n  }\n\n  void writeUnderLockOk() {\n    synchronized (this) {\n      mField = true;\n    }\n  }\n\n  boolean readOutsideLock1Bad() {\n    synchronized (this) {\n    }\n    return mField;\n  }\n\n  boolean readOutsideLock2Bad() {\n    boolean tmp = mField;\n    synchronized (this) {\n    }\n    return tmp;\n  }\n\n  public boolean readInTryCatchWithLockOk() {\n    mLock.lock();\n    try {\n      return mField;\n    } finally {\n      mLock.unlock();\n    }\n  }\n\n  public void writeInsideTryCatchWithLockOk() {\n    mLock.lock();\n    try {\n      mField = true;\n    } finally {\n      mLock.unlock();\n    }\n  }\n\n  Object mField2;\n\n  private synchronized void lockedWriteInCallee() {\n    this.mField2 = null;\n  }\n\n  public static void ownedLockedReadOk() {\n    Locks owned = new Locks();\n    owned.lockedWriteInCallee();\n  }\n\n  public Object unownedReadOk() {\n    // safe because the only other access to mField is owned\n    return this.mField2;\n  }\n\n  Object mField3;\n\n  private synchronized void lockedWriteInCallee2() {\n    this.mField3 = null;\n  }\n\n  public void unownedLockedWriteOk() {\n    lockedWriteInCallee2();\n  }\n\n  public Object unownedReadBad() {\n    return this.mField3;\n  }\n}\n"
    },
    {
      "testname": "NonSourceVar.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\n// TODO fix FN T38248006\n@ThreadSafe\npublic class NonSourceVar {\n  private long field;\n\n  public void FN_conditionalOperatorBad(long v) {\n    field = field < v ? field : v;\n  }\n}\n"
    },
    {
      "testname": "NotThreadSafeExample.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport javax.annotation.concurrent.NotThreadSafe;\n\n@NotThreadSafe\npublic class NotThreadSafeExample {\n\n  Integer f;\n\n  public void tsBad() {\n    /*Shouldn't report*/\n    f = 24;\n  }\n}\n"
    },
    {
      "testname": "Ownership.java",
      "testlanguage": "java",
      "expected-problems": 143,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport javax.annotation.concurrent.ThreadSafe;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\nclass Obj {\n  Object f;\n  Obj g;\n}\n\ninterface CustomProvider<T> extends Provider<T> {\n\n  @Override\n  public T get();\n}\n\n@ThreadSafe\npublic class Ownership {\n\n  Obj field;\n\n  public Ownership() {}\n\n  public Ownership(Obj o) {\n    field = o;\n  }\n\n  // understand that ownership can be acquired via DI\n  @Inject\n  Ownership(Provider<Obj> objProvider) {\n    Obj owned = objProvider.get();\n    owned.f = new Object(); // should not report\n  }\n\n  @Inject\n  Ownership(CustomProvider<Obj> objProvider) {\n    Obj owned = objProvider.get();\n    owned.f = new Object(); // should not report\n  }\n\n  Obj mInjectedField1;\n  Obj mInjectedField2;\n\n  // because this constructor is meant to be called via DI, we assume that injectedField and other\n  // parameters passed to the constructor will always be freshly allocated\n  @Inject\n  Ownership(Obj injectedField1, Obj injectedField2) {\n    mInjectedField1 = injectedField1;\n    mInjectedField2 = injectedField2;\n    mInjectedField1.f = new Object(); // should not warn\n    mInjectedField2.f = new Object(); // should not warn\n  }\n\n  Ownership(Obj obj, Object o) {\n    obj.f = o; // not annotated @Inject; should warn\n  }\n\n  native void leakToAnotherThread(Object o);\n\n  public void escapeViaConstructorBad() {\n    Obj local = new Obj();\n    Ownership constructed = new Ownership(local);\n    local.f = new Object();\n  }\n\n  public void ownInOneBranchBad(Obj formal, boolean b) {\n    if (b) {\n      formal = new Obj();\n    }\n    // we might not own formal\n    formal.f = new Object();\n  }\n\n  public void reassignToFormalBad(Obj formal) {\n    Obj local = new Obj();\n    formal.g = local; // bad, we don't own formal\n    formal.g.f = new Object(); // ok; now that formal.g is reassigned to local, which we do own\n  }\n\n  public void ownedLocalOk() {\n    Obj local = new Obj();\n    local.f = new Object();\n  }\n\n  public Obj returnOwnedLocalOk() {\n    Obj local = new Obj();\n    local.f = new Object();\n    return local;\n  }\n\n  public void writeOwnedLocalThenEscapeOk() {\n    Obj local = new Obj();\n    local.f = new Object();\n    leakToAnotherThread(local);\n  }\n\n  public void ownInBranchesOk1(boolean b) {\n    Obj local;\n    if (b) {\n      local = new Obj();\n      local.f = new Object();\n    } else {\n      local = new Obj();\n      local.f = new Integer(0);\n    }\n    local.f = new Boolean(false);\n  }\n\n  public void ownedAccessPathOk() {\n    Obj local = new Obj();\n    local.g = new Obj();\n    local.g.f = new Object();\n  }\n\n  public void aliasOwnedLocalOk() {\n    Obj local = new Obj();\n    Obj alias = local;\n    alias.f = new Object();\n    local.f = new Object();\n  }\n\n  public void aliasOwnedLocalAccessPathOk() {\n    Obj local = new Obj();\n    local.g = new Obj();\n    Obj alias = local.g;\n    alias.f = new Object();\n  }\n\n  private void writeToFormal(Obj formal) {\n    formal.f = new Object();\n  }\n\n  private void callWriteToFormal(Obj formal) {\n    writeToFormal(formal);\n  }\n\n  private void setField(Obj o) {\n    this.field = o;\n  }\n\n  native Obj getMaybeUnownedObj();\n\n  // warn here even though this this is safe if `o` is owned at all call sites. because it's a\n  // public method, it's possible to use it in an unsafe way\n  public void writeToNotOwnedInCalleeBad1(Obj o) {\n    writeToFormal(o);\n  }\n\n  public void FN_writeToNotOwnedInCalleeBad2() {\n    Obj o = getMaybeUnownedObj();\n    writeToFormal(o);\n  }\n\n  public void writeToNotOwnedInCalleeBad3(Obj o) {\n    callWriteToFormal(o);\n  }\n\n  // assuming that we can't own the `this` object\n  public void cantOwnThisBad() {\n    setField(new Obj());\n  }\n\n  public void writeToOwnedInCalleeOk1() {\n    Obj o = new Obj();\n    writeToFormal(o);\n  }\n\n  public void writeToOwnedInCalleeIndirectOk1() {\n    Obj o = new Obj();\n    callWriteToFormal(o);\n  }\n\n  public void writeToOwnedInCalleeIndirectOk2() {\n    Obj o = new Obj();\n    o.g = new Obj();\n    callWriteToFormal(o.g);\n  }\n\n  public Obj ownershipCanBeInterproceduralOk() {\n    Obj local = returnOwnedLocalOk();\n    local.f = new Object();\n    return local;\n  }\n\n  public void mutateDoubleReturnOwnedOk() {\n    Obj owned = ownershipCanBeInterproceduralOk();\n    owned.g = new Obj();\n  }\n\n  Obj returnOwnedOrNull(boolean b) {\n    if (b) {\n      return null;\n    }\n    return new Obj();\n  }\n\n  public void mutateAfterNullCheckOK(boolean b) {\n    Obj o = returnOwnedOrNull(b);\n    if (o != null) {\n      o.f = new Object();\n    }\n  }\n\n  private void mutateIfNotNull(Obj o) {\n    if (o != null) {\n      o.f = new Object();\n    }\n  }\n\n  public void ownInCalleeViaNullOk() {\n    mutateIfNotNull(null);\n  }\n\n  public void notOwnedInCalleeBad(Obj o) {\n    mutateIfNotNull(o);\n  }\n\n  Obj id(Obj param) {\n    return param;\n  }\n\n  public void passOwnershipInIdFunctionOk() {\n    Obj owned = new Obj();\n    Obj shouldBeOwned = id(owned);\n    shouldBeOwned.f = new Object();\n  }\n\n  Obj id2(Obj param) {\n    return id(param);\n  }\n\n  public void passOwnershipInMultiLevelIdFunctionOk() {\n    Obj owned = new Obj();\n    Obj shouldBeOwned = id2(owned);\n    shouldBeOwned.f = new Object();\n  }\n\n  native boolean nondet();\n\n  public Obj returnConditionalOwnedInTwoBranches(Obj param) {\n    if (nondet()) {\n      return param;\n    }\n    return param;\n  }\n\n  public void returnConditionalOwnedInTwoBranchesOk() {\n    Obj owned = new Obj();\n    Obj shouldBeOwned = returnConditionalOwnedInTwoBranches(owned);\n    shouldBeOwned.f = new Object();\n  }\n\n  public Obj returnOwnedOrConditionalOwned(Obj param) {\n    if (nondet()) {\n      return param;\n    } else {\n      return new Obj();\n    }\n  }\n\n  public void ownedAfterCastOk() {\n    Object o = new Obj();\n    Obj owned = (Obj) o;\n    owned.f = new Object();\n  }\n\n  // TODO: need to handle multiple ownership attributes in order to get this one\n  public void ownAndConditionalOwnOk() {\n    Obj owned = new Obj();\n    Obj shouldBeOwned = returnOwnedOrConditionalOwned(owned);\n    shouldBeOwned.f = new Object();\n  }\n\n  public Obj twoDifferentConditionalOwns(Obj param1, Obj param2) {\n    if (nondet()) {\n      return param1;\n    } else {\n      return param2;\n    }\n  }\n\n  public void threadLocalOk(ThreadLocal<Obj> threadLocal) {\n    threadLocal.get().f = new Object();\n  }\n\n  // need to handle multiple ownership attributes in order to get this one\n  public void twoDifferentConditionalOwnsOk() {\n    Obj owned1 = new Obj();\n    Obj owned2 = new Obj();\n    Obj shouldBeOwned = twoDifferentConditionalOwns(owned1, owned2);\n    shouldBeOwned.f = new Object();\n  }\n\n  // we angelically assume that callees don't leak their arguments to another thread for now, so\n  // we'll miss this\n  public void FN_escapeThenWriteLocalBad() {\n    Obj local = new Obj();\n    leakToAnotherThread(local);\n    local.f = new Object();\n  }\n\n  private Obj leakThenReturn() {\n    Obj local = new Obj();\n    leakToAnotherThread(local);\n    return local;\n  }\n\n  // the summary for leakThenReturn should not say that the caller owns the return value\n  public void FN_mutateReturnedBad() {\n    Obj notOwned = leakThenReturn();\n    notOwned.f = new Object(); // should warn here\n  }\n\n  private void castThenCall(Obj o) {\n    Subclass s = (Subclass) o;\n    s.doWrite();\n  }\n\n  void castThenCallOk() {\n    Obj o = new Obj();\n    castThenCall(o);\n  }\n\n  void FN_castThenCallBad() {\n    Obj o = getMaybeUnownedObj();\n    castThenCall(o);\n  }\n\n  private Obj castThenReturn(Obj o) {\n    Subclass s = (Subclass) o;\n    return s;\n  }\n\n  void castThenReturnOk() {\n    Obj o = new Obj();\n    castThenReturn(o).f = new Object();\n  }\n\n  void FN_castThenReturnBad() {\n    Obj o = getMaybeUnownedObj();\n    castThenReturn(o).f = new Object();\n  }\n\n  void ownViaReflectionOk1() throws InstantiationException, IllegalAccessException {\n    Class<Obj> oClass = Obj.class;\n    Obj o = oClass.newInstance();\n    o.f = new Object();\n  }\n\n  void ownViaReflectionOk2()\n      throws IllegalAccessException, InstantiationException, InvocationTargetException,\n          NoSuchMethodException {\n    Class<Obj> oClass = Obj.class;\n    Constructor<Obj> oConstructor = oClass.getConstructor();\n    Obj o = oConstructor.newInstance();\n    o.f = new Object();\n  }\n\n  void ownInSkippedCodeOk() {\n    SkippedClass c = SkippedClass.returnOwned();\n    c.f = new Object();\n  }\n\n  void cloningAquiresOwnershipOk() {\n    Ownership ow;\n    try {\n      ow = (Ownership) this.clone();\n      ow.field = null;\n    } catch (CloneNotSupportedException e) {\n    }\n  }\n\n  static MyObj global;\n\n  // would need escape analysis to detect this\n  void FN_storeInGlobalAndWriteBad() {\n    MyObj x = new MyObj();\n    synchronized (Ownership.class) {\n      global = x;\n    }\n    x.data = 5;\n  }\n\n  int readGlobalBad() {\n    return global.data;\n  }\n\n  public void writeOwnedWithExceptionOk() {\n    Obj options = returnOwnedWithException();\n    options.f = new Object();\n  }\n\n  private Obj returnOwnedWithException() {\n    Obj options = new Obj();\n    if (options.f == null) {\n      throw new IllegalArgumentException();\n    }\n    return options;\n  }\n\n  // not propagating ownership to access path rooted in formal\n  public void notPropagatingOwnershipToAccessPathRootedAtFormalBad(Obj m) {\n    m.g = new Obj();\n  }\n\n  // not propagating ownership to unowned local access path\n  public void notPropagatingOwnershipToUnownedLocalAccessPathBad() {\n    Obj m;\n    synchronized (this) {\n      m = field;\n    }\n    m.g = new Obj();\n  }\n\n  // propagating ownership to owned access path\n  public void propagatingOwnershipToOwnedAccessPathOk() {\n    Obj m = new Obj();\n    m.g = new Obj();\n    m.g.g = new Obj();\n    m.g.g.g = new Obj();\n  }\n\n  private void reassignParamToOwned(Obj o) {\n    o = new Obj();\n    o.f = null; // we know the reassigned o is owned, mutating is ok\n  }\n\n  Obj unownedField1;\n\n  void reassignParamToOwnedOk() {\n    reassignParamToOwned(this.unownedField1); // ok even though this.unownedField1 isn't owned\n  }\n\n  Obj unownedField2;\n\n  private void reassignParamToUnowned(Obj o) {\n    o = this.unownedField2;\n    o.f = null; // don't know that this.unownedField2 is owned\n  }\n\n  void FN_reassignParamToUnownedBad() {\n    reassignParamToUnowned(new Obj()); // although o is owned here, it gets reassigned in the callee\n  }\n\n  void ownedViaLocalAliasOk() {\n    Obj owned = new Obj();\n    Obj alias = owned;\n    alias.f = null;\n    owned.f = new Object();\n  }\n\n  private void ownedViaParamAlias(Obj o) {\n    Obj alias = o;\n    alias.f = null; // ok if o is owned in caller\n    o.f = new Object(); // ok if alias is owned in\n  }\n\n  public void ownedViaAliasOk() {\n    Obj owned = new Obj();\n    ownedViaParamAlias(owned);\n  }\n\n  Obj unownedField3;\n\n  private void ownedViaThisAlias() {\n    Ownership alias = this;\n    alias.unownedField3 = null; // ok if this owned in caller\n    this.unownedField3 = new Obj(); // also ok if this is owned in caller\n  }\n\n  public static void ownedViaThisAliasOk() {\n    Ownership owned = new Ownership();\n    owned.ownedViaThisAlias();\n  }\n\n  boolean nondet;\n\n  private void conditionalAlias(Obj o1, Obj o2) {\n    Obj alias;\n    if (nondet) {\n      alias = o1;\n    } else {\n      alias = o2;\n    }\n    alias.f = null; // ok if both o1 and o2 are owned\n  }\n\n  void conditionalAliasOk() {\n    conditionalAlias(new Obj(), new Obj());\n  }\n\n  void FN_conditionalAliasBad(Obj unowned) {\n    conditionalAlias(new Obj(), unowned);\n  }\n}\n\nclass MyObj {\n  int data;\n}\n\nclass Subclass extends Obj {\n\n  public void doWrite() {\n    f = new Object();\n  }\n}\n\n@ThreadSafe\nclass OtherObj {\n  private OtherObj(Obj o) {\n    o.f = new Object();\n  }\n\n  void mutateInConstructorOk() {\n    new OtherObj(new Obj());\n  }\n}\n\n@ThreadSafe\nclass ContainerOwnership {\n\n  ContainerOwnership() {\n    ArrayList<MyObj> children = new ArrayList<MyObj>();\n    setFirstOk(children);\n  }\n\n  private void setFirstOk(ArrayList<MyObj> children) {\n    MyObj obj = children.get(0);\n\n    if (obj == null) {\n      obj = new MyObj();\n    }\n\n    obj.data = 10;\n  }\n}\n"
    },
    {
      "testname": "RaceWithMainThread.java",
      "testlanguage": "java",
      "expected-problems": 60,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\nclass OurThreadUtils {\n  static native boolean isMainThread();\n\n  static void assertMainThread() {}\n\n  static void assertHoldsLock(Object lock) {}\n}\n\nclass OurThreadUtil {\n  /*This is like AndroidThreadUtil*/\n  static native boolean isUiThread();\n\n  static void assertOnUiThread() {}\n\n  static void assertOnBackgroundThread() {}\n}\n\n@ThreadSafe\nclass RaceWithMainThread {\n\n  Integer f;\n\n  void main_thread_OK() {\n    OurThreadUtils.assertMainThread();\n    f = 88;\n  }\n\n  Integer f1;\n\n  void main_thread1_OK() {\n    OurThreadUtil.assertOnUiThread();\n    f1 = 88;\n  }\n\n  void main_thread_indirect_OK() {\n    main_thread_OK();\n    f = 77;\n  }\n\n  void read_from_main_thread_OK() {\n    Integer x;\n    OurThreadUtils.assertMainThread();\n    x = f;\n  }\n\n  void read_unprotected_unthreaded_Bad() {\n    Integer x;\n    x = f;\n  }\n\n  void read_unprotected_unthreaded1_Bad() {\n    Integer x;\n    x = f1;\n  }\n\n  /*There is a particularly subtle idiom which avoids races, where a\n    variable can be read without protection on the main thread, if\n    it is written with protection on the main thread and read with\n    protection off. The next three methods do this safely, and the fourth\n    unsafely.\n  */\n  Integer i;\n\n  void protected_write_on_main_thread_OK() {\n    OurThreadUtils.assertMainThread();\n    synchronized (this) {\n      i = 99;\n    }\n  }\n\n  void unprotected_read_on_main_thread_OK() {\n    Integer x;\n    OurThreadUtils.assertMainThread();\n    x = i;\n  }\n\n  void protected_read_off_main_thread_OK() {\n    Integer x;\n    synchronized (this) {\n      x = i;\n    }\n  }\n\n  void readProtectedUnthreadedBad() {\n    Integer x;\n    synchronized (this) {\n      x = f;\n    }\n  }\n\n  Integer g;\n\n  void holds_lock_OK() {\n    OurThreadUtils.assertHoldsLock(this);\n    g = 88;\n  }\n\n  void holds_lock_indirect_OK() {\n    holds_lock_OK();\n    g = 77;\n  }\n\n  Integer ff;\n\n  void conditional1_Ok(boolean b) {\n    if (b) {\n      /*People not literally putting this assert inside if's,\n      but implicitly by method calls */\n      OurThreadUtils.assertMainThread();\n      ff = 88;\n    }\n  }\n\n  void conditional2_bad(boolean b) {\n    if (b) {\n      OurThreadUtils.assertMainThread();\n      ff = 88;\n    } else {\n      ff = 99; // this might or might now run on the main thread; warn\n    }\n  }\n\n  void conditional_isMainThread_Ok() {\n    if (OurThreadUtils.isMainThread()) {\n      ff = 88;\n    }\n  }\n\n  void conditional_isUiThread_Ok() {\n    if (OurThreadUtil.isUiThread()) {\n      ff = 88;\n    }\n  }\n\n  void conditional_isMainThread_ElseBranch_Bad() {\n    if (OurThreadUtils.isMainThread()) {\n      synchronized (this) {\n        ff = 88;\n      }\n    } else {\n      ff = 99;\n    }\n  }\n\n  void conditional_isUiThread_ElseBranch_Bad() {\n    if (OurThreadUtil.isUiThread()) {\n      synchronized (this) {\n        ff = 88;\n      }\n    } else {\n      ff = 99;\n    }\n  }\n\n  void conditional_isMainThread_Negation_Bad() {\n    if (!OurThreadUtils.isMainThread()) {\n      ff = 88;\n    }\n  }\n\n  void conditional_isMainThread_ElseBranch_Ok() {\n    if (!OurThreadUtils.isMainThread()) {\n      synchronized (this) {\n        ff = 88;\n      }\n    } else {\n      ff = 99;\n    }\n  }\n\n  Object mFld;\n\n  public void confusedAssertBad(boolean b) {\n    if (b) {\n      OurThreadUtil.assertOnBackgroundThread();\n    } else {\n      OurThreadUtil.assertOnUiThread();\n    }\n    // not sure if we're on UI or background, should report\n    mFld = null;\n  }\n\n  int mOnlyWrittenOnMain;\n\n  private void conditionalMainThreadWrite1(boolean b) {\n    if (b) {\n      OurThreadUtil.assertOnUiThread();\n      mOnlyWrittenOnMain = 7;\n    }\n  }\n\n  // make sure we don't forget what thread the callee write occurred on\n  public void conditionalMainThreadWriteOk() {\n    conditionalMainThreadWrite1(true);\n  }\n\n  int mWrittenOffMain;\n\n  private void conditionalMainThreadWrite2(boolean b) {\n    if (b) {\n      OurThreadUtil.assertOnUiThread();\n    } else {\n      mOnlyWrittenOnMain = 7;\n    }\n  }\n\n  public void conditionalMainThreadWriteBad() {\n    conditionalMainThreadWrite2(false);\n  }\n\n  int mSharedField;\n\n  public void writeAfterConditionalMainThreadInCalleeBad() {\n    conditionalMainThreadWrite1(true);\n    // one branch of the callee runs on the main thread, but that doesn't mean we can assume that\n    // the caller does too\n    mSharedField = 7;\n  }\n}\n\n// not marked thread-safe\nclass Unmarked {\n\n  int mField;\n\n  void writeOnUiThreadOk() {\n    OurThreadUtil.assertOnUiThread();\n    mField = 7;\n  }\n\n  int readOnUiThreadOk() {\n    OurThreadUtil.assertOnUiThread();\n    return mField;\n  }\n\n  int readOffUiThreadOk() {\n    // even though this read isn't known to be on the UI thread, we shouldn't assume that it occurs\n    // on a background thread\n    return mField;\n  }\n}\n"
    },
    {
      "testname": "ReadWriteRaces.java",
      "testlanguage": "java",
      "expected-problems": 34,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport java.util.concurrent.locks.ReentrantLock;\nimport javax.annotation.concurrent.ThreadSafe;\n\nclass C {\n  private int x = 0;\n\n  public int get() {\n    return x;\n  }\n\n  public void set(int v) {\n    x = v;\n  }\n}\n\n@ThreadSafe\nclass ReadWriteRaces {\n\n  // read and write outside of sync races\n  Integer safe_read;\n  Integer racy;\n\n  void m0_OK() {\n    Integer local;\n    local = safe_read;\n  }\n\n  void m0_OK2() { // parallel reads are OK\n    Integer local;\n    local = safe_read;\n  }\n\n  void m1() { // A read where there are other writes\n    Integer local;\n    local = racy;\n  }\n\n  public void m2() {\n    racy = 88;\n  }\n\n  public void m3() {\n    racy = 99;\n  }\n\n  // write inside sync, read outside of sync races\n  Object field1;\n  Object field2;\n  Object field3;\n\n  // need to report races involving safe writes in order to get this one\n  public synchronized void syncWrite1() {\n    field1 = new Object();\n  }\n\n  public Object unprotectedRead1() {\n    return field1;\n  }\n\n  private Object unprotectedReadInCallee() {\n    return field1;\n  }\n\n  public Object callUnprotecteReadInCallee() {\n    return unprotectedReadInCallee();\n  }\n\n  public void syncWrite2() {\n    synchronized (this) {\n      field2 = new Object();\n    }\n  }\n\n  public Object unprotectedRead2() {\n    return field2;\n  }\n\n  private synchronized void syncWrite3() {\n    field3 = new Object();\n  }\n\n  public void callSyncWrite3() {\n    syncWrite3();\n  }\n\n  public Object unprotectedRead3() {\n    return field3;\n  }\n\n  private final C c = new C();\n  private final ReentrantLock lock = new ReentrantLock();\n\n  public void readInCalleeOutsideSyncBad(int i) {\n    if (c.get() > i) { // should report read/write race here\n      lock.lock();\n      c.set(i);\n      lock.unlock();\n    }\n  }\n}\n"
    },
    {
      "testname": "SkippedClass.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// _SHOULD_BE_SKIPPED_\n\npackage codetoanalyze.java.checkers;\n\npublic class SkippedClass {\n\n  Object f;\n\n  public static SkippedClass returnOwned() {\n    return new SkippedClass();\n  }\n}\n"
    },
    {
      "testname": "SubFld.java",
      "testlanguage": "java",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport javax.annotation.concurrent.ThreadSafe;\n\n// Fields must encapsulate the class they are declared in, not\n// the class they are potentially inherited into.\n\n@ThreadSafe\nclass SuperFld {\n\n  private int f = 0;\n\n  public int getF() {\n    return f; // should *not* report read/write race with SubFld.setF()\n  }\n\n  protected int g = 0;\n\n  public int getG() {\n    return g; // must report read/write race with SubFld.setG()\n  }\n}\n\n@ThreadSafe\npublic class SubFld extends SuperFld {\n\n  private int f = 0;\n\n  public synchronized void setF() {\n    f = 5; // should *not* report\n  }\n\n  public synchronized void setG() {\n    g = 5; // must report\n  }\n}\n"
    },
    {
      "testname": "SwitchEnum.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport javax.annotation.concurrent.ThreadSafe;\n\n@ThreadSafe\npublic class SwitchEnum {\n  int[] a = new int[8];\n\n  // Java generates a class for the switch, which contains an int array\n  // This leads to races where there are int arrays, here a[]\n  public String getName(EnumClass value) {\n    synchronized (this) {\n      a[0] = 0; // should not report here\n    }\n    switch (value) {\n      case VALUE1:\n        return \"value 1\";\n      case VALUE3:\n        return \"value 3\";\n      default:\n        return \"other\";\n    }\n  }\n}\n\nenum EnumClass {\n  VALUE1,\n  VALUE2,\n  VALUE3\n}\n"
    },
    {
      "testname": "ThreadSafeExample.java",
      "testlanguage": "java",
      "expected-problems": 64,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport com.facebook.infer.annotation.ThreadSafe;\nimport com.google.common.annotations.VisibleForTesting;\nimport javax.annotation.concurrent.NotThreadSafe;\n\n@ThreadSafe\npublic class ThreadSafeExample {\n\n  /*Included to make sure infer does not report on class initializers*/\n  static Class<?> A = ThreadSafeExample.class;\n\n  Integer f;\n\n  public ThreadSafeExample() {\n    f = 86;\n  }\n\n  public void tsOK() {\n    synchronized (this) {\n      f = 42;\n    }\n  }\n\n  public void tsBad() {\n    f = 24;\n  }\n\n  public void recursiveBad() {\n    f = 44;\n    recursiveBad();\n  }\n\n  // shouldn't report here because it's a private method\n  private void assignInPrivateMethodOk() {\n    f = 24;\n  }\n\n  // but should report here, because now it's called\n  public void callPublicMethodBad() {\n    assignInPrivateMethodOk();\n  }\n\n  private void callAssignInPrivateMethod() {\n    assignInPrivateMethodOk();\n  }\n\n  // should report a deeperTraceBade -> callAssignInPrivateMethod -> assignInPrivateMethodOk trace\n  public void deeperTraceBad() {\n    callAssignInPrivateMethod();\n  }\n\n  public synchronized void callFromSynchronizedPublicMethodOk() {\n    assignInPrivateMethodOk();\n  }\n\n  private synchronized void synchronizedCallerOk() {\n    assignInPrivateMethodOk();\n  }\n\n  public void callFromUnsynchronizedPublicMethodOk() {\n    synchronizedCallerOk();\n  }\n\n  // although the constructor touches f, we shouldn't complain here\n  public void callConstructorOk() {\n    new ThreadSafeExample();\n  }\n\n  private Object returnConstructorOk() {\n    return new ThreadSafeExample();\n  }\n\n  public void transitivelyCallConstructorOk() {\n    returnConstructorOk();\n  }\n\n  volatile Object volatileField;\n\n  // we don't warn on unsafe writes to volatile fields\n  public void unsafeVolatileWriteOk() {\n    this.volatileField = new Object();\n  }\n\n  // don't count the method as public if it's marked VisibleForTesting\n  @VisibleForTesting\n  public void visibleForTestingNotPublicOk() {\n    this.f = 47;\n  }\n\n  // but do complain if a VisibleForTesting method is called from a public method\n  public void callVisibleForTestingBad() {\n    visibleForTestingNotPublicOk();\n  }\n\n  Object sharedField;\n\n  private void writePrivateSharedFieldOk() {\n    this.sharedField = new Object();\n  }\n\n  public Object returnSharedFieldOk() {\n    return this.sharedField; // ok because it only races with a private method\n  }\n\n  Object sStaticField;\n\n  public Object FP_lazyInitOk() {\n    synchronized (ThreadSafeExample.class) {\n      if (sStaticField != null) {\n        sStaticField = new Object();\n      }\n    }\n    return sStaticField; // we'll warn here, although this is fine\n  }\n}\n\nclass ExtendsThreadSafeExample extends ThreadSafeExample {\n\n  Integer field;\n\n  /* Presently,we will warn not just on overwridden methods from\n  @ThreadSafe class, but potentially on other methods in subclass */\n  public void newmethodBad() {\n    field = 22;\n  }\n\n  /* Bad now that it's overridden */\n  public void tsOK() {\n    field = 44;\n  }\n}\n\n@NotThreadSafe\nclass NotThreadSafeExtendsThreadSafeExample extends ThreadSafeExample {\n\n  Integer field;\n\n  /* We don't want to warn on this */\n  public void newmethodBad() {\n    field = 22;\n  }\n}\n\n@ThreadSafe\nclass YesThreadSafeExtendsNotThreadSafeExample extends NotThreadSafeExtendsThreadSafeExample {\n\n  Integer subsubfield;\n\n  /* We do want to warn on this */\n  public void subsubmethodBad() {\n    subsubfield = 22;\n  }\n}\n\nclass Unannotated {\n  int mField;\n\n  // although ThreadSafeExample is annotated @ThreadSafe, mutating fields of this class in a\n  // non-threadsafe context should be allowed\n  void callThreadSafeAnnotatedCode1Ok(ThreadSafeExample o) {\n    o.f = null;\n  }\n\n  void callThreadSafeAnnotatedCode2Ok(ThreadSafeExample o) {\n    o.tsBad();\n  }\n\n  void mutateMyFieldOk() {\n    this.mField = 1;\n  }\n}\n"
    },
    {
      "testname": "ThreadSafeMethods.java",
      "testlanguage": "java",
      "expected-problems": 37,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.checkers;\n\nimport com.facebook.infer.annotation.ThreadSafe;\nimport com.google.common.annotations.VisibleForTesting;\n\nclass ThreadSafeMethods {\n\n  Object field1;\n  Object field2;\n  Object field3;\n  Object field4;\n  Object field5;\n\n  @ThreadSafe\n  public void threadSafeMethodWriteBad() {\n    this.field1 = new Object(); // should warn\n  }\n\n  @ThreadSafe\n  public Object threadSafeMethodReadBad() {\n    return this.field2;\n  }\n\n  @ThreadSafe\n  private void threadSafePrivateMethodBad() {\n    this.field2 = new Object(); // should warn\n  }\n\n  @ThreadSafe\n  @VisibleForTesting\n  public void threadSafeVisibleForTestingMethodBad() {\n    this.field3 = new Object(); // should warn\n  }\n\n  @ThreadSafe\n  public void safeMethodOverride() {}\n\n  // if a method annotated with @ThreadSafe in class C writes field f, then all other accesses to f\n  // in C must also be thread-safe\n  public void writeSameFieldAsThreadSafeMethod1Bad() {\n    // warn here because field1 is also written in @ThreadSafe method threadSafeMethodWriteBad\n    this.field1 = new Object();\n  }\n\n  // reads a field that is written in a method marked thread-safe\n  public Object readSameFieldAsThreadSafeMethod1Bad() {\n    return this.field1;\n  }\n\n  // TODO: should we report this or not?\n  public synchronized void safelyWriteSameFieldAsThreadSafeMethod1Ok() {\n    this.field1 = new Object();\n  }\n\n  public synchronized Object readSameFieldAsThreadSafeMethodWhileSynchronized1Bad() {\n    return this.field1;\n  }\n\n  @ThreadSafe\n  public synchronized void synchronizedWriteOk() {\n    this.field4 = new Object();\n  }\n\n  // unprotected write to a field that is written safely in a method marked thread-safe\n  public void writeSameFieldAsThreadSafeMethod2Bad() {\n    this.field4 = new Object();\n  }\n\n  // unprotected read of a field that is written safely in a method marked thread-safe\n  public Object readSameFieldAsThreadSafeMethod2Bad() {\n    return this.field4;\n  }\n\n  @ThreadSafe\n  public synchronized Object FN_synchronizedReadBad() {\n    return this.field5;\n  }\n\n  private void privateAccessOk() {\n    this.field5 = new Object();\n  }\n\n  // unprotected write to a field that is read safely in a method marked thread-safe\n  public void FN_writeSameFieldAsThreadSafeMethod3Bad() {\n    this.field5 = new Object();\n  }\n\n  // none of the writes are marked thread-safe/locked, no reason to report\n  public Object readSameFieldAsThreadSafeMethodOk() {\n    return this.field5;\n  }\n}\n\nclass ThreadSafeMethodsSubclass extends ThreadSafeMethods {\n  Object subclassField;\n\n  @Override\n  // overrides method annotated with @ThreadSafe, should warn\n  public void safeMethodOverride() {\n    this.subclassField = new Object();\n  }\n\n  public void FN_writeThreadSafeFieldOfSuperclassBad() {\n    this.field1 = new Object();\n  }\n\n  public Object FN_readThreadSafeFieldOfSuperclassBad() {\n    return this.field1;\n  }\n\n  public void writeThreadSafeFieldOfOverrideBad() {\n    this.subclassField = new Object();\n  }\n\n  public Object readThreadSafeFieldOfOverrideBad() {\n    return this.subclassField;\n  }\n}\n"
    }
  ]
}