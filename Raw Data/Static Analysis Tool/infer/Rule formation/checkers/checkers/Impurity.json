{
  "name": "Impurity",
  "language": [
    "clang",
    "java",
    "hack"
  ],
  "description": "Detects functions with potential side-effects. Same as \\",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "OCaml",
  "loc": 244,
  "branches": 25,
  "apis": 39,
  "test": [
    {
      "testname": "array_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// modifies a & b\nvoid array_mod_impure(int a[10], int b[10], int c) {\n  a[0] = c;\n  b[0] = c;\n}\n\n// modifies a twice\nvoid array_mod_both_impure(int a[10], int b) {\n  a[0] = b;\n  a[1] = 0;\n}\n\n// modifies a\nvoid call_array_mod_impure(int a[10]) {\n  int b[10];\n  array_mod_impure(a, b, 9);\n}\n\nvoid call_array_mod_with_fresh_pure() {\n  int a[10];\n  array_mod_impure(a, a, 0);\n}\nvoid call_array_mod_with_both_fresh_pure() {\n  int a[10];\n  int b[10];\n  array_mod_impure(a, b, 0);\n}\n\n// modifies array\nvoid alias_mod_impure(int array[], int i, int j) {\n  int* a = array;\n  a[j] = i;\n}\n\nstruct Foo {\n  int x;\n};\n\nvoid modify_direct_impure(Foo array[10], int i, Foo foo) { array[i].x = foo.x; }\n\nvoid modify_ptr_impure(Foo array[10], Foo foo) {\n  Foo* tmp = array;\n  tmp->x = foo.x;\n}\n\nvoid call_impure_with_fresh_pure() {\n  struct Foo f1 = {1};\n  struct Foo f2 = {2};\n  struct Foo f3 = {3};\n  Foo array[2] = {f1, f2};\n  modify_direct_impure(array, 0, f3);\n  modify_ptr_impure(array, f3);\n}\n\n// Note: Unlike C++, in Java, this is gonna be impure because\n// everything is passed by reference in Java\nint modify_by_copy_pure(Foo array[1], int i, Foo foo) {\n  Foo tmp = array[i];\n  tmp.x = foo.x;\n  return tmp.x;\n}\n"
    },
    {
      "testname": "exit_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nint x;\n\nvoid exit_positive_impure(int a[10], int b) {\n  if (b > 0) {\n    exit(0);\n  }\n}\n\nvoid unreachable_impure(int a[10]) {\n  exit_positive_impure(a, 10);\n  x = 9; // unreachable\n}\n"
    },
    {
      "testname": "global_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstatic int x;\nint a[3];\n\nvoid modify_global_primitive_impure() { x = 10; }\n\nvoid modify_global_array_impure() { a[0] = 0; }\n\nvoid call_modify_global() {\n  modify_global_primitive_impure();\n  modify_global_array_impure();\n}\n\n// modifies local static arr\nint* local_static_var_impure() {\n\n  // Lifetime of a static variable is throughout the program.\n  static int arr[100];\n\n  /* Some operations on arr[] */\n  arr[0] = 10;\n  arr[1] = 20;\n\n  return arr;\n}\n\nvoid modify_global_inside_lamda_impure() {\n  auto lam = [&]() { x++; };\n}\n"
    },
    {
      "testname": "invalid_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\nint* global_pointer;\n\nvoid free_global_pointer_impure() { free(global_pointer); }\n// If Pulse raises an error, consider the function as impure.\nvoid double_free_global_impure() {\n  free_global_pointer_impure();\n  free_global_pointer_impure();\n}\n\nint free_param_impure(int* x) {\n  free(x);\n  return 0;\n}\n\nstruct Simple {\n  int f;\n};\nvoid delete_param_impure(Simple* s) { delete s; }\n\nvoid local_deleted_pure() {\n  auto* s = new Simple{1};\n  delete s;\n}\n\nSimple* reassign_pure(Simple* s) {\n  s = new Simple{2};\n  return s;\n}\n\nSimple* reassign_impure(Simple* s) {\n  *s = Simple{2};\n  return s;\n}\n\nvoid swap_impure(Simple* s1, Simple* s2) {\n  Simple temp = *s2;\n  *s2 = *s1;\n  *s1 = temp;\n}\n\nvoid swap_pure(Simple* s1, Simple* s2) {\n  Simple* temp = s2;\n  s2 = s1;\n  s1 = temp;\n}\n\nvoid swap_address_impure(Simple& lhs, Simple& rhs) {\n  Simple temp = rhs;\n  rhs = lhs;\n  lhs = temp;\n}\n"
    },
    {
      "testname": "param_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// modifies x (a mutable reference argument)\nvoid modify_mut_ref_impure(int* x) { ++*x; }\n\nint primitive_pure(int x) { x++; }\n\nint fact_pure(int n) {\n  int f = 1;\n  while (n > 0)\n    f *= n--;\n  return f;\n}\n\nstruct node {\n  struct node* next;\n  int data;\n};\nvoid create_cycle_impure(struct node* x) { x->next = x; }\n\nvoid invalidate_local_impure(int** pp) {\n  int t = 0xdeadbeef;\n  *pp = &t; // <-- potential bug here since t goes out of scope\n}\n"
    },
    {
      "testname": "struct_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstruct Foo {\n  int x;\n\n  bool operator<(const Foo& rhs) const { return x < rhs.x; }\n};\n\nvoid call_lt_pure(Foo& lhs, Foo& rhs) { lhs < rhs; }\n"
    },
    {
      "testname": "unmodeled.cpp",
      "testlanguage": "c++",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <iostream>\n\nvoid output_stream_impure() { std::cout << \"Hello, world!\" << std::endl; }\n\nint random_impure() { std::rand(); }\n"
    },
    {
      "testname": "vector.cpp",
      "testlanguage": "c++",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <vector>\nvoid insert_impure(std::vector<int>& vec) { vec.insert(vec.begin(), 2); }\n\nvoid push_back_impure(std::vector<int>& vec) { vec.push_back(32); }\n\nvoid fresh_push_back_pure() {\n  std::vector<int> vec = {0, 0};\n  push_back_impure(vec);\n}\n\n// modifies vec\nvoid push_back_in_loop_impure(std::vector<int>& vec,\n                              std::vector<int>& vec_other) {\n  for (const auto& i : vec_other) {\n    vec.push_back(i);\n  }\n}\n\n// modifies vec\nvoid clear_impure(std::vector<int>& vec) { vec.clear(); }\n\n// modifies vec\nvoid assign_impure(std::vector<int>& vec) { vec.assign(11, 7); }\n\nstruct A {\n  int i;\n};\n\nint set_zero_impure(std::vector<A>& numbers) {\n  for (auto& num : numbers) {\n    num.i = 0;\n  }\n  return 0;\n}\n"
    },
    {
      "testname": "GlobalTest.java",
      "testlanguage": "java",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass GlobalTest {\n  public static int s = 0;\n  public static Foo foo;\n\n  class Foo {\n\n    int x = 0;\n    // modifies global var 's' hence impure\n    void set_impure() {\n      s = 10;\n    }\n  }\n\n  void incr(Foo foo, int i) {\n    foo.x += i;\n  }\n\n  // calls foo which modifies global var\n  void call_set_impure() {\n    Foo f = new Foo();\n    f.set_impure();\n  }\n\n  // foo is global which is modified by incr.\n  void global_mod_via_argument_passing_impure(int size, Foo f) {\n    for (int i = 0; i < size; i++) {\n      incr(foo, i);\n    }\n  }\n\n  // aliased_foo is aliasing a global and then is modified by incr.\n  void global_mod_via_argument_passing_impure_aliased(int size, Foo f) {\n    Foo aliased_foo = foo; // Inferbo can't recognize aliasing here\n    // and assumes aliased_foo is in [-oo,+oo] not in foo\n    for (int i = 0; i < size; i++) {\n      incr(aliased_foo, i);\n    }\n  }\n}\n"
    },
    {
      "testname": "Localities.java",
      "testlanguage": "java",
      "expected-problems": 61,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nclass Localities {\n  // @pure\n  boolean contains_pure(Integer i, ArrayList<Integer> list) {\n    Iterator<Integer> listIterator = list.iterator();\n    while (listIterator.hasNext()) {\n      Integer el = listIterator.next();\n      if (i.equals(el)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // @mod:{list}\n  void makeAllZero_impure(ArrayList<Foo> list) {\n    Iterator<Foo> listIterator = list.iterator();\n    while (listIterator.hasNext()) {\n      Foo foo = listIterator.next();\n      foo.x = 0;\n    }\n  }\n\n  // @mod:{list}\n  void incrementAll_impure(ArrayList<Foo> list) {\n    Iterator<Foo> listIterator = list.iterator();\n    while (listIterator.hasNext()) {\n      Foo foo = listIterator.next();\n      foo.inc_impure();\n    }\n  }\n\n  // @pure\n  void call_impure_with_fresh_args_pure() {\n    ArrayList<Foo> list = new ArrayList<Foo>();\n    makeAllZero_impure(list);\n  }\n\n  class Bar {\n    int p;\n  }\n\n  class Foo {\n    int x;\n    Bar bar;\n\n    // @mod:{this}\n    void inc_impure() {\n      x++;\n    }\n  }\n\n  class Counter {\n\n    int i = 0;\n    // @mod:{this}\n    // only modifies fields of its receiver object\n    void inc_impure() {\n      i++;\n    }\n\n    // @pure, @loc:{}\n    int get_i_pure() {\n      return i;\n    }\n  }\n\n  // @pure, @loc:{}\n  int length_pure(ArrayList<Integer> list) {\n    Counter c = new Counter();\n    for (Integer i : list) {\n      c.inc_impure();\n    }\n    return c.i;\n  }\n\n  class HasCounter {\n    Counter counter = new Counter();\n\n    // @loc:{this}\n    Counter getCounter_pure() {\n      return counter;\n    }\n  }\n\n  // @loc:{}\n  public static int[] setFreshArrayEntry_pure(int index, int value) {\n    int[] arr = new int[] {1, 2, 3};\n    if (index > 0) {\n      arr[index % 3] = value;\n    }\n    return arr;\n  }\n\n  // @loc: T\n  private int newHashCode_impure() {\n    return new Object().hashCode();\n  }\n\n  // @loc:{c}\n  HasCounter mkHC_pure(Counter c) {\n    HasCounter hc = new HasCounter();\n    hc.counter = c;\n    return hc;\n  }\n\n  // @mod:{array}, @loc:{array,f}\n  Foo get_f_impure(Foo[] array, int i, Foo f) {\n    Foo tmp = array[i];\n    tmp.x = f.x;\n    return tmp;\n  }\n\n  // @mod:{array}, @loc:{array,f}\n  Foo[] get_array_impure(Foo[] array, int i, Foo f) {\n    Foo tmp = array[i];\n    tmp.x = f.x;\n    return array;\n  }\n\n  // @mod:{array}, @loc:{p}\n  Bar get_foo_via_tmp_impure(Foo[] array, int i, Foo f, Foo p) {\n    Foo tmp = array[i];\n    tmp.bar = f.bar;\n    Foo tmp2 = tmp;\n    tmp2.bar = p.bar;\n    return tmp.bar;\n  }\n\n  // @pure, @loc:{}\n  boolean copy_ref_pure(int[] a, int b) {\n    int[] local = a; // copy reference\n    a = new int[1]; //  a becomes fresh\n    a[0] = local[0]; // not modification\n    return true;\n  }\n\n  // @mod:{a}, @loc:{}\n  boolean copy_ref_impure(int[] a, int b) {\n    int[] local = a; // copy reference\n    a = new int[1]; // overwrite reference\n    a[0] = local[0]; // not modification\n    local[0] = b; // modify arg a\n    b = a[0]; // not modification\n    return true;\n  }\n\n  void swap_pure(Object s1, Object s2) {\n    Object temp = s2;\n    s2 = s1;\n    s1 = temp;\n  }\n\n  // @mod:{list}\n  void modify_first_el_impure(ArrayList<Foo> list) {\n    Foo first = list.get(0);\n    first.x = 0;\n  }\n\n  Foo get_first_pure(ArrayList<Foo> list) {\n    return list.get(0);\n  }\n\n  // @mod:{list}\n  void modify_via_call_impure(ArrayList<Foo> list) {\n    Foo first = get_first_pure(list);\n    first.inc_impure();\n  }\n\n  public static boolean is_null_pure(Byte a) {\n    return a == null;\n  }\n\n  public static boolean call_is_null_pure(Byte a) {\n    return is_null_pure(a);\n  }\n\n  private static final int MAX_SIZE = 2;\n\n  private static final int[][][] pool = new int[3][2][];\n\n  static int[] get_impure(int size) {\n    if (size > MAX_SIZE) {\n      return new int[size];\n    }\n    int[][] arrays = pool[size];\n    if (arrays[1] != null) {\n      int[] a = arrays[1];\n      arrays[1] = null;\n      return a;\n    } else {\n      return new int[size];\n    }\n  }\n}\n"
    },
    {
      "testname": "PurityModeled.java",
      "testlanguage": "java",
      "expected-problems": 52,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.Queue;\n\nclass PurityModeled {\n\n  double math_random_impure() {\n    return Math.random();\n  }\n\n  double math_random_infeasible_pure(int x) {\n    if (x > 1 && x < 2) {\n      return Math.random(); // this path will never be taken\n    }\n    return 0;\n  }\n\n  void arraycopy_pure(int[] src) {\n    int[] dst = {5, 10, 20, 30, 40, 50};\n    // copies an array from the specified source array\n    System.arraycopy(src, 0, dst, 0, 1);\n  }\n\n  public void array_length_loop_pure(Integer[] array) {\n    for (int i = 0; i < array.length; i++) {}\n  }\n\n  void FN_write_impure() {\n    byte[] temp = new byte[4];\n    System.out.write(temp, 0, 4);\n  }\n\n  void FN_call_write_impure() {\n    FN_write_impure();\n  }\n\n  int math_random_in_loop_impure(int x) {\n    int p = 0;\n    for (int i = 0; i < x; i++) {\n      p += Math.random();\n      FN_call_write_impure();\n    }\n\n    return p;\n  }\n\n  void list_size_pure(ArrayList<String> list) {\n    for (int i = 0; i < list.size(); i++) {}\n  }\n\n  void list_add_impure(ArrayList<String> list) {\n    list.add(\"a\");\n  }\n\n  void list_addall_impure(ArrayList<String> list1, ArrayList<String> list2) {\n    list1.addAll(list2);\n  }\n\n  void enum_loop_pure(Enumeration<String> e) {\n\n    for (; e.hasMoreElements(); ) {\n      Object o = e.nextElement();\n    }\n  }\n\n  void remove_impure(Iterator<String> i) {\n    while (i.hasNext()) {\n      if (i.next().equals(\"Orange\")) {\n        i.remove();\n        break;\n      }\n    }\n  }\n\n  void list_set_impure(ArrayList<String> list) {\n    list.set(0, \"e\");\n  }\n\n  void call_set_impure(ArrayList<String> list) {\n    list_set_impure(list);\n    list_set_impure(list);\n  }\n\n  // Pulse can only widen a fixed number of times, hence it thinks\n  // that the exit of the loop never reaches and results in empty\n  // post.\n  void timing_call_in_loop_impure() {\n    for (int i = 0; i < 10; i++) {\n      System.nanoTime();\n    }\n  }\n\n  // Pulse can only widen a fixed number of times, hence it thinks\n  // that the exit of the loop never reaches and results in empty\n  // post which is considered to be impure.\n  void constant_loop_pure_FP() {\n    for (int i = 0; i < 10; i++) {}\n  }\n\n  // Since n is symbolic, pruning doesn't result in infeasible path,\n  // but we assume that the parameter [n] must be 3 due to constant(4)\n  // \"widening\" in pulse.\n  void timing_call_in_loop_symb_impure(int n) {\n    for (int i = 0; i < n; i++) {\n      System.nanoTime();\n    }\n  }\n\n  // Due to getting the wrong summary for the callee (a=3), Pulse ends\n  // up thinking that the parameter [a] must be 3 in the loop. Hence, as\n  // a result of pruning, exit node becomes infeasible and we get\n  // empty summary which is considered to be impure.\n  void call_timing_symb_impure(int a) {\n    for (int i = 0; i < a; i++) {\n      timing_call_in_loop_symb_impure(a);\n    }\n  }\n\n  // The relation between the parameter and the argument to the callee\n  // is broken. Although, the final pulse summary for this function is\n  // still wrong.\n  void call_timing_symb_unrelated_impure(int a, int b) {\n    for (int i = 0; i < a; i++) {\n      timing_call_in_loop_symb_impure(b);\n    }\n  }\n\n  enum Color {\n    RED,\n    GREEN,\n    BLUE; // values() calls clone\n  }\n\n  public void enum_iter_pure() {\n    for (Color c : Color.values()) {}\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  void clone_pure(ArrayList<String> list) {\n    ArrayList<String> cloned = (ArrayList<String>) list.clone();\n    cloned.add(\"\"); // no change the list\n  }\n\n  String replace_impure(String s) {\n    return s.replace('a', 'f');\n  }\n\n  void process_queue_impure(ArrayList<Integer> list, Queue<Integer> queue) {\n    for (Integer el : list) {\n      queue.add(el);\n    }\n  }\n\n  String add_impure(ArrayList<Integer> list) {\n    Integer el = list.get(0);\n    list.add(4);\n    return el.toString();\n  }\n\n  void append_impure(StringBuilder strBuilder) {\n    strBuilder.append(\"JavaGuru\");\n  }\n\n  void append_pure() {\n    StringBuilder strBuilder = new StringBuilder(\"Core\");\n    strBuilder.append(\"JavaGuru\");\n  }\n\n  Integer next_impure(Iterator<Integer> it) {\n    return it.next();\n  }\n\n  String remove_iterator_impure(Iterator<Integer> listIterator) {\n    Integer f = listIterator.next();\n    listIterator.remove();\n    return f.toString();\n  }\n\n  String remove_fresh_impure(ArrayList<Integer> list) {\n    Iterator<Integer> listIterator = list.iterator();\n    Integer f = listIterator.next();\n    listIterator.remove();\n    return f.toString();\n  }\n\n  void remove_impure_mult(ArrayList<Integer> list) {\n    String s1 = remove_fresh_impure(list);\n    String s2 = remove_fresh_impure(list);\n  }\n\n  public static void remove_all_impure(ArrayList<Integer> list) {\n    for (Iterator<Integer> iter = list.iterator(); iter.hasNext(); ) {\n      Integer entry = iter.next();\n      iter.remove();\n      System.out.println(entry.toString());\n    }\n  }\n\n  void nested_remove_impure(ArrayList<ArrayList<Integer>> list) {\n    Iterator<ArrayList<Integer>> listIterator = list.iterator();\n    while (listIterator.hasNext()) {\n      ArrayList<Integer> inner_list = listIterator.next();\n      Iterator<Integer> innerListIterator = inner_list.iterator();\n      while (innerListIterator.hasNext()) {\n        Integer el = innerListIterator.next();\n        innerListIterator.remove();\n      }\n    }\n  }\n\n  void remove_all_directly_impure(ArrayList<Integer> list) {\n    for (Integer el : list) {\n      list.remove(el); // bad, must remove via iterator.\n    }\n  }\n\n  public static final String toString_delete_pure(Object args) {\n    StringBuilder builder = new StringBuilder(32).append('{');\n    if (args != null) {\n      if (builder.charAt(builder.length() - 2) == ',') {\n        builder.delete(builder.length() - 2, builder.length());\n      }\n    }\n    builder.append('}').setLength(10);\n    return builder.toString();\n  }\n\n  String getCanonicalPath_pure(File file) throws IOException {\n    return file.getCanonicalPath();\n  }\n}\n"
    },
    {
      "testname": "Test.java",
      "testlanguage": "java",
      "expected-problems": 48,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport java.util.ArrayList;\n\nclass Test {\n\n  private int a = 0;\n  static Integer[] global_arr;\n\n  void Test(int size) {\n    global_arr = new Integer[size];\n  }\n\n  void set_impure(int x, int y) {\n    a = x + y;\n  }\n\n  void global_array_set_impure(int x, int y) {\n    global_arr[0] = x + y;\n  }\n\n  int local_write_pure(int x, int y) {\n    int k = x + y;\n    k++;\n    return k;\n  }\n\n  void call_pure_pure(int size) {\n    for (int i = 0; i < size; i++) {\n      local_write_pure(i, size);\n    }\n  }\n\n  void call_impure_impure(int size) {\n    int d = 0;\n    for (int i = 0; i < size; i++) {\n      set_impure(i, size);\n    }\n  }\n\n  // no change to outside state, the local allocation is ok.\n  int local_alloc_pure(int x, int y) {\n    ArrayList<Integer> list = new ArrayList<Integer>(x + y);\n    for (Integer el : list) {\n      call_pure_pure(el);\n    }\n    return list.size();\n  }\n\n  void parameter_field_write_impure(Test test, boolean b) {\n    int c = b ? 0 : 1;\n    test.a = c;\n  }\n\n  int parameter_field_access_pure(Test test) {\n    return test.a;\n  }\n\n  // expected to be impure since y points to x\n  void local_field_write_impure(Test x) {\n    Test y = x;\n    y.a = 0;\n  }\n\n  void swap_impure(int[] array, int i, int j) {\n    int tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n\n  void alias_impure(int[] array, int i, int j) {\n    int[] a = array;\n    a[j] = i;\n  }\n\n  // Currently, we can't distinguish between returning new Objects or\n  // creating new Objects locally. Ideally, the latter should be fine\n  // as long as it doesn't leak to the result.\n  public ArrayList<Integer> emptyList_impure_FN() {\n    return new ArrayList<Integer>();\n  }\n\n  // All unmodeled calls should be considered impure\n  static long systemNanoTime_impure() {\n    return System.nanoTime();\n  }\n\n  void exit_impure() {\n    System.exit(1);\n  }\n\n  void modify_exit_impure(int[] a) {\n    a[0] = 0;\n    System.exit(1);\n  }\n\n  // We get no pulse summary, hence consider this as impure\n  void while_true_impure() {\n    while (true) {}\n  }\n\n  void modify_both_impure() {\n    set_impure(0, 1);\n    global_array_set_impure(3, 1);\n  }\n}\n"
    },
    {
      "testname": "TrickyExamples.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass TrickyExamples {\n\n  int x;\n\n  // pulse summary only includes a single disjunct for everything upto the throw statement.\n  void loop_impure_FN() {\n    if (x > 10) {\n      throw new IllegalArgumentException(\"x too big\");\n    }\n    x = 0;\n    for (int i = 0; i < 10; i++) {}\n  }\n}\n"
    }
  ]
}