{
  "name": "Liveness",
  "language": [
    "clang"
  ],
  "description": "Detection of dead stores and unused variables.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "OCaml",
  "loc": 366,
  "branches": 34,
  "apis": 93,
  "test": [
    {
      "testname": "dead_stores.cpp",
      "testlanguage": "c++",
      "expected-problems": 218,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <cstdint>\n#include <exception>\n#include <map>\n#include <mutex>\n#include <new>\n#include <stdexcept>\n#include <thread>\n\nnamespace infer {\nclass ScopeGuard {};\n}; // namespace infer\n\nnamespace dead_stores {\n\nvoid easy_bad() { int x = 5; }\n\nvoid throw_bad() {\n  int i = 20;\n  throw 1;\n}\n\nvoid reassign_param_bad(int x) { x = 5; }\n\nint dead_then_live_bad() {\n  int x = 5;\n  x = 3;\n  return x;\n}\n\nint use_then_dead_bad() {\n  int x = 5;\n  int y = x;\n  x = 7;\n  return y;\n}\n\nvoid dead_pointer_bad() {\n  int num = 2;\n  int* x = &num;\n}\n\nvoid plus_plus1_bad() {\n  int i = 1;\n  ++i;\n}\n\nvoid plus_plus2_bad() {\n  int i = 1;\n  i++;\n}\n\nint plus_plus3_bad() {\n  int i = 1;\n  return i++;\n}\n\nvoid FN_capture_no_read_bad() {\n  int x = 1;\n  [x]() { return; }();\n}\n\nint init_capture_reassign_bad() {\n  int i = 1; // this is a dead store\n  return [i = 1]() { return i; }();\n}\n\nauto FN_init_capture_no_call_bad() {\n  return [i = 1]() { return i; };\n}\n\nvoid init_capture_call_bad2() {\n  auto f = [i = 1]() { return i; };\n}\n\nint FN_init_capture_no_read_bad() {\n  return [i = 1]() { return 0; }();\n}\n\nint return_ok() {\n  int x = 5;\n  return x;\n}\n\nint branch_ok(bool b) {\n  int x = 5;\n  int y = 3;\n  if (b) {\n    y = x;\n  }\n  return y;\n}\n\nint loop_ok(bool b) {\n  int x = 5;\n  int y = 3;\n  while (b) {\n    y = x;\n    b = false;\n  }\n  return y;\n}\n\nint loop_break_ok(bool b) {\n  int x = 5;\n  while (b) {\n    x = 3;\n    break;\n  }\n  return x;\n}\n\nint loop_continue_ok(bool b) {\n  int x = 5;\n  int y = 2;\n  while (b) {\n    y = x;\n    x = 3;\n    continue;\n  }\n  return y;\n}\n\nvoid assign_pointer1_ok(int* ptr) { *ptr = 7; }\n\nint* assign_pointer2_ok() {\n  int num = 2;\n  int* ptr = &num;\n  return ptr;\n}\n\nvoid by_ref1_ok(int& ref) { ref = 7; }\n\nvoid by_ref2_ok(int& ref) { ref++; }\n\nint plus_plus_ok() {\n  int x = 1;\n  return ++x;\n}\n\nint plus_plus_loop_ok(int n) {\n  int i;\n  for (i = 1; i < n; i++) {\n    i++;\n  }\n  return i;\n}\n\nauto lambda_bad() {\n  int x = []() {\n    int y = 1;\n    y = 2;\n    return y;\n  }();\n  return x;\n}\n\nvoid capture1_ok() {\n  int x = 1;\n  [x]() { return x; }();\n}\n\nvoid capture2_ok(int x) {\n  [x]() { return x; }();\n}\n\nint capture_by_ref1_ok() {\n  int x = 1;\n  [&x]() { x++; }();\n  return x;\n}\n\nint capture_by_ref2_ok() {\n  int x = 1;\n  int y = 1;\n  [&]() {\n    x = x + y;\n    y = x;\n  }();\n  return x + y;\n}\n\nint capture_by_ref3_ok() {\n  int x = 1;\n  [&](auto y) { x += y; }(3);\n  return x;\n}\n\nint capture_by_ref4_ok() {\n  int x = 1;\n  auto lambda = [&] { return x; };\n  x = 2; // not a dead store; updates captured x\n  return lambda();\n}\n\nint dead_store_before_capture_by_ref_bad() {\n  int x = 1; // this is dead. should report it even though x is captured by ref\n             // later on\n  x = 2;\n  auto lambda = [&] { return x; };\n  x = 2;\n  return lambda();\n}\n\nint capture_by_value_bad() {\n  int x = 1;\n  auto lambda = [=] { return x; };\n  x = 2; // this is dead\n  return lambda();\n}\n\nint FN_capture_by_ref_reuseBad() {\n  int x = 1;\n  [&x]() {\n    x = 1; // dead, but we won't report\n    x = 2;\n  }();\n  return x;\n}\n\nint init_capture1_ok() {\n  return [i = 1]() { return i; }();\n}\n\nint init_capture2_ok() {\n  int i = 1;\n  return [j = i]() { return j; }();\n}\n\nint init_capture3_ok() {\n  int i = 1;\n  return [i = i]() { return i; }();\n}\n\nint init_capture4_ok() {\n  int i = 1;\n  int j = 1;\n  return [a = 1, b = i, c = j]() { return a + b + c; }();\n}\n\nint init_capture5_ok() {\n  int i = 1;\n  int k = [j = i]() { return j; }();\n  i = 5; // should not be flagged\n  return i + k;\n}\n\nint init_capture6_ok() {\n  int i = 1;\n  int k = [i = i + 1]() { return i; }();\n  i = 5; // should not be flagged;\n  return i + k;\n}\n\nchar* global;\n\nvoid assign_array_tricky_ok() {\n  char arr[1];\n  global = arr;\n  *(int*)arr = 123;\n}\n\n// Currently the frontend does not translate the casting of pointers to float.\nvoid FP_assign_array_tricky2_ok() {\n  char arr[1];\n  global = arr;\n  *(float*)arr = 1.0;\n}\n\nvoid placement_new_ok(int len, int* ptr) {\n  int* placement = ptr;\n  while (len--) {\n    new (placement++) int(5);\n  }\n}\n\n// we don't report on dead stores where the RHS is 0, 0.0, false, nullptr, etc.\nbool sentinel_bool_ok() {\n  bool b = false;\n  b = true;\n  return b;\n}\n\nint sentinel_int_ok() {\n  int i = 0;\n  i = 1;\n  return i;\n}\n\nint sentinel_long_ok() {\n  long l = 0L;\n  l = 1L;\n  return l;\n}\n\nfloat sentinel_float_ok() {\n  float f = 0.0;\n  f = 1.0;\n  return f;\n}\n\ndouble sentinel_double_ok() {\n  double d = 0.0;\n  d = 1.0;\n  return d;\n}\n\nint* sentinel_ptr_ok(int* j) {\n  int* i = nullptr;\n  i = j;\n  return i;\n}\n\nvoid custom_scope_guard_ok() { infer::ScopeGuard guard; }\n\nstruct S {\n  ~S() {}\n};\n\ntypedef S&& B;\n\nS mk_s() {\n  S s;\n  return s;\n};\n\n// s gets read by the destructor for S\nvoid FN_dead_struct_value1_bad() { S s = mk_s(); }\n\n// need to handle operator= in order to detect this case\nvoid FN_dead_struct_value2_bad() {\n  S s = mk_s();\n  s = mk_s();\n}\n\nvoid dead_struct_rvalue_ref_bad() { B b = mk_s(); }\n\nS struct_value_used_ok() {\n  S s = mk_s();\n  return s;\n}\n\nB& struct_rvalue_ref_used_ok() {\n  B b = mk_s();\n  return b;\n}\n\nstruct NoDestructor {};\n\nvoid dead_struct_no_destructor_bad() { NoDestructor dead; }\n\nvoid no_destructor_void_read_ok() {\n  NoDestructor dead;\n  (void)dead;\n}\n\nstruct NoDestructorDefinition {\n  ~NoDestructorDefinition();\n};\n\nvoid dead_struct_no_destructor_definition_ok() { NoDestructorDefinition dead; }\n\nstd::mutex my_mutex;\n\nvoid dead_lock_guard_ok() { std::lock_guard<std::mutex> lock(my_mutex); }\n\nvoid dead_unique_lock_ok() { std::unique_lock<std::mutex> lock(my_mutex); }\n\nextern int maybe_throw();\n\nclass Exceptions {\n\n  int read_in_catch1_ok() {\n    int i = 1;\n    try {\n      throw std::runtime_error(\"error\");\n    } catch (...) {\n      return i;\n    }\n    return 0;\n  }\n\n  int read_in_catch_explicit_throw_ok() {\n    int i = 1;\n    try {\n      maybe_throw();\n    } catch (...) {\n      return i;\n    }\n    return 0;\n  }\n\n  int dead_in_catch_bad() {\n    try {\n      throw std::runtime_error(\"error\");\n    } catch (...) {\n      int i = 1;\n    }\n    return 0;\n  }\n\n  int unreachable_catch_bad() {\n    int i = 1;\n    try {\n    } catch (...) {\n      return i;\n    }\n    return 0;\n  }\n\n  int multiple_catches_ok(bool b) {\n    int i = 1;\n    int j = 2;\n    try {\n      if (b) {\n        throw std::length_error(\"error\");\n      } else {\n        throw std::range_error(\"error\");\n      }\n    } catch (std::length_error& msg) {\n      return i;\n    } catch (std::range_error& msg) {\n      return j;\n    }\n    return 0;\n  }\n\n  void dont_throw() {}\n\n  int FN_harder_unreachable_catch_bad() {\n    int i = 1;\n    try {\n      dont_throw();\n    } catch (...) {\n      return i;\n    }\n    return 0;\n  }\n\n  int FN_throw_unrelated_catch_bad(int x) {\n    int i = 5;\n    throw std::invalid_argument(\"Positive argument  :(\");\n    // the rest is unreachable\n    try {\n      throw(0);\n    } catch (...) {\n\n      return i;\n    }\n  }\n\n  // currently, the only transition to the catch block is at the end of the try\n  // block. See T28898377\n  int read_in_catch_tricky_ok(bool b1, bool b2) {\n    int i = 1;\n    try {\n      if (b1) {\n        throw std::runtime_error(\"error\");\n      }\n      i = 2;\n      if (b2) {\n        throw std::runtime_error(\"error\");\n      }\n    } catch (...) {\n      return i;\n    }\n    return 0;\n  }\n\n  int read_in_loop_tricky_ok(bool b) {\n    int i = 1;\n    for (int p = 0; p <= 5; p++) {\n      try {\n        if (b) {\n          throw std::runtime_error(\"error\");\n        }\n      } catch (...) {\n        return i;\n      }\n    }\n\n    return 0;\n  }\n\n  int read_in_goto_ok(bool b) {\n    int i = 1;\n    try {\n      if (b) {\n        throw std::runtime_error(\"error\");\n\n        goto A;\n      } else {\n\n        goto B;\n      }\n    A:\n      goto B;\n    B:\n      goto A;\n    }\n\n    catch (...) {\n      return i;\n    }\n    return 0;\n  }\n  int return_in_try1_ok() {\n    bool b;\n\n    try {\n      maybe_throw();\n      return 3;\n    } catch (const char* msg) {\n      b = true;\n    }\n\n    if (b) {\n      return 2;\n    }\n    return 3;\n  }\n\n  int return_in_try2_ok() {\n    bool b;\n\n    try {\n      return maybe_throw();\n    } catch (const char* msg) {\n      b = true;\n    }\n\n    if (b) {\n      return 2;\n    }\n    return 3;\n  }\n\n  int return_in_try_in_for_ok() {\n    constexpr int i1 = 3;\n    for (int i = 1;; ++i) {\n      try {\n        return maybe_throw();\n      } catch (const char* msg) {\n        if (i1 == i) {\n          return 2;\n        }\n      }\n    }\n    return 3;\n  }\n\n  int read_in_catch_ok() {\n    int x;\n    try {\n      x = 10;\n      maybe_throw();\n      x = 20;\n    } catch (...) {\n      return x;\n    }\n    return x;\n  }\n\n  int not_read_in_catch_bad() {\n    int x;\n    try {\n      x = 10;\n      maybe_throw();\n      x = 20;\n    } catch (...) {\n      return 0;\n    }\n    return x;\n  }\n\n  int read_only_in_catch_bad() {\n    int x;\n    try {\n      x = 10;\n      maybe_throw();\n      x = 20;\n    } catch (...) {\n      return x;\n    }\n    return 0;\n  }\n\n  void never_throw() {}\n\n  int FN_read_only_in_unreachable_catch_bad() {\n    int x;\n    try {\n      x = 10;\n      never_throw();\n    } catch (...) {\n      return x;\n    }\n    return 0;\n  }\n};\n\nvoid init_in_binop_bad(int x) { x = -x & ~int{0}; }\n\nvoid unused_tmp_bad() { int __tmp = 1; }\n\n#define UNUSED(a) __typeof__(&a) __attribute__((unused)) __tmp = &a;\n\nvoid unused_attribute_tmp_ok() {\n  int x;\n  UNUSED(x);\n}\n\nvoid unused_attribute_ok() { int __attribute__((unused)) x = 42; }\n\nstruct ChainedCalls {\n  ChainedCalls chained(int i);\n};\n\nChainedCalls chain_method_calls_ok() {\n  ChainedCalls x;\n  return x.chained(5).chained(6);\n}\n\nstruct A {\n  int f : 4;\n};\n\nint FP_decltype_read_ok(int x) {\n  A a; // report here as the frontend erases the expression used in decltype\n       // below\n  decltype(a.f) i;\n  return x + i;\n}\n\n// destructor block listed for liveness in .inferconfig\nstruct BlockListedStruct {\n  ~BlockListedStruct(){};\n\n  BlockListedStruct cloneAsValue() const { return BlockListedStruct(); }\n\n  std::unique_ptr<BlockListedStruct> clone() const {\n    return std::make_unique<BlockListedStruct>(cloneAsValue());\n  }\n};\n\nvoid unused_block_listed_constructed_bad() { auto x = BlockListedStruct(); }\n\nvoid unused_block_listed_clone_bad(BlockListedStruct* something) {\n  auto x = something->clone();\n}\n\nvoid unused_block_listed_unique_ptr_bad(BlockListedStruct* something) {\n  auto x = std::make_unique<BlockListedStruct>(*something);\n}\n\nvoid unused_unique_ptr_good(A* something) {\n  auto x = std::make_unique<A>(*something);\n}\n\nstruct X {\n  operator bool() { return true; }\n};\n\nX getX() {\n  X x;\n  return x;\n}\n\nvoid binaryConditional_bad() {\n  int i = 42;\n  X a;\n  X x = getX() ?: a;\n  int j = 42;\n}\n\nX getXFromInt(int x);\n\nvoid switch_with_temporary_ok() {\n  int x = 44;\n  switch (42) {\n    case 0:\n      getXFromInt(x);\n  };\n}\n\nvoid ignored_constants_ok() {\n  int x = 0;\n  float f = 0.0;\n  int z = 44;\n}\n\nvoid store_total_in_global_state(int& total);\nvoid reads_global_state_with_total_in_it();\n\nvoid passed_by_ref_ok() {\n  int total;\n  store_total_in_global_state(total);\n  total = 42;\n  reads_global_state_with_total_in_it();\n}\n\nvoid FN_passed_by_ref_not_used_bad() {\n  int total;\n  store_total_in_global_state(total);\n  total = 42;\n  // any use of [total] would have to occur before function exit as accesses\n  // after function exit are invalid since total goes out of scope\n}\n\nvoid passed_by_ref_in_loop_ok(int n) {\n  int total;\n  for (int i = 0; i < n; i++) {\n    store_total_in_global_state(total);\n  }\n  total = 42;\n  reads_global_state_with_total_in_it();\n}\n\nvoid underscore_dead_store_ok() { int _ = 1234; }\n\nvoid use_string(std::string);\n\nvoid underscore_binding_ok(std::map<std::string, int> m) {\n  for (const auto& [key, _] : m) {\n    use_string(key);\n  }\n}\n\nvoid read(int);\n\nvoid swich_in_try_ok(int a) {\n  int x = 42;\n  try {\n    switch (a) {\n      case 42: {\n        return;\n      }\n      default:;\n    }\n  } catch (int) {\n  }\n  read(x);\n}\n\nvoid unknown();\n\nvoid unknown_call_in_try_ok() {\n  int x = 42;\n  try {\n    unknown();\n    return;\n  } catch (int) {\n  }\n  read(x);\n}\n\nbool atomic_compare_exchange_ok() {\n  uint32_t ptr = 1;\n  uint32_t expected = 1;\n  uint32_t desired = 0;\n\n  bool success = __atomic_compare_exchange(\n      &ptr, &expected, &desired, false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n\n  return success;\n}\n} // namespace dead_stores\n"
    },
    {
      "testname": "dead_stores_constexpr.cpp",
      "testlanguage": "c++",
      "expected-problems": 20,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nint foo(int a);\n\n// before, we were raising DEAD_STORE for x\nvoid capture_constexpr_good() {\n  constexpr int x = 10;\n  []() {\n    foo(x);\n    return;\n  }();\n}\n\nvoid call_it(void (*f)(void)) { f(); }\n\nvoid capture_constexpr2_good() {\n  constexpr int x = 1;\n  auto lambda = []() {\n    foo(x);\n    return;\n  };\n  call_it(lambda);\n}\n\nvoid capture_const_bad(const int y) {\n  const int x = y;\n  []() {\n    foo(0);\n    return;\n  }();\n}\n\n// we always assume const exprs are captured in lambdas\nvoid FN_capture_constexpr_good() {\n  constexpr int x = 10;\n  []() {\n    foo(0);\n    return;\n  }();\n}\n\nvoid FN_init_capture_reassign_bad() {\n  constexpr int i = 1; // this is a dead store\n  return [i = 1]() { return i; }();\n}\n\n// expected DEAD_STORE\nvoid FN_capture_constexpr_bad() {\n  constexpr int x = 1;\n  foo(2);\n}\n\n// expected since dead stores to a \"sentinel\" value are ignored\nvoid capture_constexpr_sentinel_good() {\n  constexpr int x = 0;\n  []() { return; }();\n}\n"
    },
    {
      "testname": "non_type_template_param.cpp",
      "testlanguage": "c++",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// see also https://github.com/facebook/infer/issues/950\n\ntemplate <int T>\nstruct X {\n  bool isZeroBad() {\n    int unused = 1;\n    return T == 0;\n  }\n};\n\nint instanciateTemplateBad() {\n  X<3> x;\n  x.isZeroBad();\n  int unused = 1;\n  return 0;\n}\n\nvoid instanciateTemplateConstOk_FP() {\n  const int foo = 7;\n  X<foo> x;\n  x.isZeroBad();\n}\n\nvoid instanciateTemplateConstExprOk() {\n  constexpr int foo = 7;\n  X<foo> x;\n  x.isZeroBad();\n}\n"
    }
  ]
}