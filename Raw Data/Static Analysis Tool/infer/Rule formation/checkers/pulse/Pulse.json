{
  "name": "Pulse",
  "language": [
    "clang",
    "java",
    "erlang",
    "hack"
  ],
  "description": "General-purpose memory and value analysis engine.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "OCaml",
  "loc": 1831,
  "branches": 204,
  "apis": 375,
  "test": [
    {
      "testname": "abduce.c",
      "testlanguage": "c",
      "expected-problems": 20,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid external_func(int* const*);\n\nint const_local_no_abduce(int* p) {\n  external_func(&p);\n  return p ? *p : 0;\n  // We shouldn't get a stack address escape warning here\n}\n\nvoid set_ptr(int* ptr, int val) { *ptr = val; }\n\nint set_ptr_local_array() {\n  int buf[2];\n  set_ptr(buf, 1);\n  return buf[0];\n}\n\nvoid FP_set_ptr_local_array_return_true_ok() {\n  int* p = NULL;\n  if (!set_ptr_local_array())\n    // not reachable if the analysis of set_ptr_local_array is correct\n    *p = 42;\n}\n\nint set_ptr_param_array(int buf[]) {\n  set_ptr(buf, 1);\n  return buf[0];\n}\n\nvoid FP_set_ptr_param_array_return_true_ok() {\n  int buf[2];\n  int* p = NULL;\n  if (!set_ptr_param_array(buf))\n    // not reachable if the analysis of set_ptr_local_array is correct\n    *p = 42;\n}\n\nvoid FP_set_ptr_param_array_get_ptr_ok() {\n  int x = 0;\n  int* p = NULL;\n  if (!set_ptr_param_array(&x))\n    // not reachable if the analysis of set_ptr_local_array is correct\n    *p = 42;\n}\n\nvoid set_ptr_param_array_get_null_bad() {\n  // A null pointer dereference is expected here\n  set_ptr_param_array(NULL);\n}\n"
    },
    {
      "testname": "aliasing.c",
      "testlanguage": "c",
      "expected-problems": 19,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid FP_local_addr_noalias_ok(int* p) {\n  int* q = NULL;\n  int x = 1;\n  if (&x == p) {\n    *q = 42;\n  }\n}\n\nvoid local_addr_noalias_bad(int* p) {\n  int* q = NULL;\n  int x = 1;\n  if (&x != p) {\n    *q = 42;\n  }\n}\n\nstatic int g = 0;\nvoid global_addr_alias_bad(int* p) {\n  int* q = NULL;\n  if (&g == p) {\n    *q = 42;\n  }\n}\n\nvoid angelic_treatment_of_funcction_pointers_ok(int* (*fun_pointer)()) {\n  int* p = fun_pointer();\n  *p = 42;\n}\n\nvoid null_dereference_following_function_pointer_call_bad(\n    int* (*fun_pointer)()) {\n  int* p = fun_pointer();\n  p = NULL;\n  *p = 42;\n}\n"
    },
    {
      "testname": "angelism.c",
      "testlanguage": "c",
      "expected-problems": 32,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct delicious {\n  int yum;\n  int* ptr;\n};\n\nstruct delicious* bake(struct delicious** cake) {\n  int* zero = NULL;\n  *zero = 3;\n  return NULL;\n}\n\nstruct delicious* skip_function_with_no_spec_ok(void) {\n  struct delicious* cake = NULL;\n  int i;\n\n  if (bake(&cake) == NULL) {\n    return 0;\n  }\n\n  i = cake->yum;\n  return cake;\n}\n\nextern struct delicious* bakery(struct delicious** cake);\nextern struct delicious* bakery2(struct delicious** cake,\n                                 struct delicious** pie);\nextern struct delicious* returnPassByRef();\nextern void skip(struct delicious* s);\n\nstruct delicious* skip_external_function_ok(void) {\n  struct delicious* cake = NULL;\n  int i;\n\n  if (bakery(&cake) == NULL) {\n    return 0;\n  }\n\n  i = cake->yum;\n  return cake;\n}\n\nvoid by_ref_actual_already_in_footprint(struct delicious* param) {\n  int i;\n  struct delicious* ret = bakery(&param);\n  i = param->yum;\n}\n\nvoid call_by_ref_actual_already_in_footprint_ok() {\n  by_ref_actual_already_in_footprint(NULL); // should not report a warning\n}\n\nvoid by_ref_actual_already_in_footprint2(struct delicious* param) {\n  int i;\n  i = param->yum; // should not report a warning\n  struct delicious* ret = bakery(&param);\n  i = param->yum; // should not report a warning\n}\n\nvoid call_by_ref_actual_already_in_footprint_bad() {\n  by_ref_actual_already_in_footprint2(NULL); // should report a warning\n}\n\nvoid passByRefTwiceOk() {\n  struct delicious* param;\n  bakery2(&param, &param); // should not report a warning\n  int i = param->yum;\n}\n\nstruct delicious* returnPassByRef2Ok() {\n  struct delicious* param = NULL;\n  bakery(&param);\n  int i = param->yum; // should not report a warning\n  return param;\n}\n\nvoid returnPassByRefDerefOk() {\n  struct delicious* ret = returnPassByRef();\n  ret->yum = 2; // should not report a warning\n  free(ret);\n}\n\nextern void struct_ptr_skip(struct delicious* s);\n\nextern void struct_val_skip(struct delicious s);\n\nint struct_value_by_ref_ptr_ok() {\n  struct delicious x;\n  struct_ptr_skip(&x);\n  return *x.ptr; // should not report null deref warning\n}\n\nint struct_value_by_ref_ptr_write_before_ok() {\n  struct delicious x;\n  x.ptr = NULL;\n  struct_ptr_skip(&x);\n  return *x.ptr; // should not report null deref warning\n}\n\nint struct_value_by_ref_ptr_write_bad() {\n  struct delicious x;\n  struct_ptr_skip(&x);\n  x.ptr = NULL;\n  return *x.ptr; // should report null deref warning\n}\n\nvoid setF(struct delicious* x, int val) { x->ptr = val; }\n\nint struct_value_by_ref_callee_write_no_skip_bad() {\n  struct delicious x;\n  setF(&x, NULL);\n  return *x.ptr; // should report null deref warning\n}\n\nint struct_value_by_ref_callee_write_skip_bad() {\n  struct delicious x;\n  struct_ptr_skip(&x);\n  setF(&x, NULL);\n  return *x.ptr; // should report null deref warning\n}\n\nint struct_value_by_ref_write_then_skip_ok() {\n  struct delicious x;\n  x.ptr = NULL;\n  struct_ptr_skip(&x);\n  return *x.ptr; // should not report null deref warning\n}\n\nint struct_value_skip_null_deref_bad() {\n  struct delicious x;\n  x.ptr = NULL;\n  struct_val_skip(x);\n  return *x.ptr; // should report null deref warning\n}\n\nint struct_value_skip_ok() {\n  struct delicious x;\n  x.yum = 7;\n  struct_val_skip(x);\n  return 1 / x.yum; // should not report div by zero warning\n}\n\nint struct_value_from_pointer_skip_ok(struct delicious* x) {\n  struct_val_skip(*x);\n  return 1 / x->yum; // should not report div by zero warning\n}\n\nint struct_value_from_pointer_skip_bad(struct delicious* x) {\n  x->ptr = NULL;\n  struct_val_skip(*x);\n  return 1 / *x->ptr; // should report null deref warning\n}\n"
    },
    {
      "testname": "arithmetic.c",
      "testlanguage": "c",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n\nint return_non_negative() {\n  int x = random();\n  if (x < 0) {\n    exit(1);\n  }\n  return x;\n}\n\nvoid return_non_negative_is_non_negative_ok() {\n  if (return_non_negative() < 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid assume_non_negative(int x) {\n  if (x < 0) {\n    exit(1);\n  }\n}\n\nvoid assume_non_negative_is_non_negative_ok() {\n  int x = random();\n  assume_non_negative(x);\n  if (x < 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid if_negative_then_crash_latent(int x) {\n  assume_non_negative(-x);\n  int* p = NULL;\n  *p = 42;\n}\n\nvoid FN_call_if_negative_then_crash_with_negative_bad(int x) {\n  if (x < 0) {\n    if_negative_then_crash_latent(x);\n  }\n}\n\nvoid call_if_negative_then_crash_with_local_bad() {\n  int x = random();\n  if_negative_then_crash_latent(x);\n}\n\nfloat return_non_negative_float() {\n  float x = ((float)random()) / (2 ^ 31 - 1);\n  if (x < 0.) {\n    exit(1);\n  }\n  return x;\n}\n\nvoid return_non_negative_float_is_non_negative_ok() {\n  if (return_non_negative_float() < 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid assume_non_negative_float(float x) {\n  if (x < 0.) {\n    exit(1);\n  }\n}\n\nvoid assume_non_negative_float_is_non_negative_ok() {\n  float x = ((float)random()) / (2 ^ 31 - 1);\n  assume_non_negative_float(x);\n  if (x < 0.) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "array_out_of_bounds.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// pulse doesn't detect array out of bound errors yet\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warray-bounds\"\nvoid FN_const_bound_too_large_bad() {\n  int a[7];\n  a[7] = 4;\n}\n#pragma clang diagnostic pop\n\nvoid nested_array_ok() {\n  int a[3][4][5];\n  a[2][3][4] = 0;\n}\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warray-bounds\"\nvoid FN_const_nested_bound_too_large_bad() {\n  int a[3][4][5];\n  a[4][3][2] = 0;\n}\n#pragma clang diagnostic pop\n"
    },
    {
      "testname": "assert.c",
      "testlanguage": "c",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n\n// We should report here no NPE in the first dereference, but also we\n// should report the second NPE as it is reachable\nint report_on_line_offset_6_bad(int* p) {\n  assert(p);\n  if (!p) {\n    *p = 42; // unreachable\n  }\n  int* q = NULL;\n  *q = 42;\n}\n"
    },
    {
      "testname": "assert_failure.c",
      "testlanguage": "c",
      "expected-problems": 23,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n\n// pulse does not report assertion failures yet so all these are FN\n\nvoid simple_check(int x) { assert(x < 3); }\n\nvoid simple_assertion_failure() {\n  int x = 4;\n  simple_check(x);\n}\n\nvoid no_assertion_failure() {\n  int x = 2;\n  simple_check(x);\n}\n\ntypedef struct {\n  int value;\n} node;\n\nvoid check_node(node* n) { assert(n->value < 3); }\n\nnode* assertion_failure_with_heap() {\n  node* n = malloc(sizeof(node));\n  if (n != NULL) {\n    n->value = 4;\n    check_node(n);\n  }\n  return n;\n}\n\nnode* no_assertion_failure_with_heap() {\n  node* n = malloc(sizeof(node));\n  if (n != NULL) {\n    n->value = 2;\n    check_node(n);\n  }\n  return n;\n}\n\nvoid __infer_fail(char*);\n\nvoid my_assert(int x) {\n  if (!x) {\n    __infer_fail(\"ASSERTION_FAILURE\");\n  }\n}\n\nvoid should_not_report_assertion_failure(int x) { my_assert(x); }\n\nvoid should_report_assertion_failure(int x) {\n  x = 0;\n  my_assert(x);\n}\n\nint global;\n\nvoid check_global() { assert(global != 0); }\n\nvoid skip() {}\n\nvoid assignment_after_check() {\n  check_global();\n  global = 0;\n  skip();\n}\n\nvoid assignemt_before_check() {\n  global = 0;\n  check_global();\n}\n\nvoid failure_on_both_branches(int x) {\n  if (x > 3) {\n    simple_check(x);\n  } else {\n    simple_check(42);\n  }\n}\n"
    },
    {
      "testname": "cleanup_attribute.c",
      "testlanguage": "c",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n#include <string.h>\n\nvoid cleanup_char(char** x) { free(*x); }\n\nvoid cleanup_int(int** x) { free(*x); }\n\nvoid no_cleanup(int** x) { /* nothing */ }\n\nvoid cleanup_malloc_ok() {\n  __attribute__((cleanup(cleanup_int))) int* x;\n  // attribute cleanup is done on *x not x, resulting in NPE, Uninit, and\n  // memleak FPs\n  x = malloc(sizeof(int));\n  if (x != NULL) {\n    *x = 10;\n  }\n  /* x goes out of scope. Cleanup function called - no leak */\n}\n\nvoid FN_wrong_cleanup_malloc_bad() {\n  // no_cleanup does nothing, hence there is a leak\n  __attribute__((cleanup(no_cleanup))) int* x;\n  x = malloc(sizeof(int));\n}\n\n// related to https://github.com/facebook/infer/issues/8\nvoid cleanup_string_ok() {\n  __attribute__((cleanup(cleanup_char))) char* s;\n  s = strdup(\"demo string\");\n  /* s goes out of scope. Cleanup function called - no leak */\n}\n"
    },
    {
      "testname": "compound_literal.c",
      "testlanguage": "c",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct point {\n  int x;\n  int y;\n};\n\nint return_zero() { return ((struct point){.y = 32, .x = 0}).x; }\n\nint detect_zero_bad() {\n  if (return_zero() == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint detect_zero_ok() {\n  if (return_zero() != 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "dangling_deref.c",
      "testlanguage": "c",
      "expected-problems": 16,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint* set42(int* x) {\n  *x = 42;\n  return x;\n}\n\nvoid no_dangling_deref_ok() {\n  int w, *z;\n  z = set42(&w);\n}\n\nvoid no_dangling_deref1_ok() {\n  int* y = malloc(sizeof(int));\n  int* z;\n  if (y) {\n    z = set42(y);\n    free(y);\n  }\n}\n\nvoid dangling_deref_bad() {\n  int* y;\n  int* z;\n  z = set42(y);\n}\n\nvoid intraproc_dangling_deref_bad() {\n  int* y;\n  int* z;\n  *y = 42;\n  z = y;\n}\n\nshort union_ok(int* param) {\n  union {\n    int* a;\n    short* b;\n  } u;\n  u.a = param;\n  short* p = u.b;\n  return *p;\n}\n"
    },
    {
      "testname": "divide_by_zero.c",
      "testlanguage": "c",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// pulse doesn't detect division by zero yet\nint FN_const_divide_by_zero_bad() {\n  int x = 0;\n  int y = 5;\n  return y / x;\n}\n"
    },
    {
      "testname": "enum.c",
      "testlanguage": "c",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nenum Foo { A, B, C = 10, D, E = 1, F, G = F + C };\n\nint other_enum_main() {\n  enum Foo foo_a = A;\n  enum Foo foo_b = B;\n  enum Foo foo_c = C;\n  enum Foo foo_d = D;\n  enum Foo foo_e = E;\n  enum Foo foo_f = F;\n  enum Foo foo_g = G;\n}\n\nvoid enum_values_ok() {\n  enum Foo foo_g = G;\n  enum Foo foo_a = A;\n  if (foo_g != 12 || foo_a != 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid enum_values_bad() {\n  enum Foo foo_g = G;\n  enum Foo foo_a = A;\n  if (foo_g == 12 && foo_a == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "exit_example.c",
      "testlanguage": "c",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid exit_example_bad() {\n  int* p = NULL;\n  if (p) {\n    exit(1);\n  }\n  *p = 42;\n}\n\nvoid direct_exit_example_ok() {\n  int* p = NULL;\n  exit(1);\n  *p = 42;\n}\n\nvoid exit_wrapper() { exit(1); }\n\nvoid indirect_exit_example_ok() {\n  int* p = NULL;\n  exit_wrapper();\n  *p = 42;\n}\n\nvoid direct_abort_example_ok() {\n  int* p = NULL;\n  abort();\n  *p = 42;\n}\n\nvoid abort_wrapper() { abort(); }\n\nvoid indirect_abort_example_ok() {\n  int* p = NULL;\n  abort_wrapper();\n  *p = 42;\n}\n"
    },
    {
      "testname": "field_taint.c",
      "testlanguage": "c",
      "expected-problems": 31,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntypedef struct {\n  int manipulated;\n  int other;\n} structure;\n\nint int_source(void);\nvoid taint_structure(structure);\nvoid taint_manipulated(structure);\nvoid taint_manipulated_with_indirections(structure**);\n\nvoid sink_int(int);\nvoid sink_log(int);\nvoid sink_manipulated(structure);\n\nvoid sanitize_manipulated(structure);\n\nvoid propagate_to_manipulated(structure, int);\n\nvoid test_taint_field_bad(structure s) {\n  taint_manipulated(s);\n  sink_int(s.manipulated);\n}\n\nvoid test_taint_field_good(structure s) {\n  taint_manipulated(s);\n  sink_int(s.other);\n}\n\nvoid test_sink_field_bad(structure s) {\n  int tainted = int_source();\n  s.manipulated = tainted;\n  sink_manipulated(s);\n}\n\nvoid test_sink_field_good(structure s) {\n  int tainted = int_source();\n  s.other = tainted;\n  sink_manipulated(s);\n}\n\nvoid test_sanitize_field_bad(structure s) {\n  // The 2 lines below are necessary because tainting propagates down\n  // what is known in the memory at the moment of tainting and it is never\n  // propagated again when a new manipulated appears. `s.other` and\n  // `s.manipulated` need to have different values otherwise they are both\n  // referencing the same value and sanitizing one would sanitize the other\n  s.other = 2; // makes s.other exist in memory before tainting s\n  s.manipulated = 1; // makes s.manipulated exist in memory before tainting s\n  taint_structure(s);\n  sanitize_manipulated(s);\n  sink_int(s.other);\n}\n\nvoid test_sanitize_field_good(structure s) {\n  s.other = 2; // makes s.other exist in memory before tainting s\n  s.manipulated = 1; // makes s.manipulated exist in memory before tainting s\n  taint_structure(s);\n  sanitize_manipulated(s);\n  sink_manipulated(s);\n}\nvoid test_propagate_to_field_bad(structure s) {\n  int tainted = int_source();\n  propagate_to_manipulated(s, tainted);\n  sink_int(s.manipulated);\n}\n\nvoid test_propagate_to_field_good(structure s) {\n  int tainted = int_source();\n  propagate_to_manipulated(s, tainted);\n  sink_int(s.other);\n}\n\nvoid test_taint_field_with_indirections_bad(structure s) {\n  structure* s_ptr = &s;\n  structure** s_ptr_ptr = &s_ptr;\n  taint_manipulated_with_indirections(s_ptr_ptr);\n  sink_int((**s_ptr_ptr).manipulated);\n}\n\nvoid test_taint_field_with_indirections_good(structure s) {\n  structure* s_ptr = &s;\n  structure** s_ptr_ptr = &s_ptr;\n  taint_manipulated_with_indirections(s_ptr_ptr);\n  sink_int((**s_ptr_ptr).other);\n}\n\nvoid test_taint_previously_unaccessed_field_bad(structure s) {\n  taint_structure(s);\n  sink_int(s.manipulated);\n}\n\nvoid test_taint_logger_policy(structure s) {\n  taint_manipulated(s);\n  sink_log(s.manipulated);\n}\n"
    },
    {
      "testname": "fopen.c",
      "testlanguage": "c",
      "expected-problems": 61,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid no_fopen_check_getc_bad() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  i = getc(f);\n  printf(\"i =%i\\n\", i);\n  fclose(f);\n}\n\nvoid fopen_check_getc_ok() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    i = getc(f);\n    printf(\"i =%i\\n\", i);\n    fclose(f);\n  }\n}\n\nvoid fopen_no_fclose_bad() {\n  FILE* f;\n  int i;\n  f = fopen(\"some_file\", \"r\");\n  if (f) {\n    i = getc(f);\n    printf(\"i =%i\\n\", i);\n  }\n}\n\nvoid no_fopen_check_fgetc_bad() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  i = fgetc(f);\n  printf(\"i =%i\\n\", i);\n  fclose(f);\n}\n\nvoid fopen_check_fgetc_ok() {\n  FILE* f;\n  int i;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    i = fgetc(f);\n    printf(\"i =%i\\n\", i);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_ungetc_bad() {\n  FILE* f;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  int i = ungetc(10, f);\n  fclose(f);\n}\n\nvoid fopen_check_ungetc_ok() {\n  FILE* f;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    int i = ungetc(10, f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fputs_bad() {\n  FILE* f;\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fputs(\"blablabla\", f);\n  fclose(f);\n}\n\nvoid fopen_check_fputs_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fputs(\"blablabla\", f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fputc_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fputc(42, f);\n  fclose(f);\n}\n\nvoid fopen_check_fputc_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fputc(42, f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_putc_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  putc(42, f);\n  fclose(f);\n}\n\nvoid fopen_check_putc_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    putc(42, f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fseek_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fseek(f, 7, SEEK_SET);\n  fclose(f);\n}\n\nvoid fopen_check_fseek_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fseek(f, 7, SEEK_SET);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_ftell_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  ftell(f);\n  fclose(f);\n}\n\nvoid fopen_check_ftell_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    ftell(f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fgets_bad() {\n  FILE* f;\n  char str[60];\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fgets(str, 60, f);\n  fclose(f);\n}\n\nvoid fopen_check_fgets_ok() {\n  FILE* f;\n  char str[60];\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fgets(str, 60, f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_rewind_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  rewind(f);\n  fclose(f);\n}\n\nvoid fopen_check_rewind_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    rewind(f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fileno_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fileno(f);\n  fclose(f);\n}\n\nvoid fopen_check_fileno_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fileno(f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_clearerr_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  clearerr(f);\n  fclose(f);\n}\n\nvoid fopen_check_clearerr_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    clearerr(f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_ferror_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  ferror(f);\n  fclose(f);\n}\n\nvoid fopen_check_ferror_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    ferror(f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_feof_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  feof(f);\n  fclose(f);\n}\n\nvoid fopen_check_feof_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    feof(f);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fprintf_bad() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fprintf(f, \"blablabla\\n\");\n  fclose(f);\n}\n\nvoid fopen_check_fprintf_ok() {\n  FILE* f;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fprintf(f, \"blablabla\\n\");\n    fclose(f);\n  }\n}\n\n/* NOTE: Temporarily commented out since these tests make different results on\n   macos arm machine.\n\nvoid no_fopen_check_vfprintf_bad() {\n  FILE* f;\n  va_list arg;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  vfprintf(f, \"blablabla\\n\", arg);\n  fclose(f);\n}\n\nvoid fopen_check_vfprintf_ok() {\n  FILE* f;\n  va_list arg;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    vfprintf(f, \"blablabla\\n\", arg);\n    fclose(f);\n  }\n} */\n\nvoid no_fopen_check_fgetpos_bad() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fgetpos(f, &position);\n  fclose(f);\n}\n\nvoid fopen_check_fgetpos_ok() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fgetpos(f, &position);\n    fclose(f);\n  }\n}\n\nvoid no_fopen_check_fsetpos_bad() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  fsetpos(f, &position);\n  fclose(f);\n}\n\nvoid fopen_check_fsetpos_ok() {\n  FILE* f;\n  fpos_t position;\n\n  f = fopen(\"this_file_doesnt_exist\", \"r\");\n  if (f) {\n    fsetpos(f, &position);\n    fclose(f);\n  }\n}\n\nchar* string_source();\nvoid sink_string(char* s);\nvoid sink_int(int c);\n\n// excepting 3 taint flows\nvoid file_operations_propagate_taint_bad() {\n  char* tainted = string_source();\n  FILE* file = fopen(tainted, \"r\");\n  if (!file) {\n    return;\n  }\n  char s[256];\n  char* t = fgets(s, 256, file);\n  sink_string(t);\n  sink_int(fgetc(file));\n  sink_int(getc(file));\n  sink_int(fileno(file)); // benign\n  fclose(file);\n}\n\nvoid fprintf_propagate_taint_bad() {\n  char* tainted = string_source();\n  FILE* file = fopen(\"some_file\", \"r\");\n  if (!file) {\n    return;\n  }\n  fprintf(file, \"%s\", tainted);\n  sink_int(getc(file));\n  fclose(file);\n}\n\nvoid fputs_propagate_taint_bad() {\n  char* tainted = string_source();\n  FILE* file = fopen(\"some_file\", \"r\");\n  if (!file) {\n    return;\n  }\n  fputs(tainted, file);\n  sink_int(getc(file));\n  fclose(file);\n}\n\nvoid FN_fputc_propagate_taint_bad() {\n  char* tainted = string_source();\n  FILE* file = fopen(\"some_file\", \"r\");\n  if (!file) {\n    return;\n  }\n  fputc(file, tainted[42]);\n  sink_int(getc(file));\n  fclose(file);\n}\n"
    },
    {
      "testname": "frontend.c",
      "testlanguage": "c",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid assign_implicit_cast_ok() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  uint16_t i = 1;\n  if (b) {\n    *b = true;\n    *b = !i;\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n\nvoid assign_implicit_cast_bad() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  uint16_t i = 0;\n  if (b) {\n    *b = false;\n    *b = !i;\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n\nvoid assign_paren_ok() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  int x = 42, y = 33;\n  if (b) {\n    *b = true;\n    *b = (x == y);\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n\nvoid assign_paren_bad() {\n  bool* b = (bool*)malloc(sizeof(bool));\n  int x = 42, y = 42;\n  if (b) {\n    *b = false;\n    *b = (x == y);\n    if (*b) {\n      int* p = 0;\n      *p = 5;\n    }\n    free(b);\n  }\n}\n"
    },
    {
      "testname": "frontend_compound_literal.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct point {\n  int x;\n  int y;\n};\n\nvoid init_with_compound_literal_npe_bad() {\n  struct point p = (struct point){32, 52};\n  if (p.x == 32) {\n    int* pointer = NULL;\n    *pointer = 42;\n  }\n}\n\nvoid init_with_compound_literal_npe_good() {\n  struct point p = (struct point){32, 52};\n  if (p.x == 1) {\n    int* pointer = NULL;\n    *pointer = 42;\n  }\n}\n"
    },
    {
      "testname": "frontend_struct_initlistexpr.c",
      "testlanguage": "c",
      "expected-problems": 26,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\ntypedef struct Point {\n  int x;\n  int y;\n} Point;\n\nint return_5() { return 5; }\n\nvoid init_Point() { struct Point p = {1, return_5() + 3}; }\n\nint point_coords_set_correctly_npe_bad(Point* p) {\n  *p = (Point){4, 5};\n  int* pointer = NULL;\n  if (p->x == 4) {\n    return *pointer;\n  } else\n    return 0;\n}\n\nint point_coords_set_correctly_npe_good(Point* p) {\n  *p = (Point){4, 5};\n  int* pointer = NULL;\n  if (p->x == 1) {\n    return *pointer;\n  } else\n    return 0;\n}\n\nstruct Employee {\n  int ssn;\n  float salary;\n  struct date {\n    int date;\n    int month;\n    int year;\n  } doj;\n} emp1;\n\nint field_set_correctly_npe_bad() {\n  struct Employee e = {12, 3000.50, 12, 12, 2010};\n  int* p = NULL;\n  if (e.ssn == 12) {\n    return *p;\n  } else\n    return 0;\n}\n\nint field_set_correctly_npe_good() {\n  struct Employee e = {12, 3000.50, 12, 12, 2010};\n  int* p = NULL;\n  if (e.ssn == 1) {\n    return *p;\n  } else\n    return 0;\n}\n\nstruct dotdot {\n  int a;\n  int b;\n};\n\nstruct dot {\n  struct dotdot x;\n  int y;\n};\nstruct rect {\n  struct dot origin;\n  int z;\n  int size;\n};\n\ntypedef struct rect rect;\n\nint implicit_expr_set_correctly_npe_bad() {\n  rect imageDrawRect;\n  imageDrawRect = (rect){.size = 5};\n  int* p = NULL;\n  if (imageDrawRect.origin.x.a == 0) {\n    return *p;\n  } else\n    return 0;\n}\n\nint implicit_expr_set_correctly_npe_good() {\n  rect imageDrawRect;\n  imageDrawRect = (rect){.size = 5};\n  int* p = NULL;\n  if (imageDrawRect.origin.x.a == 1) {\n    return *p;\n  } else\n    return 0;\n}\n"
    },
    {
      "testname": "funptr.c",
      "testlanguage": "c",
      "expected-problems": 112,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stddef.h>\n\nvoid do_nothing(int** _ptr) { return; }\n\nvoid assign_NULL(int** ptr) { *ptr = NULL; }\n\nvoid call_funptr(void (*funptr)(int**), int** ptr) { (*funptr)(ptr); }\n\nvoid call_call_funptr(void (*funptr)(int**), int** ptr) {\n  call_funptr(funptr, ptr);\n}\n\n// Basic case: specialized in pre-analysis\n\nvoid test_syntactic_specialization_bad(int* ptr) {\n  call_call_funptr(&assign_NULL, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n\n// Specialize over returned funptr\n\nvoid (*return_funptr(void))(int**) { return &assign_NULL; }\n\nvoid test_returned_funptr_specialization_bad(int* ptr) {\n  void (*funptr)(int**) = return_funptr();\n  call_call_funptr(funptr, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n\n// Playing around with conditions\n\nint funptr_if_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nint funptr_if_good() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_NULL;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nint funptr_else_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_NULL;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n\nint funptr_else_good() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n\nint funptr_conditional_call_bad(int x) {\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr);\n  return *ptr;\n}\n\nvoid apply_funptr_with_intptrptr(void (*funptr)(int**), int** ptr) {\n  (*funptr)(ptr);\n}\n\nint funptr_apply_funptr_with_intptrptr_specialized_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr(funptr,\n                              &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nint funptr_apply_funptr_with_intptrptr_specialized_good() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_NULL;\n  }\n  apply_funptr_with_intptrptr(funptr,\n                              &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nvoid apply_funptr_with_intptrptr_and_after(void (*funptr)(int**),\n                                           void (*after)(int**),\n                                           int** ptr) {\n  int x = 0;\n  if (x) {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr(funptr, ptr);\n  (*after)(ptr);\n}\n\nvoid dereference_dereference_ptr(int** ptr) { int x = **ptr; }\n\nint funptr_apply_funptr_with_intptrptr_and_after_specialized_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  void (*after)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n    after = &dereference_dereference_ptr;\n  } else {\n    funptr = &do_nothing;\n    after = &do_nothing;\n  }\n  apply_funptr_with_intptrptr_and_after(\n      funptr,\n      after,\n      &ptr); // Calling funptr assigned in if branch. NPE when calling after\n  return *ptr;\n}\n\nint funptr_apply_funptr_with_intptrptr_and_after_respecialized_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr_and_after(\n      funptr,\n      &dereference_dereference_ptr,\n      &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nvoid conditionnaly_apply_funptr_with_intptrptr(int x,\n                                               int** ptr,\n                                               void (*funptr)(int** ptr)) {\n  if (x) {\n    (*funptr)(ptr);\n  }\n  *ptr = NULL;\n}\n\nint funptr_conditionnaly_apply_funptr_with_intptrptr_unspecialized_bad() {\n  int x = 0;\n  int* ptr = NULL;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  conditionnaly_apply_funptr_with_intptrptr(\n      x, &ptr, funptr); // funptr is not called; function is not specialized\n  return *ptr;\n}\n\nint funptr_conditionnaly_apply_funptr_with_intptrptr_specialized_bad() {\n  int x = 1;\n  int* ptr = NULL;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_NULL;\n  } else {\n    funptr = &do_nothing;\n  }\n  conditionnaly_apply_funptr_with_intptrptr(\n      x, &ptr, funptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n\n// Playing around with structures\n\ntypedef struct FunPtrCallback {\n  void (*f)(int**);\n} callback_s;\n\nvoid set_callback(callback_s* callback, void (*f)(int**)) { callback->f = f; }\nvoid apply_callback(callback_s* callback, int** ptr) { (*callback->f)(ptr); }\n\nvoid test_assign_NULL_callback_bad(int* ptr) {\n  callback_s callback = {.f = &assign_NULL};\n  apply_callback(&callback, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n\nvoid test_do_nothing_callback_good(int* ptr) {\n  callback_s callback = {.f = &do_nothing};\n  apply_callback(&callback, &ptr);\n  *ptr = 42; // latent NULL dereference here\n}\n\nvoid test_update_callback_bad(callback_s* callback, int* ptr) {\n  set_callback(callback, &assign_NULL);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // NULL dereference here\n}\n\nvoid test_update_callback_good(callback_s* callback, int* ptr) {\n  set_callback(callback, &do_nothing);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // latent NULL dereference here\n}\n"
    },
    {
      "testname": "getcwd.c",
      "testlanguage": "c",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <unistd.h>\n\n#define BUFFER_SIZE 16\n\nchar getcwd_ok() {\n  char* cwd = getcwd(NULL, 0);\n  if (cwd != NULL) {\n    char result = cwd[0];\n    free(cwd);\n    return result;\n  }\n  char buf[BUFFER_SIZE];\n  cwd = getcwd(&buf, BUFFER_SIZE);\n  if (cwd != NULL) {\n    return cwd[0];\n  }\n  return 'a';\n}\n\nchar getcwd_no_buf_no_check_bad() {\n  char* cwd = getcwd(NULL, 0);\n  char result = cwd[0];\n  free(cwd);\n  return result;\n}\n\nchar getcwd_no_buf_no_free_bad() {\n  char* cwd = getcwd(NULL, 0);\n  if (cwd != NULL) {\n    return cwd[0];\n  }\n  return 'a';\n}\n\nchar getcwd_no_check_bad() {\n  char buf[BUFFER_SIZE];\n  char* cwd = getcwd(&buf, BUFFER_SIZE);\n  return cwd[0];\n}\n"
    },
    {
      "testname": "initlistexpr.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nint array_init_bad() {\n  int t[2][3][2] = {{{1, 1}, {2, 2}, {3, 3}}, {{4, 4}, {5, 5}, {1, 0}}};\n  if (t[0][1][0] == 2 && t[1][2][1] == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint array_init_ok() {\n  int t[2][3][2] = {{{1, 1}, {2, 2}, {3, 3}}, {{4, 4}, {5, 5}, {1, 0}}};\n  if (t[0][1][0] != 2 || t[1][2][1] != 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "integers.c",
      "testlanguage": "c",
      "expected-problems": 33,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid even_cannot_be_odd_local_ok(int y) {\n  int x = y;\n  if (x + x == 5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid even_cannot_be_odd_parameter_ok(int x) {\n  if (x + x == 5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid even_cannot_be_odd_float_conv_ok() {\n  int x = random();\n  if (x + x == (int)5.5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid FN_even_can_be_even_float_conv_bad() {\n  int x = random();\n  if (x + x == (int)6.5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid FN_int_conversions_feasible_bad() {\n  int x = random();\n  int y = 3 / 2;\n  int z = (int)1.234; // SIL ignores the cast so we get a contradiction here\n  int w = x / 2;\n  if (w == 5 && x == 10 && y == 1 && z == 1) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nstruct s {\n  int i;\n  int j;\n};\n\nvoid FP_even_cannot_be_odd_fields_ok(struct s* x) {\n  if (x->i + x->i == 5 || x->i + x->i + x->j + x->j == 5) {\n    // issue is FP: arithmetic does not know 2x + 2y == 5 is impossible\n    // when x and y are ints\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid float_div_bad() {\n  float y = 5.0 / 2.0;\n  if (y != 2.0) { // always true\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid float_comparison_bad(float f) {\n  if (2 + f < 2.2) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// FN because x > y is translated as x >= y+1 by pulse, which is not\n// valid for floats\nvoid FN_call_float_comparison_bad() { float_comparison_latent(0.1); }\n"
    },
    {
      "testname": "interprocedural.c",
      "testlanguage": "c",
      "expected-problems": 48,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid conditional_free(int x, int* y) {\n  if (x > 5) {\n    free(y);\n  }\n}\n\nvoid conditional_free_then_use_latent(int x) {\n  int* y = (int*)malloc(sizeof(int));\n  conditional_free(x, y);\n  if (y != NULL) {\n    // arguably we should report here since the code is bad, but the current\n    // heuristic classifies this as latent\n    *y = 1;\n  }\n  // avoid memory leak\n  if (x <= 5) {\n    free(y);\n  }\n}\n\nvoid call_conditional_free_then_use_bad() {\n  conditional_free_then_use_latent(7);\n}\n\n// make sure this isn't classified as latent as callers have no control over the\n// value of x being tested in the body of the function\nvoid test_modified_value_then_error_bad(int* x) {\n  *x = random();\n  if (*x == 5) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// below is a test that the calling context appears in the correct order in the\n// trace\n\nvoid latent_dereference(int a, int* p) {\n  if (a == 4) {\n    *p = 42;\n  }\n}\n\nvoid propagate_latent_1_latent(int a1) { latent_dereference(a1, NULL); }\n\nvoid propagate_latent_2_latent(int a2) { propagate_latent_1_latent(a2); }\n\nvoid propagate_latent_3_latent(int a3) { propagate_latent_2_latent(a3); }\n\nvoid make_latent_manifest() { propagate_latent_3_latent(4); }\n\nint* return_first(int* x, int a, int** out) {\n  int* w = x;\n  *out = w;\n  return w;\n}\n\nint* return_null(int** out) {\n  int* p = NULL;\n  *out = p;\n  return p;\n}\n\n// make sure the trace has all the details\nvoid follow_value_by_ref_bad() {\n  int* y;\n  return_null(&y);\n  int* z;\n  return_first(y, 12, &z);\n  *z = 42;\n}\n\n// make sure the trace has all the details\nvoid follow_value_by_ret_bad() {\n  int *dummy1, *dummy2;\n  int* y = return_null(&dummy1);\n  int* z = return_first(y, 12, &dummy2);\n  *z = 42;\n}\n\nint* malloc_wrapper_1() {\n  int* x;\n  x = (int*)malloc(sizeof(int));\n  return x;\n}\n\nint* malloc_wrapper_2(int b) {\n  if (b) {\n    return malloc_wrapper_1();\n  }\n  return NULL;\n}\n\nvoid free_wrapper(int* p, int b) {\n  if (b) {\n    free(p);\n  }\n}\n\nvoid trace_correctly_through_wrappers_bad() {\n  int* x = malloc_wrapper_2(1);\n  // TODO: ideally we would trace that we didn't go into the free() branch of\n  // the wrapper explicitly here to help understand the bug report\n  free_wrapper(x, 0);\n}\n"
    },
    {
      "testname": "issues_abort_execution.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n\nvoid uninit_continues_execution_bad() {\n  int x;\n  int y = x + 1;\n  int* p = NULL;\n  *p = 42;\n}\n\nvoid leak_bad() {\n  int* p = malloc(sizeof(int));\n  assert(p);\n}\n\nvoid memleak_continues_execution_bad() {\n  leak_bad();\n  int* p = NULL;\n  *p = 42;\n}\n"
    },
    {
      "testname": "latent.c",
      "testlanguage": "c",
      "expected-problems": 37,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid conditional_free2(int b, int* x) {\n  if (b) {\n    free(x);\n  }\n}\n\nvoid latent_use_after_free(int b, int* x) {\n  conditional_free2(b, x);\n  *x = 42;\n  if (!b) {\n    // just to avoid memory leaks\n    free(x);\n  }\n}\n\nvoid manifest_use_after_free(int* x) { latent_use_after_free(1, x); }\n\nvoid deref_then_free_then_deref_bad(int* x) {\n  *x = 42;\n  free(x);\n  *x = 42;\n}\n\nvoid create_branching(int b) {\n  if (b) {\n  }\n}\n\n// FN because it's flagged only as latent at the moment\nvoid FN_nonlatent_use_after_free_bad(int b, int* x) {\n  // the branch is independent of the issue here, so we should report the issue\n  // in this function\n  create_branching(b);\n  free(x);\n  *x = 42;\n}\n\n// same as above but branch after freeing\nvoid FN_nonlatent_use_after_free_bad2(int b, int* x) {\n  free(x);\n  create_branching(b);\n  *x = 42;\n}\n\n// all latent issues that reach main are manifest, so this should be called\n// \"main_bad\" but that would defeat the actual point :)\nint main(int argc, char** argv) {\n  int* x = malloc(sizeof(int));\n  if (x) {\n    latent_use_after_free(argc, x);\n  }\n}\n\n// *not* latent because callers have no way to influence &x inside of the\n// function\nvoid equal_to_stack_address_test_then_crash_bad(int x, int* y) {\n  if (y == &x) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid crash_if_different_addresses(int* x, int* y) {\n  *x = 42;\n  *y = 52;\n  if (x != y) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nstruct node {\n  int data;\n  struct node* next;\n};\n\nvoid traverse_and_crash_if_equal_to_root(struct node* p) {\n  struct node* old_p = p;\n  while (p != NULL) {\n    p = p->next;\n    if (old_p == p) {\n      int* crash = NULL;\n      *crash = 42;\n    }\n  }\n}\n\nvoid crash_after_one_node_bad(struct node* q) {\n  q->next = q;\n  traverse_and_crash_if_equal_to_root(q);\n}\n\nvoid crash_after_two_nodes_bad(struct node* q) {\n  q->next->next = q;\n  traverse_and_crash_if_equal_to_root(q);\n}\n\nvoid FN_crash_after_six_nodes_bad(struct node* q) {\n  q->next->next->next->next->next->next = q;\n  traverse_and_crash_if_equal_to_root(q);\n}\n"
    },
    {
      "testname": "lists.c",
      "testlanguage": "c",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct l2 {\n  int b;\n  struct l2* a;\n};\n\nint add2(struct l2* l) {\n  int r = 0;\n  for (; l; l = l->a) {\n    r += l->b;\n  }\n  return r;\n}\n\nint call_add2_then_deref_null_bad() {\n  int res = add2(NULL);\n  if (res == 0) {\n    int* p = NULL;\n    *p = 42; // reachable\n  }\n}\n\ntypedef struct node {\n  struct node* next;\n} T;\n\nvoid delete_one(T* x) { free(x); }\n\nvoid delete_all(T* x) {\n  T* temp;\n  while (x != NULL) {\n    temp = x;\n    x = x->next;\n    free(temp);\n  }\n}\n\nint call_delete_one_ok() {\n  T* root = malloc(sizeof(T));\n  delete_one(root); // no memory leak should be reported here\n  return 0;\n}\n\nint call_delete_all1_ok() {\n  T* root = malloc(sizeof(T));\n  delete_all(root); // no memory leak should be reported here\n  return 0;\n}\n\nint call_delete_all2_ok() {\n  T* root = malloc(sizeof(T));\n  if (root != NULL) {\n    root->next = malloc(sizeof(T));\n  }\n  delete_all(root); // no memory leak should be reported here\n  return 0;\n}\n"
    },
    {
      "testname": "list_api.c",
      "testlanguage": "c",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\ntypedef struct list_elem_s {\n  void* data;\n  struct list_elem_s* next;\n} list_elem_t;\n\ntypedef struct list_s {\n  list_elem_t* first;\n} list_t;\n\nlist_t* list_init() { return calloc(1, sizeof(list_t)); }\n\nvoid list_append(list_t* lst, list_elem_t* elem) {\n  list_elem_t* iter;\n\n  if (NULL == lst->first) {\n    lst->first = elem;\n  } else {\n    iter = lst->first;\n    while (NULL != iter->next) {\n      iter = iter->next;\n    }\n    iter->next = elem;\n  }\n}\n\nlist_elem_t* list_add(list_t* lst, void* data) {\n  list_elem_t* entry;\n\n  entry = calloc(1, sizeof(list_elem_t));\n  if (NULL == entry) {\n    return NULL;\n  }\n  entry->data = data;\n  list_append(lst, entry);\n  return (entry);\n}\n\nvoid list_elem_free(list_elem_t* ptr) {\n  if (NULL == ptr) {\n    return;\n  }\n\n  list_elem_free(ptr->next);\n  free(ptr);\n}\n\nvoid list_free(list_t* ptr) {\n  list_elem_free(ptr->first);\n  free(ptr);\n}\n\nint list_build_and_free_ok() {\n  int val_data = 21;\n\n  list_t* list = list_init();\n  if (NULL == list) {\n    return 1;\n  }\n  if (NULL == list_add(list, &val_data)) {\n    list_free(list);\n    return 1;\n  }\n  list_free(list);\n  return 0;\n}\n"
    },
    {
      "testname": "list_checks.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct list {\n  struct list* next;\n};\n\nvoid go_to_next(struct list* head) {\n  if (head->next != NULL) {\n    head = head->next;\n  }\n}\n\nvoid null_ptr_deref_bad() { go_to_next(NULL); }\n\nvoid go_to_end_of_list(struct list* head) {\n  while (head->next != NULL) {\n    head = head->next;\n  }\n}\n\nvoid null_ptr_deref2_bad() { go_to_end_of_list(NULL); }\n\nvoid check_next(struct list* head) {\n  while (head->next != NULL) {\n    whatever();\n  }\n}\n\nvoid null_ptr_deref3_bad() { check_next(NULL); }\n"
    },
    {
      "testname": "memcpy.c",
      "testlanguage": "c",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct X {\n  int f;\n};\n\ntypedef struct X X;\n\nvoid memcpy_ok() {\n  X x;\n  X* p = malloc(sizeof(X));\n  if (p)\n    memcpy(p, &x, sizeof(X));\n  free(p);\n}\n\nvoid memcpy_to_null_bad() {\n  X x;\n  X* p = NULL;\n  memcpy(p, &x, sizeof(X)); // crash\n}\n\nvoid memcpy_to_null_indirect_bad() {\n  X x;\n  X* r;\n  X* p = NULL;\n  r = p;\n  memcpy(r, &x, sizeof(X)); // crash\n}\n\nvoid memcpy_from_null_bad() {\n  X* src = NULL;\n  X* p = malloc(sizeof(X));\n  if (p) {\n    memcpy(p, src, sizeof(X)); // crash\n    free(p);\n  }\n}\n"
    },
    {
      "testname": "memory_leak.c",
      "testlanguage": "c",
      "expected-problems": 164,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid malloc_no_free_bad() { int* p = malloc(sizeof(p)); }\n\nint* malloc_returned_ok() {\n  int* p = malloc(sizeof(p));\n  return p;\n}\n\nvoid malloc_out_parameter_ok(int** x) { *x = (int*)malloc(sizeof(int)); }\n\nvoid malloc_out_parameter_local_mutation_ok(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  x = NULL; // not visible from the outside\n}\n\nvoid malloc_out_parameter_local_mutation_bad(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  *x = NULL;\n}\n\nvoid malloc_then_free_ok() {\n  int* p = malloc(sizeof(p));\n  if (p) {\n    *p = 5;\n    free(p);\n  }\n}\n\nint* create_p() {\n  int* p = malloc(sizeof(p));\n  return p;\n}\n\nvoid malloc_interproc_no_free_bad() { int* p = create_p(); }\n\nvoid malloc_interproc_no_free_bad2() {\n  int* p = malloc(sizeof(p));\n  int z = 3;\n  int y = 4;\n  int* q = p;\n}\n\nvoid malloc_formal_leak_bad(int* x) { x = (int*)malloc(sizeof(int*)); }\n\nstatic void* (*const malloc_func)(size_t) = malloc;\nstatic void (*const free_func)(void*) = free;\n\nvoid* malloc_via_ptr(size_t size) {\n  void* ret = NULL;\n\n  if (size <= 0) {\n    return NULL;\n  }\n\n  ret = malloc_func(size);\n  return ret;\n}\n\nvoid free_via_ptr(void* x) { free_func(x); }\n\nvoid malloc_ptr_leak_bad() { int* p = (int*)malloc_via_ptr(sizeof(int)); }\n\nvoid malloc_ptr_no_check_leak_bad() {\n  int* p = (int*)malloc_via_ptr(sizeof(int));\n  *p = 42;\n}\n\nvoid malloc_ptr_free_ok() {\n  int* p = (int*)malloc_via_ptr(sizeof(int));\n  free(p);\n}\n\nvoid malloc_ptr_free_ptr_ok() {\n  int* p = (int*)malloc_via_ptr(sizeof(int));\n  free_via_ptr(p);\n}\n\nvoid alias_ptr_free_ok(int* out, int flag) {\n  int* y;\n  if (flag) {\n    y = (int*)malloc(sizeof(int));\n  } else {\n    y = out;\n  }\n  if (y && y != out) {\n    free(y);\n  }\n}\n\nvoid report_leak_in_correct_line_bad(int* x) {\n  x = (int*)malloc(sizeof(int));\n  if (x != NULL) {\n    return; // should report leak at this line\n  }\n  free(x);\n}\n\nvoid* realloc_wrapper(void* p, size_t size) { return realloc(p, size); }\n\nvoid realloc_free_ok() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = realloc_wrapper(p, sizeof(int));\n  free(q);\n}\n\nvoid realloc_no_free_bad() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = realloc_wrapper(p, sizeof(int));\n}\n\nvoid realloc_no_check_bad() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = realloc_wrapper(p, sizeof(int));\n  *q = 42;\n  free(q);\n}\n\nvoid* my_malloc(size_t size);\nvoid* a_malloc(size_t size);\nvoid my_free(void* p);\nvoid* my_realloc(void* p, size_t size);\n\nvoid user_malloc_leak_bad() { int* x = (int*)a_malloc(sizeof(int)); }\n\nvoid test_config_options_1_ok() {\n  int* p = (int*)malloc(sizeof(int));\n  int* q = my_realloc(p, sizeof(int));\n  my_free(q);\n}\n\nvoid test_config_options_2_ok() {\n  int* p = (int*)my_malloc(sizeof(int));\n  int* q = realloc(p, sizeof(int));\n  my_free(q);\n}\n\nvoid test_config_options_no_free_bad() {\n  int* p = (int*)my_malloc(sizeof(int));\n  int* q = my_realloc(p, sizeof(int));\n}\n\nstruct ref_counted {\n  size_t count;\n  int data;\n};\n\n// the address of the malloc()'d pointer can be retrieved from the\n// return value using pointer arithmetic\nint* alloc_ref_counted_ok() {\n  struct ref_counted* p =\n      (struct ref_counted*)malloc(sizeof(struct ref_counted));\n  if (p) {\n    p->count = 1;\n    return &(p->data);\n  } else {\n    return NULL;\n  }\n}\n\n// returning the value of the field loses the address of p\nint alloc_ref_counted_bad() {\n  struct ref_counted* p =\n      (struct ref_counted*)malloc(sizeof(struct ref_counted));\n  if (p) {\n    p->count = 1;\n    p->data = 42;\n    return p->data;\n  } else {\n    return 0;\n  }\n}\n\n// the address of the malloc()'d pointer can be retrieved from the\n// return value using pointer arithmetic\nvoid* alloc_ref_counted_arith_ok(size_t size) {\n  int* p = (int*)malloc(size + sizeof(int));\n  if (p) {\n    // register count = 1 and point past the ref count\n    *p++ = 1;\n  }\n  return p;\n}\n\nint return_malloc_deref_bad() {\n  int* p = (int*)malloc(sizeof(int));\n  if (p) {\n    *p = 42;\n    return *p;\n  }\n  return 10;\n}\n\ntypedef struct node_st {\n  int* data;\n} NODE;\n\nvoid mutual_recursion_2(NODE* x);\n\nvoid mutual_recursion(NODE* x) { mutual_recursion_2(x); }\n\nvoid mutual_recursion_2(NODE* x) { mutual_recursion(x); }\n\nvoid interproc_mutual_recusion_leak(NODE* x) {\n  int* d;\n  if (x->data == NULL) {\n    x->data = (int*)malloc(sizeof(int));\n  }\n  mutual_recursion(x);\n}\n\nvoid allocate_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    array[i] = malloc(sizeof(int));\n  }\n}\n\nvoid free_all_in_array(int* array[]) {\n  for (int i = 0; i < 2; i++) {\n    free(array[i]);\n  }\n}\n\nvoid alloc_then_free_all_in_array_ok() {\n  int* array[2];\n  allocate_all_in_array(array);\n  free_all_in_array(array);\n}\n\nvoid allocate_42_in_array(int* array[]) { array[42] = malloc(sizeof(int)); }\n\nvoid free_42_in_array(int* array[]) { free(array[42]); }\n\nvoid alloc_then_free_42_in_array_ok() {\n  int* array[64];\n  allocate_42_in_array(array);\n  free_42_in_array(array);\n}\n\nvoid allocate_in_array(int* array[], int i) { array[i] = malloc(sizeof(int)); }\n\nvoid free_in_array(int* array[], int i) { free(array[i]); }\n\nvoid alloc_then_free_fixed_index_ok() {\n  int* array[64];\n  allocate_in_array(array, 42);\n  free_in_array(array, 42);\n}\n\nvoid alloc_then_free_parameter_array_ok(int* array[], int i) {\n  allocate_in_array(array, i);\n  free_in_array(array, i);\n}\n\nvoid alloc_then_free_at_index_ok(int i) {\n  int* array[64];\n  allocate_in_array(array, i);\n  free_in_array(array, i);\n}\n"
    },
    {
      "testname": "memory_leak_more.c",
      "testlanguage": "c",
      "expected-problems": 34,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n#include <string.h>\n\nvoid simple_leak_bad() {\n  int* p;\n  p = (int*)malloc(sizeof(int));\n}\n\nvoid FN_common_realloc_leak_bad() {\n  int *p, *q;\n  p = (int*)malloc(sizeof(int));\n  q = (int*)realloc(p, sizeof(int) * 42);\n  // if realloc fails, then p becomes unreachable\n  if (q != NULL)\n    free(q);\n}\n\nvoid FN_common_realloc_leak2_bad() {\n  float *p, *q;\n  p = (float*)malloc(sizeof(float));\n  q = (float*)realloc(p, sizeof(float) * 42);\n  // if realloc fails, then p becomes unreachable\n  if (q != NULL)\n    free(q);\n}\n\nint* allocate() {\n  int* p = NULL;\n  do {\n    p = (int*)malloc(sizeof(int));\n  } while (p == NULL);\n  return p;\n}\n\nvoid leak_via_allocator_bad() {\n  int* p;\n  p = allocate();\n  *p = 42;\n}\n\nvoid* return_memset_ok(size_t s) {\n  char* str = malloc(sizeof(s));\n  if (str) {\n    return memset(str, 0, s);\n  }\n}\n\nvoid conditional_last_instruction_bad() {\n  int* p = malloc(sizeof(int));\n  if (0) {\n    free(p);\n  }\n}\n\nint* compound_return_ok() {\n  return ({\n    int* p = malloc(sizeof(int));\n    p;\n  });\n}\n\nstruct payload {\n  int count;\n  int payload[];\n};\n\n#define COUNT 10\n\nvoid FN_malloc_sizeof_value_leak_bad() {\n  struct payload* x;\n  x = malloc(sizeof(*x) + COUNT * sizeof(x->payload[0]));\n  if (x == NULL) {\n    return 1;\n  }\n  x->count = COUNT;\n  for (int i = 0; i < COUNT; i++) {\n    x->payload[i] = i;\n  }\n  /* missing free(x) */\n}\n"
    },
    {
      "testname": "nullptr.c",
      "testlanguage": "c",
      "expected-problems": 110,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdnoreturn.h>\n\nint* malloc_no_check_bad() {\n  int* p = (int*)malloc(sizeof(int));\n  *p = 42;\n  return p;\n}\n\nvoid malloc_assert_ok() {\n  int* p = (int*)malloc(sizeof(int));\n  assert(p);\n  *p = 42;\n  free(p);\n}\n\nvoid create_null_path_ok(int* p) {\n  if (p) {\n    *p = 32;\n  }\n}\n\nvoid call_create_null_path_then_deref_unconditionally_ok(int* p) {\n  create_null_path_ok(p);\n  *p = 52;\n}\n\nvoid create_null_path2_bad_FN(int* p) {\n  int* q = NULL;\n  if (p) {\n    *p = 32;\n  }\n  // arguably bogus to check p above but not here, but the above could\n  // also be macro-generated code so both reporting and not reporting\n  // are sort of justifiable\n  *p = 52;\n}\n\n// combine several of the difficulties above\nvoid malloc_then_call_create_null_path_then_deref_unconditionally_bad_FN(\n    int* p) {\n  int* x = (int*)malloc(sizeof(int));\n  if (p) {\n    *p = 32;\n  }\n  create_null_path_ok(p);\n  *p = 52;\n  free(x);\n}\n\n// pulse should remember the value of vec[64] because it was just written to\nvoid nullptr_deref_young_bad(int* x) {\n  int* vec[65] = {x, x, x, x, x, x, x, x, x, x, x, x, x, x,   x, x, x,\n                  x, x, x, x, x, x, x, x, x, x, x, x, x, x,   x, x, x,\n                  x, x, x, x, x, x, x, x, x, x, x, x, x, x,   x, x, x,\n                  x, x, x, x, x, x, x, x, x, x, x, x, x, NULL};\n  int p = *vec[64];\n}\n\n// due to the recency model of memory accesses, vec[0] can get forgotten\n// by the time we have processed the last element of the\n// initialization so we don't report here\nvoid FN_nullptr_deref_old_bad(int* x) {\n  int* vec[65] = {NULL, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,\n                  x,    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,\n                  x,    x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,\n                  x,    x, x, x, x, x, x, x, x, x, x, x, x, x};\n  int p = *vec[0];\n}\n\nvoid malloc_free_ok() {\n  int* p = (int*)malloc(sizeof(int));\n  free(p);\n}\n\nvoid wrap_free(void* p) { free(p); }\n\nvoid interproc_free_ok() {\n  int* p = (int*)malloc(sizeof(int));\n  wrap_free(p);\n}\n\nnoreturn void no_return();\n\nvoid wrap_malloc(int** x) {\n  *x = (int*)malloc(sizeof(int));\n  if (!*x) {\n    no_return();\n  }\n}\n\nvoid call_no_return_good() {\n  int* x = NULL;\n  wrap_malloc(&x);\n  *x = 5;\n  free(x);\n}\n\nvoid bug_after_malloc_result_test_bad(int* x) {\n  x = (int*)malloc(sizeof(int));\n  if (x) {\n    int* y = NULL;\n    *y = 42;\n  }\n}\n\nvoid bug_after_abduction_bad(int* x) {\n  *x = 42;\n  int* y = NULL;\n  *y = 42;\n}\n\nvoid bug_with_allocation_bad(int* x) {\n  x = (int*)malloc(sizeof(int));\n  int* y = NULL;\n  *y = 42;\n}\n\nvoid null_alias_bad(int* x) {\n  int* y = NULL;\n  x = (int*)malloc(sizeof(int*));\n  *x = 42;\n}\n\nvoid dereference(int* p) { int i = *p; }\n\nvoid several_dereferences_ok(int* x, int* y, int* z) {\n  int* p = x;\n  *z = 52;\n  dereference(y);\n  *y = 42;\n  *x = 32;\n  *x = 777;\n  *y = 888;\n  *z = 999;\n}\n\nvoid report_correct_error_among_multiple_bad() {\n  int* p = NULL;\n  // the trace should complain about the first access inside the callee\n  several_dereferences_ok(p, p, p);\n}\n\nint unknown(int x);\n\nvoid unknown_is_functional_ok() {\n  int* p = NULL;\n  if (unknown(10) != unknown(10)) {\n    *p = 42;\n  }\n}\n\nvoid unknown_with_different_values_bad() {\n  int* p = NULL;\n  if (unknown(32) != unknown(52)) {\n    *p = 42;\n  }\n}\n\nvoid unknown_conditional_dereference(int x, int* p) {\n  if (unknown(x) == 999) {\n    *p = 42;\n  }\n}\n\nvoid unknown_from_parameters_latent(int x) {\n  unknown_conditional_dereference(x, NULL);\n}\n\n// is pruned away without the model\nvoid random_non_functional_bad() {\n  if (random() != random()) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid random_modelled_bad(int y) {\n  int x = random();\n  if (x == y) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid arithmetic_weakness_ok() {\n  int x = random();\n  int y = random();\n  if (x < y && x > y) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint* unknown_int_pointer();\n\nvoid no_invalidation_compare_to_NULL_bad() {\n  int* p = unknown_int_pointer();\n  int x;\n  int* q = &x;\n  if (p == NULL) {\n    q = p;\n  }\n  *q = 42;\n}\n\nvoid incr_deref(int* x, int* y) {\n  (*x)++;\n  (*y)++;\n}\n\nvoid call_incr_deref_with_alias_bad(void) {\n  int x = 0;\n  int* ptr = &x;\n  incr_deref(ptr, ptr);\n  if (x == 2) {\n    ptr = NULL;\n  }\n  x = *ptr;\n}\n\nvoid call_incr_deref_with_alias_good(void) {\n  int x = 0;\n  int* ptr = &x;\n  incr_deref(ptr, ptr);\n  if (x != 2) {\n    ptr = NULL;\n  }\n  x = *ptr;\n}\n"
    },
    {
      "testname": "nullptr_more.c",
      "testlanguage": "c",
      "expected-problems": 57,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nstruct Person {\n  int age;\n  int height;\n  int weight;\n};\n\nint simple_null_pointer_bad() {\n  struct Person* max = NULL;\n  return max->age;\n}\n\nstruct Person* Person_create(int age, int height, int weight) {\n  struct Person* who = NULL;\n  return who;\n}\n\nint get_age(struct Person* who) { return who->age; }\n\nint null_pointer_interproc_bad() {\n  struct Person* joe = Person_create(32, 64, 140);\n  return get_age(joe);\n}\n\nint negation_in_conditional_ok() {\n  int* x = NULL;\n  if (!x)\n    return 0;\n  else\n    return *x; // this never happens\n}\n\nstatic int* return_null() { return NULL; }\n\nvoid null_pointer_with_function_pointer_bad() {\n  int* (*fp)();\n  fp = return_null;\n  int* x = fp();\n  *x = 3;\n}\n\nvoid exit_if_null_ok(struct Person* htbl) {\n  if (!htbl)\n    exit(0);\n  int x = htbl->age;\n}\n\nvoid FPuseafterfree_no_check_for_null_after_realloc_bad() {\n  int* p;\n  p = (int*)malloc(sizeof(int) * 5);\n  if (p) {\n    p[3] = 42;\n  }\n  int* q = (int*)realloc(p, sizeof(int) * 10);\n  if (!q)\n    free(p); // FP\n  q[7] = 0; // NULL dereference\n  free(q);\n}\n\nvoid assign(int* p, int n) { *p = n; }\n\nvoid potentially_null_pointer_passed_as_argument_bad() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  assign(p, 42); // NULL dereference\n  free(p);\n}\n\nvoid null_passed_as_argument_bad() {\n  assign(NULL, 42); // NULL dereference\n}\n\nvoid allocated_pointer_passed_as_argument_ok() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  if (p) {\n    assign(p, 42);\n    free(p);\n  }\n}\n\nint* unsafe_allocate() {\n  int* p = NULL;\n  p = (int*)malloc(sizeof(int));\n  return p;\n}\n\nint* safe_allocate() {\n  int* p = NULL;\n  while (!p) {\n    p = (int*)malloc(sizeof(int));\n  }\n  return p;\n}\n\nvoid function_call_can_return_null_pointer_bad() {\n  int* p = NULL;\n  p = unsafe_allocate();\n  assign(p, 42); // NULL dereference\n  free(p);\n}\n\nvoid function_call_returns_allocated_pointer_ok() {\n  int* p = NULL;\n  p = safe_allocate();\n  assign(p, 42);\n  free(p);\n}\n\nvoid sizeof_expr_ok(void) {\n  struct Person* p = malloc(sizeof *p);\n  if (p) {\n    p->age = 42;\n  }\n  free(p);\n}\n\nvoid __attribute__((noreturn)) will_not_return();\n\nvoid unreachable_null_ok() {\n  int* p = NULL;\n  if (p == NULL) {\n    will_not_return();\n  }\n  *p = 42;\n}\n\nvoid no_ret() { will_not_return(); }\n\nvoid unreachable_null_no_return_ok() {\n  int* p = NULL;\n  if (p == NULL) {\n    no_ret(); // inter-procedural call to no_return\n  }\n  *p = 42;\n}\n"
    },
    {
      "testname": "offsetof_expr.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stddef.h>\n#include <stdlib.h>\n\nstruct address {\n  char v1[2];\n  char v2[5];\n  int v3;\n};\n\nint test_offsetof_expr_bad() {\n  int i = offsetof(struct address, v2);\n  if (i == 2) {\n    int* p = NULL;\n    *p = 42;\n  }\n  return 42;\n}\n\nint FN_test_offsetof_expr_nonlit_bad() {\n  size_t sum = 0;\n  for (int i = 0; i < 2; i++) {\n    sum += offsetof(struct address, v1[i]);\n  }\n  if (sum == 1) {\n    int* p = NULL;\n    *p = 42;\n  }\n  return 42;\n}\n"
    },
    {
      "testname": "pthread_create.c",
      "testlanguage": "c",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <pthread.h>\n\nvoid dummy() {}\n\nvoid deref_pointer(int* x) { int y = *x; }\n\nint pthread_create_dummy_ok() {\n  pthread_t thread;\n  return pthread_create(&thread, NULL, dummy, NULL);\n}\n\nint FN_pthread_create_deref_bad() {\n  pthread_t thread;\n  return pthread_create(&thread, NULL, deref_pointer, NULL);\n}\n\nint pthread_create_deref_ok() {\n  pthread_t thread;\n  int x;\n  return pthread_create(&thread, NULL, deref_pointer, &x);\n}\n\nextern void some_unknown_function(void);\n\nint pthread_unknown_ok() {\n  pthread_t thread;\n  return pthread_create(&thread, NULL, some_unknown_function, NULL);\n}\n"
    },
    {
      "testname": "pthread_mutex.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <pthread.h>\n\nint normal_life_ok(pthread_mutex_t* m) {\n  if (pthread_mutex_init(m, 0))\n    return 0;\n  if (pthread_mutex_lock(m))\n    return 0;\n  if (pthread_mutex_unlock(m))\n    return 0;\n  if (pthread_mutex_destroy(m))\n    return 0;\n  return 1;\n}\n\nint normal_ok2() {\n  pthread_mutex_t m;\n  normal_life_ok(&m);\n}\n\nvoid FN_double_lock_bad(pthread_mutex_t* m) {\n  pthread_mutex_lock(m);\n  pthread_mutex_lock(m);\n}\n\nvoid FN_double_lock_uninit_bad() {\n  pthread_mutex_t m;\n  FN_double_lock_bad(&m);\n}\n\nvoid double_lock_bad2() {\n  pthread_mutex_t m;\n  pthread_mutex_init(&m, 0);\n  FN_double_lock_bad(&m);\n}\n\nvoid FN_double_unlock_bad(pthread_mutex_t* m) {\n  pthread_mutex_unlock(m);\n  pthread_mutex_unlock(m);\n}\n\nvoid FN_double_unlock_bad2() {\n  pthread_mutex_t m;\n  pthread_mutex_init(&m, 0);\n  pthread_mutex_lock(&m);\n  FN_double_unlock_bad(&m);\n}\n\nvoid FN_double_init_bad(pthread_mutex_t* m) {\n  pthread_mutex_init(m, 0);\n  pthread_mutex_init(m, 0);\n}\n\n// Already reported in double_init_bad\nvoid double_init_ok() {\n  pthread_mutex_t m;\n  double_init_bad(&m);\n}\n"
    },
    {
      "testname": "pthread_spinlock.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <pthread.h>\n\n#ifdef __APPLE__\n// Spinlocks do not exist on mac\ntypedef struct {\n  int __whatever;\n} pthread_spinlock_t;\nextern int pthread_spin_init(pthread_spinlock_t* __lock, int __pshared);\nextern int pthread_spin_destroy(pthread_spinlock_t* __lock);\nextern int pthread_spin_lock(pthread_spinlock_t* __lock);\nextern int pthread_spin_trylock(pthread_spinlock_t* __lock);\nextern int pthread_spin_unlock(pthread_spinlock_t* __lock);\n#endif\n\nvoid FN_spinlock_double_lock_bad(pthread_spinlock_t* m) {\n  pthread_spin_lock(m);\n  pthread_spin_lock(m);\n}\n\nvoid FN_spinlock_double_lock_bad2() {\n  pthread_spinlock_t m;\n  FN_spinlock_double_lock_bad(&m);\n}\n"
    },
    {
      "testname": "recursion.c",
      "testlanguage": "c",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* note that the goal is flag the existence of recursive or mutually-recursive\n   calls, not non-termination, so flagging a well-founded recursion is not\n   considered a false positive */\n\nvoid trivial_recursive_bad() { trivial_recursive_bad(); }\n\nint factorial_bad(int x) {\n  if (x > 0) {\n    return x * factorial_bad(x - 1);\n  } else {\n    return 1;\n  }\n}\n\nvoid mutual1_bad();\n\nvoid mutual3_bad() { mutual1_bad(); }\n\nvoid mutual2_bad() { mutual3_bad(); }\n\nvoid mutual1_bad() { mutual2_bad(); }\n\nint global;\n\n// should report MUTUAL_RECURSION not INFINITE_RECURSION\nvoid recursive_modify_global_ok(int x) {\n  if (global > 0) {\n    global--;\n    recursive_modify_global_ok(x);\n  }\n}\n\nvoid infinite_recursion_unchanged_global_bad(int x) {\n  if (global > 0) {\n    global = global;\n    infinite_recursion_unchanged_global_bad(x);\n  }\n}\n\nstruct data {\n  int a;\n  int b;\n};\n\n// TODO: detect some memory updates occured inside the memory reachable from\n// params\nvoid fp_recursion_on_field_ok(struct data* x) {\n  if (x->a > 0) {\n    x->a = x->a - 1;\n    fp_recursion_on_field_ok(x);\n  }\n}\n\nvoid set_fields(struct data* x, int a, int b) {\n  x->b = b;\n  x->a = a;\n}\n\nvoid recursion_on_fields_bad(struct data* x) {\n  // materialize fields of x in the order \"a, b\" in the pre\n  int a = x->a;\n  int b = x->b;\n  // trick pulse into writing the fields of x in the order \"b, a\" in the post\n  set_fields(x, a, b);\n  recursion_on_fields_bad(x);\n}\n\n#include \"recursion2.h\"\n\nvoid across_file_1() { across_file_2(); }\n"
    },
    {
      "testname": "recursion2.c",
      "testlanguage": "c",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid across_file_1();\n\nvoid across_file_2() { across_file_1(); }\n"
    },
    {
      "testname": "resource_leak.c",
      "testlanguage": "c",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nvoid fileNotClosed_bad() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    char buffer[256];\n    write(fd, buffer, strlen(buffer));\n  }\n}\n\nvoid fileClosed_ok() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    char buffer[256];\n    write(fd, buffer, strlen(buffer));\n    close(fd);\n  }\n}\n\nFILE* handler;\n\nvoid fdopen_to_global_ok() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    handler = fdopen(fd, \"w\");\n    fclose(handler);\n  }\n}\n\nvoid gzdopen_to_global_ok() {\n  int fd = open(\"hi.txt\", O_WRONLY | O_CREAT | O_TRUNC, 0600);\n  if (fd != -1) {\n    handler = gzdopen(fd, \"w\");\n    fclose(handler);\n  }\n}\n\nvoid socketNotClosed_bad() {\n  int fd = socket(AF_LOCAL, SOCK_RAW, 0);\n  if (fd != -1) {\n    char buffer[256];\n    write(fd, buffer, strlen(buffer));\n  }\n}\n\nint socketClosed_ok() {\n  int socketFD = socket(AF_LOCAL, SOCK_RAW, 0);\n  if (socketFD == -1) {\n    return -1;\n  }\n\n  int status;\n\n  status = fcntl(socketFD, F_SETFL, O_NONBLOCK);\n  if (status == -1) {\n    close(socketFD);\n    return -1;\n  }\n\n  int reuseaddr = 1;\n  status = setsockopt(\n      socketFD, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));\n  if (status == -1) {\n    close(socketFD);\n    return -1;\n  }\n\n  int nosigpipe = 1;\n  status = setsockopt(\n      socketFD, SOL_SOCKET, SO_REUSEADDR, &nosigpipe, sizeof(nosigpipe));\n  if (status == -1) {\n    close(socketFD);\n    return -1;\n  }\n\n  return socketFD;\n}\n"
    },
    {
      "testname": "sentinel_attribute.c",
      "testlanguage": "c",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nextern int add_all_ints(int x, int y, int z, ...) __attribute__((sentinel));\n\nvoid valid_call_ok(int* a, int* b, int* c) {\n  // fine\n  int x = add_all_ints(0, 0, 0, a, b, c, NULL);\n}\n\nvoid FN_truncated_call_bad(void) {\n  int a = 0, b = 1, c = 2, d = 3;\n  int* p = NULL;\n\n  // warning: p is NULL so only first argument sent to add_all_ints\n  int x = add_all_ints(0, 0, 0, &a, p, &b, &c, &d, NULL);\n}\n"
    },
    {
      "testname": "setlocale.c",
      "testlanguage": "c",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <locale.h>\n\nvoid FP_setlocale_null_impossible_ok() {\n  if (setlocale(LC_ALL, NULL) == NULL) {\n    // cannot happen\n    int* p = NULL;\n    *p = 42;\n  }\n  setlocale(LC_ALL, \"\");\n  setlocale(LC_ALL, \"C\");\n}\n"
    },
    {
      "testname": "shift.c",
      "testlanguage": "c",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nint* return_depends_on_lshift(int x, int* p) {\n  if (x < (1 << 7))\n    return NULL;\n  else\n    return p;\n}\n\nint return_nonnull_deref1_ok() {\n  int y = 0;\n  return *return_depends_on_lshift(1000, &y);\n}\n\nint return_null_deref1_bad() {\n  int y = 0;\n  return *return_depends_on_lshift(0, &y);\n}\n\nint* return_depends_on_rshift(int x, int* p) {\n  if (x < (4 >> 2))\n    return NULL;\n  else\n    return p;\n}\n\nint return_nonnull_deref2_ok() {\n  int y = 0;\n  return *return_depends_on_rshift(2, &y);\n}\n\nint return_null_deref2_bad() {\n  int y = 0;\n  return *return_depends_on_rshift(0, &y);\n}\n"
    },
    {
      "testname": "sizeof.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nint sizeof_eval_ok(void) {\n  int a = 4;\n  int b = sizeof(a);\n  char c[2];\n\n  if (a % 4) { // 4 % 4 = 0\n    int* p = NULL;\n    *p = 42;\n  }\n  if (b % sizeof(a)) { // x % x = 0\n    int* p = NULL;\n    *p = 42;\n  }\n  if (sizeof(c) > 2) { // 2 > 2 is false\n    int* p = NULL;\n    *p = 42;\n  }\n  if ((sizeof(c) / sizeof(c[0])) != 2) { // (2 / 1) = 2\n    int* p = NULL;\n    *p = 42;\n  }\n  return 0;\n}\n"
    },
    {
      "testname": "specialization.c",
      "testlanguage": "c",
      "expected-problems": 32,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nint invoke(int (*f)(int), int i) { return (*f)(i); }\n\nint id(int i) { return i; }\n\nint add_one(int i) { return invoke(id, i) + 1; }\n\nint add_two(int i) {\n  int one = invoke(id, 1);\n  add_one(0);\n  return invoke(add_one, i) + 1;\n}\n\n// recursion cycle\nint add_more_bad(int i) {\n  if (i > 0) {\n    return invoke(add_more_bad, i - 1) + 1;\n  }\n  return 0;\n}\n\nvoid test_invoke_ok() {\n  if (add_one(0) != 1) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid test_invoke_bad() {\n  if (add_one(0) == 1) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid test_recursive_invoke_ok() {\n  if (add_two(0) + add_one(0) != 3) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid test_recursive_invoke_bad() {\n  if (add_two(0) + add_one(0) == 3) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// recursion cycle involving alias specialization\nint two_pointers_recursion_bad(int* x, int* y, int i) {\n  if (i > 0) {\n    return *x + *y + two_pointers_recursion_bad(x, x, i - 1);\n  }\n  return 0;\n}\n\nvoid alias_recursion(int* z) { two_pointers_recursion_bad(z, z, 10); }\n\n// recursion cycle involving closure specialization\nvoid invoke_itself_bad(int (*f)(int), int i) {\n  if (i > 0) {\n    (*f)(i);\n    invoke_itself_bad(f, i - 1);\n  }\n}\n\nvoid specialize_invoke_itself_ok() { invoke_itself_bad(id, 10); }\n"
    },
    {
      "testname": "struct_values.c",
      "testlanguage": "c",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nstruct inlined {\n  int x;\n  int y;\n};\n\nstruct s {\n  struct inlined i;\n  int f;\n  int g;\n};\n\n// the analysis should not accidentally expose the mutations to callees\nvoid changes_fields_locally(struct s a) {\n  int u = a.i.x;\n  a.f = 42;\n  a.i.y = 15;\n}\n\nvoid struct_value_in_callee_ok() {\n  struct s b = {{11, 22}, 33, 44};\n  changes_fields_locally(b);\n  if (b.i.x != 11 || b.i.y != 22 || b.f != 33 || b.g != 44) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "taint_var_arg.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdio.h>\n\nint int_source();\n\nfloat float_source();\n\nvoid printf_source_bad1() { printf(\"Integers: %i %u \\n\", -3456, int_source()); }\n\nvoid printf_source_bad2() {\n  printf(\"Some different radices: %d %x %o %#x %#o \\n\",\n         100,\n         int_source(),\n         100,\n         100,\n         100);\n}\n\nvoid printf_source_bad3() {\n  printf(\"floats: %4.2f %+.0e %E \\n\", 3.14159, 3.14159, float_source());\n}\n\nvoid printf_source_bad4() {\n  printf(\"Preceding with zeros: %010d \\n\", int_source());\n}\n"
    },
    {
      "testname": "ternary.c",
      "testlanguage": "c",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct data {\n  int flag;\n};\n\nstatic struct data d;\n\nint ternary1_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return (p && p->flag);\n}\n\nint ternary2_bad(int x) {\n  struct data* p = x ? &d : 0;\n  return p->flag && p; // NULL_DEREF\n}\n\nint ternary3_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p && p->flag); // OK\n}\n\nint ternary4_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p && p->flag); // OK\n}\n\nint ternary4_bad(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p->flag && p); // NULL_DEREF\n}\n\nint ternary5_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return !(p && p->flag); // OK\n}\n\nint ternary6_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return !p || p->flag; // OK\n}\n\nint ternary7_bad(int x) {\n  struct data* p = x ? &d : 0;\n  return p || p->flag; // NULL_DEREF\n}\n\nint ternary8_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return (!p || p->flag) && !(p && p->flag); // OK\n}\n\nint ternary9_ok(int x) {\n  struct data* p = x ? &d : 0;\n  return p && (p->flag || !(p->flag)); // OK\n}\n"
    },
    {
      "testname": "traces.c",
      "testlanguage": "c",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid simple_deref() {\n  int* p = NULL;\n  int* q = p; // this line should not be part of the trace\n  *p = 42;\n}\n\nvoid simple_deref_via_alias() {\n  int* p = NULL;\n  int* q = p;\n  *q = 42;\n}\n\nvoid something_about_strings_latent(const uint16_t* utf16String,\n                                    size_t utf16StringLen,\n                                    uint8_t** utf8StringOut,\n                                    size_t* utf8StringLenOut) {\n  if (!utf16String || utf16StringLen < 0) {\n    *utf8StringOut = NULL;\n    return;\n  }\n\n  if (utf16StringLen == 0) {\n    // forgot the null check here\n    *utf8StringOut = (uint8_t*)malloc(1);\n    **utf8StringOut = '\\0'; // the trace should be just the calling context +\n                            // malloc + this line\n    *utf8StringLenOut = 0;\n    return;\n  }\n}\n\nvoid call_makes_null_deref_manifest_bad() {\n  uint16_t utf16String;\n  uint8_t* utf8String;\n  size_t utf8StringLen;\n  something_about_strings_latent(&utf16String, 0, &utf8String, &utf8StringLen);\n  free(utf8String);\n}\n\nstruct list {\n  struct list* next;\n  int data;\n};\n\nvoid access_null_deref_bad() {\n  struct list l = {NULL, 44};\n  l.next->next = NULL;\n}\n\nvoid access_use_after_free_bad(struct list* l) {\n  free(l->next);\n  l->next->next = NULL;\n}\n"
    },
    {
      "testname": "transitive-access.c",
      "testlanguage": "c",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid sink() {}\n\nvoid wrapper_ok() { sink(); }\n\nvoid source_bad() { wrapper_ok(); }\n"
    },
    {
      "testname": "uninit.c",
      "testlanguage": "c",
      "expected-problems": 111,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <assert.h>\n#include <stdlib.h>\n\nint dereference_bad() {\n  int* p;\n  return *p;\n}\n\nvoid self_assign_bad() {\n  int x;\n  x = x;\n}\n\nvoid use_and_mayinit(int, int*);\n\nvoid call_to_use_and_mayinit_bad() {\n  int x;\n  use_and_mayinit(x, &x);\n}\n\nvoid malloc_good() {\n  int* p = (int*)malloc(sizeof(int));\n  if (p) {\n    *p = 5;\n    int x = *p;\n  }\n  free(p);\n}\n\nvoid malloc_bad() {\n  int* p = (int*)malloc(sizeof(int));\n  if (p) {\n    int x = *p;\n  }\n  free(p);\n}\n\nvoid init_int_ref(int* p) { *p = 5; }\n\nvoid interprocedural_init_in_callee_good() {\n  int x;\n  init_int_ref(&x);\n  int y = x;\n}\n\nvoid nop(int* p) {}\n\nvoid interprocedural_nop_in_callee_bad() {\n  int x;\n  nop(&x);\n  int y = x;\n}\n\nvoid read_int_ref(int* p) { int x = *p; }\n\nvoid interprocedural_read_in_callee_bad() {\n  int x;\n  read_int_ref(&x);\n}\n\nint* uninit() { return (int*)malloc(sizeof(int)); }\n\nvoid interprocedural_uninit_in_callee_bad() {\n  int* p = uninit();\n  if (p) {\n    int x = *p;\n  }\n  free(p);\n}\n\nstruct uninit_s {\n  int f1;\n  int f2;\n};\n\nvoid get_field_address_good() {\n  struct uninit_s* s = (struct uninit_s*)malloc(2 * sizeof(int));\n  if (s) {\n    int* p = &s->f1;\n  }\n  free(s);\n}\n\nvoid init_f1(struct uninit_s* p) { p->f1 = 5; }\n\nvoid interprocedural_struct_good() {\n  struct uninit_s s;\n  init_f1(&s);\n  int y = s.f1;\n}\n\nvoid interprocedural_struct_bad() {\n  struct uninit_s s;\n  init_f1(&s);\n  int y = s.f2;\n}\n\nvoid malloc_array_good(int len) {\n  char* o = (char*)malloc(len);\n  if (o) {\n    o[0] = 'a';\n    char c = o[0];\n  }\n  free(o);\n}\n\nstruct uninit_s unknown_struct();\n\nstruct uninit_s unknown_wrapper() { return unknown_struct(); }\n\nvoid havoc_calling_unknown_struct_good() {\n  struct uninit_s x = unknown_wrapper();\n  int y = x.f1;\n}\n\nvoid malloc_array_bad_FN(int len) {\n  char* o = (char*)malloc(len);\n  if (o) {\n    o[0] = 'a';\n    char c = o[1];\n  }\n  free(o);\n}\n\nvoid local_array_good() {\n  char o[10];\n  o[0] = 'a';\n  char c = o[0];\n}\n\nvoid local_array_bad_FN() {\n  char o[10];\n  o[0] = 'a';\n  char c = o[1];\n}\n\nstruct uninit_nested {\n  struct uninit_s g1;\n  int g2;\n};\n\nvoid read_g1_f1(struct uninit_nested* x) { int y = x->g1.f1; }\n\nvoid nested_struct_good() {\n  struct uninit_nested x;\n  x.g1.f1 = 42;\n  read_g1_f1(&x);\n}\n\nvoid nested_struct_bad() {\n  struct uninit_nested x;\n  x.g1.f2 = 42;\n  read_g1_f1(&x);\n}\n\nvoid init_ptr_zero(int* ptr, int i) {\n  if (i != 0) {\n    *ptr = 42;\n  } else {\n    *(ptr + i) = 42;\n  }\n}\n\nvoid call_init_ptr_zero_good() {\n  int x;\n  init_ptr_zero(&x, 0);\n  int y = x;\n}\n\nint uninit_if_zero_bad(int a) {\n  int x;\n  if (a == 0) {\n    int y = x + 1;\n    int z = 4;\n    return z;\n  }\n  return 10;\n}\n\nvoid uninit_interproc_manifest_bad() {\n  int x = uninit_if_zero_bad(0);\n  if (x == 4) {\n    int* p = NULL;\n    *p = 42; // NPE to test that uninit didn't terminate the symbolic execution\n  }\n}\n\n// another interprocedural test\n\nvoid check_range(int range_var_valid, int* range_var) {\n  if (range_var_valid) {\n    *range_var = *range_var + 1;\n  }\n\n  assert(range_var_valid >= 0 && range_var_valid <= 1);\n}\n\nvoid check_range_wrapper(int range_var_valid, int* range_var) {\n  check_range(range_var_valid, range_var);\n}\n\nvoid uninit_var_not_read_interproc_ok() {\n  int range_var_valid = 0;\n  int range_var;\n  check_range_wrapper(range_var_valid, &range_var);\n}\n\nstruct uninit_s global_uninit_s1;\n\nstruct uninit_s global_uninit_s2;\n\nstruct uninit_s init_by_conditional_exp(int b) {\n  return b ? global_uninit_s1 : global_uninit_s2;\n}\n\nint call_init_by_conditionaql_exp_ok(int b) {\n  struct uninit_s x = init_by_conditional_exp(b);\n  return x.f1;\n}\n\n/** testing passing structs by value */\n\nstruct my_pair {\n  int x;\n  int y;\n};\n\nstruct my_pair make_pair(int x, int y) {\n  struct my_pair pair;\n  pair.x = x;\n  pair.y = y;\n  return pair;\n}\n\nstruct my_pair twice(int n) { return make_pair(n, n); }\n\nint FP_build_struct_after_var_init_ok() {\n  struct my_pair p;\n  p = twice(42);\n  return p.x + p.y;\n}\n\nint build_struct_during_var_init_ok() {\n  struct my_pair p = twice(42);\n  return p.x + p.y;\n}\n\nstruct my_pair init_only_x_bad(int x) {\n  struct my_pair pair;\n  pair.x = x;\n  return pair;\n}\n\nint memset_init_ok() {\n  struct my_pair pair;\n  memset(&pair, '\\0', sizeof(struct my_pair));\n  return pair.x + pair.y;\n}\n\nstruct my_pair* set_pair_to_zero(struct my_pair* pair) {\n  return memset(pair, '\\0', sizeof(struct my_pair));\n}\n\nint memset_wrapper_init_ok() {\n  struct my_pair pair;\n  set_pair_to_zero(&pair);\n  return pair.x + pair.y;\n}\n\nvoid memset_wrapper_value_bad(struct my_pair* pair) {\n  set_pair_to_zero(pair);\n  if (pair->x == 0 && pair->y == 0) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n/** /testing passing structs by value */\n"
    },
    {
      "testname": "unsigned_values.c",
      "testlanguage": "c",
      "expected-problems": 30,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\n// integers\n\nunsigned int returnUnsigned();\n\nvoid FP_nonnegative_int_ok() {\n  unsigned int x = returnUnsigned();\n  if (x < 0) {\n    // unreachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint returnSigned();\n\nvoid signed_int_bad() {\n  int x = returnSigned();\n  if (x < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// pointers to integers\n\nunsigned int* returnUnsignedPointer();\n\nvoid FP_nonnegative_int_ptr_ok() {\n  unsigned int* x = returnUnsignedPointer();\n  if (*x < 0) {\n    // unreachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint* returnSignedPointer();\n\nvoid signed_int_ptr_bad() {\n  int* x = returnSigned();\n  if (*x < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// struct with integer fields\n\nstruct foo {\n  unsigned int unsigned_int;\n  int signed_int;\n};\n\nstruct foo* returnFoo();\n\nvoid FP_nonnegative_field_ok() {\n  struct foo* x = returnFoo();\n  if (x->unsigned_int < 0) {\n    // unreachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nvoid signed_field_bad() {\n  struct foo* x = returnFoo();\n  if (x->signed_int < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// array of integers\n\nunsigned int* returnUnsignedArray();\n\nint FP_nonnegative_array_ok() {\n  unsigned int* a = returnUnsignedArray();\n  if (a[0] < 0) {\n    // unreachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint* returnSignedArray();\n\nint signed_array_bad() {\n  int* a = returnSignedArray();\n  if (a[0] < 0) {\n    // reachable\n    int* p = NULL;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "var_arg.c",
      "testlanguage": "c",
      "expected-problems": 25,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n#include <stdarg.h>\n\nint sum(int n, ...) {\n  va_list args;\n  va_start(args, n);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += va_arg(args, int);\n  }\n  va_end(args);\n  return sum;\n}\n\nvoid sum_one_then_npe_bad() {\n  int one = sum(1, 1);\n  int* p = NULL;\n  *p = one;\n}\n\n// we run out of loop iterations before reaching 4\nvoid FN_sum_four_then_npe_bad() {\n  int four = sum(4, 1, 1, 1, 1);\n  int* p = NULL;\n  *p = four;\n}\n\n// we run out of loop iterations before reaching 4\nvoid FN_sum_then_reachable_npe_bad() {\n  int four = sum(4, 1, 1, 1, 1);\n  if (four == 4) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\n// var_arg semantics not taken into account\nvoid FP_sum_then_unreachable_npe_ok() {\n  int one = sum(1, 1);\n  if (one == 4) {\n    int* p = NULL;\n    *p = 42;\n  }\n}\n\nint unknown_sum(int n, ...);\n\nvoid unknown_sum_one_then_npe_bad() {\n  int one = unknown_sum(1, 1);\n  int* p = NULL;\n  *p = one;\n}\n\nvoid unknown_sum_four_then_npe_bad() {\n  int four = unknown_sum(4, 1, 1, 1, 1);\n  int* p = NULL;\n  *p = four;\n}\n"
    },
    {
      "testname": "aliasing.cpp",
      "testlanguage": "c++",
      "expected-problems": 28,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid ifthenderef(bool b, int* x) {\n  if (b) {\n    *x = 42;\n  }\n}\n\nvoid ifnotthenderef(bool b, int* x) {\n  if (!b) {\n    *x = 42;\n  }\n}\n\nvoid call_ifthenderef_false_null_ok() { ifthenderef(false, nullptr); }\n\nvoid call_ifthenderef_true_null_bad() { ifthenderef(true, nullptr); }\n\nvoid call_ifnotthenderef_true_null_ok() { ifnotthenderef(true, nullptr); }\n\nvoid call_ifnotthenderef_false_null_bad() { ifnotthenderef(false, nullptr); }\n\n// should be FN given the current \"all allocated addresses are assumed\n// disjoint unless specified otherwise\" but we detect the bug because\n// we don't propagate pure equalities that we discover to the heap part\nvoid FN_alias_null_deref_latent(int* x, int* y) {\n  *x = 32;\n  *y = 52;\n  if (x == y) {\n    // here we have x|-> * x |-> which should be a contradiction\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid diverge_if_alias_ok(int* x, int* y) {\n  if (x == y) {\n    for (;;)\n      ;\n  }\n}\n\nvoid diverge_before_null_deref_ok(int* x) {\n  diverge_if_alias_ok(x, x);\n  int* p = nullptr;\n  *p = 42;\n}\n\n// this test makes more sense in an inter-procedural setting\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wtautological-pointer-compare\"\nvoid stack_addresses_are_not_null_ok() {\n  int x;\n  if (&x == nullptr) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n#pragma clang diagnostic pop\n\nvoid stack_addresses_are_distinct_ok() {\n  int x;\n  int y;\n  if (&x == &y) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n// latent because of the condition \"x==0\" in the pre-condition\nvoid null_test_after_deref_latent_FN(int* x) {\n  *x = 42; // filtered out latent error given that x is tested for null below\n  if (x == nullptr) {\n    int* p = nullptr;\n    *p = 42; // should be ignored as we can never get there\n  }\n}\n"
    },
    {
      "testname": "basics.cpp",
      "testlanguage": "c++",
      "expected-problems": 49,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <string>\n#include <vector>\n\nstruct Aggregate {\n  int i;\n\n  ~Aggregate() {}\n};\n\nvoid aggregate_reassign_ok() {\n  const int len = 5;\n  Aggregate arr[len];\n  for (int i = 0; i < len; i++) {\n    Aggregate s = {1};\n    // assign with curly bracket syntax doesn't call constructor; need to\n    // recognize that this is a reassignment anyway\n    arr[0] = s; // shouldn't be flagged as a use-after-lifetime\n  }\n}\n\nstruct AggregateWithConstructedField {\n  std::string str;\n};\n\nvoid aggregate_reassign2_ok() {\n  AggregateWithConstructedField arr[10];\n  for (int i = 0; i < 10; i++) {\n    // this is translated as string(&(a.str), \"hi\"). need to make sure this is\n    // treated the same as initializing a\n    AggregateWithConstructedField a{\"hi\"};\n    arr[i] = a;\n  }\n}\n\nstruct NestedAggregate {\n  AggregateWithConstructedField a;\n};\n\nvoid aggregate_reassign3_ok() {\n  NestedAggregate arr[10];\n  for (int i = 0; i < 10; i++) {\n    // this is translated as std::basic_string(&(a.str), \"hi\"). need to make\n    // sure this is treated the same as initializing a\n    NestedAggregate a{{\"hi\"}};\n    arr[i] = a;\n  }\n}\n\nint multiple_invalidations_branch_bad(int n, int* ptr) {\n  if (n == 7) {\n    delete ptr;\n  } else {\n    delete ptr;\n  }\n  return *ptr;\n}\n\nint multiple_invalidations_loop_bad(int n, int* ptr) {\n  for (int i = 0; i < n; i++) {\n    if (i == 7) {\n      delete ptr;\n    } else {\n      delete ptr;\n    }\n  }\n  return *ptr;\n}\n\nAggregate* pointer_arithmetic_ok(Aggregate* a) {\n  a->~Aggregate();\n  a++;\n  return a;\n}\n\nvoid iterator_pointer_arithmetic_ok(std::vector<Aggregate> v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    it->~Aggregate();\n  }\n}\n\nstruct A {\n  ~A();\n  int f(int i) const;\n};\n\nconst A getA();\n\nint struct_inside_loop_ok(std::vector<int> numbers) {\n  int sum = 0;\n  for (auto number : numbers) {\n    A a = getA();\n    sum += a.f(number);\n  }\n  return sum;\n}\n\nint struct_inside_loop_break_ok(std::vector<int> numbers) {\n  int sum = 0;\n  for (auto number : numbers) {\n    A a = getA();\n    if (number < 0) {\n      break;\n    }\n    sum += a.f(number);\n  }\n  return sum;\n}\n\nint struct_inside_loop_continue_ok(std::vector<int> numbers) {\n  int sum = 0;\n  for (auto number : numbers) {\n    A a = getA();\n    if (number < 0) {\n      continue;\n    }\n    sum += a.f(number);\n  }\n  return sum;\n}\n\nvoid return_from_inner_scope_ok(bool b) {\n  {\n    A a = getA();\n    if (b) {\n      return;\n    }\n  }\n}\n\nvoid return_inside_single_branch_if_in_loop_ok() {\n  while (true) {\n    if (true) {\n      A a;\n      return;\n    }\n  }\n}\n\nstruct UseAfterSelfDestruct {\n  A a_;\n  int x_;\n  ~UseAfterSelfDestruct() {\n    if (x_ == 0) {\n      a_ = getA();\n    }\n  }\n\n  void reset_ok() {\n    this->~UseAfterSelfDestruct();\n    x_ = a_.f(x_);\n  }\n};\n\nvoid call_builtin_add_overflow_ok() {\n  int res;\n  __builtin_add_overflow(2, 3, &res);\n  if (res == 42) {\n    int* q = nullptr;\n    *q = 42;\n  }\n}\n\nvoid call_builtin_add_overflow_bad() {\n  int res;\n  __builtin_add_overflow(2, 3, &res);\n  if (res == 5) {\n    int* q = nullptr;\n    *q = 42;\n  }\n}\n\nvoid call_builtin_mul_overflow_ok() {\n  int res;\n  __builtin_mul_overflow(2, 3, &res);\n  if (res == 42) {\n    int* q = nullptr;\n    *q = 42;\n  }\n}\n\nvoid call_builtin_mul_overflow_bad() {\n  int res;\n  __builtin_mul_overflow(2, 3, &res);\n  if (res == 6) {\n    int* q = nullptr;\n    *q = 42;\n  }\n}\n\nvoid call_builtin_sub_overflow_ok() {\n  int res;\n  __builtin_sub_overflow(3, 2, &res);\n  if (res == 42) {\n    int* q = nullptr;\n    *q = 42;\n  }\n}\n\nvoid call_builtin_sub_overflow_bad() {\n  int res;\n  __builtin_sub_overflow(3, 2, &res);\n  if (res == 1) {\n    int* q = nullptr;\n    *q = 42;\n  }\n}\n"
    },
    {
      "testname": "basic_string.cpp",
      "testlanguage": "c++",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <string>\n\n// inspired by folly::Range\nstruct Range {\n  const char *b_, *e_;\n\n  Range(const std::string& str) : b_(str.data()), e_(b_ + str.size()) {}\n\n  char operator[](size_t i) { return b_[i]; }\n};\n\nconst Range setLanguage(const std::string& s) {\n  return s[0] == 'k' ? s.substr(0, 1) // cast to Range returns pointers\n                                      // into stack-allocated temporary string\n                     : \"en\";\n}\n\nbool use_range_of_invalidated_temporary_string_bad(const std::string& str) {\n  auto s = setLanguage(str);\n  return s[0] == 'k';\n}\n\nvoid some_function(std::string s);\n\nint string_passed_as_param_ok() {\n  std::string str = \"\";\n  some_function(str);\n  if (str.empty()) {\n    return 0;\n  }\n  return 1;\n}\n\nvoid copy_string_bad() {\n  std::string x = \"abc\";\n  std::string y = x;\n  if (y.length() == 3) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid copy_string_ok() {\n  std::string x = \"abc\";\n  std::string y = x;\n  if (y.length() != 3) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "call_lambdas.cpp",
      "testlanguage": "c++",
      "expected-problems": 62,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <functional>\n#include <iostream>\n\ntemplate <typename F>\nint call_lambda(F lambda) {\n  return lambda(100);\n}\n\nint call_lambda_through_function() {\n  int c = 42;\n  return call_lambda([c](int a) { return a + c; });\n}\n\nint call_lambda_directly() {\n  int c = 42;\n  return [c](int a) { return a + c; }(100);\n}\n\nint call_lambda_through_function_test_bad() {\n  if (call_lambda_through_function() == 142) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint call_lambda_through_function_test_good() {\n  if (call_lambda_through_function() == 143) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint call_lambda_directly_test_bad() {\n  if (call_lambda_directly() == 142) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint call_lambda_directly_test_good() {\n  if (call_lambda_directly() == 143) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint call_std_fun_constructor() {\n  int c = 42;\n  std::function<int(int)> f = [c](int a) { return a + c; };\n  return f(100);\n}\n\nint call_std_fun_constructor_test_bad() {\n  if (call_std_fun_constructor() == 142) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint call_std_fun_constructor_test_good() {\n  if (call_std_fun_constructor() == 143) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint* dangerous();\nvoid deref_dangerous_lambda_bad() {\n  auto l_dangerous = []() { return dangerous(); };\n  int* p = l_dangerous();\n  *p = 42;\n\n}\n\nvoid deref_dangerous_lambda_function_bad() {\n  std::function<int*()> fl_dangerous = []() { return dangerous(); };\n  int* p = fl_dangerous();\n  *p = 42;\n}\n\nclass A {\npublic:\n    std::function<int*()> f;\n\n    A(std::function<int*()> func) : f(std::move(func)) {}\n};\n\nvoid defer_dangerous_member_bad() {\n  A a([]() { return dangerous(); });\n  int *p = a.f();\n  *p = 42;\n}\n\nint* maybe_dangerous();\nvoid deref_maybe_dangerous_lambda_function_ok() {\n  std::function<int*()> fl_maybe_dangerous = []() { return maybe_dangerous(); };\n  int* p = fl_maybe_dangerous();\n  *p = 42;\n}\n\nint call_lambda_after_copy() {\n  int c = 41;\n  int d = 1;\n  auto f = [c, &d](int a) { return a + c + d; };\n  auto g = f;\n  return g(100);\n}\n\nint call_lambda_after_copy_test_bad() {\n  if (call_lambda_after_copy() == 142) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint call_lambda_after_copy_test_good() {\n  if (call_lambda_after_copy() == 143) {\n    int* p = NULL;\n    return *p;\n  }\n}\n\nint closure_as_arg(std::function<int()> closure) { return closure(); }\n\nint closure_call() {\n  int x = 5;\n  return closure_as_arg([x]() { return x + 27; });\n}\n\nint closure_call_bad() {\n  if (closure_call() == 32) {\n    int* ptr = NULL;\n    return *ptr;\n  } else\n    return 0;\n}\n\nint closure_call_good() {\n  if (closure_call() == 30) {\n    int* ptr = NULL;\n    return *ptr;\n  } else\n    return 0;\n}\n\nint named_closure_call() {\n  int x = 5;\n  auto closure = [x]() { return x + 27; };\n  return closure_as_arg(closure);\n}\n\nint named_closure_call_bad() {\n  if (named_closure_call() == 32) {\n    int* ptr = NULL;\n    return *ptr;\n  } else\n    return 0;\n}\n\nint named_closure_call_good_FP() {\n  if (named_closure_call() == 30) {\n    int* ptr = NULL;\n    return *ptr;\n  } else\n    return 0;\n}\n"
    },
    {
      "testname": "closures.cpp",
      "testlanguage": "c++",
      "expected-problems": 154,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <functional>\n\nstruct S {\n  int f;\n\n  S() { f = 1; }\n  ~S() {}\n};\n\nint ref_capture_destroy_invoke_bad() {\n  std::function<int()> f;\n  {\n    S s;\n    f = [&s] { return s.f; };\n  } // destructor for s called here\n  return f(); // s used here\n}\n\nint implicit_ref_capture_destroy_invoke_bad() {\n  std::function<int()> f;\n  {\n    auto s = S();\n    f = [&] { return s.f; };\n  }\n  return f();\n}\n\n// FN in C++14\nint reassign_lambda_capture_destroy_invoke_bad() {\n  std::function<int()> f;\n  {\n    auto s = S();\n    // this is a copy constructor in C++14, which pulse misses,\n    // but it's a straight assignment in C++17, which pulse understands\n    auto tmp = [&] { return s.f; };\n    f = tmp;\n  }\n  return f();\n}\n\nint value_capture_destroy_invoke_ok() {\n  std::function<int()> f;\n  {\n    S s;\n    f = [s] { return s.f; };\n  }\n  return f();\n}\n\nint implicit_value_capture_destroy_invoke_ok() {\n  std::function<int()> f;\n  {\n    S s;\n    f = [=] { return s.f; };\n  }\n  return f();\n}\n\nint ref_capture_invoke_ok() {\n  std::function<int()> f;\n  int ret;\n  {\n    S s;\n    f = [&s] { return s.f; };\n    ret = f();\n  }\n  return ret;\n}\n\nvoid invoke_twice_ok() {\n  std::function<int()> f;\n  int ret;\n  {\n    S s;\n    f = [&s] { return s.f; };\n    f();\n    f();\n  }\n}\n\nvoid ref_capture_read_lambda_ok() {\n  std::function<int()> f;\n  int ret;\n  {\n    S s;\n    f = [&s] { return s.f; };\n  }\n  auto tmp =\n      f; // reading (but not invoking) the lambda doesn't use its captured vars\n}\n\n// explicit destructor call is not modelled\nint FN_delete_lambda_then_call_bad() {\n  std::function<int()> lambda = [] { return 1; };\n  lambda.~function();\n  return lambda();\n}\n\n// need to treat escaping as a use in order to catch this\nstd::function<int()> FN_ref_capture_return_lambda_bad() {\n  std::function<int()> f;\n  int ret;\n  {\n    S s;\n    f = [&s] { return s.f; };\n  }\n  return f; // if the caller invokes the lambda, it will try to read the invalid\n            // stack address\n}\n\nint ref_capture_return_local_lambda_ok() {\n  S x;\n  auto f = [&x](void) -> S& {\n    // do not report this because there is a good chance that this function will\n    // only be used in the local scope\n    return x;\n  };\n  return f().f;\n}\n\nS& ref_capture_return_local_lambda_bad() {\n  S x;\n  auto f = [&x](void) -> S& {\n    // no way to know if ok here\n    return x;\n  };\n  // woops, this returns a ref to a local!\n  return f();\n}\n\nstruct C {\n  int val() const;\n  ~C();\n};\n\nstruct D {\n  void add(int v);\n  ~D();\n};\n\nvoid capture_multiple_vars_by_value_ok(C c, C c2) {\n  auto f = [=]() -> D* {\n    auto d = new D();\n    d->add(c.val());\n    d->add(c2.val());\n    return d;\n  };\n}\n\nvoid call_lambda_ok() {\n  auto f = [](S* s) { int x = s->f; };\n  S* s = new S();\n  f(s);\n  delete s;\n}\n\nvoid call_lambda_bad() {\n  auto f = [](S* s) { int x = s->f; };\n  S* s = new S();\n  delete s;\n  f(s);\n}\n\nvoid call_lambda_std_fun_bad() {\n  std::function<void(S*)> f;\n  f = [](S* s) { int x = s->f; };\n  S* s = new S();\n  delete s;\n  f(s);\n}\n\nvoid call_std_fun_constructor_bad() {\n  std::function<void(S*)> f1 = [](S* s) { int x = s->f; };\n  std::function<void(S*)> f2 = f1;\n  S* s = new S();\n  delete s;\n  f2(s);\n}\n\nvoid function_constructor_null_ok() { std::function<int()> f = nullptr; }\n\nvoid function_assign_null_ok() {\n  std::function<int()> f = [] { return 1; };\n  f = nullptr;\n}\n\nvoid capture_by_value_ok() {\n  int value = 5;\n  auto f = [value]() -> int* { return new int(value); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_value_bad() {\n  int value = 5;\n  auto f = [value]() -> int* { return new int(value); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_ref_ok() {\n  int value = 5;\n  auto f = [&value]() -> int* { return new int(value); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 6) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_ref_bad() {\n  int value = 5;\n  auto f = [&value]() -> int* { return new int(value); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 6) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_value_init_ok() {\n  int value = 5;\n  auto f = [v = value]() -> int* { return new int(v); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_value_init_bad() {\n  int value = 5;\n  auto f = [v = value]() -> int* { return new int(v); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_ref_init_ok() {\n  int value = 5;\n  auto f = [&v = value]() -> int* { return new int(v); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 6) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid capture_by_ref_init_bad() {\n  int value = 5;\n  auto f = [&v = value]() -> int* { return new int(v); };\n  value++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 6) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid ref_capture_by_value_ok() {\n  int value = 5;\n  int& ref = value;\n  auto f = [ref]() -> int* { return new int(ref); };\n  ref++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid ref_capture_by_value_bad() {\n  int value = 5;\n  int& ref = value;\n  auto f = [ref]() -> int* { return new int(ref); };\n  ref++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid ref_capture_by_ref_ok() {\n  int value = 5;\n  int& ref = value;\n  auto f = [&ref]() -> int* { return new int(ref); };\n  ref++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 6) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid ref_capture_by_ref_bad() {\n  int value = 5;\n  int& ref = value;\n  auto f = [&ref]() -> int* { return new int(ref); };\n  ref++;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 6) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid struct_capture_by_ref_bad() {\n  S s;\n  auto f = [&s]() -> int* { return new int(s.f); };\n  s.f = 5;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid struct_capture_by_ref_ok() {\n  S s;\n  auto f = [&s]() -> int* { return new int(s.f); };\n  s.f = 5;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 5) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid struct_capture_by_val_bad() {\n  S s;\n  auto f = [s]() -> int* { return new int(s.f); };\n  s.f = 5;\n  int* p = f();\n  int* q = nullptr;\n  if (*p == 1) {\n    *q = 42;\n  }\n  delete p;\n}\n\nvoid struct_capture_by_val_ok_FP() {\n  S s;\n  auto f = [s]() -> int* { return new int(s.f); };\n  s.f = 5;\n  int* p = f();\n  int* q = nullptr;\n  if (*p != 1) {\n    *q = 42;\n  }\n  delete p;\n}\n\nS* update_inside_lambda_capture_and_init(S* s) {\n  S* object = nullptr;\n  auto f = [&o = object](S* s) { o = s; };\n  f(s);\n  return object;\n}\n\nint update_inside_lambda_capture_and_init_ok(S* param_s) {\n  return update_inside_lambda_capture_and_init(param_s)->f;\n}\n\nS* update_inside_lambda_capture_only(S* s) {\n  S* object = nullptr;\n  /* FIXME: clang AST gives us `S*` for  variable `object` in the\n     lambda's body, hence the translation misses one dereference */\n  auto f = [&object](S* s) { object = s; };\n  f(s);\n  return object;\n}\n\nint update_inside_lambda_capture_only_ok(S* param_s) {\n  return update_inside_lambda_capture_only(param_s)->f;\n}\n\nvoid call_argument(std::function<void(S*)> f, S* s) { f(s); }\n\nS* update_inside_lambda_as_argument(S* s) {\n  S* object = nullptr;\n  auto f = [&o = object](S* s) { o = s; };\n  call_argument(f, s);\n  return object;\n}\n\nint update_inside_lambda_as_argument_ok(S* param_s) {\n  return update_inside_lambda_as_argument(param_s)->f;\n}\n\nstd::function<void()> get_lambda(bool b) {\n  return [b]() -> void { return; };\n}\n\nvoid capture_false_by_value_ok() {\n  const auto& f = get_lambda(false);\n  f();\n}\n\nvoid FP_update_inside_lambda_visible_outside_ok() {\n  int x = 0; // there are two variables x in the symbolic state `roots={ &x=v3,\n             // &x=v1 }`\n  auto f = [&xx = x]() {\n    xx++;\n  }; // one variable disappear because of dealloc instruction\n  x = 7; // again there are two variables x in the symbolic state\n  f();\n  if (x != 8) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "conditionals.cpp",
      "testlanguage": "c++",
      "expected-problems": 43,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid unreachable_eq_then_ne_ok(int* x, int y) {\n  if (y == 0) {\n    free(x);\n  }\n  if (y != 0) {\n    free(x);\n  }\n}\n\nvoid unreachable_ne_then_eq_ok(int* x, int y) {\n  if (y != 0) {\n    free(x);\n  }\n  if (y == 0) {\n    free(x);\n  }\n}\n\nbool equal_explicit(size_t x, size_t y) {\n  if (x == y) {\n    return true;\n  }\n  return false;\n}\n\n// need relational domain to give this a good spec\nbool equal(size_t x, size_t y) { return x == y; }\n\nvoid unreachable_interproc_compare_ok(int* x, size_t y) {\n  if (equal(y, 0)) {\n    free(x);\n  }\n  if (equal_explicit(y, 1)) {\n    free(x);\n  }\n}\n\nvoid compare_deref_ok(int* x) {\n  if (!equal((size_t)x, 0)) {\n    *x = 42;\n  }\n}\n\nvoid arith_test_ok(int* x, int y, int z) {\n  free(x);\n  if (y != 0 && y != 1 && y >= 1) { // should infer y >= 2\n    if (y < 2) { // always false\n      *x = 42;\n    }\n  }\n}\n\nvoid add_test1_ok(int* x) {\n  free(x);\n  int y = 0;\n  if (y + 1 != 1) { // always false\n    *x = 42;\n  }\n}\n\nvoid add_test2_ok(int* x, int y, int z) {\n  free(x);\n  if (y >= 0) {\n    if (z >= 4 && z <= 42) {\n      if (y + z < 4 || y + z <= 3 || z + 5 > 47) { // always false\n        *x = 42;\n      }\n    }\n  }\n}\n\nvoid add_test3_bad(int* x, int y, int z) {\n  free(x);\n  if (y > 2 && y + z > 5) { // sometimes true\n    *x = 42;\n  }\n}\n\nvoid add_test4_bad_FN(int* x) {\n  free(x);\n  // the concrete bound is never reached because it requires too many iterations\n  // and we never widen\n  for (int i = 0; i < 1000; i++) {\n  }\n  *x = 42;\n}\n\nvoid add_test5_bad(int* x, int n) {\n  free(x);\n  // the unknown bound is treated non-deterministically, good thing here\n  for (int i = 0; i < n; i++) {\n  }\n  *x = 42;\n}\n\nvoid add_test6_bad_FNish(int* x, int n, int step) {\n  free(x);\n  // the loop should diverge but arguably the code is wrong and should\n  // have a more explicit \"false\" condition (hence \"FN-ish\")\n  for (int i = n - 1; i < n;) {\n  }\n  *x = 42;\n}\n\nvoid minus_test_ok(int* x) {\n  free(x);\n  if (-1 + 3 - 2 != 0) { // always false\n    *x = 42;\n  }\n}\n\nvoid binary_and_ok(int* x) {\n  free(x);\n  if (10 & 9) {\n  } else {\n    *x = 42;\n  }\n}\n\nvoid binary_and_bad(int* x) {\n  free(x);\n  if (10 & 9) {\n    *x = 42;\n  }\n}\n"
    },
    {
      "testname": "conditional_temporaries.cpp",
      "testlanguage": "c++",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <iostream>\n\nnamespace condtemp {\n\n// keep track of how many copies are made of the object and how many\n// of these copies have been destroyed\nstruct Counter {\n  std::string name;\n  int copies;\n  int copies_destroyed;\n  bool destroyed;\n\n  Counter(std::string name_)\n      : name(name_), copies(0), copies_destroyed(0), destroyed(false) {}\n};\n\nstruct X {\n  int f; // some data\n  Counter* counter; // nullptr if this object is a copy from another X\n  Counter* original_counter; // nullptr if this object was created not from a\n                             // copy or move constructor\n\n  X() = delete;\n  X(Counter* counter_) : counter(counter_), original_counter(nullptr), f(72) {\n    //    std::cerr << \"original: \" << name() << \"\\n\";\n  }\n  X(X& x) {\n    std::cerr << \"copy (of \" << x.name()\n              << \") constructor called with f=\" << x.f << \"\\n\";\n    f = x.f + 11;\n    copy_from(x);\n  }\n  X(X&& x) {\n    std::cerr << \"move (of \" << x.name()\n              << \") constructor called with f=\" << x.f << \"\\n\";\n    f = x.f + 10;\n    copy_from(x);\n  }\n\n  // should realise [this] cannot be null to avoid FP latent (that can never be\n  // manifested)\n  ~X() {\n    std::cerr << \"~X(\" << f << \") \" << name();\n    if (original_counter) {\n      original_counter->copies_destroyed++;\n    }\n    if (counter) {\n      std::cerr << \" original destroyed\";\n      counter->destroyed = true;\n    }\n    std::cerr << \" \\n\";\n    ;\n  }\n\n private:\n  void copy_from(X& x) {\n    counter = nullptr;\n    if (x.counter) {\n      original_counter = x.counter;\n    } else {\n      original_counter = x.original_counter;\n    }\n    original_counter->copies++;\n  }\n\n  std::string& name() {\n    if (counter) {\n      return counter->name;\n    } else {\n      return original_counter->name;\n    }\n  }\n};\n\nX copy(X x) {\n  std::cerr << \"copy(\" << x.f << \")\\n\";\n  return x;\n}\n\nvoid crash(bool b) {\n  if (b) {\n  }\n}\n\nvoid FP_track_copy_operations_one_copy_ok() {\n  Counter c_true(\"c_true\"), c_false(\"c_false\");\n  X y(&c_false);\n  X x = false ? X(&c_true) : y;\n  std::cerr << \"c_false.copies=\" << c_false.copies << \"\\n\";\n  std::cerr << \"c_false.copies_destroyed=\" << c_false.copies_destroyed << \"\\n\";\n  std::cerr << \"c_false.destroyed=\" << c_false.destroyed << \"\\n\";\n  std::cerr << \"c_true.copies=\" << c_true.copies << \"\\n\";\n  std::cerr << \"c_true.copies_destroyed=\" << c_true.copies_destroyed << \"\\n\";\n  std::cerr << \"c_true.destroyed=\" << c_true.destroyed << \"\\n\";\n  // these values were checked against the output of the program\n  // compiled with clang -fno-elide-constructors, results will vary\n  // if we omit the elidable constructor calls\n  if (!(c_false.copies == 2 && c_false.copies_destroyed == 1 &&\n        !c_false.destroyed) ||\n      c_true.copies != 0 || c_true.copies_destroyed != 0 || c_true.destroyed) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid FP_track_copy_operations_complex_ok() {\n  Counter c_true(\"c_true\"), c_false(\"c_false\");\n  X y(&c_false);\n  X x = true ? copy(X(&c_true)) : y;\n  std::cerr << \"c_false.copies=\" << c_false.copies << \"\\n\";\n  std::cerr << \"c_false.copies_destroyed=\" << c_false.copies_destroyed << \"\\n\";\n  std::cerr << \"c_false.destroyed=\" << c_false.destroyed << \"\\n\";\n  std::cerr << \"c_true.copies=\" << c_true.copies << \"\\n\";\n  std::cerr << \"c_true.copies_destroyed=\" << c_true.copies_destroyed << \"\\n\";\n  std::cerr << \"c_true.destroyed=\" << c_true.destroyed << \"\\n\";\n  // these values were checked against the output of the program\n  // compiled with clang -fno-elide-constructors, results will vary\n  // if we omit the elidable constructor calls\n  if (!(c_true.copies == 4 && c_true.copies_destroyed == 3 &&\n        c_true.destroyed)) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n} // namespace condtemp\n\nint main() { condtemp::FP_track_copy_operations_complex_ok(); }\n"
    },
    {
      "testname": "const_refable.cpp",
      "testlanguage": "c++",
      "expected-problems": 93,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <optional>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n#include <functional>\n\nnamespace folly {\ntemplate <class Value>\nclass Optional {\n public:\n  Optional(const Optional& src);\n  bool has_value();\n\n private:\n  Value v;\n};\n\nnamespace coro {\ntemplate <class Value>\nclass Task {};\n} // namespace coro\n} // namespace folly\n\nnamespace const_refable {\n\nstruct Arr {\n  int arr[2];\n  std::vector<int> vec;\n};\n\n// The correct use of const reference when parameter is not modified\nint read_first_ok(const Arr& a) { return a.vec[0]; }\n\n// Non-const references are not reported on\nstd::string non_const_ref_ok(std::string& str) { return str + str; }\n\n// R-value references are not reported on\nvoid rvalue_ref_ok(Arr&& a) { auto& cpy = a; }\n\n// vec is not modified, so should be const reference.\nint read_first_bad(Arr a) { return a.vec[0]; }\n\nint modify_first_ok(Arr a) {\n  a.arr[0] += 8;\n  return a.arr[0];\n}\n\nvoid ref_modified_ok(std::vector<int> vec) {\n  auto& cpy = vec;\n  cpy[0] += 8;\n}\n\nint get_first(const std::vector<int>& vec) { return vec[0]; }\n\nvoid interprocedural_read_bad(std::vector<int> vec) {\n  int first = get_first(vec);\n}\n\n// Sum vec by reading vector elements\nint sum_in_loop_bad(std::vector<int> vec) {\n  int total = 0;\n  for (const int& x : vec)\n\n    total += x; // vec is not modified here\n  return total;\n}\n\n// anonymous parameters usually exist to satisfy the signature for virtual\n// functions. If we recommend const ref, the signature would not match and\n// making the base function const-refable might not be possible since it might\n// be using the parameter.\nvoid some_fun_ok(std::vector<int> /*unnamed_param*/) {}\n\nvoid pass_rvalue_ref(std::set<int>&& x) {}\n\n// params which are passed-by-value and get moved are usually intentional\nint move_ok(std::set<int> source) {\n  pass_rvalue_ref(std::move(source));\n  return 0;\n}\n\nint param_ref_move_ok(std::set<int> source) {\n  auto& source_ref = source;\n  pass_rvalue_ref(std::move(source_ref));\n  return 0;\n}\n\nint static_cast_to_rvalue_ref_ok(std::set<int> source) {\n  pass_rvalue_ref(static_cast<std::set<int>&&>(source));\n  return 0;\n}\n\n// structs known to be cheap to copy are not reported\nint std_pair_int_ok(std::pair<int, int> p) { return p.first; }\n\nint std_pair_vector_bad(std::pair<int, std::vector<int>> p) { return p.first; }\n\nstd::string std_pair_string_bad(std::pair<std::string, std::string> p) {\n  return p.first;\n}\n\nint folly_optional_int_ok(folly::Optional<int> n_opt) {\n  if (n_opt.has_value()) {\n    return 42;\n  }\n  return 0;\n}\n\nint folly_optional_vector_bad(folly::Optional<std::vector<int>> vec_opt) {\n  if (vec_opt.has_value()) {\n    return 42;\n  }\n  return 0;\n}\n\nint folly_optional_string_bad(folly::Optional<std::string> s_opt) {\n  if (s_opt.has_value()) {\n    return 42;\n  }\n  return 0;\n}\n\nstruct StructWithInt {\n  int n;\n  std::vector<int> vec;\n};\n\nvoid havoc_ptr(int* p);\n\n// StructWithInt s is const refable since it is not modified\nvoid havoc_reachable_by_unknown_bad(int* p, StructWithInt s) {\n  if (s.n == 42 && *p == 42) {\n    havoc_ptr(p);\n  }\n}\n\nvoid dead_param_ok(folly::Optional<std::string> s_opt) {}\n\nvoid call_lambda(const std::function<void()>& f) { f(); }\n\n// This is FN in c++11.\nvoid captured_arr_bad_FN(Arr a) {\n  call_lambda([&a]() {});\n}\n\n// This is TN in c++11.\nvoid captured_arr_ok(Arr a) {\n  call_lambda([&a]() { a.arr[0] += 8; });\n}\n\n// This is TP in c++11.\nvoid captured_shared_ptr_bad_FN(std::shared_ptr<int> a) {\n  call_lambda([&a]() {});\n}\n\nArr global;\n\nclass AssignField {\n  Arr field;\n\n public:\n  // It should NOT report const refable issue, but unncessary copy assignment\n  // issue.\n  void assign_field_bad(Arr a) { field = a; }\n\n  // It should NOT report const refable issue, but unncessary copy assignment\n  // issue.\n  void assign_global_bad(Arr a) { global = a; }\n};\n\n// Suppress const refable issues on functions returning folly::coro::Task\nfolly::coro::Task<Arr> ret_coro_task_ok(std::string s) {\n  int n = s.length();\n  return folly::coro::Task<Arr>();\n}\n\nvoid move_iterated_vector_ok(std::vector<std::string> v) {\n  std::vector<std::string> local;\n  local.insert(local.end(),\n               std::make_move_iterator(v.begin()),\n               std::make_move_iterator(v.end()));\n}\n\nchar mod_char(char);\n\nvoid modify_string(std::string& s) {\n  for (char& c : s) {\n    c = mod_char(c);\n  }\n}\n\nvoid call_modify_string_ok(std::string s) { modify_string(s); }\n\nvoid void_cast(std::string* s) { (void)s; }\n\n// FN because now infer_skip is addressed as an unknown call\nvoid call_void_cast_bad_FN(std::string s) { void_cast(&s); }\n\nint get_lambda(const std::function<int(Arr)>& f, Arr a) {\n  return f(std::move(a));\n}\n\nint call_get_lambda_ok(Arr a) {\n  return get_lambda([](Arr a) { return a.vec[0]; }, std::move(a));\n}\n\nstd::string use_unique_ptr_ok(std::unique_ptr<std::string> x) {\n  return *x.get();\n}\n\nstruct NonCopiableT {\n  std::vector<int> vec;\n  int x;\n  // doesn't allow copying\n  NonCopiableT(const NonCopiableT&) = delete;\n};\n\n// we shouldn't report const-refable here since the type doesn't allow copies\nvoid non_copiable_ok(NonCopiableT t) { auto p = t.x; }\n\nvoid modify_string_ok(std::string s) {\n  char* p = &s[0];\n  *p = 'a';\n}\n\n// currently the model semantics cannot follow the pointer arithmetics precisely\nvoid modify_string2_ok_FP(std::string s) {\n  char* p = &s[3];\n  *p = 'a';\n}\n\nclass N {\n  uint32_t n;\n};\nusing TupleN = std::tuple<N, N>;\n\nvoid use_tupleN(TupleN x);\n\nvoid pass_tupleN_ok(TupleN x) { use_tupleN(x); }\n\nstd::string move_to_return_ok(bool b, std::string s) {\n  if (b) {\n    return \"hi\";\n  } else {\n    return s; // s is moved here.\n  }\n}\n\nvoid unknown_lambda_call(std::function<void()>);\n\n// The issue is conservatively suppressed when the parameter is captured by\n// reference.\nvoid captured_ref_ok(std::vector<int> vec) {\n  auto f = [&vec]() { vec[0] += 42; };\n  unknown_lambda_call(std::move(f));\n}\n\nvoid captured_value_bad(std::vector<int> vec) {\n  auto f = [vec]() {};\n  unknown_lambda_call(std::move(f));\n}\n\nvoid captured_move_ok(std::vector<int> vec) {\n  auto f = [vec = std::move(vec)]() {};\n  unknown_lambda_call(std::move(f));\n}\n} // namespace const_refable\n"
    },
    {
      "testname": "const_volatile_type.cpp",
      "testlanguage": "c++",
      "expected-problems": 20,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nint test_volatile1_bad() {\n  std::unique_ptr<volatile int> x;\n  std::unique_ptr<volatile int> y = std::move(x);\n  return *y;\n}\n\nint test_volatile2_bad() {\n  std::unique_ptr<volatile int> x;\n  return *x;\n}\n\nint test_volatile3_bad() {\n  std::shared_ptr<volatile int> x;\n  std::shared_ptr<volatile int> y = std::move(x);\n  return *y;\n}\n\nint test_volatile4_bad() {\n  std::shared_ptr<volatile int> x;\n  return *x;\n}\n\nint test_const1_bad() {\n  std::unique_ptr<const int> x;\n  std::unique_ptr<const int> y = std::move(x);\n  return *y;\n}\n\nint test_const2_bad() {\n  std::unique_ptr<const int> x;\n  return *x;\n}\n\nint test_const3_bad() {\n  std::shared_ptr<const int> x;\n  std::shared_ptr<const int> y = std::move(x);\n  return *y;\n}\n\nint test_const4_bad() {\n  std::shared_ptr<const int> x;\n  return *x;\n}\n"
    },
    {
      "testname": "deduplication.cpp",
      "testlanguage": "c++",
      "expected-problems": 29,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nnamespace deduplication {\n\nstruct A {\n  int f;\n};\n\ntemplate <typename T>\nstruct SomeTemplatedClass {\n  void templated_wrapper_delete_ok(A* a);\n  void templated_wrapper_access_ok(A* a);\n  void lifetime_error_bad(A* a);\n};\n\ntemplate <typename T>\nvoid SomeTemplatedClass<T>::templated_wrapper_delete_ok(A* a) {\n  delete a;\n}\n\ntemplate <typename T>\nvoid SomeTemplatedClass<T>::templated_wrapper_access_ok(A* a) {\n  int x = a->f;\n}\n\ntemplate <typename T>\nvoid SomeTemplatedClass<T>::lifetime_error_bad(A* a) {\n  SomeTemplatedClass<T>::templated_wrapper_delete_ok(a);\n  SomeTemplatedClass<T>::templated_wrapper_access_ok(a);\n}\n\nvoid materialize_class_template_instances() {\n  A* a1 = new A();\n  SomeTemplatedClass<int> x1;\n  x1.lifetime_error_bad(a1);\n\n  A* a2 = new A();\n  SomeTemplatedClass<int*> x2;\n  x2.lifetime_error_bad(a2);\n}\n\ntemplate <typename T>\nvoid templated_delete_function(T t, A* a) {\n  delete a;\n}\n\ntemplate <typename T>\nvoid templated_access_function(T t, A* a) {\n  int x = a->f;\n}\n\ntemplate <typename T>\nvoid templated_function_bad(T t) {\n  A* a = new A();\n  templated_delete_function<T>(t, a);\n  templated_access_function<T>(t, a);\n}\n\ntemplate void templated_delete_function<int>(int, A*);\ntemplate void templated_delete_function<bool>(bool, A*);\ntemplate void templated_access_function<int>(int, A*);\ntemplate void templated_access_function<bool>(bool, A*);\ntemplate void templated_function_bad<int>(int);\ntemplate void templated_function_bad<bool>(bool);\n\nvoid materialize_function_template_instances() {\n  templated_function_bad<int>(42);\n  templated_function_bad<bool>(true);\n}\n\n} // namespace deduplication\n"
    },
    {
      "testname": "deref_after_move_example.cpp",
      "testlanguage": "c++",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nnamespace deref_after_move_example {\n\nstruct Person {\n  // NOTE: the implicit constructor has a mem leak FP\n  std::unique_ptr<int> age{new int(35)};\n  std::unique_ptr<int> move_age() { return std::move(age); }\n  int access_age() { return *age; }\n};\n\nint deref_after_move_bad() {\n  Person p;\n  auto x = p.move_age();\n  *x;\n  return p.access_age();\n}\n\nint deref_ok() {\n  Person p;\n  return p.access_age();\n}\n\nint deref_after_move_ok() {\n  Person p;\n  auto x = p.move_age();\n  return *x;\n}\n\nstruct SimpleStruct {\n  int field;\n};\n\nstd::unique_ptr<SimpleStruct> global_simple_struct;\n\nvoid register_to_global(std::unique_ptr<SimpleStruct> x) {\n  global_simple_struct = std::move(x);\n}\n\nvoid deref_after_register_ok(std::unique_ptr<SimpleStruct> x) {\n  SimpleStruct* p = x.get();\n  register_to_global(std::move(x));\n  int n = p->field;\n}\n\nstruct S {\n public:\n  S();\n  S(const S& s);\n  S(S&& s) {\n    if (this == &s) {\n      return;\n    }\n  }\n  ~S();\n};\n\nclass T {\n public:\n  S s;\n  T(S&& s) : s(std::move(s)) {}\n};\n\nT move_local_variable() {\n  S x{};\n  return T(std::move(x));\n}\n\nS call_move_local_variable_ok() {\n  T t = move_local_variable();\n  return t.s;\n}\n\n} // namespace deref_after_move_example\n"
    },
    {
      "testname": "destructor.cpp",
      "testlanguage": "c++",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nnamespace destructor {\n\ntemplate <typename X>\nstruct UniquePtr {\n  X* x_;\n  ~UniquePtr() { delete x_; }\n  UniquePtr(X* y) { x_ = y; }\n\n  UniquePtr(UniquePtr<X>& p) = delete; // no copy constructor\n  UniquePtr(UniquePtr<X>&& p) {\n    x_ = p.get();\n    p.x_ = nullptr;\n  }\n\n  X* get() const { return x_; }\n\n  X& operator*() const { return *get(); }\n\n  X* operator->() const { return get(); }\n};\n\nstruct X {\n  int f;\n  ~X() {}\n};\n\nvoid destruct_unique_deletes_pointer_bad() {\n  X* p = new X;\n  { UniquePtr<X> u = UniquePtr<X>(p); }\n  int i = p->f;\n}\n\nvoid destruct_unique_ref_deletes_pointer_bad() {\n  X* p = new X;\n  { const UniquePtr<X>& u = UniquePtr<X>(p); }\n  int i = p->f;\n}\n\nvoid destruct_unique_ptr_deletes_pointer_bad() {\n  X* p = new X;\n  // note: this is not a smart way to use UniquePtr in general\n  UniquePtr<X>* u = new UniquePtr<X>(p);\n  delete u;\n  int i = p->f;\n}\n\n} // namespace destructor\n"
    },
    {
      "testname": "dynamic_dispatch.cpp",
      "testlanguage": "c++",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nnamespace dynamic_dispatch {\n\nstruct Base {\n  virtual int foo() { return 32; }\n};\n\nstruct Derived : Base {\n  int foo() { return 52; }\n};\n\nBase getDerived() { return Derived{}; }\n\nBase* getDerivedPtr() { return new Derived(); }\n\nvoid dispatch_to_Base_bad() {\n  Base base{};\n  if (base.foo() == 32) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n// FN because we do not track dynamic types unless it's a heap allocation\n// initiated by new()\nvoid FN_dispatch_to_Derived_bad() {\n  Base derived = getDerived();\n  if (derived.foo() == 52) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid dispatch_to_Derived_ptr_bad() {\n  Base* derived = getDerivedPtr();\n  if (derived->foo() == 52) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n} // namespace dynamic_dispatch\n"
    },
    {
      "testname": "exit_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\n// we get two disjuncts one for each branch\nvoid exit_positive(int a[10], int b) {\n  if (b < 1) {\n    exit(0);\n  }\n}\n\nvoid unreachable_double_free_ok(int a[10], int b) {\n  exit_positive(a, 0);\n  free(a);\n  free(a);\n}\n\nvoid store_exit(int* x, bool b) {\n  if (b) {\n    *x = 42;\n    exit(0);\n  }\n}\n\nvoid store_exit_null_bad() { store_exit(NULL, true); }\n"
    },
    {
      "testname": "fbstring.cpp",
      "testlanguage": "c++",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\n// Caricature of folly::basic_fbstring without the union between small\n// and medium/large data representations, and with an explicit field\n// for category_ instead of bitmasking part of the data value.\n// ref:\n// https://github.com/facebook/folly/blob/72850c2ebfb94d87bea74d89fcf79f3aaa91a627/folly/FBString.h\n\nenum category {\n  small = 0, // ignore small strings for now\n  medium = 1,\n  large = 2,\n};\n\nvoid* checkedMalloc(size_t size) {\n  void* ptr = malloc(size);\n  if (ptr == nullptr) {\n    exit(1);\n  }\n  return ptr;\n}\n\nstruct LikeFBString {\n  int category_;\n  char* buffer_;\n  size_t size_;\n  unsigned int* refcount_;\n\n  LikeFBString() { category_ = 0; }\n\n  LikeFBString(const LikeFBString& src) {\n    category_ = src.category();\n    switch (src.category_) {\n      case small:\n        break;\n      case medium:\n        copyMedium(src);\n        break;\n      case large:\n        copyLarge(src);\n        break;\n      default:\n        exit(2);\n    }\n  }\n\n  ~LikeFBString() {\n    if (category() == medium) {\n      free(buffer_);\n    } else if (category() == large) {\n      decr_ref_count();\n    }\n  }\n\n  void copySmall(const LikeFBString& src) {}\n\n  void copyMedium(const LikeFBString& src) {\n    buffer_ = (char*)checkedMalloc(src.size_);\n    size_ = src.size_;\n  }\n\n  void copyLarge(const LikeFBString& src) {\n    buffer_ = src.buffer_;\n    size_ = src.size_;\n    refcount_ = src.refcount_;\n    *refcount_ = *refcount_ + 1;\n  }\n\n  int category() const { return category_; }\n\n  void decr_ref_count() {\n    if (*refcount_ <= 0) {\n      exit(1);\n    }\n    *refcount_ = *refcount_ - 1;\n    if (*refcount_ == 0) {\n      free(buffer_);\n    }\n  }\n};\n\nvoid copy_fbstring(LikeFBString& s) {\n  // this might alias the underlying buffers if the string is large in\n  // that case the destruction of t does not de-allocate its buffer\n  // but pulse might think it does if it fails to remember which\n  // category t belongs to and follows impossibly control flow\n  LikeFBString t = s;\n}\n\nvoid pass_to_copy_ok() {\n  LikeFBString s;\n  copy_fbstring(s);\n}\n"
    },
    {
      "testname": "folly_DestructorGuard.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nnamespace folly {\n\nclass DelayedDestructionBase {};\n\nclass DelayedDestruction : public DelayedDestructionBase {\n public:\n  virtual void destroy() { delete this; } // model ignores delete\n};\n\n} // namespace folly\n\nclass UsingDelayedDestruction : folly::DelayedDestruction {\n\n  void double_delete_bad() {\n    delete this;\n    delete this;\n  }\n\n  void double_delete_ok() {\n    destroy(); // should not delete this double delete\n    delete this;\n  }\n};\n"
    },
    {
      "testname": "frontend.cpp",
      "testlanguage": "c++",
      "expected-problems": 65,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <string>\n\nnamespace frontend {\n\nnamespace some {\nnamespace thing {\nusing foo_int = int;\nint* bad_ptr() {\n  int* p = new (int);\n  delete p;\n  return p;\n}\n} // namespace thing\n} // namespace some\n\n// test that NamespaceAliasDecl is handled correctly\nvoid deref_null_namespace_alias_ptr_bad() {\n  namespace st = some::thing;\n  st::foo_int x = 0;\n  int* p = st::bad_ptr();\n  *p = x;\n}\n\nstruct X {\n  int f;\n  X() {}\n  X(int i) : f(i) {}\n  X(X& from) : f(from.f) {}\n  X(X&& from) : f(from.f) {}\n  ~X() {}\n  int get_f() const { return f; }\n};\n\nvoid construct_in_conditional_ok() {\n  if (X(44).f != 44) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nbool is_zero(const X& x) { return x.get_f() == 0; }\n\nvoid temp_passed_in_conditional_ok() {\n  X x{44};\n  if (is_zero(x)) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid conditional_construction_xvalue_ok() {\n  X x = true ? X(44) : X(33);\n  if (x.f != 44) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid conditional_construction_lvalue_ok() {\n  const X& x = true ? X(44) : X(33);\n  if (x.f != 44) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid conditional_construction_int_lvalue_ok() {\n  const int& x = true ? 44 : 33;\n  if (x != 44) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid conditional_construction_int_ptr_ok() {\n  int* p = nullptr;\n  int j = 44;\n  int* x = true ? &j : p;\n  int* y = true ? p : &j;\n  if (*x != 44 || y != nullptr) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid conditional_expression_bad(bool b) {\n  bool ok = false;\n  ok = ok && b;\n  if (!ok) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nclass Frontend {\n public:\n  int a;\n\n  Frontend(int n) { a = (n == 0) ? 0 : 1; }\n\n  Frontend(Frontend x, int n) {\n    x.a = (n == 0) ? 0 : 1;\n    a = x.a;\n  }\n\n  void set_field_via_local(int n) {\n    int* b = (int*)malloc(sizeof(int));\n    if (b) {\n      *b = 0;\n      *b = (n == 0) ? 0 : 1;\n      a = *b;\n      free(b);\n    } else {\n      a = (n == 0) ? 0 : 1;\n    }\n  }\n};\n\nvoid call_Frontend_constructor_ok() {\n  Frontend x = Frontend(10); // x.a is 1\n  if (x.a != 1) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid call_Frontend_constructor_bad() {\n  Frontend x = Frontend(10); // x.a is 1\n  if (x.a == 1) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid call_Frontend_constructor2_ok() {\n  Frontend x = Frontend(0); // x.a is 0\n  Frontend y = Frontend(x, 10); // y.a is 1\n  if (y.a != 1) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid call_Frontend_constructor2_bad() {\n  Frontend x = Frontend(0); // x.a is 0\n  Frontend y = Frontend(x, 10); // y.a is 1\n  if (y.a == 1) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid call_set_field_via_local_ok() {\n  Frontend x = Frontend(0); // x.a is 0\n  x.set_field_via_local(10); // x.a is 1\n  if (x.a != 1) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid call_set_field_via_local_bad() {\n  Frontend x = Frontend(0); // x.a is 0\n  x.set_field_via_local(10); // x.a is 1\n  if (x.a == 1) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid not_boolean_ok() {\n  bool t = true;\n  bool* b = (bool*)malloc(sizeof(bool));\n  if (b) {\n    *b = true;\n    *b = !t; // *b is false\n    if (*b) {\n      int* p = nullptr;\n      *p = 42;\n    }\n    free(b);\n  }\n}\n\nvoid not_boolean_bad() {\n  bool f = false;\n  bool* b = (bool*)malloc(sizeof(bool));\n  if (b) {\n    *b = false;\n    *b = !f; // *b is true\n    if (*b) {\n      int* p = nullptr;\n      *p = 42;\n    }\n    free(b);\n  }\n}\n\nstruct double_fields_struct {\n  int v;\n  int a;\n};\n\ndouble_fields_struct get_double_fields_struct() {\n  double_fields_struct b;\n  b.v = 42;\n  b.a = 42;\n  return b;\n}\n\nvoid init_double_fields_struct_ok() {\n  double_fields_struct y{get_double_fields_struct()};\n  if (y.v != 42) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nstruct single_field_struct {\n  int v;\n};\n\nsingle_field_struct get_single_field_struct() {\n  single_field_struct b;\n  b.v = 42;\n  return b;\n}\n\nvoid FP_init_single_field_struct_ok() {\n  single_field_struct y{get_single_field_struct()};\n  if (y.v != 42) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nstruct Base {\n  Base(int* p1, int* p2) { *p1 = 42; }\n};\n\nstruct ForwardConstructorParams : Base {\n  // check that the parameters are forwarded in the correct order by the\n  // frontend\n  using Base::Base;\n};\n\nvoid derived_constructor_forwards_param_ok() {\n  int x;\n  ForwardConstructorParams A{&x, NULL};\n}\n\n} // namespace frontend\n"
    },
    {
      "testname": "funptr.cpp",
      "testlanguage": "c++",
      "expected-problems": 114,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvoid do_nothing(int**) { return; }\n\nvoid assign_nullptr(int** ptr) { *ptr = nullptr; }\n\nvoid call_funptr(void (*funptr)(int**), int** ptr) { (*funptr)(ptr); }\n\nvoid call_call_funptr(void (*funptr)(int**), int** ptr) {\n  call_funptr(funptr, ptr);\n}\n\n// Basic case: specialized in pre-analysis\n\nvoid test_syntactic_specialization_bad(int* ptr) {\n  call_call_funptr(&assign_nullptr, &ptr);\n  *ptr = 42; // nullptr dereference here\n}\n\n// Specialize over returned funptr\n\nvoid (*return_funptr(void))(int**) { return &assign_nullptr; }\n\nvoid test_returned_funptr_specialization_bad(int* ptr) {\n  void (*funptr)(int**) = return_funptr();\n  call_call_funptr(funptr, &ptr);\n  *ptr = 42; // nullptr dereference here\n}\n\n// Playing around with conditions\n\nint funptr_if_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_nullptr;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nint funptr_if_good() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_nullptr;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nint funptr_else_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_nullptr;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n\nint funptr_else_good() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (x) {\n    funptr = &assign_nullptr;\n  } else {\n    funptr = &do_nothing;\n  }\n  (*funptr)(&ptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n\nvoid apply_funptr_with_intptrptr(void (*funptr)(int**), int** ptr) {\n  (*funptr)(ptr);\n}\n\nint funptr_apply_funptr_with_intptrptr_specialized_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_nullptr;\n  } else {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr(funptr,\n                              &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nint funptr_apply_funptr_with_intptrptr_specialized_good() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &do_nothing;\n  } else {\n    funptr = &assign_nullptr;\n  }\n  apply_funptr_with_intptrptr(funptr,\n                              &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nvoid apply_funptr_with_intptrptr_and_after(void (*funptr)(int**),\n                                           void (*after)(int**),\n                                           int** ptr) {\n  int x = 0;\n  if (x) {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr(funptr, ptr);\n  (*after)(ptr);\n}\n\nvoid dereference_dereference_ptr(int** ptr) { int x = **ptr; }\n\nint funptr_apply_funptr_with_intptrptr_and_after_specialized_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  void (*after)(int**);\n  if (!x) {\n    funptr = &assign_nullptr;\n    after = &dereference_dereference_ptr;\n  } else {\n    funptr = &do_nothing;\n    after = &do_nothing;\n  }\n  apply_funptr_with_intptrptr_and_after(\n      funptr,\n      after,\n      &ptr); // Calling funptr assigned in if branch. NPE when calling after\n  return *ptr;\n}\n\nint funptr_apply_funptr_with_intptrptr_and_after_respecialized_bad() {\n  int x = 0;\n  int* ptr = &x;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_nullptr;\n  } else {\n    funptr = &do_nothing;\n  }\n  apply_funptr_with_intptrptr_and_after(\n      funptr,\n      &dereference_dereference_ptr,\n      &ptr); // Calling funptr assigned in if branch\n  return *ptr;\n}\n\nvoid conditionnaly_apply_funptr_with_intptrptr(int x,\n                                               int** ptr,\n                                               void (*funptr)(int** ptr)) {\n  if (x) {\n    (*funptr)(ptr);\n  }\n  *ptr = nullptr;\n}\n\nint funptr_conditionnaly_apply_funptr_with_intptrptr_unspecialized_bad() {\n  int x = 0;\n  int* ptr = nullptr;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_nullptr;\n  } else {\n    funptr = &do_nothing;\n  }\n  conditionnaly_apply_funptr_with_intptrptr(\n      x, &ptr, funptr); // funptr is not called; function is not specialized\n  return *ptr;\n}\n\nint funptr_conditionnaly_apply_funptr_with_intptrptr_specialized_bad() {\n  int x = 1;\n  int* ptr = nullptr;\n  void (*funptr)(int**);\n  if (!x) {\n    funptr = &assign_nullptr;\n  } else {\n    funptr = &do_nothing;\n  }\n  conditionnaly_apply_funptr_with_intptrptr(\n      x, &ptr, funptr); // Calling funptr assigned in else branch\n  return *ptr;\n}\n\n// Playing around with objects\n\nclass FunPtrCallback {\n private:\n  void (*_callback)(int**);\n\n public:\n  FunPtrCallback(void (*callback)(int**)) : _callback(callback) {}\n\n  void set(void (*callback)(int**)) { this->_callback = callback; }\n\n  void apply(int** ptr) { (*this->_callback)(ptr); }\n};\n\nvoid apply_callback(FunPtrCallback& callback, int** ptr) {\n  callback.apply(ptr);\n}\n\nvoid test_assign_nullptr_callback_bad(int* ptr) {\n  FunPtrCallback callback(&assign_nullptr);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // nullptr dereference here\n}\n\nvoid test_do_nothing_callback_good(int* ptr) {\n  FunPtrCallback callback(&do_nothing);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // latent nullptr dereference here\n}\n\nvoid test_update_callback_bad(FunPtrCallback& callback, int* ptr) {\n  callback.set(&assign_nullptr);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // nullptr dereference here\n}\n\nvoid test_update_callback_good(FunPtrCallback& callback, int* ptr) {\n  callback.set(&do_nothing);\n  apply_callback(callback, &ptr);\n  *ptr = 42; // latent nullptr dereference here\n}\n"
    },
    {
      "testname": "globals.cpp",
      "testlanguage": "c++",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// test templated globals manipulations\n\ntemplate <typename T>\nbool templated_global;\n\nvoid set_templated_global_int(bool b) { templated_global<int> = b; }\n\nvoid set_templated_global_bool(bool b) { templated_global<bool> = b; }\n\n// check that we handle different instantiations of the same templated global\n// correctly\nvoid several_instantiations_bad() {\n  set_templated_global_int(true);\n  set_templated_global_bool(false);\n  if (templated_global<int> && !templated_global<bool>) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n// test global initializers\n\nconstexpr bool yes = true;\n\ntemplate <typename T>\nconstexpr bool templated_const_global = false;\n\ntemplate <>\nconstexpr bool templated_const_global<int> = true;\n\nstruct X;\n\nvoid read_templated_const_global_then_crash_bad() {\n  if (yes && templated_const_global<int> && !templated_const_global<X>) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "instantiate_pre_addresses.cpp",
      "testlanguage": "c++",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct rec {\n  int* x;\n};\n\nvoid mutate_deep_pointers(rec** ptr) {\n  (*ptr)->x = new int;\n  (*(*ptr)->x) = 24;\n  *ptr = new rec;\n}\n\nvoid no_leak_nullptr() {\n  rec* r1 = new rec{nullptr};\n  rec* r2 = r1;\n\n  mutate_deep_pointers(&r1);\n\n  if (*(r2->x) != 24) {\n    int* x = nullptr;\n    *x = 12;\n  }\n  *(r2->x) = 42;\n\n  delete r1;\n  delete r2->x;\n  delete r2;\n}\n\nvoid set_inner_pointer_bad() {\n  rec* r1 = new rec{nullptr};\n  rec* r2 = r1;\n\n  mutate_deep_pointers(&r1);\n\n  if (*(r2->x) == 24) {\n    int* x = nullptr;\n    *x = 12;\n  }\n\n  delete r1;\n  delete r2->x;\n  delete r2;\n}\n\nstruct list_item {\n  list_item* next;\n};\n\nstruct list {\n  list_item* first;\n  list_item* last;\n};\n\nvoid append(list& l) {\n  list_item* new_cell = new list_item;\n  new_cell->next = nullptr;\n\n  if (l.last == nullptr) {\n    l.first = new_cell;\n  } else {\n    l.last->next = new_cell;\n  }\n\n  l.last = new_cell;\n}\n\nvoid delete_list(list& l) {\n  list_item* cell = l.first;\n  list_item* next_cell;\n\n  while (cell != nullptr) {\n    next_cell = cell->next;\n    delete cell;\n    cell = next_cell;\n  }\n}\n\nvoid no_leak() {\n  list l = {nullptr, nullptr};\n\n  append(l);\n  append(l);\n\n  delete_list(l);\n}\n"
    },
    {
      "testname": "interprocedural.cpp",
      "testlanguage": "c++",
      "expected-problems": 35,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstruct X {\n  int f;\n};\n\nvoid skip(struct X& x) {}\nvoid skip_ptr(struct X* x) {}\n\nint wraps_read_inner(struct X& x) { return x.f; }\n\nint wraps_read(struct X& x) { return wraps_read_inner(x); }\n\nvoid wraps_write_inner(struct X& x, int i) { x.f = i; }\n\nvoid wraps_write(struct X& x, int i) { wraps_write_inner(x, i); }\n\nvoid wraps_delete_inner(struct X* x) { delete x; }\n\nvoid wraps_delete(struct X* x) { wraps_delete_inner(x); }\n\nvoid delete_then_skip_ok(struct X& x) {\n  delete (&x);\n  skip(x);\n}\n\nvoid delete_then_skip_ptr_ok(struct X* x) {\n  delete x;\n  skip_ptr(x);\n}\n\nvoid delete_then_read_bad(struct X& x) {\n  delete (&x);\n  wraps_read(x);\n}\n\nvoid delete_aliased_then_read_bad(struct X& x) {\n  struct X* y = &x;\n  struct X& z = x;\n  delete y;\n  wraps_read(z);\n}\n\nvoid delete_then_write_bad(struct X& x) {\n  wraps_delete(&x);\n  wraps_read(x);\n}\n\nvoid delete_inner_then_write_bad(struct X& x) {\n  wraps_delete_inner(&x);\n  wraps_read(x);\n}\n\n// latent because delete(&x) creates a path where &x==0 but it was dereferenced\n// before, but that does not make sense as &x cannot be null\n// Latent FP filtered out\nvoid latent_read_write_then_delete_ok(struct X& x) {\n  wraps_write(x, 10);\n  wraps_read(x);\n  wraps_delete(&x);\n}\n\nint two_cells(struct X* x, struct X* y) {\n  x->f = 32;\n  y->f = 52;\n  return x->f * y->f;\n}\n\nvoid aliasing_call(struct X* x) { two_cells(x, x); }\n\nstruct Y {\n  int* p;\n};\n\nvoid store(struct Y* y, int* p) { y->p = p; }\n\nvoid call_store(struct Y* y) {\n  int x = 42;\n  store(y, &x);\n}\n\nextern bool nondet_choice();\n\nstruct Y* may_return_invalid_ptr_ok() {\n  struct Y* y = new Y();\n  if (nondet_choice()) {\n    delete y;\n  }\n  return y;\n}\n\nvoid feed_invalid_into_access_bad() {\n  struct Y* y = may_return_invalid_ptr_ok();\n  call_store(y);\n  delete y;\n}\n\nvoid invalidate_and_set_to_null(struct X** x_ptr) {\n  delete (*x_ptr);\n  *x_ptr = nullptr;\n}\n\nvoid access_to_invalidated_alias_bad(struct X* x, struct X* y) {\n  y = x;\n  invalidate_and_set_to_null(&x);\n  wraps_read(*y);\n}\n\nvoid access_to_invalidated_alias2_bad(struct X* x, struct X* y) {\n  y = x;\n  invalidate_and_set_to_null(&y);\n  wraps_read(*x);\n}\n\nvoid set_first_non_null_ok(int* x, int* y) {\n  if (x) {\n    *x = 42;\n  } else {\n    *y = 42;\n  }\n}\n\nvoid set_x_then_crash_bad(int* x) {\n  set_first_non_null_ok(x, nullptr);\n  set_first_non_null_ok(nullptr, x);\n  int* p = nullptr;\n  *p = 42;\n}\n"
    },
    {
      "testname": "join.cpp",
      "testlanguage": "c++",
      "expected-problems": 17,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n#include <vector>\n\nvoid basic_loop_count_ok(int n) {\n  for (int i = 0; i < n; i++) {\n  }\n}\n\nstruct foo {\n  int* val;\n};\n\nstruct list {\n  struct list* next;\n  struct foo* foo;\n};\n\nint invalidate_node_alias_bad(struct list* head, int cond) {\n  int* result = 0;\n  struct list* x = head;\n  if (cond) {\n    result = x->next->foo->val;\n    delete result;\n  } else {\n    x = x->next;\n    struct list* y = x->next;\n    result = x->foo->val;\n    delete result;\n  }\n  return *result;\n}\n\nvoid list_delete_ok(struct list** l) {\n  auto head = *l;\n  *l = nullptr;\n  while (head) {\n    auto tmp = head;\n    head = head->next;\n    if (tmp->foo) {\n      free(tmp->foo);\n      tmp->foo = nullptr;\n    }\n  }\n}\n\nstruct BasicStruct {\n  void some_method() {}\n  BasicStruct();\n  ~BasicStruct();\n};\n\nint nested_loops_ok() {\n  while (true) {\n    BasicStruct x;\n    for (;;) {\n      x.some_method();\n    }\n  }\n}\n\nextern bool some_bool();\nextern BasicStruct mk_basic_struct();\n\nvoid cond_inside_loop_ok() {\n  while (true) {\n    BasicStruct x;\n    if (some_bool()) {\n      x = mk_basic_struct();\n    }\n\n    x.some_method();\n  }\n}\n\nvoid nested_loops3_ok(std::vector<BasicStruct>* c) {\n  for (auto& b : *c) {\n    (&b)->~BasicStruct();\n  }\n}\n\nvoid duff_switch_loop(char* to, char* from, unsigned int count) {\n  unsigned int rounds = (count + 127) / 128;\n  switch (count % 128) {\n    case 0:\n      do {\n        *to = *from++;\n        case 127:\n          *to = *from++;\n        case 126:\n          *to = *from++;\n        case 125:\n          *to = *from++;\n        case 124:\n          *to = *from++;\n        case 123:\n          *to = *from++;\n        case 122:\n          *to = *from++;\n        case 121:\n          *to = *from++;\n        case 120:\n          *to = *from++;\n        case 119:\n          *to = *from++;\n        case 118:\n          *to = *from++;\n        case 117:\n          *to = *from++;\n        case 116:\n          *to = *from++;\n        case 115:\n          *to = *from++;\n        case 114:\n          *to = *from++;\n        case 113:\n          *to = *from++;\n        case 112:\n          *to = *from++;\n        case 111:\n          *to = *from++;\n        case 110:\n          *to = *from++;\n        case 109:\n          *to = *from++;\n        case 108:\n          *to = *from++;\n        case 107:\n          *to = *from++;\n        case 106:\n          *to = *from++;\n        case 105:\n          *to = *from++;\n        case 104:\n          *to = *from++;\n        case 103:\n          *to = *from++;\n        case 102:\n          *to = *from++;\n        case 101:\n          *to = *from++;\n        case 100:\n          *to = *from++;\n        case 99:\n          *to = *from++;\n        case 98:\n          *to = *from++;\n        case 97:\n          *to = *from++;\n        case 96:\n          *to = *from++;\n        case 95:\n          *to = *from++;\n        case 94:\n          *to = *from++;\n        case 93:\n          *to = *from++;\n        case 92:\n          *to = *from++;\n        case 91:\n          *to = *from++;\n        case 90:\n          *to = *from++;\n        case 89:\n          *to = *from++;\n        case 88:\n          *to = *from++;\n        case 87:\n          *to = *from++;\n        case 86:\n          *to = *from++;\n        case 85:\n          *to = *from++;\n        case 84:\n          *to = *from++;\n        case 83:\n          *to = *from++;\n        case 82:\n          *to = *from++;\n        case 81:\n          *to = *from++;\n        case 80:\n          *to = *from++;\n        case 79:\n          *to = *from++;\n        case 78:\n          *to = *from++;\n        case 77:\n          *to = *from++;\n        case 76:\n          *to = *from++;\n        case 75:\n          *to = *from++;\n        case 74:\n          *to = *from++;\n        case 73:\n          *to = *from++;\n        case 72:\n          *to = *from++;\n        case 71:\n          *to = *from++;\n        case 70:\n          *to = *from++;\n        case 69:\n          *to = *from++;\n        case 68:\n          *to = *from++;\n        case 67:\n          *to = *from++;\n        case 66:\n          *to = *from++;\n        case 65:\n          *to = *from++;\n        case 64:\n          *to = *from++;\n        case 63:\n          *to = *from++;\n        case 62:\n          *to = *from++;\n        case 61:\n          *to = *from++;\n        case 60:\n          *to = *from++;\n        case 59:\n          *to = *from++;\n        case 58:\n          *to = *from++;\n        case 57:\n          *to = *from++;\n        case 56:\n          *to = *from++;\n        case 55:\n          *to = *from++;\n        case 54:\n          *to = *from++;\n        case 53:\n          *to = *from++;\n        case 52:\n          *to = *from++;\n        case 51:\n          *to = *from++;\n        case 50:\n          *to = *from++;\n        case 49:\n          *to = *from++;\n        case 48:\n          *to = *from++;\n        case 47:\n          *to = *from++;\n        case 46:\n          *to = *from++;\n        case 45:\n          *to = *from++;\n        case 44:\n          *to = *from++;\n        case 43:\n          *to = *from++;\n        case 42:\n          *to = *from++;\n        case 41:\n          *to = *from++;\n        case 40:\n          *to = *from++;\n        case 39:\n          *to = *from++;\n        case 38:\n          *to = *from++;\n        case 37:\n          *to = *from++;\n        case 36:\n          *to = *from++;\n        case 35:\n          *to = *from++;\n        case 34:\n          *to = *from++;\n        case 33:\n          *to = *from++;\n        case 32:\n          *to = *from++;\n        case 31:\n          *to = *from++;\n        case 30:\n          *to = *from++;\n        case 29:\n          *to = *from++;\n        case 28:\n          *to = *from++;\n        case 27:\n          *to = *from++;\n        case 26:\n          *to = *from++;\n        case 25:\n          *to = *from++;\n        case 24:\n          *to = *from++;\n        case 23:\n          *to = *from++;\n        case 22:\n          *to = *from++;\n        case 21:\n          *to = *from++;\n        case 20:\n          *to = *from++;\n        case 19:\n          *to = *from++;\n        case 18:\n          *to = *from++;\n        case 17:\n          *to = *from++;\n        case 16:\n          *to = *from++;\n        case 15:\n          *to = *from++;\n        case 14:\n          *to = *from++;\n        case 13:\n          *to = *from++;\n        case 12:\n          *to = *from++;\n        case 11:\n          *to = *from++;\n        case 10:\n          *to = *from++;\n        case 9:\n          *to = *from++;\n        case 8:\n          *to = *from++;\n        case 7:\n          *to = *from++;\n        case 6:\n          *to = *from++;\n        case 5:\n          *to = *from++;\n        case 4:\n          *to = *from++;\n        case 3:\n          *to = *from++;\n        case 2:\n          *to = *from++;\n        case 1:\n          *to = *from++;\n      } while (--rounds > 0);\n  }\n}\n"
    },
    {
      "testname": "leaks.cpp",
      "testlanguage": "c++",
      "expected-problems": 31,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <functional>\n#include <new>\n\nnamespace leaks {\n\ntemplate <typename X>\nstruct UniquePtr {\n  X* x_;\n  ~UniquePtr() { delete x_; }\n  UniquePtr(X* y) { x_ = y; }\n\n  UniquePtr(UniquePtr<X>& p) = delete; // no copy constructor\n  UniquePtr(UniquePtr<X>&& p) {\n    x_ = p.get();\n    p.x_ = nullptr;\n  }\n\n  X* get() const { return x_; }\n\n  X& operator*() const { return *get(); }\n\n  X* operator->() const { return get(); }\n};\n\nstruct X {\n  int i;\n  ~X() {}\n};\n\nvoid simple_new_bad() { X* x = new X; }\n\nvoid simple_new_delete_ok() {\n  X* x = new X;\n  delete x;\n}\n\nvoid new_placement_new_delete_ok() {\n  X* x = new X;\n  X* y = new (x) X();\n  delete y;\n}\n\nvoid simple_new_array_bad() { X* x = new X[5]; }\n\nvoid simple_new_array_delete_array_ok() {\n  X* x = new X[5];\n  delete[] x;\n}\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wmismatched-new-delete\"\nvoid new_array_delete_bad() {\n  X* x = new X[5];\n  delete x;\n}\n#pragma clang diagnostic pop\n\nvoid unique_ptr_managed_ok() {\n  struct UniquePtr<X> stack_allocated {\n    new X\n  };\n  const struct UniquePtr<X>& const_ref { new X };\n}\n\nvoid unique_ptr_pointer_bad() {\n  struct UniquePtr<X>* heap_allocated = new UniquePtr<X>(new X);\n}\n\nvoid static_local_alloc_ok() { static X* x = new X; }\n\nvoid call_static_local_alloc_ok() { static_local_alloc_ok(); }\n\nvoid call_static_local_alloc_twice_ok() {\n  static_local_alloc_ok();\n  static_local_alloc_ok();\n}\n\nstatic UniquePtr<X>* global_pointer;\n\nvoid global_alloc_ok() { global_pointer = new UniquePtr<X>(new X); }\n\nvoid unknown(void* x);\n\nvoid unknown_wrapper(UniquePtr<X>* x) { unknown(x); }\n\nvoid unknown_alloc_ok() {\n  UniquePtr<X>* x = new UniquePtr<X>(new X);\n  // could do anything, including deallocate x, so best not to report anything\n  unknown(x);\n}\n\nvoid unknown_wrapper_alloc_ok() {\n  UniquePtr<X>* x = new UniquePtr<X>(new X);\n  // same as above, inter-procedurally\n  unknown_wrapper(x);\n}\n\nvoid unknown_wrapper_alloc_then_leak_bad() {\n  UniquePtr<X>* x = new UniquePtr<X>(new X);\n  unknown_wrapper(x);\n  x->x_ = new X;\n}\n\nstruct Y {\n  int* a;\n};\n\nvoid deep_alloc_unknown_ok(Y* y) {\n  y->a = new int;\n  unknown(y);\n  y->a = new int;\n}\n\nvoid call_deep_alloc_unknown_ok() {\n  Y* y = new Y;\n  deep_alloc_unknown_ok(y);\n  delete y->a;\n  delete y;\n}\n\nvoid store_closure_unknown(const std::function<void()>& f);\n\nvoid capture_alloc_unknown_ok() {\n  X* x = new X;\n  store_closure_unknown([&] { delete x; });\n}\n\nstd::function<void(void)> capture_alloc_return_ok() {\n  X* x = new X;\n  return [=]() { delete x; };\n}\n\n} // namespace leaks\n"
    },
    {
      "testname": "max_disjuncts.cpp",
      "testlanguage": "c++",
      "expected-problems": 34,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <vector>\n\nnamespace max_disjuncts {\n\nint rand_int();\n\n// This returns the state with current maximum disjuncts (20).\nint get_full_disjs() {\n  switch (rand_int()) {\n    case 0:\n      return 0;\n    case 1:\n      return 1;\n    case 2:\n      return 2;\n    case 3:\n      return 3;\n    case 4:\n      return 4;\n    case 5:\n      return 5;\n    case 6:\n      return 6;\n    case 7:\n      return 7;\n    case 8:\n      return 8;\n    case 9:\n      return 9;\n    case 10:\n      return 10;\n    case 11:\n      return 11;\n    case 12:\n      return 12;\n    case 13:\n      return 13;\n    case 14:\n      return 14;\n    case 15:\n      return 15;\n    case 16:\n      return 16;\n    case 17:\n      return 17;\n    case 18:\n      return 18;\n    default:\n      return 19;\n  }\n}\n\nbool unknown_bool();\n\nvoid join_full_disjs1() {\n  int x = get_full_disjs();\n  if (unknown_bool()) {\n    return; // 20 ContinueProgram disjuncts\n  }\n  throw \"exc\"; // 20 ExitProgram disjuncts\n}\n\nvoid call_join_full_disjs1_bad() {\n  join_full_disjs1();\n  int* p = nullptr;\n  *p = 42;\n}\n\nvoid join_full_disjs2() {\n  int x = get_full_disjs();\n  if (unknown_bool()) {\n    throw \"exc\"; // 20 ExitProgram disjuncts\n  }\n  return; // 20 ContinueProgram disjuncts\n}\n\nvoid call_join_full_disjs2_bad() {\n  join_full_disjs2();\n  int* p = nullptr;\n  *p = 42;\n}\n\nvoid join_full_disjs3() {\n  int x = get_full_disjs();\n  bool b;\n  if (unknown_bool()) {\n    b = 1; // 20 ContinueProgram disjuncts with b = 1\n  } else {\n    b = 0; // 20 ContinueProgram disjuncts with b = 0\n  }\n  if (b) {\n    throw \"exc\";\n  }\n  return;\n}\n\nvoid call_join_full_disjs3_bad() {\n  join_full_disjs3();\n  int* p = nullptr;\n  *p = 42;\n}\n\nstruct Arr {\n  int arr[2];\n  std::vector<int> vec;\n};\n\nvoid copy_and_modify_ok(const std::vector<int>& v, const Arr& arg) {\n  int x = get_full_disjs(); // make max disjuncts\n  auto copied_arg = arg; // copy arg\n  for (const int& e : v) {\n    copied_arg.arr[0] = 42; // modify copied_arg\n    int y = arg.arr[0];\n  }\n}\n\nvoid full_disjs_call_after_branch_bad_FN() {\n  bool b = unknown_bool() ? 1 : 0;\n  // two disjuncts\n  // #0: {b=1}\n  // #1: {b=0}\n\n  get_full_disjs();\n  // 20 disjuncts only with #0, i.e. in all disjuncts b=1.\n\n  if (!b) {\n    // 0 disjunct here!\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nclass FullDisjsInLoop {\n  Arr arr;\n\n  void full_disjs_in_loop_ok1(int k) {\n    Arr x;\n    for (int i = 0; i < k; i++) {\n      arr = x;\n    }\n  }\n\n  void full_disjs_in_loop_ok2_FP(int k) {\n    Arr x;\n    get_full_disjs();\n    for (int i = 0; i < k; i++) {\n      // Pulse does not know `x` is copied multiple times here.\n      arr = x;\n    }\n  }\n\n  void get_arr(Arr arr) {}\n\n  void full_disjs_in_loop_ok3(int k) {\n    Arr x;\n    get_full_disjs();\n    for (int i = 0; i < k; i++) {\n      // Pulse suppresses the issue when `x` is copied to intermediate in a\n      // loop.\n      get_arr(x);\n    }\n  }\n};\n\n} // namespace max_disjuncts\n"
    },
    {
      "testname": "memory_leak.cpp",
      "testlanguage": "c++",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdlib.h>\n\nvoid malloc_free_ok(int count) {\n  int* e = (int*)malloc(count);\n  int* res[] = {e};\n  free(e);\n}\n\nvoid constant_index_ok(int count) {\n  int* e = (int*)malloc(count);\n  int* res[] = {e};\n  free(res[0]);\n}\n\nvoid symbolic_index_ok(int x, int** res) {\n  int* e = (int*)malloc(10);\n  res[x] = e;\n  free(res[x]);\n}\n"
    },
    {
      "testname": "nullptr.cpp",
      "testlanguage": "c++",
      "expected-problems": 88,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <atomic>\n#include <cstdlib>\n#include <memory>\n#include <string>\n#include <type_traits>\n\nclass A {\n public:\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wundefined-bool-conversion\"\n  int this_notnull_ok() {\n    if (!this) {\n      int* q = nullptr;\n      return *q;\n    }\n    return 0;\n  }\n  int this_notnull_bad() {\n    if (this) {\n      int* q = nullptr;\n      return *q;\n    }\n    return 0;\n  }\n#pragma clang diagnostic pop\n\n  static int expect_notnull_ok(A* a) { return a->return_zero(); }\n  static int call_null_arg_bad() { return expect_notnull_ok(nullptr); }\n  int return_zero() { return 0; }\n};\n\nvoid assign_zero_ok() {\n  int x[2];\n  x[1] = 42;\n}\n\nvoid deref_nullptr_bad() {\n  int* p = nullptr;\n  *p = 42;\n}\n\nint* maybe_dangerous();\nvoid deref_maybe_dangerous_ok() {\n  int* p = maybe_dangerous();\n  *p = 42;\n}\n\nint* dangerous();\nvoid deref_dangerous_bad() {\n  int* p = dangerous();\n  *p = 42;\n}\n\nvoid guarded_nullptr_ok() {\n  int* p = nullptr;\n  if (p != nullptr) {\n    *p = 42;\n  }\n}\n\nstruct X {\n  void foo();\n};\n\nbool choice();\n\nX* may_return_nullptr() {\n  if (choice()) {\n    return nullptr;\n  }\n  return new X();\n}\n\nvoid no_check_return_bad() {\n  X* x = may_return_nullptr();\n  x->foo();\n  delete x;\n}\n\nvoid check_return_ok() {\n  X* x = may_return_nullptr();\n  if (x != nullptr) {\n    x->foo();\n    delete x;\n  }\n}\n\nvoid compare_to_null(void* x) {\n  if (x) {\n  }\n}\n\nvoid deref_after_compare_ok(int* x) {\n  compare_to_null(x);\n  *x = 42;\n}\n\nbool return_true() { return std::true_type{}; }\n\nvoid std_true_type_impossible_deref_ok() {\n  int* x = nullptr;\n  if (!return_true()) {\n    *x = 42;\n  }\n}\n\nvoid std_true_type_deref_bad() {\n  int* x = nullptr;\n  if (return_true()) {\n    *x = 42;\n  }\n}\n\nbool return_false() { return std::false_type{}; }\n\nvoid std_false_type_impossible_deref_ok() {\n  int* x = nullptr;\n  if (return_false()) {\n    *x = 42;\n  }\n}\n\nvoid std_false_type_deref_bad() {\n  int* x = nullptr;\n  if (!return_false()) {\n    *x = 42;\n  }\n}\n\nstd::atomic<bool> global_var{true};\n\nnamespace ns1 {\nnamespace ns2 {\nvoid fun_abort(bool b) {\n  bool abort = true;\n  if (b) {\n    abort = global_var.load();\n  } else {\n    abort = true;\n  }\n  if (abort) {\n    std::abort();\n  }\n}\n} // namespace ns2\n} // namespace ns1\n\nX global_x;\n\nX* getX(bool b) {\n  if (b) {\n    return &global_x;\n  } else {\n    ns1::ns2::fun_abort(true);\n  }\n\n  return nullptr;\n}\n\nvoid call_modeled_abort_ok() { getX(false)->foo(); }\n\nstruct S {\n  int field;\n};\n\nvoid set_S();\n\nstruct T {\n  static S*& get() {\n    auto& s = T::getRaw();\n    if (T::getRaw() == nullptr) {\n      set_S();\n    }\n    return s;\n  }\n\n  static S*& getRaw() {\n    thread_local S* s = nullptr;\n    return s;\n  }\n};\n\nvoid set_S() {\n  auto& s = T::getRaw();\n  if (s != nullptr) {\n    return;\n  }\n\n  s = (S*)calloc(1, sizeof(S));\n  if (!s) {\n    exit(1);\n  }\n}\n\nint thread_local_was_set_ok() { return T::get()->field; }\n\nstruct Item {\n  X* get() const;\n};\n\nstruct Handle {\n  X* get() const noexcept {\n    return item_.get() == nullptr ? nullptr : toX(item_);\n  }\n\n  X* operator->() const noexcept {\n    // dynamic check get() != null\n    return get();\n  }\n\n private:\n  Item item_{};\n  static X* toX(Item item);\n};\n\n// We do not want to report nullptr dereference in this case\n// as we \"know\" that Item::get does not return null, however\n// at the moment we are not able to show it in pulse.\n// That's why as a workaround we model the analysis of Handle::get\n// to return non-null\nvoid explicit_check_for_null_ok(Handle h) { return h->foo(); }\n\nX* checks_for_null() { return getX(true) == nullptr ? nullptr : new X(); }\n\nvoid cannot_be_null_ok() { return checks_for_null()->foo(); }\n\nvoid free_nullptr_ok() {\n  int* p = nullptr;\n  free(p);\n}\n\nvoid delete_nullptr_ok() {\n  int* p = nullptr;\n  delete p;\n}\n\nvoid test_after_dereference_bad(int* x) {\n  // create a path split where x==0 in one of the paths\n  // since this happens in the same function that x is dereferenced we\n  // should report\n  if (x == 0)\n    ;\n  *x = 42;\n}\n\n// Filtered out\nvoid test_after_dereference2_latent(int* x) {\n  *x = 42;\n  if (x == 0)\n    ;\n}\n\nvoid call_test_after_dereference2_bad() {\n  test_after_dereference2_latent(NULL);\n}\n\nenum Type { STRING };\n\nstatic constexpr Type typeGlobal = STRING;\n\nstruct D {\n  Type type;\n  std::string string;\n\n  D(std::string s) : type(STRING) { new (&string) std::string(std::move(s)); }\n\n  std::string const* get() const& {\n    if (type != typeGlobal) {\n      return nullptr;\n    }\n    return &string;\n  }\n\n  std::string to(const std::string& value) const { return value.c_str(); };\n\n  std::string asString() const {\n    if (type == STRING) {\n      const std::string& value = *get();\n      return to(value);\n    }\n    return \"\";\n  }\n};\n\nstd::string global_const_skipped_function_ok() {\n  D* s = new D(\"\");\n  std::shared_ptr<D> ptr(s);\n  return ptr->asString();\n}\n\nstruct SomeClass {\n  X* pointer_;\n  int field_init_to_zero_{0};\n  explicit SomeClass(X* ptr) : pointer_(ptr) {\n    if (pointer_) {\n    }\n  }\n};\n\nclass SomeDerivedClass : public SomeClass {\n public:\n  explicit SomeDerivedClass(X* ptr) : SomeClass(ptr) { ptr->foo(); }\n};\n\nX* unknown_function_X();\n\n// this creates a null derefer false positives with a non-sensical \"forked\"\n// trace (one sub-trace for where 0 came from, which in this case ends in the\n// unrelated \"field_init_to_zero\" assignment, and one sub-trace for the\n// dereference in ptr->foo() in the constructor), which should be ignored\nvoid createSomeDerivedClass_from_unknown_function_ok() {\n  SomeDerivedClass something(unknown_function_X());\n}\n\nvoid test_call_nullptr_bad() {\n  void (*f)() = nullptr;\n  f();\n}\n\nvoid incr_deref(int* x, int* y) {\n  (*x)++;\n  (*y)++;\n}\n\nvoid call_incr_deref_with_alias_bad(void) {\n  int x = 0;\n  int* ptr = &x;\n  incr_deref(ptr, ptr);\n  if (x == 2) {\n    ptr = nullptr;\n  }\n  x = *ptr;\n}\n\nvoid call_incr_deref_with_alias_good(void) {\n  int x = 0;\n  int* ptr = &x;\n  incr_deref(ptr, ptr);\n  if (x != 2) {\n    ptr = nullptr;\n  }\n  x = *ptr;\n}\n\n// FN in pulse-11 tests because incr_deref contructions forgets about its\n// captured vars\nvoid test_capture_alias_bad(void) {\n  int x = 0;\n  int* ptr = &x;\n  auto incr_deref = [ptr](int* ptr2) {\n    (*ptr)++;\n    (*ptr2)++;\n  };\n  incr_deref(ptr);\n  if (x == 2) {\n    ptr = nullptr;\n  }\n  x = *ptr;\n}\n\n// FP in pulse-11 tests because incr_deref contructions forgets about its\n// captured vars\nvoid test_capture_alias_good(void) {\n  int x = 0;\n  int* ptr = &x;\n  auto incr_deref = [ptr](int* ptr2) {\n    (*ptr)++;\n    (*ptr2)++;\n  };\n  incr_deref(ptr);\n  if (x != 2) {\n    ptr = nullptr;\n  }\n  x = *ptr;\n}\n"
    },
    {
      "testname": "optional.cpp",
      "testlanguage": "c++",
      "expected-problems": 102,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <vector>\n#include <string>\n#include <memory>\n\n// remove once we upgrade clang:\n// https://github.com/llvm/llvm-project/issues/37522\n#pragma clang diagnostic ignored \"-Wundefined-inline\"\n\nnamespace folly {\n\ntemplate <class Value>\nclass Optional;\n\nstruct None {\n  enum class _secret { _token };\n  explicit constexpr None(_secret) {}\n};\nconstexpr None none{None::_secret::_token};\n\ntemplate <class Value>\nclass Optional {\n public:\n  typedef Value value_type;\n\n  constexpr Optional();\n\n  Optional(const Optional& src);\n\n  constexpr Optional(const None&) noexcept;\n\n  constexpr Optional(const Value& newValue);\n\n  constexpr Optional(Value&& newValue);\n\n  void assign(const None&);\n\n  void assign(const Optional& src);\n\n  Optional& operator=(None) noexcept {\n    reset();\n    return *this;\n  }\n\n  Optional& operator=(const Optional& other) {\n    assign(other);\n    return *this;\n  }\n\n  template <class... Args>\n  Value& emplace(Args&&... args);\n\n  void reset() noexcept;\n\n  constexpr const Value& value() const&;\n\n  constexpr bool has_value() const noexcept;\n\n  constexpr explicit operator bool() const noexcept { return has_value(); }\n\n  constexpr const Value* operator->() const { return &value(); }\n\n  Value* get_pointer();\n\n  template <class U>\n  constexpr Value value_or(U&& dflt) const&;\n};\n} // namespace folly\n\nstruct Integer {\n  int field;\n\n  Integer(int x = 0) : field(x) {}\n  int get() const { return field; }\n};\n\nvoid call_constructors() {\n  // Since in this file we define only the interface of Optional, we need\n  // to call some methods to ensure that they are actually compiled (and thus\n  // analyzed).\n  Integer x(5);\n  Integer y(x);\n  Integer z(std::move(x));\n}\n\nint not_none_ok() {\n  folly::Optional<int> foo{5};\n  return foo.value();\n}\n\n// missing a more precise model for\n// constructing an optional from a value\nint not_none_check_value0_ok() {\n  folly::Optional<int> foo{5};\n  int x = foo.value();\n  if (x != 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return x;\n}\n\nint not_none_check_value1_ok() {\n  int p = 5;\n  folly::Optional<int> foo{p};\n  p++;\n  int x = foo.value();\n  if (x != 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return x;\n}\n\nint not_none_check_value2_ok() {\n  auto p = Integer{5};\n  folly::Optional<Integer> foo{p};\n  p.field += 1;\n  if (foo.value().get() != 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint not_none_check_value0_bad() {\n  folly::Optional<int> foo{5};\n  if (foo.value() == 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint not_none_check_value1_bad() {\n  auto p = Integer{5};\n  folly::Optional<Integer> foo{p};\n  if (foo.value().get() == 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint not_none_check_value2_bad() {\n  auto p = Integer{5};\n  folly::Optional<Integer> foo{p};\n  p.field += 1;\n  if (foo.value().get() == 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint none_check_ok() {\n  folly::Optional<int> foo{folly::none};\n  if (foo) {\n    return foo.value();\n  }\n  return -1;\n}\n\nint none_no_check_bad() {\n  folly::Optional<int> foo{folly::none};\n  return foo.value();\n}\n\nint not_none_copy0_ok() {\n  folly::Optional<int> foo{5};\n  folly::Optional<int> bar{foo};\n  if (foo.value() != 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint not_none_copy0_bad() {\n  folly::Optional<int> foo{5};\n  folly::Optional<int> bar{foo};\n  if (foo.value() == 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint not_none_copy_ok() {\n  folly::Optional<int> foo{5};\n  folly::Optional<int> bar{foo};\n  return bar.value();\n}\n\nint none_copy_bad() {\n  folly::Optional<int> foo{folly::none};\n  folly::Optional<int> bar{foo};\n  return bar.value();\n}\n\nint assign_ok() {\n  folly::Optional<int> foo{5};\n  folly::Optional<int> bar{foo};\n  foo = folly::none;\n  return bar.value();\n}\n\nint assign_bad() {\n  folly::Optional<int> foo{folly::none};\n  folly::Optional<int> bar{5};\n  int sum = bar.value();\n  bar = foo;\n  sum += bar.value();\n  return sum;\n}\n\nint assign2_bad() {\n  folly::Optional<int> foo{5};\n  int sum = foo.value();\n  foo = folly::none;\n  sum += foo.value();\n  return sum;\n}\n\nint has_value_ok() {\n  folly::Optional<int> foo{0};\n  if (!foo.has_value() || foo.value() != 0) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nint has_value_bad() {\n  folly::Optional<int> foo{0};\n  if (foo.has_value() && foo.value() == 0) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return 0;\n}\n\nstruct State {\n  std::vector<int> vec;\n};\n\nvoid emplace(folly::Optional<State> state) {\n  if (state) {\n    state.emplace();\n  }\n  auto pos = state->vec.begin();\n}\n\nvoid operator_arrow_bad() { emplace(folly::none); }\n\nvoid get_pointer_check_none_check_ok() {\n  folly::Optional<int> foo{folly::none};\n  if (int* v = foo.get_pointer()) {\n    *v = 42;\n  }\n}\n\nvoid get_pointer_check_value_check_ok() {\n  folly::Optional<int> foo{5};\n  if (int* ptr = foo.get_pointer()) {\n    *ptr = 42;\n  }\n}\n\nvoid get_pointer_no_check_none_check_bad() {\n  folly::Optional<int> foo{folly::none};\n  int* ptr = foo.get_pointer();\n  *ptr = 42;\n}\n\nvoid get_pointer_no_check_value_check_ok() {\n  folly::Optional<int> foo{5};\n  int* ptr = foo.get_pointer();\n  *ptr = 42;\n}\n\nint value_or_check_empty_ok() {\n  folly::Optional<int> foo{folly::none};\n  if (foo.value_or(0) > 0) {\n    return foo.value();\n  }\n  return -1;\n}\n\nint value_or_check_value_ok() {\n  folly::Optional<int> foo{5};\n  int x = foo.value_or(0);\n  if (x != 5) {\n    folly::Optional<int> foo{folly::none};\n    return foo.value();\n  }\n  return -1;\n}\n\nint test_trace_ref() {\n  folly::Optional<int> foo{5};\n  int sum = foo.value();\n  foo = folly::none;\n  const int& x = foo.value();\n  sum += x;\n  return sum;\n}\n\nstruct StringWrapper {\n  static folly::Optional<StringWrapper> get_optional() {\n    return StringWrapper();\n  };\n  std::string x;\n};\n\nstd::string get_optional_string_wrapper_ok() {\n  return StringWrapper::get_optional().value().x.data();\n}\n\nstruct Container final {\n  std::vector<int> _vec;\n\n  Container() : _vec(std::vector<int>{}) {}\n\n  folly::Optional<int> getFirst() const {\n    if (_vec.empty()) {\n      return folly::none;\n    }\n    return _vec.front();\n  }\n\n  int optional_check_ok(const Container& c) {\n    if (!c._vec.empty()) {\n      return c.getFirst().value();\n    }\n    return -1;\n  }\n};\n\nstruct Node {\n  std::shared_ptr<int> shared;\n\n  folly::Optional<std::shared_ptr<int>> getShared() const {\n    if (shared == nullptr) {\n      return folly::none;\n    }\n    return shared;\n  }\n};\n\nint smart_pointer(const Node& node) {\n  if (node.getShared().has_value()) {\n    return *(node.getShared().value());\n  }\n  return -1;\n}\n"
    },
    {
      "testname": "pair.cpp",
      "testlanguage": "c++",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <utility>\n#include <tuple> // for std::get\n\nnamespace pair {\n\nstd::pair<int, int*> pairOfZeroNull() {\n  return std::pair<int, int*>(0, nullptr);\n}\n\nstd::pair<int, int*> pairOfZeroNull2() { return std::make_pair(0, nullptr); }\n\nstd::pair<int, int> pairOfZeroNull3() { return std::make_pair(58, 42); }\n\nint deref_makepair_constants0_bad() {\n  auto p = pairOfZeroNull3();\n  if (p.first == 58) {\n    // Should report an NPE here as p.first is equal to 58\n    int* q = nullptr;\n    return *q;\n  }\n  return p.first;\n}\n\nint deref_makepair_constants1_bad() {\n  auto p = pairOfZeroNull3();\n  if (p.second == 42) {\n    // Should report an NPE here as p.second is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return p.first;\n}\n\nint deref_makepair_constants0_ok() {\n  auto p = pairOfZeroNull3();\n  if (p.first != 58) {\n    // Should not report an NPE here as p.first is equal to 58\n    int* q = nullptr;\n    return *q;\n  }\n  return p.first;\n}\n\nint deref_makepair_constants1_ok() {\n  auto p = pairOfZeroNull3();\n  if (p.second != 42) {\n    // Should not report an NPE here as p.second is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return p.first;\n}\n\nint FN_deref_pair_null0_bad() {\n  auto p = pairOfZeroNull();\n  // Should report an NPE here as p.second is NULL\n  return p.first + *p.second;\n}\n\nint FN_deref_pair_null1_bad() {\n  auto p = pairOfZeroNull();\n  // Should report an NPE here as p.second is NULL\n  return std::get<0>(p) + *std::get<1>(p);\n}\n\nint FN_deref_makepair_null0_bad() {\n  auto p = pairOfZeroNull2();\n  // Should report an NPE here as p.second is NULL\n  return p.first + *p.second;\n}\n\nint FN_deref_makepairnull1_bad() {\n  auto p = pairOfZeroNull2();\n  // Should report an NPE here as p.second is NULL\n  return std::get<0>(p) + *std::get<1>(p);\n}\n\nint deref_pair_null_guard0_ok() {\n  auto p = pairOfZeroNull();\n  if (p.second != nullptr) {\n    // Should not report an NPE here as p.second is guarded\n    return p.first + *p.second;\n  }\n  return 0;\n}\n\nint deref_makepair_null_guard1_ok() {\n  auto p = pairOfZeroNull2();\n  if (p.second != nullptr) {\n    // Should not report an NPE here as p.second is guarded\n    return p.first + *p.second;\n  }\n  return 0;\n}\n\n} // namespace pair\n"
    },
    {
      "testname": "path.cpp",
      "testlanguage": "c++",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nint* may_return_null(int x) {\n  if (x == 42) {\n    return nullptr;\n  }\n  return new int();\n}\n\nvoid FP_only_bad_on_42_latent(int x) {\n  int* p = may_return_null(x);\n  *p = 12;\n  delete p;\n}\n\nvoid FN_faulty_call_bad() { FP_only_bad_on_42_latent(42); }\n\nvoid call_not_with_42_ok() { FP_only_bad_on_42_latent(41); }\n"
    },
    {
      "testname": "readonly_shared_ptr_param.cpp",
      "testlanguage": "c++",
      "expected-problems": 17,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <functional>\n#include <memory>\n\nint read_shared_ptr_param_bad(std::shared_ptr<int> x) { return *x; }\n\nint read_shared_ptr_param_cond_bad(std::shared_ptr<int> x) {\n  if (x) {\n    return *x;\n  } else {\n    return 42;\n  }\n}\n\n// x should be captured with move.\nstd::function<void(void)> captured_shared_ptr_param_bad_FN(\n    std::shared_ptr<int> x) {\n  return [x]() {};\n}\n\nclass SharedPtrField1_Bad {\n  std::shared_ptr<int> field;\n\n public:\n  // x should be moved.\n  SharedPtrField1_Bad(std::shared_ptr<int> x) { field = x; }\n};\n\nint* global_ptr;\n\n// It reports PULSE_READONLY_SHARED_PTR_PARAM. While copying raw pointer to\n// global is dangerous in general, changing the function to get a raw\n// pointer does not make it more dangerous.\nvoid copy_raw_ptr_to_global_bad(std::shared_ptr<int> x) {\n  global_ptr = x.get();\n}\n\nstd::shared_ptr<int> global_shared_ptr;\n\n// x should be moved.\nvoid copy_shared_ptr_to_global_bad(std::shared_ptr<int> x) {\n  global_shared_ptr = x;\n}\n"
    },
    {
      "testname": "reference_stability.cpp",
      "testlanguage": "c++",
      "expected-problems": 230,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <algorithm>\n#include <initializer_list>\n#include <unordered_map>\n#include <utility>\n#include <type_traits>\n\n// Keep a simplified skeleton of F14 maps for testing.\nnamespace folly {\nstruct F14HashToken {};\n\nnamespace f14::detail {\ntemplate <typename ValuePtr>\nstruct ValueContainerIterator {\n  using pointee = typename std::pointer_traits<ValuePtr>::element_type;\n  using pointer = ValuePtr;\n  using reference = pointee&;\n\n  reference operator*() const;\n  pointer operator->() const;\n  ValueContainerIterator& operator++();\n  friend bool operator==(ValueContainerIterator const& lhs,\n                         ValueContainerIterator const& rhs);\n  friend bool operator!=(ValueContainerIterator const& lhs,\n                         ValueContainerIterator const& rhs);\n};\n\ntemplate <typename ValuePtr>\nstruct VectorContainerIterator {\n  using pointee = typename std::pointer_traits<ValuePtr>::element_type;\n  using pointer = ValuePtr;\n  using reference = pointee&;\n\n  reference operator*() const;\n  pointer operator->() const;\n  VectorContainerIterator& operator++();\n  friend bool operator==(VectorContainerIterator const& lhs,\n                         VectorContainerIterator const& rhs);\n  friend bool operator!=(VectorContainerIterator const& lhs,\n                         VectorContainerIterator const& rhs);\n};\n\ntemplate <typename Key, typename Mapped, typename Iter, typename ConstIter>\nstruct F14BasicMap {\n  using key_type = Key;\n  using mapped_type = Mapped;\n  using value_type = std::pair<const Key, Mapped>;\n  using size_type = std::size_t;\n  using iterator = Iter;\n  using const_iterator = ConstIter;\n\n  F14BasicMap() noexcept;\n\n  explicit F14BasicMap(std::size_t initialCapacity);\n\n  template <typename InputIt>\n  F14BasicMap(InputIt first, InputIt last, std::size_t initialCapacity = 0);\n\n  F14BasicMap(F14BasicMap const& rhs);\n\n  F14BasicMap(F14BasicMap&& rhs);\n\n  F14BasicMap(std::initializer_list<value_type> init,\n              std::size_t initialCapacity = 0);\n\n  F14BasicMap& operator=(F14BasicMap const&);\n\n  F14BasicMap& operator=(F14BasicMap&&);\n\n  F14BasicMap& operator=(std::initializer_list<value_type> ilist);\n\n  iterator begin() noexcept;\n  const_iterator begin() const noexcept;\n  const_iterator cbegin() const noexcept;\n  iterator end() noexcept;\n  const_iterator end() const noexcept;\n  const_iterator cend() const noexcept;\n\n  void clear() noexcept;\n\n  std::pair<iterator, bool> insert(value_type const& value);\n  std::pair<iterator, bool> insert(value_type&& value);\n  iterator insert(const_iterator /*hint*/, value_type const& value);\n  iterator insert(const_iterator /*hint*/, value_type&& value);\n\n  template <class... Args>\n  iterator emplace_hint(const_iterator /*hint*/, Args&&... args);\n\n  template <class InputIt>\n  void insert(InputIt first, InputIt last);\n  void insert(std::initializer_list<value_type> ilist);\n\n  template <typename M>\n  std::pair<iterator, bool> insert_or_assign(key_type const& key, M&& obj);\n\n  template <typename M>\n  std::pair<iterator, bool> insert_or_assign(key_type&& key, M&& obj);\n\n  template <typename M>\n  std::pair<iterator, bool> insert_or_assign(F14HashToken const& token,\n                                             key_type const& key,\n                                             M&& obj);\n\n  template <typename M>\n  std::pair<iterator, bool> insert_or_assign(F14HashToken const& token,\n                                             key_type&& key,\n                                             M&& obj);\n\n  template <typename M>\n  iterator insert_or_assign(const_iterator /*hint*/,\n                            key_type const& key,\n                            M&& obj);\n\n  template <typename M>\n  iterator insert_or_assign(const_iterator /*hint*/, key_type&& key, M&& obj);\n\n  template <typename... Args>\n  std::pair<iterator, bool> emplace(Args&&... args);\n\n  template <typename... Args>\n  std::pair<iterator, bool> try_emplace(key_type const& key, Args&&... args);\n\n  template <typename... Args>\n  std::pair<iterator, bool> try_emplace(key_type&& key, Args&&... args);\n\n  template <typename... Args>\n  std::pair<iterator, bool> try_emplace_token(F14HashToken const& token,\n                                              key_type const& key,\n                                              Args&&... args);\n\n  template <typename... Args>\n  std::pair<iterator, bool> try_emplace_token(F14HashToken const& token,\n                                              key_type&& key,\n                                              Args&&... args);\n\n  template <typename... Args>\n  iterator try_emplace(const_iterator /*hint*/,\n                       key_type const& key,\n                       Args&&... args);\n\n  template <typename... Args>\n  iterator try_emplace(const_iterator /*hint*/, key_type&& key, Args&&... args);\n\n  iterator erase(const_iterator pos);\n\n  iterator erase(iterator pos);\n\n  iterator erase(const_iterator first, const_iterator last);\n\n  size_type erase(key_type const& key);\n\n  template <typename BeforeDestroy>\n  iterator eraseInto(const_iterator pos, BeforeDestroy&& beforeDestroy);\n\n  template <typename BeforeDestroy>\n  iterator eraseInto(iterator pos, BeforeDestroy&& beforeDestroy);\n\n  template <typename BeforeDestroy>\n  iterator eraseInto(const_iterator first,\n                     const_iterator last,\n                     BeforeDestroy&& beforeDestroy);\n\n  template <typename BeforeDestroy>\n  size_type eraseInto(key_type const& key, BeforeDestroy&& beforeDestroy);\n\n  mapped_type& at(key_type const& key);\n\n  mapped_type const& at(key_type const& key) const;\n\n  mapped_type& operator[](key_type const& key);\n\n  mapped_type& operator[](key_type&& key);\n\n  size_type count(key_type const& key) const;\n\n  F14HashToken prehash(key_type const& key) const;\n\n  iterator find(key_type const& key);\n  const_iterator find(key_type const& key) const;\n  iterator find(F14HashToken const& token, key_type const& key);\n  const_iterator find(F14HashToken const& token, key_type const& key) const;\n\n  bool contains(key_type const& key) const;\n  bool contains(F14HashToken const& token, key_type const& key) const;\n\n  std::pair<iterator, iterator> equal_range(key_type const& key);\n\n  std::pair<const_iterator, const_iterator> equal_range(\n      key_type const& key) const;\n\n  void rehash(std::size_t bucketCapacity);\n\n  void reserve(std::size_t capacity);\n\n  std::size_t size() const;\n};\n\ntemplate <typename Key, typename Mapped>\nclass F14VectorMapImpl\n    : public F14BasicMap<\n          Key,\n          Mapped,\n          VectorContainerIterator<std::pair<Key const, Mapped>*>,\n          VectorContainerIterator<std::pair<Key const, Mapped> const*>> {\n  using F14BasicMap<Key,\n                    Mapped,\n                    VectorContainerIterator<std::pair<Key const, Mapped>*>,\n                    VectorContainerIterator<\n                        std::pair<Key const, Mapped> const*>>::F14BasicMap;\n};\n} // namespace f14::detail\n\ntemplate <typename Key, typename Mapped>\nstruct F14ValueMap\n    : public f14::detail::F14BasicMap<\n          Key,\n          Mapped,\n          f14::detail::ValueContainerIterator<std::pair<Key const, Mapped>*>,\n          f14::detail::ValueContainerIterator<\n              std::pair<Key const, Mapped> const*>> {\n  using f14::detail::F14BasicMap<\n      Key,\n      Mapped,\n      f14::detail::ValueContainerIterator<std::pair<Key const, Mapped>*>,\n      f14::detail::ValueContainerIterator<\n          std::pair<Key const, Mapped> const*>>::F14BasicMap;\n\n  void swap(F14ValueMap& rhs);\n};\n\ntemplate <typename Key, typename Mapped>\nstruct F14VectorMap : public f14::detail::F14VectorMapImpl<Key, Mapped> {\n  using f14::detail::F14VectorMapImpl<Key, Mapped>::F14VectorMapImpl;\n\n  void swap(F14VectorMap& rhs);\n};\n\ntemplate <typename Key, typename Mapped>\nstruct F14FastMap : public std::conditional<\n                        sizeof(std::pair<Key const, Mapped>) < 24,\n                        F14ValueMap<Key, Mapped>,\n                        f14::detail::F14VectorMapImpl<Key, Mapped>>::type {\n  using Super = typename std::conditional<\n      sizeof(std::pair<Key const, Mapped>) < 24,\n      F14ValueMap<Key, Mapped>,\n      f14::detail::F14VectorMapImpl<Key, Mapped>>::type;\n  using Super::Super;\n\n  void swap(F14FastMap& rhs);\n};\n} // namespace folly\n\n// sizeof(std::pair<const BigPoint, T>) >= 24.\nstruct BigPoint {\n  std::uint64_t x, y, z;\n  friend BigPoint operator+(const BigPoint& a, const BigPoint& b) {\n    return {a.x + b.x, a.y + b.y, a.z + b.z};\n  }\n  friend bool operator==(const BigPoint& a, const BigPoint& b);\n};\n\ntemplate <>\nstruct std::hash<BigPoint> {\n  std::size_t operator()(const BigPoint& point) const;\n};\n\nvoid unordered_map_ok() {\n  std::unordered_map<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n\n  // Obtain long-lived references to keys and values.\n  const auto& keyRef = map.begin()->first;\n  const auto& valueRef = map.begin()->second;\n\n  // Possible rehash, but std::unordered_map guarantees reference stability.\n  map[4] = 16;\n  const auto keyCopy = keyRef;\n}\n\nvoid folly_fastmap_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n\n  // Obtain long-lived references to keys and values.\n  const auto& keyRef = map.begin()->first;\n  const auto& valueRef = map.begin()->second;\n\n  // Possible rehash, references invalidated.\n  map.emplace(4, 16);\n  const auto keyCopy = keyRef;\n}\n\nvoid folly_fastmap_short_lived_ok() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n\n  {\n    // Use short-lived references in a limited scope.\n    const auto& keyRef = map.begin()->first;\n    const auto& valueRef = map.begin()->second;\n\n    const auto keyCopy = keyRef;\n    const auto valueCopy = valueRef;\n\n    // No need to access keyRef and valueRef outside this block.\n    // Short-lived references are still valid here.\n  }\n\n  // Modify the map (no potential issues with short-lived references).\n  map[4] = 16;\n\n  // Access elements using iterators (no long-lived references).\n  for (const auto& pair : map) {\n    const auto keyCopy = pair.first;\n    const auto valueCopy = pair.second;\n  }\n}\n\nvoid long_lived_but_unused_ref_ok() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n\n  const auto& value = map.at(1);\n\n  map.reserve(100);\n\n  // value should be marked as invalidated here, but no error reported.\n}\n\n// We know there is no growth, so iterators/references wouldn't be invalidated.\nvoid no_growth_ok_FP() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n\n  const auto& keyRef = map.at(1);\n\n  // We know that 1 is already a key in the map, so there won't be a rehash.\n  map[1] = 1;\n\n  const auto valueCopy = keyRef;\n}\n\nvoid folly_valuemap_bad() {\n  folly::F14ValueMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_vectormap_bad() {\n  folly::F14VectorMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_clear_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_rehash_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.rehash(13);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_reserve_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.reserve(13);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_operator_equal_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map = folly::F14FastMap<int, int>();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_insert_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert({4, 16});\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_hinted_insert_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert(map.cbegin(), {4, 16});\n  const auto valueCopy = valueRef;\n}\n\nvoid use_return_insert_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto [it, inserted] = map.insert({4, 16});\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid use_iterator_hinted_insert_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.insert(map.cbegin(), {4, 16});\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid insert_initializer_list_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert({{4, 16}, {5, 25}});\n  const auto valueCopy = valueRef;\n}\n\nvoid insert_range_bad(const std::initializer_list<std::pair<int, int>>& list) {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert(list.begin(), list.end());\n  const auto valueCopy = valueRef;\n}\n\nvoid insert_range_from_map_bad(const folly::F14FastMap<int, int>& other) {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert(other.begin(), other.end());\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_insert_or_assign_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert_or_assign(4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_token_insert_or_assign_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert_or_assign(map.prehash(4), 4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_hinted_insert_or_assign_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.insert_or_assign(map.cbegin(), 4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid use_return_insert_or_assign_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto [it, inserted] = map.insert_or_assign(4, 16);\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid use_return_token_insert_or_assign_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto [it, inserted] = map.insert_or_assign(map.prehash(4), 4, 16);\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid use_iterator_hinted_insert_or_assign_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.insert_or_assign(map.cbegin(), 4, 16);\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid folly_fastmap_emplace_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.emplace(4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_try_emplace_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.try_emplace(4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_hinted_try_emplace_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.try_emplace(map.cbegin(), 4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid use_try_emplace_return_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto [it, inserted] = map.try_emplace(4, 16);\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid use_hinted_try_emplace_iterator_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.try_emplace(map.cbegin(), 4, 16);\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid folly_fastmap_try_emplace_token_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.try_emplace_token(map.prehash(4), 4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_emplace_hint_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.emplace_hint(map.cbegin(), 4, 16);\n  const auto valueCopy = valueRef;\n}\n\nvoid use_iterator_emplace_hint_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.emplace_hint(map.cbegin(), 4, 16);\n  map.clear();\n  const auto valueCopy = it->second;\n}\n\nvoid folly_fastmap_operator_bracket_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map[4] = 16;\n  const auto valueCopy = valueRef;\n}\n\nvoid use_reference_operator_bracket_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map[1];\n  map[4] = 16;\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_erase_bad_FN() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto& valueRef = map.at(1);\n  map.erase(1);\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_swap_ok() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  folly::F14FastMap<int, int> other;\n  const auto& valueRef = map.at(1);\n  map.swap(other); // valueRef now valid in other.\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_swap_bad() {\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  folly::F14FastMap<int, int> other;\n  const auto& valueRef = map.at(1);\n  map.swap(other); // valueRef now valid in other.\n  other.clear(); // valueRef now invalid.\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_valuemap_find_arrow_bad() {\n  folly::F14ValueMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.find(1);\n  const auto& valueRef = it->second;\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_valuemap_find_star_bad() {\n  folly::F14ValueMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.find(1);\n  const auto& keyRef = (*it).first;\n  map.clear();\n  const auto keyCopy = keyRef;\n}\n\nvoid folly_vectormap_find_arrow_bad() {\n  folly::F14VectorMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.find(1);\n  const auto& valueRef = it->second;\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_vectormap_find_star_bad() {\n  folly::F14VectorMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.find(1);\n  const auto& keyRef = (*it).first;\n  map.clear();\n  const auto keyCopy = keyRef;\n}\n\nvoid folly_fastmap_find_arrow_bad() {\n  // The underlying map is an F14ValueMap.\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.find(1);\n  const auto& valueRef = it->second;\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_find_star_bad() {\n  // The underlying map is an F14ValueMap.\n  folly::F14FastMap<int, int> map = {{1, 1}, {2, 4}, {3, 9}};\n  const auto it = map.find(1);\n  const auto& keyRef = (*it).first;\n  map.clear();\n  const auto keyCopy = keyRef;\n}\n\nvoid folly_fastmap_big_find_arrow_bad(folly::F14FastMap<BigPoint, int>& map) {\n  // The underlying map is an F14VectorMap.\n  const auto it = map.find({0, 0, 0});\n  const auto& valueRef = it->second;\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid folly_fastmap_big_find_star_bad(folly::F14FastMap<BigPoint, int>& map) {\n  // The underlying map is an F14VectorMap.\n  const auto it = map.find({0, 0, 0});\n  const auto& keyRef = (*it).first;\n  map.clear();\n  const auto keyCopy = keyRef;\n}\n\nvoid folly_fastmap_begin_bad(folly::F14FastMap<int, int>& map) {\n  auto it = map.begin();\n  map.clear();\n  ++it->second;\n}\n\nvoid folly_fastmap_cbegin_bad(folly::F14FastMap<int, int>& map) {\n  const auto it = map.cbegin();\n  map.clear();\n  const auto keyCopy = it->first;\n}\n\nvoid folly_fastmap_iterator_increment_bad_FN(folly::F14FastMap<int, int>& map) {\n  auto it = map.begin();\n  ++it;\n  const auto& valueRef = it->second;\n  map.clear();\n  const auto valueCopy = valueRef;\n}\n\nvoid iterator_copy_constructor_bad(folly::F14FastMap<int, int>& map) {\n  const auto it = map.begin();\n  const auto it2 = it;\n  map.clear();\n  const auto keyCopy = it2->first;\n}\n\nvoid iterator_copy_operator_equal_bad(folly::F14FastMap<int, int>& map) {\n  const auto it = map.begin();\n  folly::F14FastMap<int, int>::iterator it2;\n  it2 = it;\n  map.clear();\n  const auto keyCopy = it2->first;\n}\n\nvoid weird_operator_bracket_bad_FN(folly::F14FastMap<int, int>& map) {\n  // This is not valid, as the map may resize for the insert call prior to\n  // accessing map[71] and constructing the pair.\n  map.emplace(13, map[71]);\n}\n\n// https://github.com/facebook/folly/blob/1cf9ac0/folly/container/F14.md?plain=1#L293-L296\nvoid reserve_operator_bracket_ok_FP(folly::F14FastMap<int, int>& map) {\n  map.reserve(map.size() + 2);\n  const auto& r1 = map[13];\n  const auto& r2 = map[71];\n  const auto r1Copy = r1;\n}\n\nvoid use_emplace_iterator_bad(folly::F14FastMap<int, int>& map) {\n  const auto [it, inserted] = map.emplace(13, 71);\n  map.clear();\n  // Copy here is fine, iterator is invalid but we are not accessing it.\n  const auto copy = it;\n  const auto value = copy->second;\n}\n\nvoid multiple_lookups_existing_key_ok(folly::F14FastMap<int, int>& map) {\n  const auto& valueRef = map.at(71);\n  const auto key = 13;\n  if (map.contains(key)) {\n    map[key] = 17;\n    map[key] = 31;\n    map[key] = 71;\n  }\n  const auto valueCopy = valueRef;\n}\n\nvoid known_existing_map_key_count_ok(folly::F14FastMap<int, int>& map) {\n  const auto& valueRef = map.at(71);\n  const auto key = 13;\n  if (map.count(key) != 0) {\n    map[key] = std::max(map[key], 17);\n  }\n  const auto valueCopy = valueRef;\n}\n\nvoid known_existing_map_key_contains_ok(folly::F14FastMap<int, int>& map) {\n  const auto& valueRef = map.at(71);\n  const auto key = 13;\n  if (map.contains(key)) {\n    map[key] = std::max(map[key], 17);\n  }\n  const auto valueCopy = valueRef;\n}\n\nvoid known_existing_map_key_find_ok(folly::F14FastMap<int, int>& map) {\n  const auto& valueRef = map.at(71);\n  const auto key = 13;\n  if (map.find(key) != map.end()) {\n    map[key] = std::max(map[key], 17);\n  }\n  const auto valueCopy = valueRef;\n}\n\nvoid double_lookup_not_found_bad_FN(folly::F14FastMap<int, int>& map) {\n  const auto& valueRef = map.at(71);\n  const auto key = 13;\n  if (!map.contains(key)) {\n    map[key] = 17;\n  }\n  const auto valueCopy = valueRef;\n}\n\nvoid known_existing_map_key_literal_ok_FP(folly::F14FastMap<int, int>& map) {\n  const auto& valueRef = map.at(71);\n  if (map.contains(13)) {\n    map[13] = std::max(map[13], 17);\n  }\n  const auto valueCopy = valueRef;\n}\n\nvoid delete_in_loop_ok(folly::F14FastMap<int, int*>& map) {\n  for (auto& it : map) {\n    delete it.second;\n  }\n}\n\nvoid right_sequenced_before_left_ok(folly::F14FastMap<int, int>& map) {\n  // > The assignment operator (=) and the compound assignment operators all\n  // > group right-to-left. The right operand is sequenced before the left\n  // > operand.\n  // -- https://wg21.link/N4950, section 7.6.19 [expr.ass].\n  map[13] = map[71] / 31;\n}\n\nvoid right_before_left_compound_ok(folly::F14FastMap<int, int>& map) {\n  map[13] += map[71] / 31;\n}\n\n// This only seems to be a false negative for integral types.\nvoid unsafe_assign_bad_FN(folly::F14FastMap<int, int>& map) {\n  // The LHS evaluation can invalidate the RHS reference.\n  map[13] = map[71];\n}\n\nvoid unsafe_operation_bad_FN(folly::F14FastMap<int, int>& map) {\n  const auto result = map[13] * map[71];\n}\n\nvoid unsafe_assign_struct_bad(folly::F14FastMap<int, BigPoint>& map) {\n  map[13] = map[71];\n}\n\nvoid unsafe_operation_struct_bad(folly::F14FastMap<int, BigPoint>& map) {\n  const auto result = map[13] + map[71];\n}\n\nint mul(const int& a, const int& b) { return a * b; }\n\nvoid unsafe_function_call_bad(folly::F14FastMap<int, int>& map) {\n  const auto result = mul(map[13], map[71]);\n}\n\nvoid unsafe_function_call_lambda_bad(folly::F14FastMap<int, int>&& map) {\n  [&]() { const auto result = mul(map[13], map[71]); };\n}\n"
    },
    {
      "testname": "reference_wrapper.cpp",
      "testlanguage": "c++",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstruct B {\n  B(int v) : f(v){};\n  int f;\n};\n\nstruct WrapsB {\n  WrapsB(int f) { b = new B(f); }\n  B* b;\n  B* getb() { return b; };\n  ~WrapsB() { delete b; }\n};\n\nstruct ReferenceWrapperHeap {\n  ReferenceWrapperHeap(WrapsB& a) : b(a.getb()){};\n  B* b;\n};\n\nReferenceWrapperHeap getwrapperHeap() {\n  WrapsB a(1);\n  return a; // We store a.b in ReferenceWrapper, but we delete a.b in the\n            // destructor of WrapsB\n}\n\nint reference_wrapper_heap_bad() {\n  ReferenceWrapperHeap rw = getwrapperHeap();\n  return rw.b->f; // we want to report use after lifetime bug here\n}\n\nstruct ReferenceWrapperStack {\n  ReferenceWrapperStack(B& bref) : b(&bref){};\n  B* b;\n};\n\nReferenceWrapperStack getwrapperStack() {\n  B b(1);\n  return b;\n}\n\nint reference_wrapper_stack_bad() {\n  ReferenceWrapperStack rw = getwrapperStack();\n  return rw.b->f; // we want to report use after lifetime bug here\n}\n"
    },
    {
      "testname": "returns.cpp",
      "testlanguage": "c++",
      "expected-problems": 62,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <map>\n#include <string>\n\nnamespace returns {\n\nstruct S {\n  int f_;\n\n  S(int f) : f_(f) {}\n\n  ~S() {}\n};\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wreturn-stack-address\"\nconst int& return_literal_stack_reference_bad() { return 1; }\n\nconst int& return_variable_stack_reference1_bad() {\n  const int& x = 2;\n  return x;\n}\n\nconst int& return_variable_stack_reference2_bad() {\n  const int& x = 2;\n  const int& y = x;\n  return y;\n}\n#pragma clang diagnostic pop\n\nconst int return_read_of_stack_reference_ok() {\n  const int& x = 2;\n  return x;\n}\n\nconst int& return_formal_reference_ok(int& formal) { return formal; }\n\nconst int& return_reference_to_formal_pointer_ok(const int* formal) {\n  const int& local = *formal;\n  return local;\n}\n\nextern const int& callee();\n\nconst int& return_reference_from_callee_ok() {\n  const int& local = callee();\n  return local;\n}\n\nconst int return_int_ok() { return 1; }\n\nconst bool return_comparison_temp_ok() { return 1 != 2; }\n\nconst bool compare_local_refs_ok() {\n  const int& local1 = 1;\n  const int& local2 = 1;\n  return local1 != local2;\n}\n\nextern int& global;\n\nconst int& return_global_reference_ok() { return global; }\n\nstruct MemberReference {\n  int& member1;\n\n  int& return_member_reference_ok() { return member1; }\n\n  int* member2;\n  int* return_member_reference_indirect_ok() {\n    int* local = member2;\n    return local;\n  }\n};\n\nextern const char* const kOptions;\n\nconst char* return_field_addr_ternary_ok() {\n  const char* const* const t = &kOptions;\n  return t ? *t : \"\";\n}\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wreturn-stack-address\"\nint* return_stack_pointer_bad() {\n  int x = 3;\n  return &x;\n}\n#pragma clang diagnostic pop\n\nS* return_static_local_ok() {\n  S* local;\n  static S s{1};\n  local = &s;\n  return local;\n}\n\nstatic const S& return_static_local_ref_ok() {\n  static const S& s{1};\n  return s;\n}\n\nS* return_static_local_inner_scope_ok(bool b) {\n  S* local = nullptr;\n  if (b) {\n    static S s{1};\n    local = &s;\n    // destructor for s gets called here, but it shouldn't be\n  }\n  return local;\n}\n\nint* return_formal_pointer_ok(int* formal) { return formal; }\n\n// this *could* be ok depending on what the caller does\nint* return_deleted_ok() {\n  int* x = new int;\n  *x = 2;\n  delete x;\n  return x;\n}\n\n// this *could* be ok depending on what the caller does\nS* return_destructed_pointer_ok() {\n  S* s = new S(1);\n  s->~S();\n  return s;\n}\n\nconst char* return_nullptr1_ok() { return nullptr; }\n\nconst char* return_nullptr2_ok() {\n  const char* local = nullptr;\n  return local;\n}\n\nstruct A {\n  ~A();\n};\n\nint try_catch_return_ok() {\n  A a;\n  try {\n    return 1;\n  } catch (...) {\n    return 2;\n  }\n}\n\nstd::map<int, std::string> global_map;\n\nconst int& return_structured_variable_ok() {\n  for (const auto& [key, _] : global_map) {\n    return key;\n  }\n}\n\nconst int* return_bound_memory_ref(const std::map<int, int>& m) {\n  // take a ref inside the heap\n  auto& [_, v] = *m.begin();\n  // &v is an address in memory\n  return &v;\n}\n\nint deref_return_bound_memory_ref_ok() {\n  std::map<int, int> m = {{1, 11}};\n  const int* vp = return_bound_memory_ref(m);\n  return *vp;\n}\n\nconst int* return_bound_stack_ref(const std::map<int, int>& m) {\n  auto [_, v] = *m.begin();\n  // &v is an address on the stack\n  return &v;\n}\n\nint deref_return_bound_stack_ref_bad() {\n  std::map<int, int> m = {{1, 11}};\n  const int* vp = return_bound_stack_ref(m);\n  return *vp;\n}\n\n} // namespace returns\n"
    },
    {
      "testname": "set_global.cpp",
      "testlanguage": "c++",
      "expected-problems": 1,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"global.h\"\n\nvoid set_global_42() { g = 42; }\n"
    },
    {
      "testname": "shared_ptr_compil.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\n/* Compilation tests */\n\nnamespace shared_ptr_conv_from_derived {\n/*\nshared_ptr conversion does not work if inheritance is not public\n*/\nclass Base {};\nclass Derived : public Base {};\nclass Q {\n protected:\n  std::shared_ptr<Base> m_;\n\n public:\n  void setM(std::shared_ptr<Base> m) { m_ = std::move(m); }\n};\nclass P {\n  std::shared_ptr<Derived> m_;\n  Q q_;\n  void u() { q_.setM(m_); }\n};\n} // namespace shared_ptr_conv_from_derived\n"
    },
    {
      "testname": "shared_ptr_constructors.cpp",
      "testlanguage": "c++",
      "expected-problems": 32,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <functional>\n#include <memory>\n#include <stdexcept>\n\nnamespace shared_ptr_constructors {\n\nstruct Base {\n  int* f1;\n};\n\nstruct Derived : public Base {\n  int* f2;\n};\n\nstd::shared_ptr<Base> getFromBase1(Base* b) { return std::shared_ptr<Base>(b); }\n\nstd::shared_ptr<Base> getFromBase2(Base* b) {\n  std::shared_ptr<Base> result;\n  result = std::shared_ptr<Base>(b); // assignment operator\n  return result;\n}\n\nstd::shared_ptr<Base> getFromDerived1(Derived* d) {\n  return std::shared_ptr<Base>(d);\n}\n\nstd::shared_ptr<Base> ERROR_getFromDerived2(Derived* d) {\n  std::shared_ptr<Derived> sd(d);\n  return std::shared_ptr<Base>(sd);\n}\n\nstd::shared_ptr<Base> ERROR_getFromDerived3(Derived* d) {\n  std::shared_ptr<Derived> sd(d);\n  std::shared_ptr<Base> result;\n  result = sd; // assignment operator\n  return result;\n}\n\nvoid get_from_base1_nullptr_deref_bad() { Base b = *(getFromBase1(nullptr)); }\n\nvoid get_from_base2_nullptr_deref_bad() { Base b = *(getFromBase2(nullptr)); }\n\nvoid get_from_derived1_nullptr_deref_bad() {\n  Base b = *(getFromDerived1(nullptr));\n}\n\nvoid get_from_derived2_nullptr_deref_bad() {\n  Base b = *(ERROR_getFromDerived2(nullptr));\n}\n\nvoid get_from_derived3_nullptr_deref_bad() {\n  Base b = *(ERROR_getFromDerived3(nullptr));\n}\n\nvoid get_from_base1_null_f1_deref_bad() {\n  Base b;\n  int v;\n  b.f1 = &v;\n  std::shared_ptr<Base> p = getFromBase1(&b);\n  b.f1 = nullptr;\n  int r = *(p->f1);\n}\n\nvoid get_from_base2_null_f1_deref_bad() {\n  Base b;\n  int v;\n  b.f1 = &v;\n  std::shared_ptr<Base> p = getFromBase2(&b);\n  b.f1 = nullptr;\n  int r = *(p->f1);\n}\n\nvoid get_from_derived1_null_f1_deref_bad() {\n  Derived b;\n  int v;\n  b.f1 = &v;\n  std::shared_ptr<Base> p = getFromDerived1(&b);\n  b.f1 = nullptr;\n  int r = *(p->f1);\n}\n\nvoid get_from_derived2_null_f1_deref_bad() {\n  Derived b;\n  int v;\n  b.f1 = &v;\n  std::shared_ptr<Base> p = ERROR_getFromDerived2(&b);\n  b.f1 = nullptr;\n  int r = *(p->f1);\n}\n\nvoid get_from_derived3_null_f1_deref_bad() {\n  Derived b;\n  int v;\n  b.f1 = &v;\n  std::shared_ptr<Base> p = ERROR_getFromDerived3(&b);\n  b.f1 = nullptr;\n  int r = *(p->f1);\n}\n\nstruct A {\n  void baz();\n};\nstruct B {\n  A* a;\n};\n\nstd::shared_ptr<B> external_def();\nstd::shared_ptr<B> internal_null_def() {\n  // TODO: do the same test for std::make_shared\n  // We can't use std::make_shared here because it will cause a memory leak to\n  // be reported instead. In the future we probably need to use something like\n  // __set_wont_leak_attribute() to suppress the leak report.\n  auto r = external_def();\n  r->a = nullptr;\n  return r;\n}\n\nstd::shared_ptr<A> ERROR_aliasing_construct_from_external() {\n  auto p = external_def();\n  if (!p)\n    throw std::logic_error(\"Suppress NULL\");\n  return {p, p->a};\n}\nstd::shared_ptr<A> ERROR_aliasing_construct_from_internal() {\n  auto p = internal_null_def();\n  if (!p)\n    throw std::logic_error(\"Suppress NULL\");\n  return {p, p->a};\n}\n\nvoid aliasing_member_not_null_ok() {\n  auto q = ERROR_aliasing_construct_from_external();\n  // q is unknown here so we should not report null deref\n  // Also we should not report dangling pointer because q is still alive\n  q->baz();\n}\nvoid aliasing_member_null_bad_FN() {\n  auto q = ERROR_aliasing_construct_from_internal();\n  // q is known here so we should report null deref\n  // Also we should not report dangling pointer because q is still alive\n  q->baz();\n}\n\nclass LambdaParam {\n public:\n  LambdaParam(std::function<void()> f) : n(42) {}\n  int n;\n};\n\nint make_shared_lambda_ok() {\n  std::shared_ptr<LambdaParam> p = std::make_shared<LambdaParam>([]() {});\n  if (p->n != 42) {\n    int* p = NULL;\n    *p = 0;\n  }\n}\n} // namespace shared_ptr_constructors\n"
    },
    {
      "testname": "shared_ptr_deref.cpp",
      "testlanguage": "c++",
      "expected-problems": 53,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nnamespace shared_ptr {\n\nstruct X {\n  int field;\n  int get() { return field; }\n  void set(int value) { field = value; }\n};\n\nint empty_ptr_access() {\n  std::shared_ptr<int> x;\n  int* p = x.get(); // no dereference\n  if (p) {\n    return 1;\n  }\n  return 0;\n}\n\nint empty_ptr_deref_bad() {\n  std::shared_ptr<int> x;\n  return *x;\n}\n\nint nullptr_ptr_deref_bad() {\n  std::shared_ptr<int> x(nullptr);\n  return *x;\n}\n\nint shared_ptr_create_use_ok() {\n  std::shared_ptr<X> x(new X());\n  return x->get();\n}\n\nint empty_ptr_field_deref_bad() {\n  std::shared_ptr<X> x;\n  return x.get()->field;\n}\n\nint empty_ptr_field_deref2_bad() {\n  std::shared_ptr<X> x;\n  return x->field;\n}\n\nint empty_ptr_method_deref_bad() {\n  std::shared_ptr<X> x;\n  return x->get();\n}\n\nint reset_ptr_null_deref0_bad() {\n  std::shared_ptr<int> x(new int);\n  x.reset();\n  return *x;\n}\n\nint reset_ptr_null_deref1_bad() {\n  std::shared_ptr<int> x(new int);\n  x.reset(new int);\n  x.reset();\n  return *x;\n}\n\nint reset_ptr_deref_ok() {\n  std::shared_ptr<int> x;\n  x.reset(new int);\n  return *x;\n}\n\nint reset_ptr_deref2_ok() {\n  std::shared_ptr<int> x;\n  x.reset();\n  x.reset(new int);\n  return *x;\n}\n\nint shared_ptr_copy_null_deref_bad() {\n  std::shared_ptr<int> p1;\n  std::shared_ptr<int> p2 = p1;\n  return *p2;\n}\n\nint shared_ptr_assign_null_deref_bad() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2;\n  p1 = p2;\n  return *p1;\n}\n\nint shared_ptr_copy_deref_ok() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2 = p1;\n  return *p2;\n}\n\nint shared_ptr_assign_deref_ok() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2;\n  p2 = p1;\n  p1.reset();\n  return *p2;\n}\n\nint shared_ptr_move_null_deref_bad() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2 = std::move(p1);\n  return *p1;\n}\n\nint ERROR_shared_ptr_check_null_ok() {\n  std::shared_ptr<int> p;\n  if (p == nullptr)\n    return 1;\n  return *p;\n}\n\nint shared_ptr_check_notnull_ok() {\n  std::shared_ptr<int> p;\n  if (p != nullptr)\n    return *p;\n  return 1;\n}\n\nint shared_ptr_check_null2_ok(std::shared_ptr<int> p) {\n  if (p == nullptr)\n    return 1;\n  return *p;\n}\n} // namespace shared_ptr\n"
    },
    {
      "testname": "shared_ptr_destructor.cpp",
      "testlanguage": "c++",
      "expected-problems": 43,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n#include <string>\n\nnamespace destructor_shared_ptr {\nstruct X {\n  int field;\n  int* pointer_field;\n  int get() { return field; }\n  void set(int value) { field = value; }\n  X() { pointer_field = new int; }\n  ~X() { delete pointer_field; }\n};\n\nstruct Y {\n  X* pointer_field;\n  void leak() { pointer_field = new X(); }\n  Y() { pointer_field = new X(); }\n  ~Y() { delete pointer_field; }\n};\n\nint destructor0_ok() {\n  auto x = new std::shared_ptr<int>(new int(5));\n  delete x;\n  return 0;\n}\n\nint destructor1_ok() {\n  { std::shared_ptr<int>(new int(5)); }\n  return 0;\n}\n\nint destructor2_ok() {\n  { std::shared_ptr<int> p; }\n  return 0;\n}\n\nint destructor3_ok() {\n  auto x = new std::shared_ptr<int>();\n  delete x;\n  return 0;\n}\n\nint destructor4_ok() {\n  auto p = new int(5);\n  {\n    std::shared_ptr<int> x(p);\n    int i = *p;\n    {\n      std::shared_ptr<int> y(x);\n      if (*p == *y && *p == *x)\n        return *p;\n      else {\n        int* q = nullptr;\n        return *q;\n      }\n    }\n  }\n  return 0;\n}\n\nvoid destructor5_ok() {\n  auto x = new std::shared_ptr<Y>(new Y());\n  delete x;\n}\n\nint destructor6_ok() {\n  auto x = std::shared_ptr<Y>(new Y());\n  return 0;\n}\n\nvoid destructor7_ok() {\n  auto x = std::shared_ptr<Y>(new Y());\n  x.reset();\n}\n\nvoid destructor8_ok() {\n  auto x = std::shared_ptr<Y>(new Y());\n  x.reset(new Y());\n}\n\nint destructor0_bad() {\n  auto p = new int(5);\n  auto x = new std::shared_ptr<int>(p);\n  delete x;\n  // Should report a NPE here as p has been deallocated\n  return *p;\n}\n\nint destructor1_bad() {\n  auto p = new int(5);\n  { std::shared_ptr<int> x(p); }\n  // Should report a NPE here as p has been deallocated\n  return *p;\n}\n\nint destructor2_bad() {\n  auto p = new int(5);\n  {\n    std::shared_ptr<int> x(p);\n    { std::shared_ptr<int> y(x); }\n  }\n  // Should report a NPE here as p has been deallocated\n  return *p;\n}\n\nint destructor3_bad() {\n  auto x = std::shared_ptr<Y>(new Y());\n  x->leak(); // Should report a memory leak\n  return 0;\n}\n\nint destructor4_bad() {\n  auto x = std::shared_ptr<Y>(new Y());\n  x->leak(); // Should report a memory leak\n  x.reset();\n  return 0;\n}\n\nint destructor5_bad() {\n  auto x = std::shared_ptr<Y>(new Y());\n  x.reset(new Y());\n  x->leak(); // Should report a memory leak\n  return 0;\n}\n\nclass MySharedPtrClass : public std::shared_ptr<std::string> {};\n\nvoid find_element_type_to_destruct_ok() {\n  MySharedPtrClass x;\n  x.reset();\n}\n} // namespace destructor_shared_ptr\n"
    },
    {
      "testname": "shared_ptr_semantics.cpp",
      "testlanguage": "c++",
      "expected-problems": 211,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nnamespace shared_ptr_semantics {\nstruct X {\n  int field;\n  X(int x = 0) : field(x) {}\n  int get() { return field; }\n};\n\nint constructor0_ok() {\n  std::shared_ptr<int> x(new int(42));\n  if (*x != 42) {\n    // Should not report a NPE here as *x is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint constructor0_bad() {\n  int* p = new int(42);\n  std::shared_ptr<int> x(p);\n  if (*x == 42) {\n    // Should report a NPE here as *x is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor0_ok() {\n  std::shared_ptr<X> x(std::shared_ptr<X>(new X(42)));\n  if (x->get() != 42 || x.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\nint move_constructor1_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(std::move(x));\n  if (*y != 42 || y.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor2_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(std::move(x));\n  if (x) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor3_ok() {\n  std::shared_ptr<X> x(new X(42));\n  std::shared_ptr<X> y(std::move(x));\n  if (x || y->get() != 42 || y.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor0_bad() {\n  std::shared_ptr<int> x(std::shared_ptr<int>(new int(42)));\n  if (*x == 42 && x.use_count() == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor1_bad() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(std::move(x));\n  if (*y == 42 && y.use_count() == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor2_bad() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(std::move(x));\n  if (!x) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint move_constructor3_bad() {\n  std::shared_ptr<X> x(new X(42));\n  std::shared_ptr<X> y(std::move(x));\n  if (!x && y->get() == 42 && y.use_count() == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor0_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  if (*x != 42) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor1_ok() {\n  std::shared_ptr<int> w(new int);\n  std::shared_ptr<int> x(new int);\n  std::shared_ptr<int> y(w);\n  if (w.use_count() != 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  y = x;\n  if (w.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor2_ok() {\n  int* p = new int;\n  std::shared_ptr<int> x(p);\n  x = x;\n  if (x.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor3_ok() {\n  int* p = new int;\n  std::shared_ptr<int> x(p);\n  std::shared_ptr<int>& y = x;\n  x = y;\n  if (x.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor0_bad() {\n  std::shared_ptr<int> x;\n  std::shared_ptr<int> y(x);\n  if (y.use_count() == 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor1_bad() {\n  std::shared_ptr<int> x;\n  std::shared_ptr<int> y(x);\n  if (x.use_count() == 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor2_bad() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  if (*y == 42 && y.use_count() == 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint copy_constructor3_bad() {\n  auto p = new int(1);\n  auto q = new int(2);\n  std::shared_ptr<int> x(p);\n  std::shared_ptr<int> y(q);\n  y = x;\n  return *q;\n}\n\nint assignment0_bad() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y;\n  y = x;\n  if (*x == 42) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count0_ok() {\n  std::shared_ptr<int> x(new int(42));\n  if (x.use_count() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count1_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  if (x.use_count() != 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count2_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  std::shared_ptr<int> z(x);\n  if (x.use_count() != 3) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count3_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  std::shared_ptr<int> z(y);\n  if (x.use_count() != 3) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count4_ok() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  std::shared_ptr<int> z;\n  z = y;\n  if (x.use_count() != 3) {\n    // Should not report a NPE here as the ref count is 3\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count0_bad() {\n  std::shared_ptr<int> x;\n  if (x.use_count() == 0) {\n    // Should report a NPE here as the ref count is 0\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count1_bad() {\n  std::shared_ptr<int> x(new int(42));\n  std::shared_ptr<int> y(x);\n  std::shared_ptr<int> z;\n  z = y;\n  if (x.use_count() == 3 && *z == 42) {\n    // Should report a NPE here as the ref count is 3\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count2_bad() {\n  std::shared_ptr<int> x(new int(42));\n  { std::shared_ptr<int> y(x); }\n  if (x.use_count() == 1 && *x == 42) {\n    // Should report a NPE here as the ref count is 1\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint use_count3_bad() {\n  std::shared_ptr<int> x(new int(42));\n  {\n    std::shared_ptr<int> y(x);\n    { std::shared_ptr<int> z(y); }\n    if (x.use_count() == 2 && *y == 42) {\n      // Should report a NPE here as the ref count is 2\n      int* q = nullptr;\n      return *q;\n    }\n  }\n  return 0;\n}\nint use_count4_bad() {\n  std::shared_ptr<int> x(nullptr);\n  if (x.use_count() == 0) {\n    // Should report a NPE here as the ref count is 0\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get0_ok() {\n  int* p = new int(42);\n  std::shared_ptr<int> x(p);\n  if (x.get() != p) {\n    // Should not report a NPE here as x contains the pointer p\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get1_ok() {\n  std::shared_ptr<int> x;\n  int* p = x.get(); // no dereference\n  if (p) {\n    // Should not report a NPE here as p points to nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get0_bad() {\n  int* p = new int(42);\n  std::shared_ptr<int> x(p);\n  if (x.get() == p) {\n    // Should not report a NPE here as x contains the pointer p\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get1_bad() {\n  std::shared_ptr<int> x;\n  int* p = x.get(); // no dereference\n  if (!p) {\n    // Should report a NPE here as p points to nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint reset_ptr_ok() {\n  std::shared_ptr<int> x(new int(10));\n  x.reset();\n  return 42;\n}\n\nint reset_ptr_use_count0_bad() {\n  std::shared_ptr<int> x(new int(10));\n  x.reset();\n  if (x.use_count() == 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 42;\n}\n\nint reset_ptr_use_count1_bad() {\n  auto p = new int(5);\n  std::shared_ptr<int> x(p);\n  std::shared_ptr<int> y(x);\n  y.reset();\n  if (x.use_count() == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 42;\n}\n\nint reset_ptr_use_count2_bad() {\n  auto p = new int(5);\n  std::shared_ptr<int> x(p);\n  std::shared_ptr<int> y(x);\n  y.reset();\n  if (y.use_count() == 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 42;\n}\n\nint reset_ptr_deref1_ok() {\n  std::shared_ptr<int> x;\n  x.reset();\n  x.reset(new int);\n  return *x;\n}\n\nint shared_ptr_move_deref_ok() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2 = std::move(p1);\n  return *p2;\n}\n\nint shared_ptr_move0_bad() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2 = std::move(p1);\n  return *p1;\n}\n\nint shared_ptr_move_count0_bad() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2;\n  p2 = std::move(p1);\n  if (p2.use_count() == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return *p2;\n}\n\nint shared_ptr_move_count1_bad() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2;\n  p2 = std::move(p1);\n  if (p1.use_count() == 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return *p2;\n}\n\nint shared_ptr_move_deref_bad() {\n  std::shared_ptr<int> p1(new int);\n  std::shared_ptr<int> p2;\n  p1 = std::move(p2);\n  return *p1;\n}\n\nstruct Foo : public std::enable_shared_from_this<Foo> {\n  Foo() {}\n  ~Foo() {}\n  std::shared_ptr<Foo> getFoo() { return shared_from_this(); }\n};\n\nint FP_shared_from_this_ok() {\n  Foo* f = new Foo;\n  int* q = nullptr;\n  std::shared_ptr<Foo> pf1;\n  {\n    std::shared_ptr<Foo> pf2(f);\n    pf1 = pf2->getFoo(); // shares ownership of object with pf2\n    if (pf2.use_count() !=\n        2) { // should not report a NPE here as the ref count is 2\n      return *q;\n    }\n  }\n  if (pf1.use_count() != 1) {\n    // pf2 is out of scope\n    // should not report a NPE here as the ref count is 1\n    return *q;\n  }\n  return 0;\n}\n\nint FN_shared_from_this_bad() {\n  Foo* f = new Foo;\n  int* q = nullptr;\n  std::shared_ptr<Foo> pf1;\n  {\n    std::shared_ptr<Foo> pf2(f);\n    pf1 = pf2->getFoo();\n    if (pf2.use_count() == 2 && pf1.use_count() == 2) {\n      // should report a NPE here as pf1, pf2 share ownership of f\n      return *q;\n    }\n  }\n  return 0;\n}\n\ntemplate <typename T>\nclass PrimaryPtr {\n public:\n  std::shared_ptr<T> lock() const {\n    if (auto res = weak.lock()) {\n      return *res;\n    }\n    return nullptr;\n  }\n\n private:\n  std::weak_ptr<std::shared_ptr<T>> weak;\n};\n\nvoid lock_primary_ptr_ok(PrimaryPtr<std::string> primary) {\n  auto x = primary.lock();\n}\n\nint call_static_pointer_cast_ok() {\n  std::shared_ptr<X> x(new X(42));\n  int* p = &std::static_pointer_cast<X>(x)->field;\n  return *p;\n}\n} // namespace shared_ptr_semantics\n"
    },
    {
      "testname": "skip_config.cpp",
      "testlanguage": "c++",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nnamespace skip_model {\nstruct SkipAll {\n  int* foo() { return nullptr; }\n  static int* goo() { return nullptr; }\n};\n\ntemplate <typename T>\nstruct SkipSome {\n  int* skip_me(int**) { return nullptr; }\n  static int no_skip() { return 42; }\n};\n\nvoid test_config_no_skip_ok() {\n  if (SkipSome<SkipSome<int>>::no_skip() != 42) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid test_config_skip_me_ok() {\n  int* may_be_mutated = nullptr;\n  int* p = nullptr;\n  SkipSome<SkipSome<int>> x;\n  p = x.skip_me(&may_be_mutated);\n  *p = 42;\n  *may_be_mutated = 42;\n}\n} // namespace skip_model\n\nnamespace skip_another_namespace {\nvoid test_config_foo_ok() {\n  int* p = nullptr;\n  skip_model::SkipAll x;\n  p = x.foo();\n  *p = 42;\n}\nvoid test_config_goo_ok() {\n  int* p = skip_model::SkipAll::goo();\n  *p = 42;\n}\n\n} // namespace skip_another_namespace\n"
    },
    {
      "testname": "slow.cpp",
      "testlanguage": "c++",
      "expected-problems": 1,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// make sure pulse doesn't take too long to analyze this\nconst unsigned char huge_array[8192] = {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03,\n    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,\n    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,\n    0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,\n    0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,\n    0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab,\n    0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,\n    0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,\n    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,\n    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13,\n    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,\n    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,\n    0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,\n    0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,\n    0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,\n    0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,\n    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n};\n"
    },
    {
      "testname": "std_atomics.cpp",
      "testlanguage": "c++",
      "expected-problems": 71,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <atomic>\n\nnamespace atomic_test {\n\nvoid fetch_sub_add_ok() {\n  std::atomic<int> a{0};\n  int* p = nullptr;\n  a.fetch_add(1, std::memory_order_acq_rel);\n  a.fetch_add(1);\n  a.fetch_sub(1, std::memory_order_acq_rel);\n  a.fetch_sub(1);\n  int result_zero = a.fetch_sub(1);\n  if (result_zero != 0) {\n    *p = 42;\n  }\n}\n\nvoid pre_increment_decrement_test_ok() {\n  std::atomic<int> a{0};\n  int* p = nullptr;\n  int x = ++a;\n  int y = --a;\n  if (a != 0 || x != 1 || y != a) {\n    *p = 42;\n  }\n}\n\nvoid pre_increment_decrement_test_bad() {\n  std::atomic<int> a{0};\n  int* p = nullptr;\n  ++a;\n  --a;\n  if (a == 0) {\n    *p = 42;\n  }\n}\n\nvoid post_increment_decrement_test_ok() {\n  std::atomic<int> a{0};\n  int* p = nullptr;\n  int x = a++;\n  int y = a--;\n  if (a != 0 || x != 0 || y != 1) {\n    *p = 42;\n  }\n}\n\nvoid load_store_impossible_npe_ok() {\n  std::atomic<int> a(0);\n  int* p = nullptr;\n  a.store(1);\n  if (a.load() != 1) {\n    *p = 42;\n  }\n}\n\nvoid load_store_possible_npe_bad() {\n  std::atomic<int> a(0);\n  int* p = nullptr;\n  a.store(1);\n  if (a.load() == 1) {\n    *p = 42;\n  }\n}\n\nvoid exchange_impossible_npe_ok() {\n  std::atomic<int> a(0);\n  int* p = nullptr;\n  int b = a.exchange(1);\n  if (a != 1 || b != 0) {\n    *p = 42;\n  }\n}\n\nvoid exchange_possible_npe_bad() {\n  std::atomic<int> a(0);\n  int* p = nullptr;\n  int b = a.exchange(1);\n  if (a == 1 && b == 0) {\n    *p = 42;\n  }\n}\n\nvoid FP_compare_exchange_weak_impossible_npe1_ok() {\n  std::atomic<int> a(0);\n  int b = 0;\n  int* p = nullptr;\n  int succ = a.compare_exchange_weak(b, 2);\n  if (a != 2 || b != 0 || !succ) {\n    *p = 42;\n  }\n}\n\nvoid compare_exchange_weak_possible_npe1_bad() {\n  std::atomic<int> a(0);\n  int b = 0;\n  int* p = nullptr;\n  int succ = a.compare_exchange_weak(b, 2);\n  if (a == 2 && b == 0 && succ) {\n    *p = 42;\n  }\n}\n\nvoid FP_compare_exchange_weak_impossible_npe2_ok() {\n  std::atomic<int> a(0);\n  int b = 1;\n  int* p = nullptr;\n  int succ = a.compare_exchange_weak(b, 2);\n  if (a != 0 || b != 0 || succ) {\n    *p = 42;\n  }\n}\n\nvoid compare_exchange_weak_possible_npe2_bad() {\n  std::atomic<int> a(0);\n  int b = 1;\n  int* p = nullptr;\n  int succ = a.compare_exchange_weak(b, 2);\n  if (a == 0 && b == 0 && !succ) {\n    *p = 42;\n  }\n}\n\nvoid FP_compare_exchange_strong_impossible_npe1_ok() {\n  std::atomic<int> a(0);\n  int b = 0;\n  int* p = nullptr;\n  int succ = a.compare_exchange_strong(b, 2);\n  if (a != 2 || b != 0 || !succ) {\n    *p = 42;\n  }\n}\n\nvoid compare_exchange_strong_possible_npe1_bad() {\n  std::atomic<int> a(0);\n  int b = 0;\n  int* p = nullptr;\n  int succ = a.compare_exchange_strong(b, 2);\n  if (a == 2 && b == 0 && succ) {\n    *p = 42;\n  }\n}\n\nvoid FP_compare_exchange_strong_impossible_npe2_ok() {\n  std::atomic<int> a(0);\n  int b = 1;\n  int* p = nullptr;\n  int succ = a.compare_exchange_strong(b, 2);\n  if (a != 0 || b != 0 || succ) {\n    *p = 42;\n  }\n}\n\nvoid compare_exchange_strong_possible_npe2_bad() {\n  std::atomic<int> a(0);\n  int b = 1;\n  int* p = nullptr;\n  int succ = a.compare_exchange_strong(b, 2);\n  if (a == 0 && b == 0 && !succ) {\n    *p = 42;\n  }\n}\n} // namespace atomic_test\n"
    },
    {
      "testname": "swap.cpp",
      "testlanguage": "c++",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <utility>\n\nint swap_null_ok() {\n  int a = 0;\n  int *p = nullptr, *q = &a;\n  std::swap(p, q);\n  return *p;\n}\n\nint swap_null_bad() {\n  int a = 0;\n  int *p = nullptr, *q = &a;\n  std::swap(p, q);\n  return *q;\n}\n"
    },
    {
      "testname": "temporaries.cpp",
      "testlanguage": "c++",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nnamespace temporaries {\n\ntemplate <typename X>\nstruct UniquePtr {\n  X* x_;\n  ~UniquePtr() { delete x_; }\n  UniquePtr(X* y) { x_ = y; }\n\n  UniquePtr(UniquePtr<X>& p) = delete; // no copy constructor\n  UniquePtr(UniquePtr<X>&& p) {\n    x_ = p.get();\n    p.x_ = nullptr;\n  }\n\n  X* get() const { return x_; }\n\n  X& operator*() const { return *get(); }\n\n  X* operator->() const { return get(); }\n};\n\nstruct A {\n  int s_;\n  ~A() {}\n  A() : A(42) {}\n  A(int s) { s_ = s; }\n  A(A& a) { s_ = a.s_; }\n};\n\nUniquePtr<A> mk_UniquePtr_A() { return UniquePtr<A>(new A); }\n\nint call_mk_UniquePtr_A_deref_bad() {\n  A* a = mk_UniquePtr_A().get(); // temporary unique_ptr returned by\n                                 // `mk_UniquePtr_A` is destroyed at the end\n                                 // of the statement\n  return a->s_;\n}\n\nint call_mk_UniquePtr_A_ok() {\n  const UniquePtr<A>& local =\n      mk_UniquePtr_A(); // ok, as ownership of a temporary unique_ptr is passed\n                        // to `local`\n  return local->s_;\n}\n\nint call_mk_UniquePtr_A_copy_object_ok() {\n  A a = *mk_UniquePtr_A().get(); // ok, as value is copied before temporary\n                                 // unique_prt is destroyed\n  return a.s_;\n}\n\nvoid temporary_in_ternary_ok() {\n  while (true) {\n    int x = true ? 0 : A(4).s_;\n  }\n}\n\nvoid temporary_in_if_condition_ok() {\n  if (A(4).s_) {\n  }\n\n  if (true && A(4).s_ && true) {\n  }\n}\n\nvoid temporary_in_while_condition_ok() {\n  while (A(4).s_) {\n  }\n\n  while (true && A(4).s_ && true) {\n  }\n}\n\nvoid call_mk_UniquePtr_A_get_field_ok() { int x = A().s_; }\n\nint bind_temporary_to_const_bad() {\n  A* a_ptr;\n  {\n    const UniquePtr<A>& local = mk_UniquePtr_A();\n    a_ptr = local.get();\n  }\n  return a_ptr->s_;\n}\n\nstruct AutoConvertibleFromA {\n  ~AutoConvertibleFromA() {}\n\n  // auto-conversion between A and AutoConvertibleFromA\n  constexpr AutoConvertibleFromA(const A&) {}\n};\n\nstruct InitListConstructible {\n  ~InitListConstructible() {}\n  InitListConstructible(const InitListConstructible&) noexcept;\n};\n\nA make_an_A(); // creates an A\nInitListConstructible make_a_InitListConstructible(AutoConvertibleFromA);\n\n// test that the frontend deals with this correctly\nvoid temporary_in_constructor_in_init_list_ok() {\n  while (true) {\n    // A -> AutoConvertibleFromA conversion requires a temporary to be\n    // materialized to hold the A& necessary for the conversion, then\n    // InitListConstructible's copy constructor generates the init list we want\n    // to test\n    InitListConstructible p =\n        InitListConstructible{make_a_InitListConstructible(make_an_A())};\n  }\n}\n\n} // namespace temporaries\n"
    },
    {
      "testname": "throw_test.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nint double_free_in_catch_bad_FN(int a[10], int b) {\n  try {\n    if (b > 0) {\n      free(a);\n      throw(0);\n    }\n  } catch (...) {\n    free(a);\n  }\n  return 0;\n}\n\nvoid throw_positive(int a[10], int b) {\n  if (b > 0) {\n    free(a);\n    throw(1);\n  }\n}\n\nint double_free_interproc_bad_FN(int a[10], int b) {\n  try {\n    throw_positive(a, 2);\n  } catch (...) {\n    free(a);\n  }\n  return 0;\n}\n"
    },
    {
      "testname": "trace.cpp",
      "testlanguage": "c++",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid make_alias(int** src, int** dst) { *dst = *src; }\n\nvoid do_free(int* x) {\n  int* y = x;\n  int* z = y;\n  free(y);\n}\n\nvoid trace_free_bad(int* x) {\n  int* y;\n  make_alias(&x, &y);\n  do_free(y);\n  int i = *x;\n}\n"
    },
    {
      "testname": "traces.cpp",
      "testlanguage": "c++",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <string>\n\nvoid access_destructed_string() {\n  const char* ptr;\n  {\n    std::string s = \"blah\";\n    ptr = s.data();\n  }\n  char first_char = *ptr;\n}\n"
    },
    {
      "testname": "uninit.cpp",
      "testlanguage": "c++",
      "expected-problems": 74,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <atomic>\n#include <functional>\n#include <string>\n\nvoid get_closure(std::function<int()> closure);\n\nenum my_enum {\n  my_enum_1 = 0,\n  my_enum_2 = 1,\n};\n\nextern my_enum get_my_enum();\n\nclass Uninit {\n  void closure_call_ok() {\n    auto closure = [this]() { return 5; };\n    get_closure(closure);\n  }\n\n  class MyClass {\n   public:\n    int i;\n    int j;\n\n    MyClass() {}\n    MyClass(int x, int y) : i(x), j(y) {}\n  };\n\n  void init_by_store(MyClass* x) {\n    MyClass y{3, 5};\n    reinterpret_cast<std::atomic<MyClass>*>(x)->store(\n        y, std::memory_order_release);\n  }\n\n  void call_init_by_store_ok() {\n    MyClass x;\n    init_by_store(&x);\n    int y = x.i;\n  }\n\n  MyClass get_MyClass() {\n    switch (get_my_enum()) {\n      case (my_enum_1):\n        return MyClass{1, 2};\n        break;\n      case (my_enum_2):\n        return MyClass{1, 2};\n        break;\n    }\n  }\n\n  void call_get_MyClass_ok() { int x = get_MyClass().i; }\n\n  MyClass get_MyClass_param(my_enum my_enum) {\n    switch (my_enum) {\n      case (my_enum_1):\n        return MyClass{1, 2};\n        break;\n      case (my_enum_2):\n        return MyClass{1, 2};\n        break;\n    }\n  }\n\n  void call_get_MyClass_param_ok(my_enum my_enum) {\n    int x = get_MyClass_param(my_enum).i;\n  }\n\n  MyClass get_MyClass_infeasible_default() {\n    switch (get_my_enum()) {\n      case (my_enum_1):\n        return MyClass{1, 2};\n        break;\n      case (my_enum_2):\n        return MyClass{1, 2};\n        break;\n      default:\n        // infeasible\n        break;\n    }\n  }\n\n  void call_get_MyClass_infeasible_default_ok() {\n    int x = get_MyClass_infeasible_default().i;\n  }\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wreturn-type\"\n  MyClass get_MyClass_feasible_default() {\n    switch (get_my_enum()) {\n      case (my_enum_1):\n        return MyClass{1, 2};\n        break;\n      default:\n        // feasible\n        break;\n    }\n  }\n#pragma clang diagnostic pop\n\n  void call_get_MyClass_feasible_default_bad() {\n    int x = get_MyClass_feasible_default().i;\n  }\n\n  std::function<MyClass()> unknown;\n\n  MyClass havoc_return_param() { return unknown(); }\n\n  int call_havoc_return_param_ok() {\n    MyClass x = havoc_return_param();\n    return x.i;\n  }\n};\n\nclass Uninit2 {\n public:\n  int f1;\n  int f2;\n\n  Uninit2() {}\n\n  void may_read_f1_empty(std::string s) {\n    if (s.empty()) {\n      int x = f1;\n    }\n  }\n\n  void not_read_f1_ok() {\n    Uninit2 o;\n    o.may_read_f1_empty(\"non empty string\");\n  }\n\n  void read_f1_bad() {\n    Uninit2 o;\n    o.may_read_f1_empty(std::string());\n  }\n\n  void may_read_f2_length(std::string s) {\n    if (s.length() == 0) {\n      int x = f2;\n    }\n  }\n\n  void not_read_f2_ok() {\n    Uninit2 o;\n    o.may_read_f2_length(\"non empty string\");\n  }\n\n  void read_f2_bad() {\n    Uninit2 o;\n    o.may_read_f2_length(\"\");\n  }\n};\n\nvoid unknown_call_lambda(std::function<void()> f);\n\nint init_by_capture_good() {\n  int x;\n  unknown_call_lambda([&]() { x = 42; });\n  return x;\n}\n\nvoid init_param(int* p) { p[0] = 42; }\n\nint init_in_callee_ok() {\n  int x;\n  init_param(&x);\n  return x;\n}\n\nclass Nested {\n public:\n  int i;\n  Uninit2 mc;\n};\n\nvoid unknown_init_nested(Nested& x);\n\nint read_nested(Nested& x) {\n  unknown_init_nested(x);\n  return x.mc.f1;\n}\n\nint call_read_nested_ok() {\n  Nested x;\n  return read_nested(x);\n}\n\nclass Uninit3 {\n public:\n  int f1;\n  int f2;\n};\n\nclass Uninit4 {\n  Uninit3& uninit3_;\n  int x;\n\n public:\n  Uninit4(Uninit3& uninit3) : uninit3_{uninit3} { Uninit3 dummy = uninit3_; }\n};\n\nvoid construct_unint4_ok(Uninit3 uninit3) { Uninit4 uninit4(uninit3); }\n\nint dummy_func(int);\n\nvoid comma_operator_ok() {\n  int i, j;\n  i = ({ dummy_func(42); }), j = ({ dummy_func(i); });\n}\n\nclass UninitUserProvided {\n private:\n  int p;\n\n public:\n  int x;\n  int y = 42;\n\n  UninitUserProvided() {}\n};\n\nint uninit_user_provided_bad() {\n  UninitUserProvided a{};\n  return a.x;\n}\n\nclass UninitDefault {\n private:\n  int p;\n\n public:\n  int x;\n  int y = 42;\n\n  UninitDefault() = default;\n};\n\nint uninit_default_ok() {\n  UninitDefault a{}; // a.x is initialized by the value-initialization rule.\n  return a.x;\n}\n"
    },
    {
      "testname": "unique_lock.cpp",
      "testlanguage": "c++",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace UniqueLock {\n\nint constructor0_ok() {\n  std::mutex m;\n  std::unique_lock<std::mutex> lock(m);\n  auto raw = reinterpret_cast<int*>(lock.mutex());\n  return *raw;\n}\n\nint constructor1_ok() {\n  std::mutex m;\n  std::defer_lock_t t;\n  std::unique_lock<std::mutex> lock(m, t);\n  auto raw = reinterpret_cast<int*>(lock.mutex());\n  return *raw;\n}\n\nint constructor_bad() {\n  std::unique_lock<std::mutex> lock;\n  auto raw = reinterpret_cast<int*>(lock.mutex());\n  return *raw;\n}\n\nint lock_ok() {\n  std::mutex m;\n  std::unique_lock<std::mutex> lock(m);\n  lock.lock();\n  return 0;\n}\n\nint copy_null_deref_bad() {\n  std::unique_lock<std::mutex> l1;\n  std::unique_lock<std::mutex> l2 = std::move(l1);\n  auto raw = reinterpret_cast<int*>(l2.mutex());\n  return *raw;\n}\n\nint assign_null_deref_bad() {\n  std::mutex m;\n  std::unique_lock<std::mutex> l1(m);\n  std::unique_lock<std::mutex> l2;\n  l1 = std::move(l2);\n  auto raw = reinterpret_cast<int*>(l1.mutex());\n  return *raw;\n}\n\nint move_deref_ok() {\n  std::mutex m;\n  std::unique_lock<std::mutex> l1(m);\n  std::unique_lock<std::mutex> l2 = std::move(l1);\n  auto raw = reinterpret_cast<int*>(l2.mutex());\n  return *raw;\n}\n\nint assign_deref_ok() {\n  std::mutex m;\n  std::unique_lock<std::mutex> l1(m);\n  std::unique_lock<std::mutex> l2 = std::move(l1);\n  l1.release();\n  auto raw = reinterpret_cast<int*>(l2.mutex());\n  return *raw;\n}\n\nint move_null_deref_bad() {\n  std::mutex m;\n  std::unique_lock<std::mutex> l1(m);\n  std::unique_lock<std::mutex> l2 = std::move(l1);\n  auto raw = reinterpret_cast<int*>(l1.mutex());\n  return *raw;\n}\n\nint self_move_assignment_ok() {\n  std::mutex m;\n  std::unique_lock<std::mutex> lock(m);\n  lock = std::move(lock);\n  auto raw = reinterpret_cast<int*>(lock.mutex());\n  return *raw;\n}\n\nint release_ok() {\n  std::mutex m;\n  std::unique_lock<std::mutex> lock(m);\n  auto raw = reinterpret_cast<int*>(lock.mutex());\n  lock.release();\n  return *raw;\n}\n\nint release_bad() {\n  std::mutex m;\n  std::unique_lock<std::mutex> lock(m);\n  auto m1 = lock.mutex();\n  auto m2 = lock.release();\n  if (m1 == m2) {\n    auto raw = reinterpret_cast<int*>(lock.mutex());\n    return *raw;\n  }\n  return 0;\n}\n\nint swap_ok() {\n  std::mutex m1;\n  std::mutex m2;\n  std::unique_lock<std::mutex> lock1(m1);\n  std::unique_lock<std::mutex> lock2(m2);\n  lock1.swap(lock2);\n  if (&m1 != lock2.mutex() || &m2 != lock1.mutex()) {\n    lock1.release();\n    auto raw = reinterpret_cast<int*>(lock1.mutex());\n    return *raw;\n  }\n  return 0;\n}\n\nint swap_bad() {\n  std::mutex m1;\n  std::mutex m2;\n  std::unique_lock<std::mutex> lock1(m1);\n  std::unique_lock<std::mutex> lock2(m2);\n  lock1.swap(lock2);\n  if (&m1 == lock2.mutex() && &m2 == lock1.mutex()) {\n    lock1.release();\n    auto raw = reinterpret_cast<int*>(lock1.mutex());\n    return *raw;\n  }\n  return 0;\n}\n\n} // namespace UniqueLock\n"
    },
    {
      "testname": "unique_ptr_deref.cpp",
      "testlanguage": "c++",
      "expected-problems": 143,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nnamespace unique_ptr {\n\nstruct X {\n  int field;\n  int* pointer_field;\n  int get() { return field; }\n  void set(int value) { field = value; }\n  X() { pointer_field = new int; }\n  ~X() { delete pointer_field; }\n};\n\nint constructor0_ok() {\n  std::unique_ptr<int> x(new int(42));\n  if (*x != 42) {\n    // Should not report a NPE here as *x is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint constructor0_bad() {\n  int* p = new int(42);\n  std::unique_ptr<int> x(p);\n  if (*x == 42) {\n    // Should report a NPE here as *x is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint constructor1_bad() {\n  std::unique_ptr<int> x(nullptr);\n  return *x;\n}\n\nint array_access0_ok() {\n  auto p = new int[3];\n  p[1] = 42;\n  std::unique_ptr<int[]> x(p);\n  if (x[1] != 42) { // Should not report a NPE here as x[1] is equal to 42\n    int* q = nullptr;\n    *q = 10;\n  }\n  return 0;\n}\n\nint array_access1_ok() {\n  auto p = new int[3];\n  p[1] = 42;\n  std::unique_ptr<int[]> x(p);\n  if (x[1] != 42) { // Should not report a NPE here as x[1] is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint array_access0_bad() {\n  std::unique_ptr<int[]> x(new int[3]);\n  x[1] = 42;\n  if (x[1] == 42) { // Should report a NPE here as x[1] is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint array_access1_bad() {\n  auto p = new int[3];\n  p[1] = 42;\n  std::unique_ptr<int[]> x(p);\n  if (x[1] == 42) { // Should report a NPE here as x[1] is equal to 42\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get0_ok() {\n  int* p = new int(42);\n  std::unique_ptr<int> x(p);\n  if (x.get() != p) {\n    // Should not report a NPE here as x contains the pointer p\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get1_ok() {\n  std::unique_ptr<int> x;\n  int* p = x.get(); // no dereference\n  if (p) {\n    // Should not report a NPE here as p points to nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get0_bad() {\n  int* p = new int(42);\n  std::unique_ptr<int> x(p);\n  if (x.get() == p) {\n    // Should not report a NPE here as x contains the pointer p\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint get1_bad() {\n  std::unique_ptr<int> x;\n  int* p = x.get(); // no dereference\n  if (!p) {\n    // Should report a NPE here as p points to nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint empty_ptr_deref_bad() {\n  std::unique_ptr<int> x;\n  return *x;\n}\n\nint empty_array_ptr_deref_bad() {\n  std::unique_ptr<int[]> x;\n  return x[0];\n}\n\nint nullptr_ptr_deref_bad() {\n  std::unique_ptr<int> x(nullptr);\n  return *x;\n}\n\nint nullptr_array_ptr_deref_bad() {\n  std::unique_ptr<int[]> x(nullptr);\n  return x[2];\n}\n\nint empty_ptr_field_deref_bad() {\n  std::unique_ptr<X> x;\n  return x.get()->field;\n}\n\nint empty_ptr_field_deref2_bad() {\n  std::unique_ptr<X> x;\n  return x->field;\n}\n\nint empty_ptr_method_deref_bad() {\n  std::unique_ptr<X> x;\n  return x->get();\n}\n\nint unique_ptr_create_use_ok() {\n  std::unique_ptr<X> x(new X());\n  return x->get();\n}\n\nvoid unique_ptr_release0_bad() {\n  std::unique_ptr<X> x(new X());\n  x.release();\n  *x; // Should report a NPE here as x, after the release, contains a nullptr\n}\n\nvoid unique_ptr_release1_bad() {\n  std::unique_ptr<X> x(new X());\n  x.release(); // Should report a memory leak since the object of X has not been\n               // deallocated\n}\n\nint reset_ptr_null_deref_bad() {\n  std::unique_ptr<int> x(new int);\n  x.reset();\n  return *x;\n}\n\nvoid unique_ptr_release_get0_bad() {\n  std::unique_ptr<X> x(new X());\n  if (x.get() != x.release()) {\n    // Should not report a NPE here as both x.release() and x.get() return the\n    // pointers contained in x\n    *x; // x, after the release, contains a nullptr\n  }\n  // Should report a memory leak since the object of X has not been\n  // deallocated\n}\n\nvoid unique_ptr_release_get1_bad() {\n  std::unique_ptr<X> x(new X());\n  if (x.get() == x.release())\n  // Should report a NPE here as both x.release() and x.get() return the\n  // pointers contained in x\n  {\n    *x; // x, after the release, contains a nullptr\n  }\n}\n\nint reset_ptr_null_deref2_bad() {\n  std::unique_ptr<int> x(new int);\n  x.reset(new int);\n  x.reset();\n  return *x;\n}\n\nint reset_ptr_null_deref_ok() {\n  std::unique_ptr<int> x(new int);\n  x.reset();\n  return 42;\n}\n\nint reset_ptr_deref_ok() {\n  std::unique_ptr<int> x;\n  x.reset(new int);\n  return *x;\n}\n\nint reset_ptr_deref2_ok() {\n  std::unique_ptr<int> x;\n  x.reset();\n  x.reset(new int);\n  return *x;\n}\n\nint unique_ptr_copy_null_deref_bad() {\n  std::unique_ptr<int> p1;\n  std::unique_ptr<int> p2 = std::move(p1);\n  return *p2;\n}\n\nint unique_ptr_assign_null_deref_bad() {\n  std::unique_ptr<int> p1(new int);\n  std::unique_ptr<int> p2;\n  p1 = std::move(p2);\n  return *p1;\n}\n\nint unique_ptr_move_deref_ok() {\n  std::unique_ptr<int> p1(new int);\n  std::unique_ptr<int> p2 = std::move(p1);\n  return *p2;\n}\n\nint unique_ptr_assign_deref_ok() {\n  std::unique_ptr<int> p1(new int);\n  std::unique_ptr<int> p2;\n  p2 = std::move(p1);\n  p1.reset();\n  return *p2;\n}\n\nint unique_ptr_move_null_deref_bad() {\n  std::unique_ptr<int> p1(new int);\n  std::unique_ptr<int> p2 = std::move(p1);\n  return *p1;\n}\n\nint unique_ptr_self_move_assignment_ok() {\n  std::unique_ptr<int> x(new int(42));\n  x = std::move(x);\n  return *x;\n}\n\nint unique_ptr_swap0_ok() {\n  int* p1 = new int(1);\n  int* p2 = new int(2);\n  {\n    std::unique_ptr<int> x(p1);\n    {\n      std::unique_ptr<int> y(p2);\n      x.swap(y);\n    }\n    return *p2;\n  }\n}\n\nint unique_ptr_swap0_bad() {\n  std::unique_ptr<int> p1(new int(1));\n  std::unique_ptr<int> p2(new int(2));\n  p1.swap(p2);\n  if (*p1 == 2 && *p2 == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return *p1;\n}\n\nint unique_ptr_swap1_bad() {\n  int* p1 = new int(1);\n  int* p2 = new int(2);\n  {\n    std::unique_ptr<int> x(p1);\n    {\n      std::unique_ptr<int> y(p2);\n      x.swap(y);\n    }\n    return *p1;\n  }\n}\n\nint operator_bool0_ok() {\n  std::unique_ptr<int> x(new int);\n  x.reset();\n  if (x) {\n    // Should not report a NPE here as x manages nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint operator_bool1_ok() {\n  std::unique_ptr<int> x;\n  if (x) {\n    // Should not report a NPE here as x manages nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint operator_bool0_bad() {\n  std::unique_ptr<int> x(new int);\n  x.reset();\n  if (!x) {\n    // Should report a NPE here as x manages nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint operator_bool1_bad() {\n  std::unique_ptr<int> x;\n  if (!x) {\n    // Should report a NPE here as x manages nullptr\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\n// Deleter that doesn't actually call delete\ntemplate <class T>\nstruct Deleter {\n  using pointer = T*;\n\n  void operator()(pointer ptr) const {}\n};\n\n// leaky because the deleter doesn't delete the managed pointer\ntemplate <class T>\nusing leaky_unique_ptr = std::unique_ptr<T, Deleter<T>>;\n\nvoid no_delete_in_leaky_unique_ptr_bad() { leaky_unique_ptr<X> p(new X()); }\n\n} // namespace unique_ptr\n"
    },
    {
      "testname": "unique_ptr_destructor.cpp",
      "testlanguage": "c++",
      "expected-problems": 31,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nnamespace destructor_unique_ptr {\nstruct X {\n  int field;\n  int* pointer_field;\n  int get() { return field; }\n  void set(int value) { field = value; }\n  X() { pointer_field = new int; }\n  ~X() { delete pointer_field; }\n};\n\nstruct Y {\n  X* pointer_field;\n  void leak() { pointer_field = new X(); }\n  Y() { pointer_field = new X(); }\n  ~Y() { delete pointer_field; }\n};\n\nint destructor0_ok() {\n  auto x = new std::unique_ptr<int>(new int(5));\n  delete x;\n  return 0;\n}\n\nint destructor1_ok_FP() {\n  { std::unique_ptr<int>(new int(5)); }\n  return 0;\n}\n\nint destructor2_ok() {\n  { std::unique_ptr<int> p; }\n  return 0;\n}\n\nint destructor3_ok() {\n  auto x = new std::unique_ptr<int>();\n  delete x;\n  return 0;\n}\n\nint destructor4_ok() {\n  auto x = new std::unique_ptr<X>(new X());\n  delete x;\n  return 0;\n}\n\nvoid destructor5_ok() {\n  auto x = new std::unique_ptr<Y>(new Y());\n  delete x;\n}\n\nint destructor6_ok() {\n  auto x = std::unique_ptr<Y>(new Y());\n  return 0;\n}\n\nvoid destructor7_ok() {\n  auto x = std::unique_ptr<Y>(new Y());\n  x.reset();\n}\n\nvoid destructor8_ok() {\n  auto x = std::unique_ptr<Y>(new Y());\n  x.reset(new Y());\n}\n\nint destructor0_bad() {\n  auto p = new int(5);\n  auto x = new std::unique_ptr<int>(p);\n  delete x;\n  // Should report a NPE here as p has been deallocated\n  return *p;\n}\n\nint destructor1_bad() {\n  auto p = new int(5);\n  { std::unique_ptr<int> x(p); }\n  // Should report a NPE here as p has been deallocated\n  return *p;\n}\n\nX destructor2_bad() {\n  auto p = new X();\n  { std::unique_ptr<X> x(p); }\n  // Should report a NPE here as p has been deallocated\n  return *p;\n}\n\nint destructor3_bad() {\n  auto x = std::unique_ptr<Y>(new Y());\n  x->leak(); // Should report a memory leak\n  return 0;\n}\n\nint destructor4_bad() {\n  auto x = std::unique_ptr<Y>(new Y());\n  x->leak(); // Should report a memory leak\n  x.reset();\n  return 0;\n}\n\nint destructor5_bad() {\n  auto x = std::unique_ptr<Y>(new Y());\n  x.reset(new Y());\n  x->leak(); // Should report a memory leak\n  return 0;\n}\n\n} // namespace destructor_unique_ptr\n"
    },
    {
      "testname": "unknown_functions.cpp",
      "testlanguage": "c++",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nstruct X {\n  ~X(){};\n  void foo();\n};\n\nvoid unknown_init_ptr_by_ref(X** x);\nvoid unknown_no_init_ptr(X* const* x); // cannot init because const\n\nvoid init_ok() {\n  X* p = nullptr;\n  unknown_init_ptr_by_ref(&p);\n  p->foo();\n}\n\nvoid const_no_init_bad() {\n  X* p = nullptr;\n  unknown_no_init_ptr(&p);\n  p->foo();\n}\n\nvoid unknown_init_value_by_ref(X** x);\n\nvoid wrap_unknown_init(X** x) { unknown_init_value_by_ref(x); }\n\nvoid call_unknown_init_interproc_ok() {\n  X* p = nullptr;\n  wrap_unknown_init(&p);\n  p->foo();\n}\n\nvoid unknown_with_pointer_formal(X* x);\n\nvoid wrap_unknown_no_init(X* x) { unknown_with_pointer_formal(x); }\n\nvoid call_init_with_pointer_value_bad() {\n  X* p = nullptr;\n  wrap_unknown_no_init(p);\n  p->foo();\n}\n"
    },
    {
      "testname": "unnecessary_copy.cpp",
      "testlanguage": "c++",
      "expected-problems": 248,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <algorithm>\n#include <assert.h>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"header.h\"\n\nstruct Arr {\n  int arr[2];\n  std::vector<int> vec;\n};\n\nArr& get_a_ref() {\n  static Arr a;\n  return a;\n}\n\nauto global = get_a_ref();\n\nint copy_decl_bad() {\n  auto a = get_a_ref(); // unnecessary copy, use a ref\n  // call to copy constructor Arr::Arr(a, n$0)\n  return a.arr[0];\n}\n\nint source_mod_ok() {\n  Arr source;\n  auto cpy = source;\n  source.arr[0] = 9; // source is modified, so copy is not unnecessary as we\n                     // can't just add &\n  return cpy.arr[0];\n}\n\nint source_mod_param_ok(Arr source) {\n  auto cpy = source;\n  source.arr[0] = 9; // source is modified, so copy is not unnecessary as we\n                     // can't just add &\n  return cpy.arr[0];\n}\n\nvoid copy_in_branch_bad(bool b) {\n  if (b) {\n    Arr a;\n    auto cpy = a;\n  }\n}\n\nvoid copy_in_branch_mod_ok(bool b) {\n  if (b) {\n    Arr a;\n    auto cpy = a;\n    cpy.arr[0] = 8;\n  }\n}\n\nvoid copy_outside_branch_mod_ok(bool b) {\n  Arr a;\n  auto cpy = a;\n  if (b) {\n    cpy.arr[0] = 8;\n  }\n}\n\nvoid multiple_copies_bad(bool b) {\n  Arr a;\n  auto cpy1 = a; // unnecessary copy\n  if (b) {\n    auto cpy2 = cpy1; // unnecessary copy\n  }\n}\n\nvoid modified_copy_decl_ok() {\n  auto a = get_a_ref();\n  a.arr[0] = 9; // copy modified here, it is not unnecessary\n}\n\n// Clang frontend doesn't properly translate array copy constructor\nvoid copy_via_constructor_bad_FN() {\n  auto my_arr = Arr{{1, 2}}; // call to constructor\n  auto c = my_arr; // copy\n  c.arr[0] = 9;\n}\n\nint get_first_elem(Arr a) { return a.arr[0]; }\n\nvoid copy_via_constructor_read_bad() {\n  auto my_arr = Arr{{1, 2}}; // call to constructor\n  auto cpy_arr = my_arr; // copy\n  get_first_elem(cpy_arr);\n}\n\nArr get_a() {\n  Arr a;\n  return a;\n}\n\nvoid set_to_zero(int arr[]) { arr[0] = 0; }\n\nvoid modified_interproc_copy_decl_ok() {\n  auto a = get_a_ref();\n  set_to_zero(a.arr); // copy modified here by callee, it is not unnecessary\n}\n\nvoid copy_vec_bad(std::vector<int> vec) { auto cpy_vec = vec; }\n\nvoid copy_vec_mod_ok(std::vector<int> vec) {\n  auto cpy_vec = vec;\n  cpy_vec.push_back(0);\n}\n\nclass Vec {\n\n public:\n  std::vector<int> vec;\n  std::list<Arr> my_list;\n\n  Vec() {\n    for (int i = 1; i <= 3; i++) {\n      vec.push_back(i);\n    }\n  }\n\n  Vec(const Vec& v) {\n    for (int i = 1; i <= 3; i++)\n      vec.push_back(v.get(i));\n  }\n\n  void setVec(std::vector<int> my_vec) { vec = std::move(my_vec); }\n\n  void intermediate_field_copy_ok() { setVec(vec); }\n\n  int get(int i) const { return vec[i]; }\n\n  void source_modified_via_unmodeled_ok() {\n    auto arr = my_list.front(); // result of unknown call on source is copied\n    my_list.pop_front();\n    // when checking for modifications, we need to check that arr is propagated\n    // from my_list which is modified\n  }\n\n  const std::vector<int>& get_const_ref() const { return vec; }\n};\n\nvoid copy_own_vec_bad() {\n  Vec vec;\n  auto copied_own_vec = vec; // copy\n}\n\nvoid call_get_const_ref_ok(const Vec& v) { auto& x = v.get_const_ref(); }\n\nvoid call_get_const_ref_bad(const Vec& v) { auto x = v.get_const_ref(); }\n\n// copy created only in one branch\nvoid loop_via_copy_bad(std::vector<std::string>& namesOfTheEntirePopulation) {\n  for (const auto name :\n       namesOfTheEntirePopulation) { // copies the name unnecessarily\n                                     // use const auto&\n  }\n}\n\n// as opposed to the above one, there is no copy here\nvoid loop_no_copy_ok(std::vector<std::string>& namesOfTheEntirePopulation) {\n  for (const auto& name : namesOfTheEntirePopulation) {\n  }\n}\n\nArr& get_cond_arr_ref(Arr& arr1, Arr& arr2, bool cond) {\n  if (cond) {\n    return arr1;\n  } else {\n    return arr2;\n  }\n}\n\nvoid copy_in_both_cases_bad(bool cond) {\n  Arr arr1;\n  Arr arr2;\n  auto cpy = get_cond_arr_ref(arr1, arr2, cond); // call to copy ctor\n}\n\n// We can't detect this case because we only keep track of one source\n// (arr's abstract value) but in two brances they point to two\n// different addresses, making us think that one of them is modified\nvoid copy_in_both_cases_aliasing_bad_FN(bool cond) {\n  Arr arr;\n  auto cpy = get_cond_arr_ref(arr, arr, cond); // call to copy ctor\n}\n\nvoid copy_in_both_cases_mod_ok(bool cond) {\n  Arr arr1;\n  Arr arr2;\n  auto cpy = get_cond_arr_ref(arr1, arr2, cond); // call to copy ctor\n  cpy.arr[0] = 9;\n}\n\nvoid copy_in_both_cases_source_mod_ok(bool cond) {\n  Arr arr1;\n  Arr arr2;\n  auto cpy = get_cond_arr_ref(arr1, arr2, cond); // call to copy ctor\n  arr1.arr[0] = 9;\n}\n\nvoid copy_in_both_cases_branch_bad(bool cond) {\n  Arr arr1;\n  Arr arr2;\n  auto cpy = get_cond_arr_ref(arr1, arr2, true); // call to copy ctor\n}\n\nvoid copy_modified_after_abort_ok(std::vector<int> source_vec) {\n  auto cpy = source_vec;\n  std::vector<int> vec(2);\n  int* elt = &vec[1];\n  vec.push_back(0);\n  int temp = *elt; // abort: vector invalidation, so non-disjunctive\n                   // value becomes top\n  cpy.push_back(0);\n}\n\nnamespace ns {\n\ntemplate <typename X>\nX creates_copy(X a) {\n  return X{a};\n}\n} // namespace ns\n\nvoid copy_via_model_bad(Arr arr) {\n  auto cpy = ns::creates_copy(arr); // creates copy (via model)\n}\n\nvoid source_modified_before_lib_destructor_ok(std::vector<int>& source_vec) {\n  auto cpy = source_vec;\n  source_vec[0] = 0;\n}\n\nvoid copy_modified_before_lib_destructor_ok(std::vector<int>& source_vec) {\n  auto cpy = source_vec;\n  cpy[0] = 0;\n}\n\nclass String {\n private:\n  char* text;\n  int size;\n\n public:\n  int x;\n  ~String() { delete[] text; } // destructor\n  void set_size(int new_size) { size = new_size; }\n};\n\nvoid check_before_custom_destructor_bad(String s) { auto cpy = s; }\n\nvoid modified_before_custom_destructor_ok(String s) {\n  auto cpy = s;\n  cpy.set_size(10);\n}\n\nint get_size(String s) { return s.x; }\nvoid check_no_move_op_bad(String arg) {\n  int x = get_size(std::move(arg)); // String has no auto-generated move\n                                    // constructor so there is no move here!\n}\n\nvoid copy_vec_name_contains_copy_ok(std::vector<int> vec) {\n  auto copy_vec = vec;\n} // variable contains \"copy\", hence warning should be suppressed\n\nvoid set_erase_ok(std::set<int> source) {\n  auto cpy = source;\n  cpy.erase(3); // unmodeled call assumes all non-const ptr args are modified\n}\n\nvoid source_const_fcn_bad(std::set<int> source) {\n  auto cpy = source;\n  int count =\n      source.count(3); // count is a const function which doesn't modify this*\n}\n\nvoid source_dispatch_const_fcn_bad(const std::set<int>& source) {\n  auto cpy = source;\n  auto it = source.find(3); // const find is dispatched since argument is const\n}\n\nvoid source_dispatch_non_const_fcn_bad(std::set<int> source) {\n  auto cpy = source;\n  auto it = source.find(3);\n}\n\nvoid iterator_ptr_modified_ok(const std::vector<int>& numbers) {\n  auto lDataValues = numbers;\n  std::sort(lDataValues.begin(), lDataValues.end());\n}\n\nstruct SimpleS {\n  int a;\n  std::vector<int> vec;\n};\n\nstruct SwapSimple {\n  SimpleS v;\n  void swap_bad_FN(SwapSimple& x) {\n    const auto temp = v;\n    v = x.v;\n    x.v = temp; // report copy assignment from const\n  }\n};\n\nstruct SwapVector {\n  std::vector<int> v;\n  void swap_bad_FN(SwapVector& x) {\n    const auto temp = v;\n    v = x.v;\n    x.v = temp; // report copy assignment from const\n  }\n};\n\nvoid capture_by_value_ok(SimpleS arg) {\n  auto f = [c = arg]() mutable { c.a = 19; };\n}\n\n// NOTE: Currently we do not support unnecessary capture-by-value in lambda.\nvoid capture_by_value_bad_FN(SimpleS arg) {\n  auto f = [c = arg]() { int n = c.a; };\n}\n\nvoid constructor_bad() {\n  std::vector<int> source;\n  auto cpy = source;\n}\n\n// We can't detect this due to aliasing problem when we analyze the source code\n// of shared ptr copy ctor\nvoid shared_ptr_bad_FN(std::shared_ptr<Arr> source) { auto c = source; }\n\nvoid copy_assignment_bad(std::set<int> source) {\n  std::set<int> init_set; // default constructor is called\n  init_set = source; // copy assignment operator is called\n}\n\nvoid copy_assignment_ok(std::set<int> source) {\n  std::set<int> init_set; // default constructor is called\n  init_set = source; // copy assignment operator is called\n  source.insert(1); // source modified\n}\n\nvoid move_assignment_ok(std::set<int> source) {\n  std::set<int> init_set; // default constructor is called\n  init_set =\n      std::move(source); // move assignment operator is called, no copy created\n}\n\nvoid get_rvalue_ref(std::set<int>&& x) {}\n\nvoid copy_and_move_bad(std::set<int> source) {\n  std::set<int> c = source;\n  get_rvalue_ref(std::move(c)); // We can move source without copy.\n}\n\nvoid copy_and_move_const_ref_ok(const std::set<int>& source) {\n  std::set<int> c = source;\n  get_rvalue_ref(std::move(c));\n}\n\nstruct TriviallyCopyable {\n  int a;\n  float f;\n  int* p;\n};\n\nvoid copy_trivially_copyable_ok(TriviallyCopyable source) {\n  TriviallyCopyable c = source;\n}\n\nclass WrapperArr {\n\n  explicit WrapperArr(const Arr& internal_arr) : hidden_arr_(internal_arr) {}\n\n  // unnecessary copy into hidden_arr_, it should be moved\n  explicit WrapperArr(Arr&& internal_arr) : hidden_arr_(internal_arr) {}\n\n  const Arr getArr() const { return hidden_arr_; }\n\n private:\n  Arr hidden_arr_;\n\n  void unnecessary_copy_moveable_bad(Arr&& a) {\n    hidden_arr_ = a;\n    hidden_arr_.arr[0] = 9; // it is ok that the copy is modified since it has\n                            // the ownership of the object.\n  }\n\n  void unnecessary_copy_moveable_source_mod_ok(Arr&& a) {\n    hidden_arr_ = a;\n    a.arr[0] = 9; // we cannot suggest move above as source is modified\n  }\n\n  void unnecessary_copy_moveable_copy_mod_bad(Arr&& a) {\n    hidden_arr_ = a;\n    hidden_arr_.arr[0] = 9; // copy can be modified since it will have the\n                            // ownership of the object.\n  }\n\n  void copy_assignment_from_this_ok() {\n    Arr local_arr; // default constructor is called\n    local_arr = hidden_arr_; // copy assignment operator is called but it is\n                             // from a member field which cannot be moved.\n  }\n};\n\nnamespace my_proj {\nstruct CheapToCopy {\n  std::vector<int> vec;\n};\n\nvoid cheap_to_copy_ok(CheapToCopy source) { auto c = source; }\n}; // namespace my_proj\n\nvoid unnecessary_copy_initializer_list(std::vector<int> c1,\n                                       std::vector<int> c2) {\n  for (const auto& c : {c1, c2}) {\n  }\n  // fix here is not to add & but use ptrs\n  // for (const auto* c : { &c1, &c2 }) // use *c\n}\n\nclass LockedPtr {};\n\nclass MyValueOr {\n  bool b;\n  Arr& value;\n  std::shared_ptr<Arr> shared_ptr;\n  LockedPtr lock();\n  LockedPtr rlock();\n\n public:\n  MyValueOr();\n\n  Arr value_or(const Arr& default_value) const {\n    if (b) {\n      return value;\n    } else {\n      return default_value;\n    }\n  }\n\n  Arr get_arr_implicit_cpy() const { return get_a_ref(); }\n\n  std::shared_ptr<Arr> cpy_shared_ptr() const { return shared_ptr; }\n\n  Arr intentional_copy() const { return get_a_ref(); }\n\n  Arr intentional_cpy_under_lock() {\n    auto l = lock();\n    return value;\n  }\n\n  Arr intentional_cpy_under_rlock_ok() {\n    auto l = rlock();\n    auto result = value;\n    return result;\n  }\n\n  Arr no_cpy_NRVO() const {\n    Arr x;\n    return x;\n  }\n\n  void suppress_intentional_cpy_under_lock(Arr src) {\n    auto l = lock();\n    auto tgt = src;\n  }\n};\n\nvoid call_value_or_bad(const MyValueOr& c) {\n  const static Arr f{};\n  Arr g = c.value_or(f);\n}\n\nvoid call_value_or_ok(const MyValueOr& c) {\n  const static Arr f{};\n  Arr g = c.value_or(f);\n  g.arr[0] = 42;\n}\n\nvoid call_get_arr_implicit_cpy_bad(const MyValueOr& c) {\n  Arr g = c.get_arr_implicit_cpy();\n}\n\nvoid call_cpy_shared_ptr_ok(const MyValueOr& c) { auto g = c.cpy_shared_ptr(); }\n\nvoid call_intentional_copy_ok(const MyValueOr& c) {\n  auto g = c.intentional_copy();\n}\n\nvoid call_intentional_cpy_under_lock_ok(MyValueOr c) {\n  auto g = c.intentional_cpy_under_lock();\n}\n\nvoid call_no_cpy_NRVO_ok(const MyValueOr& c) { auto g = c.no_cpy_NRVO(); }\n\nclass ClassWithoutConstructDef {\n  int __internal_field;\n  std::vector<int> __internal_vec;\n\n  // we should detect copy assignment and suggest a move into the field\n  void field_setter_bad(std::vector<int> vec) {\n    __internal_vec = vec; // copy assignment\n  }\n\n public:\n  ClassWithoutConstructDef(const ClassWithoutConstructDef& src);\n  int* get_field_ref() { return &__internal_field; }\n};\nvoid assign_value_unknown(int* ref, int v);\n\nvoid modify_by_unknown_ok(const ClassWithoutConstructDef& src) {\n  ClassWithoutConstructDef tgt = src;\n  assign_value_unknown(tgt.get_field_ref(), 42);\n}\n\nvoid call_unknown_constructor_twice_ok(const ClassWithoutConstructDef& src) {\n  ClassWithoutConstructDef tgt = src;\n  assign_value_unknown(tgt.get_field_ref(), 42);\n  ClassWithoutConstructDef dummy = tgt;\n  assign_value_unknown(dummy.get_field_ref(), 42);\n}\n\n#define LOCAL_MACRO(accessor) \\\n  { auto cpy = (accessor); }\n\nvoid foo(std::vector<int> my_vec) { LOCAL_MACRO(my_vec); }\n\nclass CopiedToField1_Bad {\n  Arr field;\n\n public:\n  CopiedToField1_Bad(Arr a) : field(a) {}\n};\n\nclass CopiedToField1_Ok {\n  Arr field;\n\n public:\n  CopiedToField1_Ok(Arr a) : field(std::move(a)) {}\n};\n\nclass CopiedToField2_Bad {\n  Arr field;\n\n public:\n  CopiedToField2_Bad(Arr a) { field = a; }\n};\n\nclass CopiedToField2_Ok {\n  Arr field;\n\n public:\n  CopiedToField2_Ok(Arr a) { field = std::move(a); }\n};\n\nstruct Arrs {\n  Arr a;\n  Arr b;\n};\n\nclass CopiedToField3_Last_Bad {\n  Arrs field1;\n  Arr field2;\n\n public:\n  // last copy could be avoided\n  CopiedToField3_Last_Bad(Arrs as) {\n    field1 = as;\n    field2 = as.a;\n  }\n};\n\nclass PassedToUnknown_Bad {\n  Arr field;\n\n  static void unknown(Arr a);\n\n public:\n  PassedToUnknown_Bad(Arr a) { unknown(a); }\n};\n\nclass PassedToUnknown_Ok {\n  Arr field;\n\n  static void unknown(Arr a);\n\n public:\n  PassedToUnknown_Ok(Arr a) { unknown(std::move(a)); }\n};\n\nclass PassedToUnknownRef_Bad {\n  Arr field;\n\n  static void unknown(const Arr& a);\n\n public:\n  // Ideally, the parameter can be changed to const-ref, but this pattern is not\n  // common in practice. The test is just for showing checker's behavior.\n  PassedToUnknownRef_Bad(Arr a) { unknown(a); }\n};\n\nclass CopiedToMultipleField_Last_Bad {\n  Arr field1;\n  Arr field2;\n\n public:\n  // Ideally, the last copy can be avoided by std::move, but this pattern is not\n  // common in practice. The test is just for showing checker's behavior.\n  CopiedToMultipleField_Last_Bad(Arr a) : field1(a), field2(a) {}\n};\n\nvoid global_setter_ok(const Arr& arr) {\n  global = arr; // don't suggest std::move(arr) due to const\n}\n\nvoid modify_arg(std::vector<int> arg) { arg.push_back(42); }\n\nvoid intermediate_copy_modified_unused_bad(std::vector<int> input) {\n  modify_arg(input); // copy from input to an intermediate which is modified\n  // input is never used so it is ok to suggest move\n}\n\nint intermediate_copy_modified_used_ok(std::vector<int> input) {\n  modify_arg(input); // copy from input to an intermediate which is modified\n  return input.size(); // input is used, we can't trivially suggest move without\n                       // also moving its uses to before the copy is made which\n                       // might hurt performance if accesses are conditional.\n                       // Better don't report.\n}\n\nvoid intermediate_copy_modified_local_unused_bad() {\n  std::vector<int> input = {0};\n  input.push_back(1);\n  modify_arg(input); // copy from input to an intermediate which is modified\n  // input is never used so it is ok to suggest move\n}\n\nint intermediate_copy_modified_local_used_ok() {\n  std::vector<int> input = {0};\n  modify_arg(input); // copy from input to an intermediate which is modified\n  return input[0];\n}\n\nint intermediate_local_copy_used_ok() {\n  Arr input;\n  int x = get_first_elem(input); // copy from input to an intermediate\n  input.arr[0] = 0; // can't suggest moving input as it is used\n  return x;\n}\n\nvoid copy_assignment_const_ref_member_ok(const Arr& arr) {\n  std::vector<int> my_vec;\n  my_vec = arr.vec;\n}\n\nvoid copy_assignment_const_value_param_bad(const Arr arr) {\n  Arr my_arr;\n  my_arr = arr; // fix here is to remove const from param type\n}\n\nvoid copy_assignment_const_ref_param_ok(const Arr& arr) {\n  Arr my_arr;\n  const Arr& c = arr;\n  my_arr = c;\n}\n\nint intermediate_copy_assignment_const_ref_ok(const Arr& arr) {\n  const auto& c = arr;\n  return get_first_elem(c);\n}\n\nint intermediate_copy_assignment_const_value_bad(const Arr arr) {\n  return get_first_elem(arr); // fix here is to remove const from param type\n}\n\nstruct Wrapper {\n  Arr my_field;\n  const Arr& get_const_ref();\n\n  void intermediate_const_ref_callee_ok() { get_first_elem(get_const_ref()); }\n\n  void assignment_const_ref_ok() { my_field = get_const_ref(); }\n};\nclass FVector {\n\n  FVector(FVector const& rhs) {\n    table_ = rhs.table_; // don't report on copy ctors\n  }\n\n  FVector& operator=(FVector const& rhs) {\n    if (this != &rhs) {\n      table_ = rhs.table_; // don't report on copy ctors\n    }\n    return *this;\n  }\n\n protected:\n  std::vector<int> table_;\n};\n\nvoid call_templated_func_specialized_int(const std::vector<int>& arg) {\n  copy_in_header_bad(arg);\n}\n\nvoid call_templated_func_specialized_string(\n    const std::vector<std::string>& arg) {\n  copy_in_header_bad(arg);\n}\n\nclass NonTrivialCopyClass {\n\n public:\n  NonTrivialCopyClass& operator=(const NonTrivialCopyClass& rhs) {\n    if (this == &rhs) {\n      return *this;\n    }\n    return *this;\n  }\n\n private:\n  long my_int1_;\n  long my_int2_;\n};\n\nclass NonTrivialCopySmallClass {\n public:\n  NonTrivialCopySmallClass& operator=(const NonTrivialCopySmallClass& rhs) {\n    if (this == &rhs) {\n      return *this;\n    }\n    return *this;\n  }\n\n private:\n  int my_int1_;\n};\n\nclass FieldCopyClass {\n\n public:\n  Arr my_arr1_;\n  Arr my_arr2_;\n  NonTrivialCopyClass nt_;\n  NonTrivialCopySmallClass nt_small_;\n\n  void set_field_ok(Arr arg) {\n    my_arr1_ = my_arr2_; // rhs is a field, we cannot suggest move\n  }\n\n  void copy_assign_bad(NonTrivialCopyClass arg) { nt_ = arg; }\n\n  void copy_assign_small_ok(NonTrivialCopySmallClass arg) { nt_small_ = arg; }\n\n  void copy_assign_from_global_ok() {\n    my_arr1_ = global; // rhs is a global, we cannot suggest move\n  }\n\n  FieldCopyClass* getPtr() { return this; }\n  void copy_assign_from_this_pointed_ok() {\n    auto t = getPtr();\n    my_arr1_ = t->my_arr1_;\n  }\n};\n\nvoid intermediate_copy_global_ok() {\n  get_first_elem(global); // we cannot suggest moving global\n}\n\nclass CopyConstructGlobalOk {\n  Arr my_arr;\n\n public:\n  CopyConstructGlobalOk() : my_arr(global) {}\n};\n\nvoid copy_from_global_bad(bool b) { auto x = b ? global : global; }\n\nclass CopyConstructFromRefOk {\n  Arr my_arr;\n\n public:\n  CopyConstructFromRefOk(Arr& arr) : my_arr(arr) {}\n};\n\nclass CopyConstructFromRefBad1 {\n  Arr my_arr;\n\n public:\n  CopyConstructFromRefBad1(Arr arr) : my_arr(arr) {}\n};\n\nclass CopyConstructFromRefBad2 {\n  Arr my_arr;\n\n public:\n  CopyConstructFromRefBad2(Arr&& arr) : my_arr(arr) {}\n};\n\nstd::map<std::string, std::string> unreliable_source_ok(\n    const std::map<std::string, std::string>& input) {\n  auto modified = input; // the source of `modified` was `input` in the copy map\n  for (const auto& elem : input) {\n    modified[elem.first] = \"abc\";\n  }\n  return modified;\n  // the source of `modified` was `__range` from the for loop iteration, thus it\n  // did not correctly check `modified` is modified.\n}\n\nvoid copy_assignment_from_lvalue_ref_ok_intermediate_bad(std::string& str,\n                                                         Arr arr) {\n  std::string s;\n  s = str; // no report here since we can't safely move str without affecting\n           // callees\n  int res = get_first_elem(arr); // we still wanna report here\n}\n\nvoid normal_copy_from_lvalue_ref_bad(std::string& str) {\n  auto f = str; // still report here\n}\n\nvoid intermediate_copy_from_lvalue_ref_ok(Arr& arr) {\n  get_first_elem(arr); // don't report since we can't safely move str without\n                       // affecting callees\n}\n\nvoid intermediate_copy_from_pointer_ok(Arr* arr) { get_first_elem(*arr); }\n\nstd::string unknown_modification_twice_ok(std::string p) {\n  std::string path = p;\n  std::replace(path.begin(), path.end(), '\\\\', '/');\n  return path;\n}\n\nvoid assert_false(\n    const std::string& s) { // summary for this results in 0 disjuncts\n  assert(false);\n};\n\nstruct NonDisjJoin_ok {\n\n  NonDisjJoin_ok(std::string myStr, int k) : NonDisjJoin_ok(myStr) {\n    if (k > 0) {\n      assert_false(myStr);\n    } // here we were joining 0 disjuncts (with NonDisj.bottom) with Foo(myStr)\n    // which resulted in ignoring the read of myStr in the conditional. Fixed\n    // now.\n  }\n\n  NonDisjJoin_ok(std::string s) {}\n};\n\nstruct NonDisjJoinLoop_ok_FP {\n\n  NonDisjJoinLoop_ok_FP(std::string myStr, int k)\n      : NonDisjJoinLoop_ok_FP(myStr) {\n    for (int i = 0; i < k; i++) {\n      assert_false(myStr);\n    } // still doesn't work. TODO\n  }\n\n  NonDisjJoinLoop_ok_FP(std::string s) {}\n};\n\nstruct Ptr {\n  int* ptr;\n  std::vector<int> vec;\n};\n\nPtr* get_unknown_ptr_field();\n\nPtr global_ptr;\nclass UnownedTest {\n  Arr field;\n  Ptr ptr_field;\n  std::vector<int> vec_field;\n  int* ptr;\n\n  void copy_assignment_points_to_global_ok() {\n    auto& ref = global;\n    field = ref; // we can't suggest moving here\n  }\n\n  void copy_assignment_copy_of_global_bad() {\n    auto ref = global;\n    field = ref; // moving is ok here\n  }\n\n  Arr* get_global_ptr() { return &global; }\n\n  void copy_assignment_via_callee_points_to_global_ok() {\n    auto& ref = get_global_ptr()->vec;\n    vec_field = ref; // we can't suggest moving here\n  }\n\n  void copy_assignment_points_to_ref_param_ok(Arr& param) {\n    auto& ref = param;\n    field = ref; // we can't suggest moving here\n  }\n\n  void intermediate_copy_points_to_global_ok() {\n    auto& ref = global;\n    get_first_elem(ref);\n  }\n\n  void intermediate_copy_copy_of_global_bad() {\n    auto ref = global;\n    get_first_elem(ref); // ok to move here\n  }\n\n  void intermediate_copy_via_callee_points_to_global_ok() {\n    auto& ref = get_global_ptr()->vec;\n    modify_arg(ref); // we can't suggest moving here\n  }\n\n  void intermediate_copy_points_to_ref_param_ok(Arr& param) {\n    auto& ref = param;\n    get_first_elem(ref);\n  }\n\n  void copy_assignment_copy_ptr_bad() {\n    Ptr c{};\n    c.ptr = global_ptr.ptr;\n    ptr_field = c; // ok to move here\n  }\n\n  void copy_assign_from_unknown_ok() { ptr_field = *get_unknown_ptr_field(); }\n};\n\nstruct ArrWrap {\n  Arr arr;\n};\n\nvoid captured_by_ref_ok() {\n  Arr x;\n  auto _ = [&]() {\n    ArrWrap y;\n    y.arr = x;\n    return y;\n  };\n  x.arr[0] = 42;\n}\n"
    },
    {
      "testname": "use_after_delete.cpp",
      "testlanguage": "c++",
      "expected-problems": 26,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n#include <string>\n#include <vector>\n\nstruct Simple {\n  int f;\n};\n\nvoid deref_deleted_bad() {\n  auto* s = new Simple{1};\n  delete s;\n  Simple tmp = *s;\n}\n\n// could be ok depending on what the caller does\nSimple* return_deleted_ok() {\n  auto s = new Simple{1};\n  delete s;\n  return s;\n}\n\nSimple* reassign_deleted_ok() {\n  auto s = new Simple{1};\n  delete s;\n  s = new Simple{2};\n  return s;\n}\n\nvoid reassign_field_of_deleted_bad() {\n  auto s = new Simple{1};\n  delete s;\n  s->f = 7;\n}\n\nvoid reassign_field_of_reinitialized_ok(Simple* tmp) {\n  auto s = new Simple{1};\n  delete s;\n  s = tmp;\n  s->f = 7;\n}\n\nvoid double_delete_bad() {\n  auto s = new Simple{1};\n  delete s;\n  delete s;\n}\n\nvoid delete_in_branch_bad(bool b) {\n  auto s = new Simple{1};\n  if (b) {\n    delete s;\n  }\n  s->f = 7;\n  // avoid leak\n  if (!b) {\n    delete s;\n  }\n}\n\nvoid delete_in_branch_ok(bool b) {\n  auto s = new Simple{1};\n  if (b) {\n    delete s;\n  } else {\n    delete s;\n  }\n}\n\nvoid use_in_branch_bad(bool b) {\n  auto s = new Simple{1};\n  delete s;\n  if (b) {\n    auto tmp = *s;\n  }\n}\n\nvoid delete_in_loop_bad() {\n  auto s = new Simple{1};\n  for (int i = 0; i < 10; i++) {\n    delete s;\n  }\n}\n\nvoid delete_in_loop_ok() {\n  for (int i = 0; i < 10; i++) {\n    auto s = new Simple{1};\n    delete s;\n  }\n}\n\nvoid delete_ref_in_loop_ok(int j, std::vector<std::string> v) {\n  for (int i = 0; i < 10; i++) {\n    auto s = &v[i];\n    delete s;\n  }\n}\n\nvoid use_in_loop_bad() {\n  auto s = new Simple{1};\n  delete s;\n  for (int i = 0; i < 10; i++) {\n    s->f = i;\n  }\n}\n\nvoid gated_delete_abort_ok(bool b) {\n  auto s = new Simple{1};\n  if (b) {\n    delete s;\n    std::abort();\n  }\n  s->f = 7;\n  // avoid leak\n  if (!b) {\n    delete s;\n  }\n}\n\nvoid gated_exit_abort_ok(bool b) {\n  auto s = new Simple{1};\n  if (b) {\n    delete s;\n    exit(1);\n  }\n  s->f = 7;\n  // avoid leak\n  if (!b) {\n    delete s;\n  }\n}\n\nvoid gated_delete_throw_ok(bool b) {\n  auto s = new Simple{1};\n  if (b) {\n    delete s;\n    throw 5;\n  }\n  s->f = 7;\n  // avoid leak\n  if (!b) {\n    delete s;\n  }\n}\n\nvoid delete_allocated_then_error_bad(int* x) {\n  *x = 42;\n  delete x;\n  *x = 0;\n}\n\nvoid null_call_delete_allocated_then_error_bad(int* x) {\n  delete_allocated_then_error_bad(nullptr);\n}\n\nstruct Nested {\n  Simple s;\n};\n\nvoid access_field_after_delete_bad() {\n  auto x = new Nested();\n  int* p = &x->s.f;\n  delete (x);\n  *p = 42;\n}\n"
    },
    {
      "testname": "use_after_destructor.cpp",
      "testlanguage": "c++",
      "expected-problems": 52,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <iostream>\n#include <memory>\n#include <string>\n\nnamespace use_after_destructor {\n\nstruct S {\n  int* f;\n  S(int i) {\n    f = new int;\n    *f = i;\n  }\n\n  // missing: operator= to copy the pointer. double delete can happen if\n  // operator= is called\n\n  ~S() { delete f; }\n\n  void reinit(S s) {\n    f = new int;\n    *f = *(s.f);\n  }\n};\n\n// destructor called at end of function, no issues\nvoid normal_scope_destructor_ok() { S s(1); }\n\nvoid nested_scope_destructor_ok() {\n  { S s(1); }\n}\n\nint reinit_after_explicit_destructor_ok() {\n  S s(1);\n  s.~S();\n  s.reinit(S(2));\n  return *s.f;\n}\n\nint reinit_after_explicit_destructor_bad() {\n  S s(1);\n  s.~S();\n  s = S(2); // a temporary is created then operator= is called\n  return *s.f;\n}\n\nint reinit_after_explicit_destructor2_bad() {\n  S s(1);\n  S s2(2);\n  s.~S();\n  s = s2; // operator=\n  return *s.f;\n  // [s2.f] is [s.f] so gets deleted twice\n}\n\nvoid placement_new_explicit_destructor_ok() {\n  char buf[sizeof(S)];\n  {\n    S* s = new (buf) S(1);\n    s->~S();\n  }\n  {\n    // this use of [buf] shouldn't be flagged\n    S* s = new (buf) S(2);\n    s->~S();\n  }\n}\n\nvoid double_destructor_bad() {\n  S s(1);\n  s.~S();\n  // destructor will be called again after S goes out of scope, which is\n  // undefined behavior\n}\n\nint use_after_destructor_bad() {\n  S s(1);\n  s.~S();\n  int ret = *s.f;\n  s = S{2};\n  return ret;\n}\n\n// S::operator= doesn't copy resources correctly\nvoid use_after_scope1_bad() {\n  S s(1);\n  {\n    S tmp(2);\n    s = tmp; // translated as operator=(s, tmp)\n  } // destructor for tmp runs here\n  // destructor for s here; second time the value held by s has been destructed\n}\n\n// same as above\nvoid use_after_scope2_bad() {\n  S s(1);\n  { s = S(1); }\n}\n\nstruct POD {\n  int f;\n};\n\n// this code is ok since double-destructing POD struct is ok\nvoid destruct_twice_ok() {\n  POD p{1};\n  {\n    POD tmp{2};\n    p = tmp;\n  } // destructor for tmp\n} // destructor for p runs here, but it's harmless\n\nclass Subclass : virtual POD {\n  int* f;\n  Subclass() { f = new int; }\n\n  /** frontend code for this destructor will be:\n   * ~Subclass:\n   *  __infer_inner_destructor_~Subclass(this)\n   *  __infer_inner_destructor_~POD(this)\n   *\n   * __infer_inner_destructor_~Subclass:\n   *  delete f;\n   *\n   * We need to be careful not to warn that this has been double-destructed\n   */\n  ~Subclass() { delete f; }\n};\n\nvoid basic_placement_new_ok() {\n  S* ptr = new S(1);\n  ptr->~S();\n  S* tptr = new (ptr) S(1);\n  delete tptr;\n}\n\n// the correct code is shown in basic_placement_new_ok()\nvoid placement_new_wrong_order_bad() {\n  S* ptr = new S(1);\n  S* tptr = new (ptr) S(1); // leaking ptr->f\n  tptr->~S();\n  delete ptr; // deleting tptr->f again because of the aliasing induced by\n              // placement new\n}\n\nint* destruct_pointer_contents_then_placement_new1_ok(S* s) {\n  s->~S();\n  new (s) S(1);\n  return s->f;\n}\n\nint* destruct_pointer_contents_then_placement_new2_ok(S* s) {\n  s->~S();\n  new (&(s->f)) S(1);\n  return s->f;\n}\n\nint* placement_new_aliasing1_bad() {\n  S* s = new S(1);\n  s->~S();\n  auto alias = new (s) S(2);\n  delete alias; // this deletes s too\n  return s->f; // bad, accessing freed memory\n}\n\nint* placement_new_aliasing2_bad() {\n  S* s = new S(1);\n  s->~S();\n  auto alias = new (s) S(2);\n  delete s; // this deletes alias too\n  return alias->f; // bad, accessing freed memory\n}\n\nint* placement_new_aliasing3_bad() {\n  S* s = new S(1);\n  s->~S();\n  S* alias = s;\n  auto alias_placement = new (s) S(2);\n  delete s; // this deletes alias too\n  return alias->f; // bad, accessing freed memory\n}\n\nvoid placement_new_non_var_ok() {\n  struct M {\n    S* s;\n  } m;\n  m.s = new S(1);\n  m.s->~S();\n  new (m.s) S(2);\n  delete m.s;\n}\n\nS* return_placement_new_ok() {\n  auto mem = new S(1);\n  mem->~S();\n  return new (mem) S(2);\n}\n\nvoid destructor_in_loop_ok() {\n  for (int i = 0; i < 10; i++) {\n    S s(1);\n  }\n}\n\nint FN_use_after_scope3_bad() {\n  int* p;\n  {\n    int value = 3;\n    p = &value;\n  } // we do not know in the plugin that value is out of scope\n  return *p;\n}\n\nstruct C {\n  C(int v) : f(v){};\n  ~C();\n  int f;\n};\n\nint use_after_scope4_bad() {\n  C* pc;\n  {\n    C c(3);\n    pc = &c;\n  }\n  return pc->f;\n}\n\nstruct B {\n  ~B();\n};\n\nstruct A {\n  ~A() { (void)*f; }\n  const B* f;\n};\n\nvoid FN_destructor_order_bad() {\n  A a;\n  B b;\n  a.f = &b;\n}\n\nstruct A2 {\n  ~A2() {}\n  const B* f;\n};\n\nvoid destructor_order_empty_destructor_ok() {\n  A2 a;\n  B b;\n  a.f = &b;\n}\n\nstd::string mk_string();\n\nvoid variable_init_ternary_ok(bool b) {\n  // this can cause issues because of the way the frontend treatment of ternary\n  // ?: interacts with the treatment of passing return values by reference as\n  // parameters\n  std::string newPath = b ? \"\" : mk_string();\n}\n\nvoid move_data(POD* from, POD* to);\n\nstruct Moveable {\n  Moveable() = default;\n  Moveable(const Moveable&) = delete; // not copyable\n\n  // move constructor\n  Moveable(Moveable&& that) noexcept { move_data(&that.data, &data); }\n\n  Moveable& operator=(Moveable&& that) noexcept {\n    this->~Moveable();\n    ::new (this) Moveable(std::move(that));\n    return *this;\n  }\n\n  ~Moveable() {}\n\n  Moveable& operator=(const Moveable&) = delete;\n\n  POD data;\n};\n\nvoid move_moveable_ok(Moveable& src) {\n  Moveable x;\n  x = std::move(src);\n}\n\nvoid placement_new_nothrow_ok() {\n  std::unique_ptr<int> p1(new (std::nothrow) int);\n  std::unique_ptr<int> p2(new (std::nothrow) int);\n}\n} // namespace use_after_destructor\n"
    },
    {
      "testname": "use_after_free.cpp",
      "testlanguage": "c++",
      "expected-problems": 29,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nint use_after_free_simple_bad(int* x) {\n  free(x);\n  return *x;\n}\n\nvoid double_free_simple_bad(int* x) {\n  free(x);\n  free(x);\n}\n\nint* global_pointer;\n\nvoid free_global_pointer_ok() { free(global_pointer); }\n\nvoid double_free_global_bad() {\n  free_global_pointer_ok();\n  free_global_pointer_ok();\n}\n\nvoid free_null_then_deref_bad() {\n  int* x = NULL;\n  free(x);\n  *x = 1;\n}\n\nvoid assumed_aliasing_latent(int* x, int* y) {\n  if (x == y) {\n    free(x);\n    free(y);\n  }\n}\n\nvoid trigger_assumed_aliasing_bad(int* x) { assumed_aliasing_latent(x, x); }\n\nvoid assumed_aliasing2_latent(int* x, int* y) {\n  if (x == y)\n    ;\n  free(x);\n  free(y);\n}\n\nvoid trigger_assumed_aliasing2_bad(int* x) { assumed_aliasing2_latent(x, x); }\n\nvoid assumed_aliasing3_latent(int* x, int* y) {\n  free(x);\n  if (x == y)\n    ;\n  free(y);\n}\n\nvoid trigger_assumed_aliasing3_bad(int* x) { assumed_aliasing3_latent(x, x); }\n\nvoid FN_assumed_aliasing4_latent(int* x, int* y) {\n  free(x);\n  free(y);\n  // we create the x==y case too late: x|->- * y|->- is already in the\n  // state so adding x==y creates a contradition\n  if (x == y)\n    ;\n}\n\nvoid FN_trigger_assumed_aliasing4_bad(int* x) {\n  FN_assumed_aliasing4_latent(x, x);\n}\n"
    },
    {
      "testname": "use_after_scope.cpp",
      "testlanguage": "c++",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stddef.h>\n#include <string>\n#include <utility>\n\nvoid invalidate_local_ok(int** pp) {\n  int t = 0xdeadbeef;\n  *pp = &t; // <-- potential bug here since t goes out of scope\n}\n\nvoid access_out_of_scope_stack_ref_bad() {\n  int* p = NULL;\n  invalidate_local_ok(&p);\n  int k = *p; // accessing invalid\n}\n\nvoid no_access_out_of_scope_stack_ref_ok() {\n  int* p = NULL;\n  invalidate_local_ok(&p);\n  // p is not accessed, hence ok\n}\n\nstd::pair<std::string, int> return_make_pair() {\n  std::string s = \"abc\";\n  return std::make_pair(s, 42);\n}\n\nstd::string make_pair_first_ok() { return return_make_pair().first; }\n"
    },
    {
      "testname": "use_global.cpp",
      "testlanguage": "c++",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"global.h\"\n\nvoid use_global_ok() {\n  set_global_42();\n  if (g != 42) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "values.cpp",
      "testlanguage": "c++",
      "expected-problems": 46,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <stdlib.h>\n\nvoid error_under_true_conditionals_bad(int* x) {\n  if (1) {\n    free(x);\n  }\n  if (2 == 2) {\n    *x = 42;\n  }\n}\n\nvoid simple_infeasible_error_path_ok(int* x) {\n  free(x);\n  if (0 == 1) {\n    *x = 42;\n  }\n\n  int y = 0;\n  if (y == 1) {\n    *x = 42;\n  }\n  if (y) {\n    *x = 42;\n  }\n  if (y != 0) {\n    *x = 42;\n  }\n  if (!(y == 0)) {\n    *x = 42;\n  }\n  if (!(!(y != 0))) {\n    *x = 42;\n  }\n  if (!(!(!(0 == y)))) {\n    *x = 42;\n  }\n}\n\nvoid free_if(int* x, int b) {\n  if (b) {\n    free(x);\n  }\n}\n\nvoid no_free_if_ok(int* x) {\n  free_if(x, 0);\n  *x = 42;\n}\n\nvoid free_if_deref_bad(int* x) {\n  free_if(x, 1);\n  *x = 42;\n}\n\nvoid infeasible_tricky_ok(int* x) {\n  free_if(x, 1);\n  int y = 42;\n  if (2 * y != y << 1) {\n    free(x);\n    *x = 42;\n  }\n}\n\nint minus(int x, int y) { return x - y; }\n\nvoid function_call_infeasible_error_path_ok(int* x) {\n  free(x);\n  if (minus(0, 0) < 0) {\n    *x = 42;\n  }\n}\n\n// somewhat like folly::Range<char const*>\nstruct StringRange {\n  char const *b_, *e_;\n  StringRange() : b_(), e_(){};\n  char const* data() const { return b_; }\n  size_t size() const { return size_t(e_ - b_); }\n};\n\nvoid function_empty_range_ok() {\n  StringRange x{};\n  auto b = x.data(), past = x.data() + x.size();\n  for (;; ++b) {\n    if (b >= past) {\n      return;\n    }\n    if (*b != ' ') {\n      break;\n    }\n  }\n}\n\nvoid find_first_non_space(StringRange& x) {\n  auto b = x.data(), past = x.data() + x.size();\n  for (;; ++b) {\n    if (b >= past) {\n      return;\n    }\n    if (*b != ' ') {\n      break;\n    }\n  }\n}\n\nvoid function_empty_range_interproc_ok() {\n  StringRange x{};\n  find_first_non_space(x);\n}\n\n// arithmetic on integers does not wrap around but ignores too-large\n// values. However, somehow the FP is gone for other reasons.\nvoid int_over_cap_ok() {\n  unsigned long one = 1;\n  // 2^(63+63+3) + 2*2^(63+3) + 1*8 = 2^129 + 2^67 + 8 = 8 mod 2^64\n  // this is convoluted to escape various simplifications from Z that would\n  // avoid the false positive\n  unsigned long x = ((one << 62) * 2 + 1) * ((one << 62) * 2 + 1) * 8;\n  unsigned long y = ((one << 62) * 2 + 1) * ((one << 62) * 2 + 1) * 8;\n  // - x == y+1 is true in \"Formulas\" because x = y = Q.undef, but not true in\n  //   inferbo intervals because they keep arbitrary precision integers\n  // - x != 8 is not true in Formulas but true in inferbo\n  // - In C both of these would be false, so overall we get a false positive\n  if (x == y + 1 || x != 8) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid int_under_cap_ok() {\n  unsigned long one = 1;\n  // 2^63\n  unsigned long x = (one << 62) * 2;\n  if (x != 9223372036854775808UL) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n// used to confuse inferbo\nint mult(int x, int y) { return x * y; }\n\nvoid ints_are_not_rationals_ok() {\n  int x = 5 / 2;\n  if (x != mult(2, 1)) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\nvoid shift_equal_mult_by_power_of_two_ok(int x) {\n  if (x << 1 != mult(2, x)) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wshift-count-overflow\"\nvoid shift_by_too_much_ok(int x) {\n  if (x << 64 != 0 || x >> 4000 != 0) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n#pragma clang diagnostic pop\n\nvoid interproc_mult_ok(int v, int w) {\n  if (mult(32, 52) != 1664 || mult(10, v) != 10 * v || mult(v, w) != v * w) {\n    int* p = nullptr;\n    *p = 42;\n  }\n}\n"
    },
    {
      "testname": "vector.cpp",
      "testlanguage": "c++",
      "expected-problems": 135,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <iostream>\n#include <vector>\n#include <memory>\n\nstruct Vector {\n  std::vector<std::unique_ptr<int>> u_vector;\n  std::vector<std::shared_ptr<int>> s_vector;\n  int add(std::unique_ptr<int> u_ptr) {\n    u_vector.push_back(std::move(u_ptr));\n    return 0;\n  }\n  int add(std::shared_ptr<int> s_ptr) {\n    s_vector.push_back(s_ptr);\n    return 0;\n  }\n  static Vector* getInstance() {\n    static Vector instance;\n    return &instance;\n  }\n};\n\n// missing a more precise model for vector::push_back\nint push_back0_ok(int* value) {\n  std::unique_ptr<int> ptr(value);\n  Vector* v = Vector::getInstance();\n  v->add(std::move(ptr));\n  // value should not be deallocated: it is owned by the first element of\n  // u_vector\n  return *value;\n}\n\n// missing a more precise model for vector::push_back\nint FP_push_back1_ok(int* value) {\n  {\n    std::shared_ptr<int> ptr(value);\n    Vector* v = Vector::getInstance();\n    v->add(ptr);\n  }\n  // value should not be deallocated: it is owned by the first element of\n  // s_vector\n  return *value;\n}\n\nint push_back0_bad() {\n  std::vector<int> v;\n  int n = 42;\n  v.push_back(n);\n  if (v.back() == 42) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size0_ok() {\n  std::vector<int> v;\n  if (v.size() != 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size1_ok() {\n  std::vector<int> v;\n  v.push_back(0);\n  v.push_back(42);\n  if (v.size() != 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size2_ok() {\n  std::vector<int> v;\n  v.push_back(0);\n  v.push_back(42);\n  std::vector<int> v_copy{v};\n  if (v_copy.size() != 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size3_ok() {\n  std::vector<int> v;\n  v.push_back(0);\n  std::vector<int> v_copy{v};\n  v.push_back(0);\n  if (v.size() != 2 || v_copy.size() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\n// missing a more precise model for std::initializer_list\nint FP_size4_ok() {\n  std::vector<int> v{0, 42};\n  if (v.size() != 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size5_ok() {\n  std::vector<int> v;\n  v.push_back(0);\n  v.push_back(0);\n  v.pop_back();\n  if (v.size() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size0_bad() {\n  std::vector<int> v;\n  if (v.size() == 0) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size1_bad() {\n  std::vector<int> v;\n  v.push_back(0);\n  v.push_back(42);\n  if (v.size() == 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint size2_bad() {\n  std::vector<int> v;\n  v.push_back(0);\n  std::vector<int> v_copy{v};\n  v_copy.push_back(0);\n  if (v.size() == 1 && v_copy.size() == 2) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint empty0_ok() {\n  std::vector<int> v;\n  if (!v.empty()) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint empty1_ok() {\n  std::vector<int> v;\n  v.push_back(0);\n  if (v.empty()) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint empty2_ok() {\n  std::vector<int> v;\n  v.push_back(0);\n  v.pop_back();\n  if (!v.empty()) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint empty0_bad() {\n  std::vector<int> v;\n  if (v.empty()) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nvoid deref_vector_element_after_push_back_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  int* y = elt;\n  vec.push_back(42);\n  std::cout << *y << \"\\n\";\n}\n\n// slight variation of above, in particular use vector::at()\nvoid deref_vector_pointer_element_after_push_back_bad(std::vector<int>* vec) {\n  int* elt = &vec->at(1);\n  int* y = elt;\n  vec->push_back(42);\n  std::cout << *y << \"\\n\";\n}\n\nvoid deref_local_vector_element_after_push_back_bad() {\n  std::vector<int> vec = {0, 0};\n  int* elt = &vec[1];\n  vec.push_back(42);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid deref_null_local_vector_element_bad() {\n  std::vector<int*> vec = {nullptr};\n  std::cout << *vec[0] << \"\\n\";\n}\n\nvoid two_push_back_ok(std::vector<int>& vec) {\n  vec.push_back(32);\n  vec.push_back(52);\n}\n\nvoid push_back_in_loop_ok(std::vector<int>& vec, std::vector<int>& vec_other) {\n  for (const auto& i : vec_other) {\n    vec.push_back(i);\n  }\n}\n\nvoid reserve_then_push_back_ok(std::vector<int>& vec) {\n  vec.reserve(vec.size() + 1);\n  int* elt = &vec[1];\n  vec.push_back(42);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid FN_reserve_too_small_bad() {\n  std::vector<int> vec;\n  vec.reserve(1);\n  vec.push_back(32);\n  int* elt = &vec[0];\n  vec.push_back(52);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid reserve_then_push_back_loop_ok(std::vector<int>& vec,\n                                    std::vector<int>& vec_other) {\n  vec.reserve(vec.size() + vec_other.size());\n  int* elt = &vec[1];\n  for (const auto& i : vec_other) {\n    vec.push_back(i);\n  }\n  std::cout << *elt << \"\\n\";\n}\n\nvoid FP_init_fill_then_push_back_ok(std::vector<int>& vec_other) {\n  std::vector<int> vec(vec_other.size());\n  int* elt = &vec[1];\n  vec.push_back(0);\n  vec.push_back(0);\n  vec.push_back(0);\n  vec.push_back(0);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid push_back_loop_bad(std::vector<int>& vec_other) {\n  std::vector<int> vec(2);\n  int* elt = &vec[1];\n  for (const auto& i : vec_other) {\n    vec.push_back(i);\n  }\n  std::cout << *elt << \"\\n\";\n}\n\nvoid reserve_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.reserve(vec.size() + 1);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid clear_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.clear();\n  std::cout << *elt << \"\\n\";\n}\n\nvoid assign_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.assign(11, 7);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid shrink_to_fit_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.shrink_to_fit();\n  std::cout << *elt << \"\\n\";\n}\n\nvoid insert_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.insert(vec.begin(), 7);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid emplace_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.emplace(vec.begin(), 7);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid emplace_back_bad(std::vector<int>& vec) {\n  int* elt = &vec[1];\n  vec.emplace_back(7);\n  std::cout << *elt << \"\\n\";\n}\n\nvoid f(int&);\n\nvoid push_back_value_ok(std::vector<int>& vec) {\n  int x = vec[0];\n  vec.push_back(7);\n  f(x);\n}\n\nstruct VectorA {\n  int x;\n\n  void push_back_value_field_ok(std::vector<int>& vec) {\n    x = vec[0];\n    vec.push_back(7);\n    f(x);\n  }\n};\n\nvoid push_back_wrapper() {\n  static std::vector<int> v{};\n  v.push_back(7);\n}\n\nvoid call_push_back_wrapper_ok() {\n  push_back_wrapper();\n  push_back_wrapper();\n}\n\nint emplace_back_size_ok() {\n  std::vector<int> v;\n  v.emplace_back(42);\n  if (v.size() != 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n\nint emplace_back_size_bad() {\n  std::vector<int> v;\n  v.emplace_back(42);\n  if (v.size() == 1) {\n    int* q = nullptr;\n    return *q;\n  }\n  return 0;\n}\n"
    },
    {
      "testname": "vector_iterator.cpp",
      "testlanguage": "c++",
      "expected-problems": 37,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <iostream>\n#include <vector>\n\nvoid iterator_read_after_emplace_bad(std::vector<int>& vec) {\n  auto iter = vec.begin();\n  vec.emplace(iter, 4);\n  std::cout << *iter << '\\n';\n}\n\nvoid iterator_next_after_emplace_bad(std::vector<int>& vec) {\n  auto iter = vec.begin();\n  vec.emplace(iter, 4);\n  ++iter;\n  std::cout << *iter << '\\n';\n}\n\nvoid another_iterator_ok(std::vector<int>& vec) {\n  auto iter = vec.begin();\n  vec.emplace(iter, 4);\n  auto another_iter = vec.begin();\n  std::cout << *another_iter << '\\n';\n  ++another_iter;\n  std::cout << *another_iter << '\\n';\n}\n\nvoid read_iterator_loop_ok(std::vector<int>& vec) {\n  int sum = 0;\n  for (auto iter = vec.begin(); iter != vec.end(); ++iter) {\n    sum += *iter;\n  }\n}\n\nvoid iterator_next_after_emplace_loop_latent(std::vector<int>& vec) {\n  int sum = 0;\n  for (auto iter = vec.begin(); iter != vec.end(); ++iter) {\n    int elem = *iter;\n    sum += elem;\n    if (elem < 0)\n      vec.emplace(iter, -elem);\n  }\n}\n\nvoid iterator_after_push_back_loop_bad(std::vector<int>& vec_other) {\n  std::vector<int> vec(2);\n  auto iter_begin = vec.begin();\n  auto iter_end = vec.end();\n  for (const auto& i : vec_other) {\n    vec.push_back(i);\n  }\n  int sum = 0;\n  for (auto iter = iter_begin; iter != iter_end; ++iter) {\n    sum += *iter;\n  }\n}\n\nvoid FN_iterator_empty_vector_read_bad() {\n  std::vector<int> vec = {};\n  auto iter = vec.begin();\n  std::cout << *iter << '\\n';\n}\n\nvoid iterator_end_read_bad() {\n  std::vector<int> vec = {1, 2};\n  auto iter = vec.end();\n  std::cout << *iter << '\\n';\n}\n\nvoid iterator_end_next_bad() {\n  std::vector<int> vec = {1, 2};\n  auto iter = vec.end();\n  ++iter;\n}\n\nvoid iterator_end_prev_read_ok() {\n  std::vector<int> vec = {1, 2};\n  auto iter = vec.end();\n  std::cout << *(--iter) << '\\n';\n}\n\nvoid iterator_prev_after_emplace_bad(std::vector<int>& vec) {\n  auto iter = vec.begin();\n  ++iter;\n  vec.emplace(iter, 4);\n  --iter;\n  std::cout << *iter << '\\n';\n}\n\nvoid FN_iterator_begin_prev_read_bad() {\n  std::vector<int> vec = {1, 2};\n  auto iter = vec.begin();\n  std::cout << *(--iter) << '\\n';\n}\n\nbool for_each_ok(std::vector<int>& vec, bool b) {\n  int res = 0;\n  for (const auto& elem : vec) {\n    res += 0;\n  }\n  return b;\n}\n\nvoid call_iterator_loop_ok(bool b) {\n  std::vector<int> vec;\n  bool finished = false;\n  while (!finished) {\n    if (!for_each_ok(vec, b))\n      return;\n  }\n}\n\nstd::vector<int>::iterator find(std::vector<int>& vec, bool b) {\n  for (auto it = vec.begin(); it != vec.end(); ++it) {\n    if (b) {\n      return it;\n    }\n  }\n  return vec.end();\n}\n\nvoid iterator_end_returned_ok(std::vector<int> vec, bool b) {\n  auto it = find(vec, b);\n  if (it != vec.end()) {\n    *it = 3;\n  } else {\n    return;\n  }\n}\n"
    },
    {
      "testname": "weak_ptr.cpp",
      "testlanguage": "c++",
      "expected-problems": 63,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n\nnamespace weak_ptr_constructors {\n\nstruct Base {\n  int* f1;\n  Base(int* f1 = nullptr) : f1(f1) {}\n};\n\nstruct Derived : public Base {\n  int* f2;\n  Derived(int* f1 = nullptr) : Base(f1) {}\n};\n\nstd::weak_ptr<Base> empty() { return std::weak_ptr<Base>(); }\n\nstd::weak_ptr<Base> fromWeakBaseConstr(std::weak_ptr<Base> b) {\n  return std::weak_ptr<Base>(b);\n}\n\nstd::weak_ptr<Base> fromWeakBaseAssign(std::weak_ptr<Base> b) {\n  std::weak_ptr<Base> result;\n  result = b;\n  return result;\n}\n\nstd::weak_ptr<Base> fromWeakDerivedConstr(std::weak_ptr<Derived> d) {\n  return std::weak_ptr<Base>(d);\n}\n\nstd::weak_ptr<Base> fromWeakDerivedAssign(std::weak_ptr<Derived> d) {\n  std::weak_ptr<Base> result;\n  result = d;\n  return result;\n}\n\nstd::weak_ptr<Base> fromSharedBaseConstr(std::shared_ptr<Base> b) {\n  return std::weak_ptr<Base>(b);\n}\n\nstd::weak_ptr<Base> fromSharedBaseAssign(std::shared_ptr<Base> b) {\n  std::weak_ptr<Base> result;\n  result = b;\n  return result;\n}\n\nstd::weak_ptr<Base> fromSharedDerivedConstr(std::shared_ptr<Derived> d) {\n  return std::weak_ptr<Base>(d);\n}\n\nstd::weak_ptr<Base> fromSharedDerivedConstr2(std::shared_ptr<Derived> d) {\n  std::weak_ptr<Derived> sd(d);\n  return std::weak_ptr<Base>(sd);\n}\n\nstd::weak_ptr<Base> fromSharedDerivedAssign(std::shared_ptr<Derived> d) {\n  std::weak_ptr<Derived> sd(d);\n  std::weak_ptr<Base> result;\n  result = sd;\n  return result;\n}\n} // namespace weak_ptr_constructors\n\nnamespace weak_ptr_derefs {\nusing namespace weak_ptr_constructors;\n\nint safeGetFromEmpty_good() {\n  auto w = empty();\n  auto s = w.lock();\n  while (!s)\n    ;\n  return *s->f1; // never reached\n}\n\nstd::shared_ptr<Base> safeGet(std::weak_ptr<Base> p) {\n  auto s = p.lock();\n  while (!s)\n    ;\n  return s;\n}\n\nint FN_safeGetFromWeakBaseConstr_bad(int v) {\n  auto b = std::make_shared<Base>(&v);\n  auto s = safeGet(fromWeakBaseConstr(std::weak_ptr<Base>(b)));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromWeakBaseAssign_bad(int v) {\n  auto b = std::make_shared<Base>(&v);\n  auto s = safeGet(fromWeakBaseAssign(std::weak_ptr<Base>(b)));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromWeakDerivedConstr_bad(int v) {\n  auto d = std::make_shared<Derived>(&v);\n  auto s = safeGet(fromWeakDerivedConstr(std::weak_ptr<Derived>(d)));\n  d->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromWeakDerivedAssign_bad(int v) {\n  auto d = std::make_shared<Derived>(&v);\n  auto s = safeGet(fromWeakDerivedAssign(std::weak_ptr<Derived>(d)));\n  d->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromSharedBaseConstr_bad(int v) {\n  auto b = std::make_shared<Base>(&v);\n  auto s = safeGet(fromSharedBaseConstr(b));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromSharedBaseAssign_bad(int v) {\n  auto b = std::make_shared<Base>(&v);\n  auto s = safeGet(fromSharedBaseAssign(b));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromSharedDerivedConstr_bad(int v) {\n  auto b = std::make_shared<Derived>(&v);\n  auto s = safeGet(fromSharedDerivedConstr(b));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromSharedDerivedConstr2_bad(int v) {\n  auto b = std::make_shared<Derived>(&v);\n  auto s = safeGet(fromSharedDerivedConstr2(b));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n\nint FN_safeGetFromSharedDerivedAssign_bad(int v) {\n  auto b = std::make_shared<Derived>(&v);\n  auto s = safeGet(fromSharedDerivedAssign(b));\n  b->f1 = nullptr;\n  return *s->f1;\n}\n} // namespace weak_ptr_derefs\n\nnamespace weak_ptr_modifiers {\n\nvoid reset(std::weak_ptr<int>& p) { p.reset(); }\n\nvoid swap(std::weak_ptr<int>& p) {\n  std::weak_ptr<int> q;\n  q.swap(p);\n}\n} // namespace weak_ptr_modifiers\n\nnamespace weak_ptr_observers {\nusing namespace weak_ptr_constructors;\n\nlong use_count(std::weak_ptr<int>& p) { return p.use_count(); }\n\nvoid use_count_empty_bad() {\n  std::weak_ptr<int> p;\n  if (p.use_count() == 0) {\n    int* x = nullptr;\n    *x = 42;\n  }\n}\n\nvoid use_count_after_reset_bad(std::weak_ptr<int>& p) {\n  p.reset();\n  if (p.use_count() == 0) {\n    int* x = nullptr;\n    *x = 42;\n  }\n}\n\nbool expired(std::weak_ptr<int>& p) { return p.expired(); }\n\nvoid expired_empty_bad() {\n  std::weak_ptr<int> p;\n  if (p.expired()) {\n    int* x = nullptr;\n    *x = 42;\n  }\n}\n\nvoid expired_after_reset_bad(std::weak_ptr<int>& p) {\n  p.reset();\n  if (p.expired()) {\n    int* x = nullptr;\n    *x = 42;\n  }\n}\n\nvoid expired_after_swap_bad(std::weak_ptr<int>& p) {\n  std::weak_ptr<int> q;\n  q.swap(p);\n  if (p.expired()) {\n    int* x = nullptr;\n    *x = 42;\n  }\n}\n\nstd::shared_ptr<int> lock(std::weak_ptr<int>& p) { return p.lock(); }\n\nvoid FN_empty_weak_lock_returns_null_bad() {\n  std::weak_ptr<int> p;\n  auto s = p.lock();\n  int _ = *s.get();\n}\n\nvoid FN_expired_means_null_bad(std::weak_ptr<int>& p) {\n  if (p.expired()) {\n    auto s = p.lock();\n    int _ = *s.get();\n  }\n}\n\nvoid FN_lock_can_be_null_bad(std::weak_ptr<int>& p) {\n  auto s = p.lock();\n  int _ = *s.get();\n}\n\nint safe_deref_ok(std::weak_ptr<int>& p) {\n  if (auto s = p.lock()) {\n    return *s.get();\n  }\n  return 0;\n}\n\nstd::shared_ptr<int> shared_still_in_scope_good_FP() {\n  /* It's not a big issue to FP in this case.\n    Code should not be written like that anyway. */\n  auto s = std::make_shared<int>();\n  auto p = std::weak_ptr<int>(s);\n  auto s2 = p.lock();\n  auto _ = *s2.get();\n  return s;\n}\n\nbool owner_before(std::weak_ptr<Base>& p, std::weak_ptr<Base>& q) {\n  return p.owner_before(q);\n}\n\nbool owner_before(std::weak_ptr<Base>& p, std::shared_ptr<Derived>& q) {\n  return p.owner_before(q);\n}\n} // namespace weak_ptr_observers\n"
    },
    {
      "testname": "weak_ptr_compil.cpp",
      "testlanguage": "c++",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#include <unordered_map>\n\n/* Compilation tests */\n\nnamespace weak_ptr_lock_repro_small {\ntemplate <class T>\nstd::shared_ptr<T> joinT(std::shared_ptr<T> x) {\n  return x;\n};\n\nvoid foo(std::weak_ptr<int> p) {\n  auto self = p.lock();\n  std::shared_ptr<int> x = joinT(self);\n}\n} // namespace weak_ptr_lock_repro_small\n\nnamespace weak_ptr_lock_repro_large {\n\nclass S {\n public:\n  template <typename T>\n  std::shared_ptr<T> joinT(std::shared_ptr<T> s);\n};\n\nclass DCC {\n public:\n  const std::shared_ptr<S>& s();\n};\n\nclass DC {};\n\nclass CDM {\n public:\n  std::shared_ptr<DC> gdc(std::function<DCC()>);\n};\n\nclass RDC : DC {\n public:\n  static std::shared_ptr<RDC> create(std::function<DCC()> cf);\n\n private:\n  const std::shared_ptr<CDM> cdm;\n  mutable std::function<std::shared_ptr<DC>()> dcf;\n};\n\nstd::shared_ptr<RDC> RDC::create(std::function<DCC()> cf) {\n  auto dc = std::make_shared<RDC>();\n  dc->dcf = [cf = std::move(cf),\n             weakSelf =\n                 std::weak_ptr<RDC>(dc)]() mutable -> std::shared_ptr<DC> {\n    if (auto self = weakSelf.lock()) {\n      return self->cdm->gdc([&]() mutable {\n        auto c = cf();\n        c.s()->joinT(self);\n        return c;\n      });\n    }\n    return nullptr;\n  };\n  return dc;\n}\n} // namespace weak_ptr_lock_repro_large\n\nnamespace weak_ptr_owner_less {\nclass K {};\nclass V {};\nclass C {\n  using S = std::set<std::weak_ptr<K>, std::owner_less<std::weak_ptr<K>>>;\n  std::\n      map<std::weak_ptr<K>, std::weak_ptr<V>, std::owner_less<std::weak_ptr<K>>>\n          m;\n  S s;\n#ifdef INFER_USE_LIBCPP\n  /* requires Clang headers */\n  std::unordered_map<K, S> u;\n#endif\n};\n} // namespace weak_ptr_owner_less\n"
    },
    {
      "testname": "basics.cpp",
      "testlanguage": "c++",
      "expected-problems": 89,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <atomic>\n#include <chrono>\n#include <string>\n#include <assert.h>\n#include <stdlib.h>\n\nextern void* __infer_taint_source();\nextern void __infer_taint_sink(void*);\nextern void __infer_taint_sink(int);\n\nnamespace basics {\n\nclass Obj {\n public:\n  void* method_source() { return (void*)malloc(sizeof(int)); }\n  void method_sink(void*) {}\n  static void* static_source() { return (void*)malloc(sizeof(int)); }\n  static void static_sink(void*) {}\n  std::string string_source(int i) { return \"\"; }\n  static int taint_arg_source(int* arg) { return 1; }\n  void string_sink(std::string) {}\n  static std::string* sanitizer1(std::string* input) { return input; }\n  static std::string sanitizer2(const std::string& input) {\n    return input.substr();\n  }\n  static std::string propagator(std::string& input, std::string& output);\n\n  std::string field1;\n  std::string field2;\n\n  void endpoint(std::string source1, void* source2) {\n    this->string_sink(source1);\n    __infer_taint_sink(source2);\n  }\n};\n\nvoid* returnSource() { return __infer_taint_source(); }\n\nvoid callSink(void* param) { __infer_taint_sink(param); }\n\nvoid* id(void* param) { return param; }\n\nvoid sourceToSinkDirectBad() {\n  void* source = __infer_taint_source();\n  __infer_taint_sink(source);\n}\n\nvoid returnSourceToSinkBad() {\n  void* source = returnSource();\n  __infer_taint_sink(source);\n}\n\nvoid sourceThenCallSinkBad() {\n  void* source = __infer_taint_source();\n  callSink(source);\n}\n\nvoid propagateBad() {\n  void* source = __infer_taint_source();\n  void* launderedSource = id(source);\n  callSink(launderedSource);\n}\n\n// make sure specifying external sources/sinks as instance methods works\nvoid object_source_sink_bad(Obj obj) {\n  void* source = obj.method_source();\n  obj.method_sink(source);\n  free(source);\n}\n\n// make sure specifying external sources/sinks as static methods works\nvoid static_source_sink_bad(Obj obj) {\n  void* source = Obj::static_source();\n  Obj::static_sink(source);\n  free(source);\n}\n\nvoid compound_stmt_bad() {\n  void* taint = ({\n    assert(true);\n    __infer_taint_source();\n  });\n  __infer_taint_sink(taint);\n}\n\nvoid compound_stmt_taint_arg_bad(Obj* obj) {\n  Obj* taint = ({\n    assert(true);\n    obj;\n  });\n  __infer_taint_sink(taint);\n}\n\ntemplate <class T>\nT* template_source() {\n  return new T();\n}\n\ntemplate <class T>\nvoid template_sink(T) {}\n\nvoid template_source_bad() {\n  void* source = template_source<void*>();\n  __infer_taint_sink(source);\n}\n\nvoid string_source_bad(Obj obj) {\n  std::string source = obj.string_source(5);\n  obj.string_sink(source);\n}\n\nvoid getenv_source_bad(Obj obj) {\n  std::string source = std::getenv(\"var\");\n  obj.string_sink(source);\n}\n\nvoid via_field_bad1() {\n  Obj* obj = new Obj();\n  obj->field1 = *template_source<std::string>();\n  template_sink<std::string>(obj->field1);\n  delete obj;\n}\n\nvoid via_field_bad2(Obj* obj) {\n  obj->field1 = *template_source<std::string>();\n  template_sink<std::string>(obj->field1);\n}\n\nvoid via_field_ok1() {\n  Obj* obj = new Obj();\n  obj->field1 = *template_source<std::string>();\n  obj->field1 = nullptr;\n  template_sink<std::string>(obj->field1);\n  delete obj;\n}\n\nvoid via_field_ok2() {\n  Obj* obj = new Obj();\n  obj->field1 = *template_source<std::string>();\n  template_sink<std::string>(obj->field2);\n  delete obj;\n}\n\ntemplate <class T>\nT* id1(T* t) {\n  return t;\n}\n\ntemplate <class T>\nT id2(T t) {\n  return t;\n}\n\nvoid via_passthrough_bad1(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string* source_ptr = &source;\n  std::string* laundered_source = id1<std::string>(source_ptr);\n  obj->string_sink(*laundered_source);\n}\n\nvoid via_passthrough_bad2(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string laundered_source = id2<std::string>(source);\n  obj->string_sink(laundered_source);\n}\n\nvoid taint_arg_source_bad() {\n  int source = 1;\n  Obj::taint_arg_source(&source);\n  __infer_taint_sink(source);\n}\n\nvoid taint_arg_source_ok() {\n  int source;\n  int ret = Obj::taint_arg_source(&source);\n  __infer_taint_sink(ret); // return value is not a source\n}\n\nvoid via_sanitizer_ok1(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string* sanitized = Obj::sanitizer1(&source);\n  obj->string_sink(*sanitized);\n}\n\nvoid via_sanitizer_ok2(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string sanitized = obj->sanitizer2(source);\n  obj->string_sink(sanitized);\n}\n\nvoid implicit_sanitized_ok(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string* sanitized = Obj::sanitizer1(&source);\n  obj->string_sink(source);\n}\n\nvoid unsanitized_bad(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string sanitized = Obj::sanitizer2(source);\n  obj->string_sink(source);\n}\n\nvoid funCall_bad2(int x, void* t) { __infer_taint_sink(t); }\n\nvoid funCall_bad1() { funCall_bad2(0, __infer_taint_source()); }\n\nvoid atomic_eq(std::atomic<std::chrono::duration<int, std::centi>> x,\n               std::chrono::duration<int, std::centi> y) {\n  // this gets translated as operator=(x, y, &tmp_return), which used to cause a\n  // crash\n  x = y;\n}\nstruct node {\n  struct node* prev;\n  struct node* next;\n};\n\nvoid loop_ok(struct node* init) {\n  struct node* tmp = new node{.prev = nullptr, .next = nullptr};\n\n  while (1) {\n    tmp->next = init;\n    init = tmp;\n    tmp->prev = init;\n  }\n}\n\nvoid ret_void_ok() { return; }\n\nvoid ret_void_transitive_ok() { return ret_void_ok(); }\n\nvoid via_propagator_bad(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string propagated(\"\");\n  std::string unpropagated = Obj::propagator(source, propagated);\n  obj->string_sink(propagated);\n}\n\nvoid via_propagator_ok1(Obj* obj) {\n  std::string source = obj->string_source(0);\n  std::string propagated(\"\");\n  std::string unpropagated = Obj::propagator(source, propagated);\n  obj->string_sink(unpropagated);\n}\n\nvoid FP_via_propagator_ok2(Obj* obj) {\n  std::string propagated = obj->string_source(0);\n  std::string source(\"\");\n  std::string unpropagated = Obj::propagator(source, propagated);\n  obj->string_sink(source);\n}\n\n} // namespace basics\n"
    },
    {
      "testname": "pointers.cpp",
      "testlanguage": "c++",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <string>\n#include <iostream>\n\nextern std::string* __infer_taint_source();\nextern void __infer_taint_sink(std::string);\n\nnamespace pointers {\n\nvoid assign_pointer_to_source(std::string* pointer) {\n  *pointer = *__infer_taint_source();\n}\n\nvoid assign_pointer_pass_to_sink_bad1(std::string* pointer) {\n  assign_pointer_to_source(pointer);\n  __infer_taint_sink(*pointer);\n}\n\nvoid assign_pointer_pass_to_sink_bad2() {\n  std::string* pointer = new std::string();\n  assign_pointer_to_source(pointer);\n  __infer_taint_sink(*pointer);\n}\n\nvoid assign_source_by_reference(std::string& reference) {\n  reference = *__infer_taint_source();\n}\n\nvoid assign_source_by_reference_bad1() {\n  std::string local;\n  assign_source_by_reference(local);\n  __infer_taint_sink(local);\n}\n\nvoid assign_source_by_reference_bad2(std::string formal) {\n  assign_source_by_reference(formal);\n  __infer_taint_sink(formal);\n}\n\nvoid call_assign_source_by_reference(std::string& formal) {\n  assign_source_by_reference(formal);\n}\n\nvoid assign_source_by_reference_bad3() {\n  std::string local;\n  call_assign_source_by_reference(local);\n  __infer_taint_sink(local);\n}\n\nvoid reuse_pointer_as_local(std::string* pointer) {\n  pointer = __infer_taint_source();\n  std::cout << *pointer;\n}\n\nvoid reuse_pointer_as_local_ok(std::string* pointer) {\n  reuse_pointer_as_local(pointer);\n  __infer_taint_sink(*pointer);\n}\n\nvoid __infer_taint_sink1(std::string) {}\n\nvoid funptr_bad0() {\n  auto f = __infer_taint_sink;\n  f(*(__infer_taint_source()));\n}\n\nvoid funptr_helper_bad1(void (*sink)(std::string)) {\n  sink(*(__infer_taint_source()));\n}\n\nvoid funptr1() {\n  auto f = __infer_taint_sink;\n  funptr_helper_bad1(f);\n}\n\nvoid funptr_helper_bad2(std::string* (*source)()) {\n  __infer_taint_sink(*(source()));\n}\n\nvoid funptr2() { funptr_helper_bad2(__infer_taint_source); }\n\nvoid pointer_arithmetic_ok1(int* i) { *(i + 1) = 7; }\n\nvoid pointer_arithmetic_ok2(int* i) { *(2 + 7 + 5 + i + 1) = 7; }\n} // namespace pointers\n"
    },
    {
      "testname": "strings.cpp",
      "testlanguage": "c++",
      "expected-problems": 45,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <stdio.h>\n#include <string>\n\nextern std::string __infer_taint_source();\nextern void __infer_taint_sink(std::string);\n\n// tests related to string manipulation, format strings, etc.\nnamespace strings {\n\nvoid sprintf1_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  sprintf(laundered_source, \"%s\", source.c_str());\n  __infer_taint_sink(laundered_source);\n}\n\nvoid sprintf2_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  sprintf(laundered_source, \"%s%s%d\", \"a\", source.c_str(), 1);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid strcpy1_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  auto copy = strcpy(laundered_source, source.c_str());\n  __infer_taint_sink(copy);\n}\n\nvoid strcpy2_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  strcpy(laundered_source, source.c_str());\n  __infer_taint_sink(laundered_source);\n}\n\nvoid strncpy_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  strncpy(laundered_source, source.c_str(), 50);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid memcpy_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  memcpy(laundered_source, source.c_str(), 50);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid memmove_bad() {\n  char laundered_source[50];\n  auto source = __infer_taint_source();\n  auto copy = (char*)memmove(laundered_source, source.c_str(), 50);\n  __infer_taint_sink(copy);\n}\n\nvoid memchr_ok() {\n  auto source = __infer_taint_source();\n  auto laundered_source = (char*)memchr(source.c_str(), 'a', 10);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid constructor1_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = std::string(source);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid constructor2_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = std::string(source, 0, 5);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid constructor3_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = std::string(source.begin(), source.begin() + 5);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid concat1_bad() {\n  auto source = __infer_taint_source();\n  source += \"other string\";\n  __infer_taint_sink(source);\n}\n\nvoid concat2_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = std::string(\"string\");\n  laundered_source += source;\n  __infer_taint_sink(laundered_source);\n}\n\nvoid concat3_bad() {\n  auto source = __infer_taint_source();\n  __infer_taint_sink(source += \"string\");\n}\n\nvoid append1_bad() {\n  auto source = __infer_taint_source();\n  __infer_taint_sink(std::string(\"string\").append(source));\n}\n\nvoid append2_bad() {\n  auto source = __infer_taint_source();\n  source.append(\"string\");\n  __infer_taint_sink(source);\n}\n\nvoid assign1_bad() {\n  auto source = __infer_taint_source();\n  __infer_taint_sink(std::string(\"string\").assign(source));\n}\n\nvoid assign2_bad() {\n  auto source = __infer_taint_source();\n  source.assign(\"string\");\n  __infer_taint_sink(source);\n}\n\nvoid insert1_bad() {\n  auto source = __infer_taint_source();\n  __infer_taint_sink(std::string(\"string\").assign(source));\n}\n\nvoid insert2_bad() {\n  auto source = __infer_taint_source();\n  source.insert(0, \"string\");\n  __infer_taint_sink(source);\n}\n\nvoid replace1_bad() {\n  auto source = __infer_taint_source();\n  __infer_taint_sink(std::string(\"string\").replace(0, 5, source));\n}\n\nvoid replace2_bad() {\n  auto source = __infer_taint_source();\n  source.replace(0, 5, \"string\");\n  __infer_taint_sink(source);\n}\n\nvoid swap_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = std::string(\"string\");\n  laundered_source.swap(source);\n  __infer_taint_sink(laundered_source);\n}\n\ntemplate <class... Args>\nclass Formatter {\n\n public:\n  explicit Formatter(std::string str, Args&&... args);\n  std::string str();\n};\n\ntemplate <class... Args>\nFormatter<Args...> format1(std::string fmt, Args&&... args) {\n  return Formatter<Args...>(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <class... Args>\nFormatter<Args...>* format2(std::string fmt, Args&&... args) {\n  return new Formatter<Args...>(fmt, std::forward<Args>(args)...);\n}\n\ntemplate <class... Args>\nFormatter<Args...> format3(std::string fmt, Args&&... args);\n\ntemplate <class... Args>\nFormatter<Args...>* format4(std::string fmt, Args&&... args);\n\nvoid FN_format1_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = format1(\"%s\", source).str();\n  __infer_taint_sink(laundered_source);\n}\n\nvoid FN_format2_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = format2(\"%s\", source)->str();\n  __infer_taint_sink(laundered_source);\n}\n\nvoid format3_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = format3(\"%s\", source).str();\n  __infer_taint_sink(laundered_source);\n}\n\nvoid format4_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = format4(\"%s\", source)->str();\n  __infer_taint_sink(laundered_source);\n}\n\nvoid format_varargs_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = format3(\"%s%s\", \"a\", source, \"b\").str();\n  __infer_taint_sink(laundered_source);\n}\n} // namespace strings\n"
    },
    {
      "testname": "structs.cpp",
      "testlanguage": "c++",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <memory>\n#include <string>\n\nstruct mystruct {\n  char* str;\n  int i;\n};\n\nextern mystruct* __infer_taint_source();\nextern void __infer_taint_sink(mystruct);\n\nnamespace structs {\n\nvoid struct_source_bad() {\n  mystruct* source = __infer_taint_source();\n  __infer_taint_sink(*source);\n}\n\nvoid struct_field_source_unique_pointer_bad() {\n  std::unique_ptr<mystruct> source(__infer_taint_source());\n  __infer_taint_sink(*source);\n}\n\nvoid struct_field_source_bad() {\n  mystruct* tainted = __infer_taint_source();\n  mystruct source;\n  source.str = tainted->str;\n  source.i = 0;\n  __infer_taint_sink(source);\n}\n\nvoid read_from_struct_source_field_bad_FN() {\n  mystruct* source = __infer_taint_source();\n  system(source->str);\n}\n\n} // namespace structs\n"
    },
    {
      "testname": "taint_field.cpp",
      "testlanguage": "c++",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntypedef struct {\n  int manipulated;\n  int other;\n} structure;\n\nint int_source(void);\nvoid taint_structure(structure);\nvoid taint_manipulated(structure);\nvoid taint_manipulated_with_indirections(structure**);\n\nvoid sink_int(int);\nvoid sink_manipulated(structure);\n\nvoid sanitize_manipulated(structure);\n\nvoid propagate_to_manipulated(structure, int);\n\nvoid test_taint_field_bad(structure s) {\n  taint_manipulated(s);\n  sink_int(s.manipulated);\n}\n\nvoid test_taint_field_good(structure s) {\n  taint_manipulated(s);\n  sink_int(s.other);\n}\n\nvoid test_sink_field_bad(structure s) {\n  int tainted = int_source();\n  s.manipulated = tainted;\n  sink_manipulated(s);\n}\n\nvoid test_sink_field_good(structure s) {\n  int tainted = int_source();\n  s.other = tainted;\n  sink_manipulated(s);\n}\n\nvoid test_sanitize_field_bad(structure s) {\n  // The 2 lines below are necessary because tainting propagates down\n  // what is known in the memory at the moment of tainting and it is never\n  // propagated again when a new manipulated appears. `s.other` and\n  // `s.manipulated` need to have different values otherwise they are both\n  // referencing the same value and sanitizing one would sanitize the other\n  s.other = 2; // makes s.other exist in memory before tainting s\n  s.manipulated = 1; // makes s.manipulated exist in memory before tainting s\n  taint_structure(s);\n  sanitize_manipulated(s);\n  sink_int(s.other);\n}\n\nvoid test_sanitize_field_good(structure s) {\n  s.other = 0; // makes s.other exist in memory before tainting s\n  s.manipulated = 1; // makes s.manipulated exist in memory before tainting s\n  taint_structure(s);\n  sanitize_manipulated(s);\n  sink_manipulated(s);\n}\nvoid test_propagate_to_field_bad(structure s) {\n  int tainted = int_source();\n  propagate_to_manipulated(s, tainted);\n  sink_int(s.manipulated);\n}\n\nvoid test_propagate_to_field_good(structure s) {\n  int tainted = int_source();\n  propagate_to_manipulated(s, tainted);\n  sink_int(s.other);\n}\n\nvoid test_taint_field_with_indirections_bad(structure s) {\n  structure* s_ptr = &s;\n  structure** s_ptr_ptr = &s_ptr;\n  taint_manipulated_with_indirections(s_ptr_ptr);\n  sink_int((**s_ptr_ptr).manipulated);\n}\n\nvoid test_taint_field_with_indirections_good(structure s) {\n  structure* s_ptr = &s;\n  structure** s_ptr_ptr = &s_ptr;\n  taint_manipulated_with_indirections(s_ptr_ptr);\n  sink_int((**s_ptr_ptr).other);\n}\n"
    },
    {
      "testname": "unknown_code.cpp",
      "testlanguage": "c++",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <map>\n#include <memory>\n#include <string>\n\nextern std::string __infer_taint_source();\nextern void __infer_taint_sink(std::string);\nextern std::string skip_value(std::string);\nextern std::string* skip_pointer(std::string);\nextern void skip_by_ref(std::string, std::string&);\n\nextern int of_string(std::string);\n\nnamespace unknown_code {\n\nvoid direct_bad() {\n  auto source = __infer_taint_source();\n  __infer_taint_sink(source);\n}\n\nvoid skip_value_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = skip_value(source);\n  __infer_taint_sink(laundered_source);\n}\n\nvoid skip_pointer_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = skip_pointer(source);\n  __infer_taint_sink(*laundered_source);\n}\n\nstd::string skip_indirect(std::string formal) {\n  auto skipped_pointer = skip_pointer(formal);\n  return skip_value(*skipped_pointer);\n}\n\nvoid FN_skip_indirect_bad() {\n  auto source = __infer_taint_source();\n  auto laundered_source = skip_indirect(source);\n  __infer_taint_sink(laundered_source);\n}\n\n// for now, we don't have any heuristics for guessing that laundered_by_ref is\n// assigned by ref in\n// the skipped function\nvoid FN_via_skip_by_ref_bad() {\n  auto source = __infer_taint_source();\n  std::string laundered_by_ref;\n  skip_by_ref(source, laundered_by_ref);\n  __infer_taint_sink(laundered_by_ref);\n}\n\n} // namespace unknown_code\n"
    },
    {
      "testname": "AnalysisStops.java",
      "testlanguage": "java",
      "expected-problems": 106,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.util.Iterator;\n\npublic class AnalysisStops {\n\n  private native Object externalFunc();\n\n  public void skipPointerDerefMayCauseLocalFalseNegativeBad() {\n    Object ret = externalFunc();\n    ret.toString();\n    int i = 1 / 0;\n  }\n\n  private Object skipPointerDerefPreventsSpecInferenceRetObj() {\n    Object ret = externalFunc();\n    ret.toString();\n    return new Object();\n  }\n\n  public void skipPointerDerefMayCauseCalleeFalsePositiveOk() {\n    Object o = skipPointerDerefPreventsSpecInferenceRetObj();\n    o.toString();\n  }\n\n  private int skipPointerDerefPreventsSpecInferenceRetZero() {\n    Object ret = externalFunc();\n    ret.toString();\n    return 0;\n  }\n\n  public void skipPointerDerefMayCauseCalleeFalseNegativeBad() {\n    int ret = skipPointerDerefPreventsSpecInferenceRetZero();\n    int i = 1 / ret;\n  }\n\n  private void divideByParam(int i) {\n    int j = 1 / i;\n  }\n\n  public void skipPointerDerefMayCauseInterprocFalseNegativeBad() {\n    int i = skipPointerDerefPreventsSpecInferenceRetZero();\n    divideByParam(i);\n  }\n\n  private String castExternalPreventsSpecInference() {\n    return (String) externalFunc();\n  }\n\n  public void castFailureOnUndefinedObjMayCauseFalseNegativeBad() {\n    castExternalPreventsSpecInference();\n    int i = 1 / 0;\n  }\n\n  public void callOnCastUndefinedObjMayCauseFalseNegativeBad() {\n    String s = castExternalPreventsSpecInference();\n    s.toString();\n    int i = 1 / 0;\n  }\n\n  private static class MyObj {\n    Object f;\n    MyObj rec;\n    int i;\n\n    public int retOne() {\n      return 1;\n    }\n\n    public int retZero() {\n      return 0;\n    }\n  }\n\n  private native MyObj externalFunc2();\n\n  public void callOnUndefinedObjMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    int i = 1 / ret.retZero();\n  }\n\n  public void callOnUndefinedObjMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    int i = 1 / ret.retOne();\n  }\n\n  public void fieldWriteOnUndefinedObjMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    ret.f = new Object();\n    int i = 1 / 0;\n  }\n\n  public void fieldWriteOnUndefinedObjMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    ret.f = new Object();\n    ret.f.toString();\n  }\n\n  public void fieldReadOnUndefinedObjMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    Object o = ret.f;\n    int i = 1 / 0;\n  }\n\n  public void fieldReadOnUndefinedObjMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    Object o = ret.f;\n    o.toString();\n  }\n\n  public void recursiveAngelicTypesMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    MyObj rec1 = ret.rec;\n    MyObj rec2 = rec1.rec;\n    int i = 1 / 0;\n  }\n\n  public void recursiveAngelicTypesMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    MyObj rec1 = ret.rec;\n    rec1.rec.toString();\n  }\n\n  public void infiniteMaterializationMayCauseFalseNegativeBad(boolean b) {\n    MyObj rec = externalFunc2();\n    while (b) {\n      rec = rec.rec;\n    }\n    int i = 1 / 0;\n  }\n\n  public void infiniteMaterializationMayCauseFalsePositiveOk(boolean b) {\n    MyObj rec = externalFunc2();\n    while (b) {\n      rec = rec.rec;\n    }\n    rec.toString();\n  }\n\n  public void primitiveFieldOfAngelicObjMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    if (ret.i == 0) {\n      int i = 1 / 0;\n    } else {\n      int i = 1 / 0;\n    }\n  }\n\n  public void primitiveFieldOfAngelicObjMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    if (ret.i != 0) {\n      int i = 1 / ret.i;\n    }\n  }\n\n  public void heapFieldOfAngelicObjMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    Object obj = ret.f;\n    if (obj == ret.f) {\n      int i = 1 / 0;\n    }\n  }\n\n  public void heapFieldOfAngelicObjMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    Object obj = ret.f;\n    if (obj != ret.f) {\n      int i = 1 / 0;\n    }\n  }\n\n  public void fieldReadAferCastMayCauseFalseNegativeBad(Iterator<MyObj> iter) {\n    MyObj ret = iter.next();\n    Object obj = ret.f;\n    obj.toString();\n    int i = ret.i;\n    if (i == 7) {\n      int j = 1 / 0;\n    }\n  }\n\n  public void derefParamOk(MyObj obj) {\n    Object f = obj.f;\n    f.toString();\n  }\n\n  public void fieldReadInCalleeMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    derefParamOk(ret);\n  }\n\n  public void fieldReadInCalleeMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    ret.f = null;\n    derefParamOk(ret);\n  }\n\n  public void fieldReadInCalleeWithAngelicObjFieldMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    derefParamOk(ret.rec);\n  }\n\n  public void fieldReadInCalleeWithAngelicObjFieldMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    ret.rec.f = null;\n    derefParamOk(ret.rec);\n  }\n\n  public void accessPathOnParamOk(MyObj obj) {\n    MyObj ret = obj.rec;\n    Object f = ret.f;\n    f.toString();\n  }\n\n  public void accessPathInCalleeMayCauseFalsePositiveOk() {\n    MyObj ret = externalFunc2();\n    accessPathOnParamOk(ret);\n  }\n\n  public void accessPathInCalleeMayCauseFalseNegativeBad() {\n    MyObj ret = externalFunc2();\n    ret.rec.f = null;\n    accessPathOnParamOk(ret);\n  }\n\n  public void FN_skipFunctionInLoopMayCauseFalseNegativeBad() {\n    Object o = null;\n    for (int i = 0; i < 10; i++) {\n      externalFunc();\n    }\n    o.toString();\n  }\n\n  // will fail to find error unless spec inference succeeds for all callees\n  public void specInferenceMayFailAndCauseFalseNegativeBad(boolean b, Iterator<MyObj> iter) {\n    skipPointerDerefMayCauseLocalFalseNegativeBad();\n    skipPointerDerefPreventsSpecInferenceRetObj();\n    skipPointerDerefPreventsSpecInferenceRetZero();\n    skipPointerDerefMayCauseCalleeFalseNegativeBad();\n    skipPointerDerefMayCauseInterprocFalseNegativeBad();\n    castFailureOnUndefinedObjMayCauseFalseNegativeBad();\n    callOnCastUndefinedObjMayCauseFalseNegativeBad();\n    callOnUndefinedObjMayCauseFalseNegativeBad();\n    callOnUndefinedObjMayCauseFalsePositiveOk();\n    fieldWriteOnUndefinedObjMayCauseFalseNegativeBad();\n    fieldWriteOnUndefinedObjMayCauseFalsePositiveOk();\n    fieldReadOnUndefinedObjMayCauseFalseNegativeBad();\n    fieldReadOnUndefinedObjMayCauseFalsePositiveOk();\n    recursiveAngelicTypesMayCauseFalseNegativeBad();\n    recursiveAngelicTypesMayCauseFalsePositiveOk();\n    infiniteMaterializationMayCauseFalseNegativeBad(b);\n    infiniteMaterializationMayCauseFalsePositiveOk(b);\n    primitiveFieldOfAngelicObjMayCauseFalsePositiveOk();\n    primitiveFieldOfAngelicObjMayCauseFalseNegativeBad();\n    heapFieldOfAngelicObjMayCauseFalsePositiveOk();\n    heapFieldOfAngelicObjMayCauseFalseNegativeBad();\n    fieldReadAferCastMayCauseFalseNegativeBad(iter);\n    fieldReadInCalleeMayCauseFalsePositiveOk();\n    fieldReadInCalleeWithAngelicObjFieldMayCauseFalsePositiveOk();\n    accessPathInCalleeMayCauseFalsePositiveOk();\n    int i = 1 / 0;\n  }\n}\n"
    },
    {
      "testname": "ArrayOutOfBounds.java",
      "testlanguage": "java",
      "expected-problems": 69,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class ArrayOutOfBounds {\n\n  public int arrayOutOfBoundsBad() {\n    int[] arr = new int[1];\n    return arr[3];\n  }\n\n  public int arrayInBoundsOk() {\n    int[] arr = new int[2];\n    return arr[1];\n  }\n\n  // tests below this line are turned off until array functionality improves\n  public void arrayLoopOutOfBoundsOk(int[] arr) {\n    for (int i = 0; i <= arr.length; i++) {\n      int j = arr[i];\n    }\n  }\n\n  public void arrayLoopInBoundsOk(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      int j = arr[i];\n    }\n  }\n\n  public void buggyIterOk(int[] arr1, int[] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n      arr2[i] = 7;\n    }\n  }\n\n  public void switchedArrsOutOfBoundsOk() {\n    buggyIterOk(new int[11], new int[10]);\n  }\n\n  public void buggyNestedLoop1Ok(int[] arr1, int[] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n      for (int j = 0; i < arr2.length; j++) {\n        arr1[i] = arr1[i] + arr2[j];\n      }\n    }\n  }\n\n  public void nestedOutOfBounds1Ok() {\n    buggyNestedLoop1Ok(new int[11], new int[10]);\n  }\n\n  public void buggyNestedLoop2Ok(int[] arr1, int[] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n      for (int j = 0; j < arr2.length; i++) {\n        arr1[i] = arr1[i] + arr2[j];\n      }\n    }\n  }\n\n  public void nestedOutOfBounds2Ok() {\n    buggyNestedLoop2Ok(new int[11], new int[10]);\n  }\n\n  public void buggyNestedLoop3Ok(int[] arr1, int[] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n      for (int j = 0; j < arr2.length; j++) {\n        arr1[i] = 2 * arr2[i];\n      }\n    }\n  }\n\n  public void nestedOutOfBounds3Ok() {\n    buggyNestedLoop3Ok(new int[11], new int[10]);\n  }\n\n  public void safeNestedLoopOk(int[] arr1, int[] arr2) {\n    for (int i = 0; i < arr1.length; i++) {\n      for (int j = 0; j < arr2.length; j++) {\n        arr1[i] = arr1[i] + arr2[j];\n      }\n    }\n  }\n\n  public void nestedInBoundsOk() {\n    safeNestedLoopOk(new int[11], new int[10]);\n  }\n}\n"
    },
    {
      "testname": "Assertion.java",
      "testlanguage": "java",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class Assertion {\n\n  public void assertFalseBad() {\n    assert false;\n  }\n\n  public void assertTrueOk() {\n    assert true;\n  }\n\n  /* the assert-error issue is not latent: we consider such a\n  partial function should be considered bad */\n  public void runAssertBooleanLatentBad(boolean b) {\n    assert b;\n  }\n\n  /* the assert-error issue is not latent: we consider such a\n  partial function should be considered bad */\n  public void runAssertIntLatentBad(int i) {\n    assert (i > 0);\n  }\n}\n"
    },
    {
      "testname": "AutoGenerated.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\n/* @generated */\n\npublic class AutoGenerated {\n\n  void npeBad() {\n    String s = null;\n    int n = s.length();\n  }\n}\n"
    },
    {
      "testname": "ClassCastExceptions.java",
      "testlanguage": "java",
      "expected-problems": 27,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nclass SuperClass {}\n\nclass SubClassA extends SuperClass {}\n\nclass SubClassB extends SuperClass {}\n\ninterface MyInterface {\n  public int getInt();\n}\n\nclass ImplementationOfInterface implements MyInterface {\n\n  public int getInt() {\n    return 0;\n  }\n}\n\nclass AnotherImplementationOfInterface implements MyInterface {\n  public int getInt() {\n    return 1;\n  }\n}\n\npublic class ClassCastExceptions {\n\n  public void classCastExceptionBad() {\n    SuperClass a = new SubClassA();\n    SubClassB b = (SubClassB) a;\n  }\n\n  public int classCastExceptionImplementsInterfaceCalleeOk(MyInterface i) {\n    ImplementationOfInterface impl = (ImplementationOfInterface) i;\n    return impl.getInt();\n  }\n\n  public int classCastExceptionImplementsInterfaceBad() {\n    return classCastExceptionImplementsInterfaceCalleeOk(new AnotherImplementationOfInterface());\n  }\n\n  public String getURL() {\n    return \"http://bla.com\";\n  }\n\n  public void openHttpURLConnectionOk() throws IOException {\n    URL url = new URL(getURL());\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.disconnect();\n  }\n\n  public void castingArrayOfPrimitiveTypeOk(int[] a) {\n    int[] b = (int[]) a;\n  }\n}\n"
    },
    {
      "testname": "CloseableAsResourceExample.java",
      "testlanguage": "java",
      "expected-problems": 58,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass LocalException extends IOException {}\n\nclass SomeResource implements Closeable {\n\n  void doSomething() throws LocalException {\n    if (!CloseableAsResourceExample.star()) {\n      throw new LocalException();\n    }\n  }\n\n  public void close() {}\n\n  native void foo(int i);\n\n  static native void bar(SomeResource r);\n}\n\nclass Resource implements Closeable {\n  public Resource() {}\n\n  public void close() {}\n}\n\nclass Wrapper implements Closeable {\n  Resource mR;\n\n  public Wrapper(Resource r) {\n    mR = r;\n  }\n\n  public void close() {\n    mR.close();\n  }\n}\n\nclass Sub extends Wrapper {\n  public Sub(Resource r) {\n    super(r);\n  }\n}\n\nclass ResourceWithException implements Closeable {\n\n  public void close() throws IOException {\n    if (CloseableAsResourceExample.star()) {\n      throw new IOException();\n    }\n  }\n}\n\nclass ByteArrayOutputStreamWrapper extends ByteArrayOutputStream {}\n\nclass ByteArrayInputStreamWrapper extends ByteArrayInputStream {\n\n  public ByteArrayInputStreamWrapper(byte[] arr) {\n    super(arr);\n  }\n}\n\npublic class CloseableAsResourceExample {\n\n  static native boolean star();\n\n  void closingCloseable() {\n    SomeResource res = new SomeResource();\n    res.close();\n  }\n\n  void notClosingCloseable() {\n    SomeResource res = new SomeResource();\n  } // should report a resource leak\n\n  void tryWithResource() {\n    try (SomeResource res = new SomeResource()) {\n      try {\n        res.doSomething();\n      } catch (LocalException e) {\n        // do nothing\n      }\n    }\n  }\n\n  void withExceptionBad() throws LocalException {\n    SomeResource res = new SomeResource();\n    res.doSomething();\n    res.close();\n  } // should report a resource leak\n\n  void closingWrapper() {\n    Resource r = new Resource();\n    Sub s = new Sub(r);\n    s.close();\n  }\n\n  void notClosingWrapper() {\n    Sub s = new Sub(new Resource());\n    s.mR.close();\n  } // should report a resource leak\n\n  void needToCloseStringReaderBad() {\n    // The need for closing a StringReader is a bit controversial\n    // between Java programmers. But not closing it would violate\n    // the spec of the interface java.io.Reader anyway\n    StringReader stringReader = new StringReader(\"paf!\");\n  }\n\n  void noNeedToCloseByteArrayOutputStream() {\n    ByteArrayOutputStream stream = new ByteArrayOutputStream(42);\n  }\n\n  void noCloseByteArrayWrappersOk(byte[] array) {\n    ByteArrayOutputStreamWrapper stream1 = new ByteArrayOutputStreamWrapper();\n    ByteArrayInputStreamWrapper stream2 = new ByteArrayInputStreamWrapper(array);\n  }\n\n  void noNeedToCloseByteArrayInputStream(byte[] array) {\n    ByteArrayInputStream stream = new ByteArrayInputStream(array);\n  }\n\n  void closingWithCloseQuietly() {\n    SomeResource r = null;\n    try {\n      r = new SomeResource();\n      r.doSomething();\n    } catch (IOException e) {\n    } finally {\n      Utils.closeQuietly(r);\n    }\n  }\n\n  void failToCloseWithCloseQuietly() {\n    try {\n      SomeResource r = new SomeResource();\n      r.doSomething();\n      Utils.closeQuietly(r);\n    } catch (IOException e) {\n    }\n  }\n\n  void noLeakwithExceptionOnClose() throws IOException {\n    ResourceWithException res = new ResourceWithException();\n    res.close();\n  }\n\n  void noLeakWithCloseQuietlyAndExceptionOnClose() {\n    ResourceWithException res = new ResourceWithException();\n    Utils.closeQuietly(res);\n  }\n\n  static T sourceOfNullWithResourceLeak() {\n    SomeResource r = new SomeResource();\n    return null;\n  }\n\n  interface MyCloseable extends Closeable {}\n\n  class MyResource implements MyCloseable {\n    public void close() {}\n  }\n\n  void leakFoundWhenIndirectlyImplementingCloseable() {\n    MyResource res = new MyResource();\n  }\n\n  void skippedCallClosesResourceOnArgs() {\n    SomeResource res = new SomeResource();\n    SomeResource.bar(res);\n  }\n\n  void skippedVritualCallDoesNotCloseResourceOnReceiver() {\n    SomeResource res = new SomeResource();\n    res.foo(42);\n  }\n\n  Map returnsLocalMapContainingResourcesOk() {\n    HashMap<Integer, Closeable> map = new HashMap<>();\n    SomeResource res = new SomeResource();\n    Integer key = 42;\n    map.put(key, res);\n    return map;\n  }\n\n  void createsLocalMapContainingResourcesOk() {\n    HashMap<Integer, Closeable> map = new HashMap<>();\n    SomeResource res = new SomeResource();\n    Integer key = 42;\n    map.put(key, res);\n    map.clear();\n  }\n\n  HashMap<Integer, Closeable> resourceMap = new HashMap<>();\n\n  void fieldMapContainingResourcesOk() {\n    Integer key = 42;\n    SomeResource res = new SomeResource();\n    resourceMap.put(key, res);\n  }\n\n  // this case is not supported\n  void FN_notClearinglocalMapContainingResourcesBad() {\n    HashMap<Integer, Closeable> map = new HashMap<>();\n    SomeResource res = new SomeResource();\n    Integer key = 42;\n    map.put(key, res);\n  }\n\n  public static void closeCloseable(Closeable closeable) {\n    try {\n      if (closeable != null) {\n        closeable.close();\n      }\n    } catch (Exception ex) {\n    }\n  }\n\n  public void finallyCloseOk(File file, String fileContent) {\n    if (!file.exists()) {\n      FileWriter writer = null;\n      try {\n        writer = new FileWriter(file);\n        writer.write(fileContent);\n      } catch (FileNotFoundException e) {\n        e.printStackTrace();\n      } catch (IOException e) {\n        e.printStackTrace();\n      } finally {\n        closeCloseable(writer);\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "CountDeadCode.java",
      "testlanguage": "java",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\n/*\n This is a test file specific to the unreachability counting\n*/\n\npublic class CountDeadCode {\n\n  public int no_deadcode() {\n    int i = 0;\n    int x = 0;\n    if (i == 0) {\n      x = 1;\n    }\n    return x;\n  }\n\n  public int else_with_deadcode() {\n    int i = 0;\n    int x;\n    if (i == 0) {\n      x = 0;\n    } else { // only this part\n      x = 1; // is counted as unreachable\n    }\n    return x;\n  }\n\n  public int long_catch_block() {\n    try {\n      int i = 0;\n      int x;\n      if (i == 0) {\n        x = 0;\n      } else { // only this part\n        x = 1; // is counted as unreachable\n      }\n      return x;\n    } catch (Exception e) { // the unreachability count\n      int i = 0; // will not take into account\n      i++; // this block\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      i++;\n      return 0;\n    }\n  }\n}\n"
    },
    {
      "testname": "CursorLeaks.java",
      "testlanguage": "java",
      "expected-problems": 38,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport android.app.DownloadManager;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.CursorWrapper;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\n\npublic class CursorLeaks {\n\n  public int cursorClosed(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    try {\n      return cursor.getCount();\n    } finally {\n      cursor.close();\n    }\n  }\n\n  public Object cursorClosedCheckNull(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    Object value = null;\n\n    try {\n      if (cursor == null) {\n        return null;\n      }\n\n      value = cursor.getString(0);\n    } finally {\n      if (cursor != null) {\n        cursor.close();\n      }\n    }\n    return value;\n  }\n\n  public Object cursorClosedCheckNullCheckClosed_FP(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    Object value = null;\n\n    try {\n      if (cursor == null) {\n        return null;\n      }\n\n      value = cursor.getString(0);\n    } finally {\n      if (cursor != null && !cursor.isClosed()) {\n        cursor.close();\n      }\n    }\n    return value;\n  }\n\n  public int cursorNotClosed(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    return cursor.getCount();\n  }\n\n  Context mContext;\n  ContentResolver mContentResolver;\n\n  public int getImageCountHelperNotClosed(String customClause) {\n    String[] projection = {\"COUNT(*)\"};\n\n    String selectionClause = selectionClause = customClause;\n\n    Cursor cursor =\n        mContext.getContentResolver().query(null, projection, selectionClause, null, null);\n\n    if (cursor != null) {\n      int count = cursor.getInt(0);\n      // cursor.close();\n      return count;\n    } else {\n      return 0;\n    }\n  }\n\n  public int getImageCountHelperClosed(String customClause) {\n    String[] projection = {\"COUNT(*)\"};\n\n    String selectionClause = selectionClause = customClause;\n\n    Cursor cursor =\n        mContext.getContentResolver().query(null, projection, selectionClause, null, null);\n\n    if (cursor != null) {\n      int count = cursor.getInt(0);\n      cursor.close();\n      return count;\n    } else {\n      return 0;\n    }\n  }\n\n  public int getBucketCountNotClosed() {\n    Cursor cursor = MediaStore.Images.Media.query(mContentResolver, null, null, null, null, null);\n    if (cursor == null) {\n      return 0;\n    } else {\n      int count = 0;\n      while (cursor.moveToNext()) {\n        count++;\n      }\n      return count;\n    }\n  }\n\n  public int getBucketCountClosed() {\n    Cursor cursor = MediaStore.Images.Media.query(mContentResolver, null, null, null, null, null);\n    if (cursor == null) {\n      return 0;\n    } else {\n      try {\n        int count = 0;\n        while (cursor.moveToNext()) {\n          count++;\n        }\n        return count;\n      } finally {\n        cursor.close();\n      }\n    }\n  }\n\n  private void queryUVMLegacyDbNotClosed() {\n    SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n    builder.setTables(\"\");\n    Cursor cursor = builder.query(null, null, \"\", null, null, null, null);\n    if (cursor != null) cursor.moveToFirst();\n  }\n\n  private void queryUVMLegacyDbClosed() {\n    SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n    builder.setTables(\"\");\n    Cursor cursor = builder.query(null, null, \"\", null, null, null, null);\n    if (cursor != null) cursor.close();\n  }\n\n  public int completeDownloadClosed(DownloadManager downloadManager) {\n    DownloadManager.Query query = new DownloadManager.Query();\n    Cursor cursor = (Cursor) null;\n    try {\n      cursor = downloadManager.query(query);\n      if (cursor == null) {\n        return 0;\n      } else {\n        return cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);\n      }\n    } finally {\n      if (cursor != null) cursor.close();\n    }\n  }\n\n  public int completeDownloadNotClosed(DownloadManager downloadManager) {\n    DownloadManager.Query query = new DownloadManager.Query();\n    Cursor cursor = null;\n    try {\n      cursor = downloadManager.query(query);\n      if (cursor == null) {\n        return 0;\n      } else {\n        return cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);\n      }\n    } finally {\n      // cursor.close();\n    }\n  }\n\n  private void loadPrefsFromContentProviderClosed() {\n    ContentProviderClient contentProviderClient = mContentResolver.acquireContentProviderClient(\"\");\n    if (contentProviderClient != null) {\n      Cursor cursor = null;\n      try {\n        try {\n          cursor = contentProviderClient.query(null, null, null, null, null);\n        } catch (RemoteException ex) {\n        }\n      } finally {\n        if (cursor != null) {\n          cursor.close();\n        }\n      }\n    }\n  }\n\n  private void loadPrefsFromContentProviderNotClosed() {\n    ContentProviderClient contentProviderClient = mContentResolver.acquireContentProviderClient(\"\");\n    if (contentProviderClient == null) return;\n    Cursor cursor = null;\n    try {\n      try {\n        cursor = contentProviderClient.query(null, null, null, null, null);\n      } catch (RemoteException ex) {\n      }\n    } finally {\n      if (cursor != null) {\n        // cursor.close();\n      }\n    }\n  }\n\n  class NamedCursor extends CursorWrapper {\n    private String mName;\n\n    NamedCursor(Cursor cursor, String name) {\n      super(cursor);\n      mName = name;\n    }\n  }\n\n  public Cursor cursorWrapperReturned(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    return new NamedCursor(cursor, \"abc\");\n  }\n\n  // TODO (#7474990): investigate why is Infer reporting a resource leak here\n  //  public void cursorWrapperClosed(SQLiteDatabase sqLiteDatabase) {\n  //    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n  //    Cursor c = new NamedCursor(cursor, \"abc\");\n  //    c.close();\n  //  }\n\n  native NamedCursor createWrapper(Cursor cursor);\n\n  public NamedCursor cursorAttachedTheWrapper(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    return createWrapper(cursor);\n  }\n}\n"
    },
    {
      "testname": "CursorNPEs.java",
      "testlanguage": "java",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport android.app.DownloadManager;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.os.RemoteException;\nimport android.provider.MediaStore;\n\npublic class CursorNPEs {\n\n  public int cursorNPEfromQuery(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    try {\n      return cursor.getCount();\n    } finally {\n      cursor.close();\n    }\n  }\n\n  Context mContext;\n  ContentResolver mContentResolver;\n\n  public void FN_cursorFromContentResolverNPE(String customClause) {\n    String[] projection = {\"COUNT(*)\"};\n\n    String selectionClause = selectionClause = customClause;\n\n    Cursor cursor =\n        mContext.getContentResolver().query(null, projection, selectionClause, null, null);\n\n    cursor.close();\n  }\n\n  public void FN_cursorFromMediaNPE() {\n    Cursor cursor = MediaStore.Images.Media.query(mContentResolver, null, null, null, null, null);\n    cursor.close();\n  }\n\n  private void cursorFromSQLiteQueryBuilderNPE() {\n    SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n    builder.setTables(\"\");\n    Cursor cursor = builder.query(null, null, \"\", null, null, null, null);\n    cursor.close();\n  }\n\n  public int FN_cursorFromDownloadManagerNPE(DownloadManager downloadManager) {\n    DownloadManager.Query query = new DownloadManager.Query();\n    Cursor cursor = null;\n    try {\n      cursor = downloadManager.query(query);\n      return cursor.getColumnIndex(DownloadManager.COLUMN_STATUS);\n    } finally {\n      if (cursor != null) cursor.close();\n    }\n  }\n\n  private void cursorFromContentProviderClient() {\n    ContentProviderClient contentProviderClient = mContentResolver.acquireContentProviderClient(\"\");\n    if (contentProviderClient != null) {\n      Cursor cursor = null;\n      try {\n        try {\n          cursor = contentProviderClient.query(null, null, null, null, null);\n          cursor.moveToFirst();\n        } catch (RemoteException ex) {\n        }\n      } finally {\n        if (cursor != null) {\n          cursor.close();\n        }\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "DefaultInInterface.java",
      "testlanguage": "java",
      "expected-problems": 25,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npublic class DefaultInInterface {\n\n  static interface I {\n    default Object defaultMethod1() {\n      return null;\n    }\n\n    default Object defaultMethod2() {\n      return \"foo\";\n    }\n  }\n\n  public static class A implements I {\n    public void defaultCallNPE() {\n      System.out.println(this.defaultMethod1().toString());\n    }\n\n    public void defaultCallOk() {\n      System.out.println(this.defaultMethod2().toString());\n    }\n  }\n\n  public static class B extends A {\n    public Object defaultMethod1() {\n      return \"foo\";\n    }\n\n    public Object defaultMethod2() {\n      return null;\n    }\n\n    public void overridenCallOk() {\n      System.out.println(this.defaultMethod1().toString());\n    }\n\n    public void overridenCallNPE() {\n      System.out.println(this.defaultMethod2().toString());\n    }\n  }\n\n  static void uncertainCallMethod1NPE(int i) {\n    A aAorB = new A();\n    if (i > 0) { // feasible path\n      aAorB = new B();\n    }\n    System.out.println(aAorB.defaultMethod1().toString());\n  }\n\n  static void uncertainCallMethod2NPE(int i) {\n    A aAorB = new A();\n    if (i > 0) { // feasible path\n      aAorB = new B();\n    }\n    System.out.println(aAorB.defaultMethod2().toString());\n  }\n}\n"
    },
    {
      "testname": "DivideByZero.java",
      "testlanguage": "java",
      "expected-problems": 20,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class DivideByZero {\n\n  public int divByZeroLocal(String s) {\n    int denominator = 0;\n    int nominator = 10;\n    int result = nominator / denominator;\n    return result;\n  }\n\n  public int divideByZeroInterProc(int denominator) {\n    return 10 / denominator;\n  }\n\n  // DO NOT MOVE, test relies on line number\n  public int callDivideByZeroInterProc() {\n    return divideByZeroInterProc(0);\n  }\n\n  // divide by zero with static fields\n  private static int x;\n\n  public void setXToZero() {\n    x = 0;\n  }\n\n  public int divideByZeroWithStaticField() {\n    setXToZero();\n    return divideByZeroInterProc(x);\n  }\n}\n"
    },
    {
      "testname": "DoubleExample.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport javax.annotation.Nullable;\n\npublic class DoubleExample {\n\n  @Nullable Double x;\n\n  private Double testAssignNonNullOk() {\n    x = 1.0;\n    return x + 1.0;\n  }\n\n  private Double FN_testdReadNullableBad() {\n    return x + 1.0;\n  }\n}\n"
    },
    {
      "testname": "DynamicDispatch.java",
      "testlanguage": "java",
      "expected-problems": 74,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class DynamicDispatch {\n\n  static interface Interface {\n    public Object foo();\n  }\n\n  static class Impl implements Interface {\n    @Override\n    public Object foo() {\n      return null;\n    }\n  }\n\n  static final class FinalImpl extends Impl {}\n\n  static void interfaceShouldNotCauseFalseNegativeEasyBad() {\n    Interface i = new Impl();\n    // should be a warning since Impl's implementation of foo returns null\n    i.foo().toString();\n  }\n\n  static void FN_interfaceShouldNotCauseFalseNegativeHardOK(Interface i) {\n    i.foo().toString();\n  }\n\n  static void callWithBadImplementationBad_FN(Impl impl) {\n    FN_interfaceShouldNotCauseFalseNegativeHardOK(impl);\n  }\n\n  static void callWithBadFinalImplementationBad(FinalImpl impl) {\n    FN_interfaceShouldNotCauseFalseNegativeHardOK(impl);\n  }\n\n  static class Supertype {\n    Object foo() {\n      return new Object();\n    }\n\n    Object bar() {\n      return null;\n    }\n  }\n\n  static class Subtype extends Supertype {\n    @Override\n    Object foo() {\n      return null;\n    }\n\n    @Override\n    Object bar() {\n      return new Object();\n    }\n  }\n\n  static void dynamicDispatchShouldNotCauseFalseNegativeEasyBad() {\n    Supertype o = new Subtype();\n    // should report a warning because we know the dynamic type of o is Subtype\n    o.foo().toString();\n  }\n\n  static void dynamicDispatchShouldNotCauseFalsePositiveEasyOK() {\n    Supertype o = new Subtype();\n    // should not report a warning because we know the dynamic type of o is Subtype\n    o.bar().toString();\n  }\n\n  static void dynamicDispatchShouldNotReportWhenCallingSupertypeOK(Supertype o) {\n    // should not report a warning because the Supertype implementation\n    // of foo() does not return null\n    o.foo().toString();\n  }\n\n  static void dynamicDispatchShouldReportWhenCalledWithSubtypeParameterBad_FN(Subtype o) {\n    // should report a warning because the Subtype implementation\n    // of foo() returns null\n    dynamicDispatchShouldNotReportWhenCallingSupertypeOK(o);\n  }\n\n  static Object dynamicDispatchWrapperFoo(Supertype o) {\n    return o.foo();\n  }\n\n  static Object dynamicDispatchWrapperBar(Supertype o) {\n    return o.bar();\n  }\n\n  static void dynamicDispatchCallsWrapperWithSupertypeOK() {\n    // Should not report because Supertype.foo() does not return null\n    Supertype o = new Supertype();\n    dynamicDispatchWrapperFoo(o).toString();\n  }\n\n  static void dynamicDispatchCallsWrapperWithSupertypeBad() {\n    // Should report because Supertype.bar() returns null\n    Supertype o = new Supertype();\n    dynamicDispatchWrapperBar(o).toString();\n  }\n\n  static void dynamicDispatchCallsWrapperWithSubtypeBad() {\n    // Should report because Subtype.foo() returns null\n    Supertype o = new Subtype();\n    dynamicDispatchWrapperFoo(o).toString();\n  }\n\n  static void dynamicDispatchCallsWrapperWithSubtypeOK() {\n    // Should not report because Subtype.bar() does not returns null\n    Supertype o = new Subtype();\n    dynamicDispatchWrapperBar(o).toString();\n  }\n\n  static class WithField {\n\n    Supertype mField;\n\n    WithField(Supertype t) {\n      mField = t;\n    }\n\n    static void dispatchOnFieldOK() {\n      Supertype subtype = new Subtype();\n      WithField object = new WithField(subtype);\n      object.mField.bar().toString();\n    }\n\n    static void dispatchOnFieldBad() {\n      Supertype subtype = new Subtype();\n      WithField object = new WithField(subtype);\n      object.mField.foo().toString();\n    }\n  }\n\n  private Object callFoo(Supertype o) {\n    return o.foo();\n  }\n\n  void dynamicResolutionWithPrivateMethodBad() {\n    Supertype subtype = new Subtype();\n    callFoo(subtype).toString();\n  }\n\n  Object variadicMethod(Supertype... args) {\n    if (args.length == 0) {\n      return null;\n    } else {\n      return args[0].foo();\n    }\n  }\n\n  void dynamicResolutionWithVariadicMethodBad() {\n    Supertype subtype = new Subtype();\n    variadicMethod(subtype, null, null).toString();\n  }\n}\n\nclass InheritanceDispatch {\n  class A {\n    int foo() {\n      return 32;\n    }\n  }\n\n  class B extends A {\n    int foo() {\n      return 52;\n    }\n  }\n\n  class C extends B {}\n\n  A getB() {\n    return new B();\n  }\n\n  A getC() {\n    return new C();\n  }\n\n  void dispatch_to_B_ok() {\n    A b = getB();\n    if (b.foo() == 32) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  void dispatch_to_B_bad() {\n    A b = getB();\n    if (b.foo() == 52) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  void dispatch_to_A_bad() {\n    A a = new A();\n    if (a.foo() == 32) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  void dispatch_to_C_bad() {\n    A c = getC();\n    if (c.foo() == 52) {\n      Object o = null;\n      o.toString();\n    }\n  }\n}\n\nclass Specialization {\n\n  static class C {\n    C f;\n  }\n\n  abstract static class A {\n    abstract C buildC();\n\n    C callBuildC(A a) {\n      return a.buildC();\n    }\n  }\n\n  static class A_Good extends A {\n    C buildC() {\n      return new C();\n    }\n\n  }\n\n  static class A_Bad extends A {\n    C buildC() {\n      return null;\n    }\n\n  }\n\n  // basic specialization on parameters\n  C callBuildCGood(A a) {\n    return a.buildC();\n  }\n\n  C buildCAndDerefBad() {\n    return callBuildCGood(new A_Bad()).f;\n  }\n\n  C buildCAndDerefGood() {\n    return callBuildCGood(new A_Good()).f;\n  }\n\n  // specialization on field\n  static class Box1 {\n    Box2 f1;\n\n    Box1(Box2 f1) {\n      this.f1 = f1;\n    }\n  }\n\n  static class Box2 {\n    Box3 f2;\n\n    Box2(Box3 f2) {\n      this.f2 = f2;\n    }\n  }\n\n  static class Box3 {\n    A f3;\n\n    Box3(A f3) {\n      this.f3 = f3;\n    }\n  }\n\n  C callBuildCOnBoxGood(Box1 box) {\n    return box.f1.f2.f3.buildC();\n  }\n\n  C buildCOnBoxAndDerefBad() {\n    return callBuildCOnBoxGood(new Box1(new Box2(new Box3(new A_Bad())))).f;\n  }\n\n  C buildCOnBoxAndDerefGood() {\n    return callBuildCOnBoxGood(new Box1(new Box2(new Box3(new A_Good())))).f;\n  }\n\n  // require iterative specialization\n  C callCallBuildC(A a1, A a2) {\n    return a1.callBuildC(a2);\n  }\n\n  C buildCTransitivelyAndDerefBad() {\n    return callCallBuildC(new A_Good(), new A_Bad()).f;\n  }\n\n  C buildCTransitivelyAndDerefGood() {\n    return callCallBuildC(new A_Bad(), new A_Good()).f;\n  }\n\n  C callBuildCWithEmptyPaths(A a, boolean b) {\n    return b ? a.buildC(): null;\n  }\n\n  C buildCWithInfeasiblePathsAndDerefBad() {\n    return callBuildCWithEmptyPaths(new A_Bad(), true).f;\n  }\n\n  C buildCWithInfeasiblePathsAndDerefGood() {\n    return callBuildCWithEmptyPaths(new A_Good(), true).f;\n  }\n\n  C callBuildCTwiceGood(A a1, A a2) {\n    C c = (a1 == null) ? null : a1.buildC();\n    return (a2 == null) ? null : a2.buildC();\n  }\n\n  C buildCAndDerefNeedPartialSpecializationBad(A a) {\n    return callBuildCTwiceGood(a, new A_Bad()).f;\n  }\n\n  C buildCAndDerefNeedPartialSpecializationGood(A a) {\n    return callBuildCTwiceGood(a, new A_Good()).f;\n  }\n}\n"
    },
    {
      "testname": "FilterInputStreamLeaks.java",
      "testlanguage": "java",
      "expected-problems": 44,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.*;\nimport java.security.DigestInputStream;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.DeflaterInputStream;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.InflaterInputStream;\nimport javax.crypto.CipherInputStream;\n\npublic class FilterInputStreamLeaks {\n\n  // BufferedInputStream  tests\n\n  public void bufferedInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      BufferedInputStream bis = new BufferedInputStream(fis);\n      bis.read();\n      bis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void bufferedInputStreamClosedAfterResetOk() throws IOException {\n    FileInputStream fis;\n    BufferedInputStream bis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      bis = new BufferedInputStream(fis);\n      bis.reset();\n    } catch (IOException e) {\n    } finally {\n      if (bis != null) bis.close();\n    }\n  }\n\n  // CheckedInputStream  tests\n\n  public void checkedInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      CheckedInputStream chis = new CheckedInputStream(fis, null);\n      chis.read();\n      chis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void checkedInputStreamClosedAfterSkipOk() throws IOException {\n    FileInputStream fis;\n    CheckedInputStream chis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      chis = new CheckedInputStream(fis, null);\n      chis.skip(5);\n    } catch (IOException e) {\n    } finally {\n      if (chis != null) chis.close();\n    }\n  }\n\n  // CipherInputStream  tests\n\n  public void cipherInputStreamNotClosedAfterSkipBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      CipherInputStream cis = new CipherInputStream(fis, null);\n      cis.skip(8);\n      cis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void cipherInputStreamClosedAfterReadOk() throws IOException {\n    FileInputStream fis;\n    CipherInputStream cis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      cis = new CipherInputStream(fis, null);\n      cis.read();\n    } catch (IOException e) {\n    } finally {\n      if (cis != null) cis.close();\n    }\n  }\n\n  // DataInputStream  tests\n\n  public void dataInputStreamNotClosedAfterReadBad() {\n    byte[] arr = new byte[10];\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      DataInputStream dis = new DataInputStream(fis);\n      dis.read(arr);\n      dis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void dataInputStreamClosedAfterReadBooleanOk() throws IOException {\n    FileInputStream fis;\n    DataInputStream dis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      dis = new DataInputStream(fis);\n      dis.readBoolean();\n    } catch (IOException e) {\n    } finally {\n      if (dis != null) dis.close();\n    }\n  }\n\n  public static void try_with_resourceOK() throws IOException {\n    try (DataInputStream dis = new DataInputStream(new FileInputStream(\"foo.txt\"))) {\n      int version = dis.readInt();\n      if (version != 0) {\n        throw new RuntimeException(\"Unexpected version \" + version);\n      }\n    }\n  }\n\n  // DeflaterInputStream  tests\n\n  public void deflaterInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      DeflaterInputStream dis = new DeflaterInputStream(fis, null);\n      dis.read();\n      dis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void deflaterInputStreamClosedAfterResetOk() throws IOException {\n    FileInputStream fis;\n    DeflaterInputStream dis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      dis = new DeflaterInputStream(fis, null);\n      dis.reset();\n    } catch (IOException e) {\n    } finally {\n      if (dis != null) dis.close();\n    }\n  }\n\n  // GZipInputStream  tests\n\n  public void gzipInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      GZIPInputStream gzipInputStream = new GZIPInputStream(fis);\n      gzipInputStream.read();\n      gzipInputStream.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void gzipInputStreamClosedAfterReadOk() throws IOException {\n    FileInputStream fis = null;\n    GZIPInputStream gzipInputStream = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      gzipInputStream = new GZIPInputStream(fis);\n      gzipInputStream.read();\n    } catch (IOException e) {\n    } finally {\n      if (gzipInputStream != null) gzipInputStream.close();\n      else if (fis != null) fis.close();\n    }\n  }\n\n  // DigestInputStream  tests\n\n  public void digestInputStreamNotClosedAfterReadBad() {\n    byte[] arr = new byte[10];\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      DigestInputStream dis = new DigestInputStream(fis, null);\n      dis.read(arr);\n      dis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void digestInputStreamClosedAfterReadOk() throws IOException {\n    FileInputStream fis;\n    DigestInputStream dis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      dis = new DigestInputStream(fis, null);\n      dis.read();\n    } catch (IOException e) {\n    } finally {\n      if (dis != null) dis.close();\n    }\n  }\n\n  // InflaterInputStream  tests\n\n  public void inflaterInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      InflaterInputStream iis = new InflaterInputStream(fis, null);\n      iis.read();\n      iis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void inflaterInputStreamClosedAfterAvailableOk() throws IOException {\n    FileInputStream fis;\n    InflaterInputStream iis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      iis = new InflaterInputStream(fis, null);\n      iis.available();\n    } catch (IOException e) {\n    } finally {\n      if (iis != null) iis.close();\n    }\n  }\n\n  // PushbackInputStream tests\n\n  public void pushbackInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      PushbackInputStream pms = new PushbackInputStream(fis);\n      pms.read();\n      pms.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pushbackInputStreamClosedAfterResetOk() throws IOException {\n    FileInputStream fis;\n    PushbackInputStream pms = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      pms = new PushbackInputStream(fis);\n      pms.reset();\n    } catch (IOException e) {\n    } finally {\n      if (pms != null) pms.close();\n    }\n  }\n\n  public void twoLevelWrapperNoLeakOk(File file) throws IOException {\n    DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(file)));\n    in.close();\n  }\n}\n"
    },
    {
      "testname": "FilterOutputStreamLeaks.java",
      "testlanguage": "java",
      "expected-problems": 46,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.security.DigestOutputStream;\nimport java.util.zip.CheckedOutputStream;\nimport java.util.zip.DeflaterOutputStream;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.InflaterOutputStream;\nimport javax.crypto.CipherOutputStream;\n\npublic class FilterOutputStreamLeaks {\n\n  // FilterOutputStream  tests\n\n  public void filterOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      FilterOutputStream fos = new FilterOutputStream(fis);\n      fos.write(arr);\n      fos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void filterOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    FilterOutputStream fos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      fos = new FilterOutputStream(fis);\n      fos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (fos != null) fos.close();\n    }\n  }\n\n  // DataOutputStream  tests\n\n  public void dataOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      DataOutputStream dos = new DataOutputStream(fis);\n      dos.write(arr);\n      dos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void dataOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    DataOutputStream dos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      dos = new DataOutputStream(fis);\n      dos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (dos != null) dos.close();\n    }\n  }\n\n  // BufferedOutputStream  tests\n\n  public void bufferedOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      BufferedOutputStream bos = new BufferedOutputStream(fis);\n      bos.write(arr);\n      bos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void bufferedOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    BufferedOutputStream bos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      bos = new BufferedOutputStream(fis);\n      bos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (bos != null) bos.close();\n    }\n  }\n\n  // CheckedOutputStream  tests\n\n  public void checkedOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      CheckedOutputStream chos = new CheckedOutputStream(fis, null);\n      chos.write(arr);\n      chos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void checkedOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    CheckedOutputStream chos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      chos = new CheckedOutputStream(fis, null);\n      chos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (chos != null) chos.close();\n    }\n  }\n\n  // CipherOutputStream  tests\n\n  public void cipherOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      CipherOutputStream cos = new CipherOutputStream(fis, null);\n      cos.write(arr);\n      cos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void cipherOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    CipherOutputStream cos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      cos = new CipherOutputStream(fis, null);\n      cos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (cos != null) cos.close();\n    }\n  }\n\n  // DeflaterOutputStream  tests\n\n  public void deflaterOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      DeflaterOutputStream dos = new DeflaterOutputStream(fis, null);\n      dos.write(arr);\n      dos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void deflaterOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    DeflaterOutputStream dos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      dos = new DeflaterOutputStream(fis, null);\n      dos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (dos != null) dos.close();\n    }\n  }\n\n  public void deflaterOutputStreamWithArgNotClosedAfterWriteBad(FileOutputStream fis) {\n    byte[] arr = {1, 2, 3};\n    try {\n      DeflaterOutputStream dos = new DeflaterOutputStream(fis, null);\n      dos.write(arr);\n    } catch (IOException e) {\n    }\n  }\n\n  public void deflaterOutputStreamWithArgClosedAfterWriteOk(FileOutputStream fis)\n      throws IOException {\n    byte[] arr = {1, 2, 3};\n    DeflaterOutputStream dos = new DeflaterOutputStream(fis, null);\n    try {\n      dos.write(arr);\n    } finally {\n      dos.finish();\n    }\n  }\n\n  // DigestOutputStream  tests\n\n  public void digestOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      DigestOutputStream dos = new DigestOutputStream(fis, null);\n      dos.write(arr);\n      dos.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void digestOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    DigestOutputStream dos = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      dos = new DigestOutputStream(fis, null);\n      dos.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (dos != null) dos.close();\n    }\n  }\n\n  // InflaterOutputStream  tests\n\n  public void inflaterOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      InflaterOutputStream ios = new InflaterOutputStream(fis, null);\n      ios.write(arr);\n      ios.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void inflaterOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    InflaterOutputStream ios = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      ios = new InflaterOutputStream(fis, null);\n      ios.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (ios != null) ios.close();\n    }\n  }\n\n  // GZipOutputStream  tests\n\n  public void gzipOutputStreamNotClosedAfterFlushBad() {\n    FileOutputStream fos;\n    try {\n      fos = new FileOutputStream(\"file.txt\");\n      GZIPOutputStream gzipOutputStream = new GZIPOutputStream(fos);\n      gzipOutputStream.flush();\n      gzipOutputStream.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void gzipOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fos = null;\n    GZIPOutputStream gzipOutputStream = null;\n    try {\n      fos = new FileOutputStream(\"file.txt\");\n      gzipOutputStream = new GZIPOutputStream(fos);\n      gzipOutputStream.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (gzipOutputStream != null) gzipOutputStream.close();\n      else if (fos != null) fos.close();\n    }\n  }\n\n  // PrintStream  tests\n\n  public void printStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      InflaterOutputStream printer = new InflaterOutputStream(fis, null);\n      printer.write(arr);\n    } catch (IOException e) {\n    }\n  }\n\n  public void printStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis;\n    InflaterOutputStream printer = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      printer = new InflaterOutputStream(fis, null);\n      printer.write(arr);\n    } catch (IOException e) {\n    } finally {\n      if (printer != null) printer.close();\n    }\n  }\n}\n"
    },
    {
      "testname": "GuardedByExample.java",
      "testlanguage": "java",
      "expected-problems": 117,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport android.annotation.SuppressLint;\nimport com.google.common.annotations.VisibleForTesting;\nimport java.io.Closeable;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport javax.annotation.concurrent.GuardedBy;\n\npublic class GuardedByExample {\n\n  static class AutoCloseableReadWriteUpdateLock implements Closeable {\n    @Override\n    public void close() {}\n  }\n\n  private Object mLock = new Object();\n\n  private Object mOtherLock = new Object();\n\n  private AutoCloseableReadWriteUpdateLock mReadWriteLock = new AutoCloseableReadWriteUpdateLock();\n\n  @GuardedBy(\"mLock\")\n  private Object f = new Object();\n\n  @GuardedBy(\"this\")\n  Object g = new Object();\n\n  Object mCopyOfG;\n\n  @GuardedBy(\"SomeLockThatDoesntExist\")\n  Object h = new Object();\n\n  @GuardedBy(\"mReadWriteLock\")\n  Object i = new Object();\n\n  private static Object sLock = new Object();\n\n  @GuardedBy(\"sLock\")\n  static Object sFld;\n\n  @GuardedBy(\"GuardedByExample.class\")\n  static Object sGuardedByClass;\n\n  static {\n    // don't warn on class initializer\n    sFld = new Object();\n  }\n\n  public GuardedByExample() {\n    // don't warn on reads or writes of Guarded fields in constructor\n    f.toString();\n    g = new Object();\n  }\n\n  void readFBad() {\n    this.f.toString();\n  }\n\n  @SuppressLint(\"InvalidAccessToGuardedField\")\n  void readFBadButSuppressed() {\n    this.f.toString();\n  }\n\n  @SuppressLint(\"SomeOtherWarning\")\n  void readFBadButSuppressedOther() {\n    this.f.toString();\n  }\n\n  void writeFBad() {\n    this.f = new Object();\n  }\n\n  void readFBadWrongLock() {\n    synchronized (mOtherLock) {\n      this.f.toString(); // f is supposed to be protected by mLock\n    }\n  }\n\n  void writeFBadWrongLock() {\n    synchronized (mOtherLock) {\n      this.f = new Object(); // f is supposed to be protected by mLock\n    }\n  }\n\n  void readFAfterBlockBad() {\n    synchronized (mLock) {\n    }\n    this.f.toString();\n  }\n\n  void writeFAfterBlockBad() {\n    synchronized (mLock) {\n    }\n    this.f = new Object();\n  }\n\n  @GuardedBy(\"mOtherLock\")\n  void readFBadWrongAnnotation() {\n    this.f.toString();\n  }\n\n  @GuardedBy(\"mLock\")\n  void readFOkMethodAnnotated() {\n    this.f.toString();\n  }\n\n  synchronized void synchronizedMethodReadOk() {\n    this.g.toString();\n  }\n\n  synchronized void synchronizedMethodWriteOk() {\n    this.g = new Object();\n  }\n\n  void readFOkSynchronized() {\n    synchronized (mLock) {\n      this.f.toString();\n    }\n  }\n\n  void writeFOkSynchronized() {\n    synchronized (mLock) {\n      this.f = new Object();\n    }\n  }\n\n  synchronized void synchronizedMethodReadBad() {\n    this.f.toString(); // f is supposed to be protected by mLock, not this\n  }\n\n  synchronized void synchronizedMethodWriteBad() {\n    this.f = new Object(); // f is supposed to be protected by mLock, not this\n  }\n\n  void reassignCopyOk() {\n    synchronized (this) {\n      mCopyOfG = g; // these are ok: access of g guarded by this\n    }\n    mCopyOfG = new Object(); // ok; this doesn't change the value of g\n  }\n\n  void readHBad() {\n    synchronized (mLock) { // h is not protected by mLock\n      this.h.toString();\n    }\n  }\n\n  synchronized void readHBadSynchronizedMethodShouldntHelp() {\n    this.h.toString(); // h is not protected by this\n  }\n\n  private void privateUnguardedAccess() {\n    // not protected, but safe if all call sites guard the access to f\n    this.g.toString();\n  }\n\n  public void guardedCallSite1() {\n    synchronized (this) {\n      privateUnguardedAccess(); // should not warn; lock is held\n    }\n  }\n\n  public synchronized void guardedCallSite2() {\n    privateUnguardedAccess(); // should not warn; lock is held\n  }\n\n  private void wrapper() {\n    privateUnguardedAccess(); // should not warn, just propagate the proof obl\n  }\n\n  public void guardedCallSite3() {\n    synchronized (this) {\n      wrapper(); // should not  warn\n    }\n  }\n\n  void readWriteLockOk() {\n    try (AutoCloseableReadWriteUpdateLock lock = mReadWriteLock) {\n      this.i.toString();\n    }\n  }\n\n  static synchronized void staticSynchronizedOk() {\n    sGuardedByClass.toString();\n  }\n\n  static void synchronizeOnClassOk1() {\n    synchronized (GuardedByExample.class) {\n      sGuardedByClass.toString(); // should not warn here\n      sGuardedByClass = new Object(); // or here\n    }\n  }\n\n  void synchronizedOnThisBad() {\n    sGuardedByClass.toString();\n  }\n\n  Object dontReportOnCompilerGenerated() {\n    return new Object() {\n      public void accessInAnonClassOk() {\n        synchronized (mLock) {\n          f.toString();\n        }\n      }\n    };\n  }\n\n  Object readFromInnerClassOkOuter() {\n    return new Object() {\n      public String readFromInnerClassOk() {\n        synchronized (GuardedByExample.this) {\n          return g.toString();\n        }\n      }\n    };\n  }\n\n  Object readFromInnerClassBad1Outer() {\n    return new Object() {\n      public String readFromInnerClassBad1() {\n        synchronized (this) {\n          return g.toString(); // g is guarded by the outer class this, not this$0\n        }\n      }\n    };\n  }\n\n  Object readFromInnerClassBad2Outer() {\n    return new Object() {\n      public synchronized String readFromInnerClassBad2() {\n        return g.toString(); // g is guarded by the outer class this, not this$0\n      }\n    };\n  }\n\n  @VisibleForTesting\n  public void visibleForTestingOk1() {\n    f.toString(); // should push proof obl to caller\n  }\n\n  @VisibleForTesting\n  void visibleForTestingOk2() {\n    f.toString(); // should push proof obl to caller\n  }\n\n  synchronized Object returnPtG() {\n    return g;\n  }\n\n  // note: this test should raise an error under \"by value\" GuardedBy semantics, but not under\n  // \"by reference\" GuardedBy semantics\n  void readGFromCopyOk() {\n    synchronized (this) {\n      mCopyOfG = g; // these are ok: access of g guarded by this\n      g.toString();\n    }\n    mCopyOfG.toString(); // should be an error; unprotected access to pt(g)\n  }\n\n  // another \"by reference\" vs \"by value\" test. buggy in \"by value\", but safe in \"by reference\"\n  void usePtG() {\n    Object ptG = returnPtG();\n    ptG.toString();\n  }\n\n  Object byRefTrickyBad() {\n    Object local = null;\n    synchronized (this) {\n      local = g; // we have a local pointer... to pt(G)\n    }\n    g.toString(); // ...but unsafe access is through g!\n    return local;\n  }\n\n  void byRefTrickyOk() {\n    Object local = null;\n    synchronized (this) {\n      local = g; // we have a local pointer... to pt(G)\n    }\n    local.toString(); // ...but unsafe access is through g!\n  }\n\n  @GuardedBy(\"ui_thread\")\n  Object uiThread1;\n\n  @GuardedBy(\"ui-thread\")\n  Object uiThread2;\n\n  @GuardedBy(\"uithread\")\n  Object uiThread3;\n\n  @GuardedBy(\"something that's clearly not an expression\")\n  Object nonExpression;\n\n  // tests for not reporting false alarms on unrecognized GuardedBy strings\n  void accessUnrecognizedGuardedByFieldsOk() {\n    uiThread1 = new Object();\n    uiThread1.toString();\n    uiThread2 = new Object();\n    uiThread2.toString();\n    uiThread3 = new Object();\n    uiThread3.toString();\n    nonExpression = new Object();\n    nonExpression.toString();\n  }\n\n  // outer class this tests\n  @GuardedBy(\"GuardedByExample.this\")\n  Object guardedByOuterThis;\n\n  synchronized void okOuterAccess() {\n    guardedByOuterThis = null;\n  }\n\n  // inner class this tests\n  private class Inner {\n    @GuardedBy(\"this\")\n    Object guardedByInnerThis1;\n\n    @GuardedBy(\"Inner.this\")\n    Object guardedByInnerThis2;\n\n    @GuardedBy(\"GuardedByExample$Inner.this\")\n    Object guardedByInnerThis3;\n\n    @GuardedBy(\"Inner.class\")\n    Object guardedByInnerClass1;\n\n    @GuardedBy(\"GuardedByExample.Inner.class\")\n    Object guardedByInnerClass2;\n\n    @GuardedBy(\"GuardedByExample$Inner.class\")\n    Object guardedByInnerClass3;\n\n    synchronized void okAccess1() {\n      guardedByInnerThis1 = null;\n    }\n\n    synchronized void okAccess2() {\n      guardedByInnerThis2 = null;\n    }\n\n    synchronized void okAccess3() {\n      guardedByInnerThis3 = null;\n    }\n\n    void okInnerClassGuard1() {\n      synchronized (Inner.class) {\n        guardedByInnerClass1 = new Object();\n        guardedByInnerClass2 = new Object();\n        guardedByInnerClass3 = new Object();\n      }\n    }\n\n    void okInnerClassGuard2() {\n      synchronized (GuardedByExample.Inner.class) {\n        guardedByInnerClass1 = new Object();\n        guardedByInnerClass2 = new Object();\n        guardedByInnerClass3 = new Object();\n      }\n    }\n  }\n\n  // TODO: report on these cases\n  /*\n  public void unguardedCallSiteBad1() {\n    privateUnguardedAccess(); // should warn; lock is not held\n  }\n\n  protected void unguardedCallSiteBad2() {\n    privateUnguardedAccess(); // should warn; lock is not held\n  }\n\n  void unguardedCallSiteBad3() {\n    privateUnguardedAccess(); // should warn; lock is not held\n  }\n  */\n\n  int n;\n\n  public void withloop2() {\n    synchronized (mLock) {\n      for (int i = 0; i <= n; i++) {\n        f = 42;\n      }\n    }\n  }\n\n  public void withoutloop2() {\n    synchronized (mLock) {\n      f = 42;\n    }\n  }\n\n  @GuardedBy(\"self_reference\")\n  Object self_reference;\n\n  void guardedBySelfReferenceOK() {\n    synchronized (self_reference) {\n      this.self_reference.toString();\n    }\n  }\n\n  // TODO: report on this case, or at least a version which writes\n  /*\n  void guardedBySelfReferenceBad() {\n     this.self_reference.toString();\n   }\n   */\n\n  @GuardedBy(\"itself\")\n  Object itself_fld;\n\n  void itselfOK() {\n    synchronized (itself_fld) {\n      this.itself_fld.toString();\n    }\n  }\n\n  // TODO: report on this case, or at least a version which writes\n  /*\n  void itselfBad() {\n     this.itself_fld.toString();\n   }\n   */\n\n  ReadWriteLock mRWL;\n\n  @GuardedBy(\"mRWL\")\n  Integer guardedbymRWL;\n\n  Integer someOtherInt;\n\n  void readLockOK() {\n    mRWL.readLock().lock();\n    someOtherInt = guardedbymRWL;\n    mRWL.readLock().unlock();\n  }\n\n  void writeLockOK() {\n    mRWL.writeLock().lock();\n    guardedbymRWL = 55;\n    mRWL.writeLock().unlock();\n  }\n\n  ReentrantReadWriteLock mRRWL;\n\n  @GuardedBy(\"mRRWL\")\n  Integer guardedbymRRWL;\n\n  void reentrantReadLockOK() {\n    mRRWL.readLock().lock();\n    someOtherInt = guardedbymRRWL;\n    mRRWL.readLock().unlock();\n  }\n\n  void reentrantWriteLockOK() {\n    mRRWL.writeLock().lock();\n    guardedbymRRWL = 55;\n    mRRWL.writeLock().unlock();\n  }\n\n  // TODO: warn on misuse of read/write locks.\n\n  @GuardedBy(\"this\")\n  Integer xForSub;\n\n  static class Sub extends GuardedByExample {\n\n    void goodSub1() {\n      synchronized (this) {\n        xForSub = 22;\n      }\n    }\n\n    synchronized void goodSub2() {\n      xForSub = 22;\n    }\n\n    void badSub() {\n      xForSub = 22;\n    }\n  }\n\n  Lock normallock;\n\n  @GuardedBy(\"normallock\")\n  Integer guardedbynl;\n\n  ReentrantLock reentrantlock;\n\n  @GuardedBy(\"reentrantlock\")\n  Integer guardedbyrel;\n\n  void goodGuardedByNormalLock() {\n    normallock.lock();\n    guardedbynl = 22;\n    normallock.unlock();\n  }\n\n  void goodTryLockGuardedByNormalLock() {\n    if (normallock.tryLock()) {\n      guardedbynl = 22;\n      normallock.unlock();\n    }\n  }\n\n  void goodTryLockGuardedByReentrantLock() {\n    if (reentrantlock.tryLock()) {\n      guardedbyrel = 44;\n      reentrantlock.unlock();\n    }\n  }\n\n  void badGuardedByNormalLock() {\n    guardedbynl = 22;\n  }\n\n  void badGuardedByReentrantLock() {\n    guardedbyrel = 44;\n  }\n\n  static class OtherClassWithLock {\n    ReentrantLock lock;\n\n    @GuardedBy(\"lock\")\n    Object guardedByLock;\n\n    Object otherClassObject;\n\n    void guardedInSameClassOk() {\n      lock.lock();\n      guardedByLock = new Object();\n      lock.unlock();\n    }\n  }\n\n  @GuardedBy(\"OtherClassWithLock.lock\")\n  Object guardedByLock1;\n\n  @GuardedBy(\"codetoanalyze.java.infer.GuardedByExample$OtherClassWithLock.lock\")\n  Object guardedByLock2;\n\n  @GuardedBy(\"OtherClassWithLock.otherClassObject\")\n  Object guardedByLock3;\n\n  OtherClassWithLock otherClass;\n\n  void guardedByTypeSyntaxOk1() {\n    otherClass.lock.lock();\n    guardedByLock1 = true;\n    guardedByLock2 = true;\n    otherClass.lock.unlock();\n  }\n\n  void guardedByTypeSyntaxOk2() {\n    synchronized (otherClass.otherClassObject) {\n      guardedByLock3 = true;\n    }\n  }\n\n  void guardedByTypeSyntaxBad() {\n    guardedByLock1 = true;\n    guardedByLock2 = true;\n  }\n}\n"
    },
    {
      "testname": "HashMapExample.java",
      "testlanguage": "java",
      "expected-problems": 24,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.util.HashMap;\n\npublic class HashMapExample {\n\n  public static void putIntegerTwiceThenGetTwiceOk(HashMap<Integer, Integer> hashMap) {\n    Integer i32 = new Integer(32);\n    Integer i52 = new Integer(52);\n\n    hashMap.put(i32, i32);\n    hashMap.put(i52, i52);\n\n    Integer a = hashMap.get(i32);\n    Integer b = hashMap.get(i52);\n\n    a.intValue();\n    b.intValue();\n  }\n\n  public static void containsIntegerTwiceThenGetTwiceOk(HashMap<Integer, Integer> hashMap) {\n    Integer i32 = new Integer(32);\n    Integer i52 = new Integer(52);\n\n    if (hashMap.containsKey(i32) && hashMap.containsKey(i52)) {\n      Integer a = hashMap.get(i32);\n      Integer b = hashMap.get(i52);\n      a.intValue();\n      b.intValue();\n    }\n  }\n\n  public static int getOneIntegerWithoutCheckBad() {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    Integer i32 = new Integer(32);\n\n    Integer a = hashMap.get(i32);\n\n    return a.intValue();\n  }\n\n  public static void getTwoIntegersWithOneCheckOk(Integer i, Integer j) {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n\n    if (hashMap.containsKey(i) && !i.equals(j)) {\n      Integer a = hashMap.get(i);\n      Integer b = hashMap.get(j);\n\n      a.intValue();\n      b.intValue();\n    }\n  }\n\n  public static Integer getOrCreateInteger(final HashMap<Integer, Integer> map, final int id) {\n    Integer x = null;\n    if (map.containsKey(id)) {\n      x = map.get(id);\n    } else {\n      x = new Integer(0);\n      map.put(id, x);\n    }\n    return x;\n  }\n\n  public static void getOrCreateIntegerThenDerefOk(final HashMap<Integer, Integer> map) {\n    Integer x = getOrCreateInteger(map, 42);\n    // dereference x\n    x.toString();\n  }\n\n  void getAfterRemovingTheKeyBad() {\n    HashMap<Integer, Object> map = new HashMap();\n    Integer key = 42;\n    map.put(key, new Object());\n    map.remove(key);\n    map.get(key).toString(); // NPE here\n  }\n\n  void getAfterRemovingAnotherKeyOk() {\n    HashMap<Integer, Object> map = new HashMap();\n    Integer key = 42;\n    map.put(key, new Object());\n    map.remove(0);\n    map.get(key).toString();\n  }\n\n  void getAfterClearBad() {\n    HashMap<Integer, Object> map = new HashMap();\n    Integer key = 42;\n    map.put(key, new Object());\n    map.clear();\n    map.get(key).toString(); // NPE here\n  }\n\n  // A null pointer dereference is currently reportedduring the access of s.equals(\"foo\").\n  // Once keySet() is modelled, this null deference should not be reported anymore.\n  void FP_getFromKeySetOk(HashMap<String, String> map) {\n    for (String key : map.keySet()) {\n      String s = map.get(key);\n      if (s.equals(\"foo\")) {\n        System.out.println(\"true\");\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "InstanceOfExample.java",
      "testlanguage": "java",
      "expected-problems": 57,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport java.util.*;\n\npublic class InstanceOfExample {\n  abstract class Person {}\n\n  class Faculty extends Person {}\n\n  class Professor extends Faculty {}\n\n  class Student extends Person {}\n\n  public void testInstanceOfObjFacultyOk() {\n    Person p = new Professor();\n    Person p2 = null;\n    if (p instanceof Faculty) {\n      p2 = new Student();\n    }\n    p2.toString();\n  }\n\n  public Person updatePerson(Person p) {\n    Person new_p = null;\n    if (p instanceof Student) {\n      new_p = p;\n    }\n\n    return new_p;\n  }\n\n  public void testInstanceOfObjStudentOk() {\n    Person p = new Student();\n    if (p instanceof Student) {\n      Person x = updatePerson(p);\n      x.toString();\n    }\n  }\n\n  public void testInstanceOfObjProfessorBad() {\n    Person p = new Professor();\n    Person new_p = updatePerson(p);\n    new_p.toString();\n  }\n\n  public void testInstanceOfObjProfessorOk() {\n    Person p = new Professor();\n    if (p instanceof Student) {\n      Person new_p = updatePerson(p);\n      new_p.toString();\n    }\n  }\n\n  public void testInstanceOfNullInterOk() {\n    Person p = new Professor();\n    // p is null after this call\n    p = updatePerson(p);\n    // null is not an instance of any class\n    if (p instanceof Professor) {\n      p.toString();\n    }\n  }\n\n  public void testInstanceOfNullIntraOk() {\n    Person p = null;\n    if (p instanceof Professor) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testInstanceOfNullIntraBad() {\n    Person p = null;\n    if (!(p instanceof Professor)) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testInstanceOfPersonBad(Person p) {\n    if (p instanceof Person) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testInstanceOfStudentBad(Person p) {\n    if (p instanceof Student) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testNotInstanceOfPersonBad(Person p) {\n    if (!(p instanceof Person)) { // true if p is null\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void FP_testNotInstanceOfPersonNotNullOk(Person p) {\n    if (p != null && !(p instanceof Person)) { // must be false\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testInstanceOfAndNotInstanceOfPersonOk(Person p) {\n    if (p instanceof Person) {\n      if (!(p instanceof Person)) {\n        Object o = null;\n        o.toString();\n      }\n    }\n  }\n\n  public void testNotInstanceOfAndInstanceOfPersonOk(Person p) {\n    if (!(p instanceof Person)) {\n      if (p instanceof Person) {\n        Object o = null;\n        o.toString();\n      }\n    }\n  }\n\n  public void testSubclassOk(Person p) {\n    if (p instanceof Faculty) {\n      if (!(p instanceof Person)) { // must be false\n        Object o = null;\n        o.toString();\n      }\n    }\n  }\n\n  public void testUnrelatedOk(Person p) {\n    if (p instanceof Faculty && p instanceof Student) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void checkInstanceArrayLatent(Object array, boolean b) {\n    Object o = null;\n    if (array instanceof int[]) {\n      o = new Object();\n    }\n\n    if (b && array instanceof boolean[]) {\n      o.toString();\n    }\n  }\n\n  public void testInstanceOfIntArrayOk() {\n    int arr[] = new int[10];\n    checkInstanceArrayLatent(arr, true);\n  }\n\n  public void testInstanceOfBooleanArrayBad() {\n    boolean arr[] = new boolean[10];\n    checkInstanceArrayLatent(arr, true);\n  }\n\n  public List<Integer> createsEmptyList() {\n    return new ArrayList<Integer>();\n  }\n\n  public void testInstanceOfArrayListOk() {\n    List<Integer> elems = createsEmptyList();\n    Person p = null;\n    if (elems instanceof ArrayList) {\n      p = new Student();\n    }\n    p.toString();\n  }\n\n  public String getClassByName(Object o) {\n    return o.getClass().getName();\n  }\n\n  /*\n   * This example triggers a call to instanceof with a Var expression instead of a literal type.\n   * This only happens in some peculiar cases. For instance, if we inline the getClassByName call\n   * we don't have this problem. For now, we do not handle this example properly but we hope to\n   * investigate soon.\n   */\n  public void requiresFurtherInvestigationOk(List<Person> people) {\n    people.stream().filter(p -> getClassByName(p).equals(\"Student\") && p instanceof Student);\n  }\n}\n"
    },
    {
      "testname": "IntegerExample.java",
      "testlanguage": "java",
      "expected-problems": 20,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class IntegerExample {\n\n  private static void testIntegerEqualsMethodGood() {\n    Integer a = new Integer(42);\n    Integer b = new Integer(42);\n    Integer c = null;\n\n    if (!a.equals(b)) {\n      c.intValue();\n    }\n  }\n\n  private static void testIntegerEqualsMethodBad() {\n    Integer a = new Integer(42);\n    Integer b = new Integer(42);\n    Integer c = null;\n\n    if (a.equals(b)) {\n      c.intValue();\n    }\n  }\n\n  /*\n   * Assignments of the form Integer a = n triggers the method valueOf.\n   * The valueOf method caches values between -128 and 127 (inclusive).\n   */\n  private static void FP_testIntegerBuiltInEqualOperatorCachedValuesOk() {\n    Integer a = new Integer(42);\n    Integer b = 127;\n    Integer c = 127;\n    Integer d = null;\n\n    if (a != 42) {\n      d.intValue();\n    }\n\n    if (b != 127) {\n      d.intValue();\n    }\n\n    /* This is wrong according to the semantics of valueOf.\n     * (b==c should hold in this case as 127 is in the cache interval)\n     */\n\n    if (b != c) {\n      d.intValue();\n    }\n  }\n\n  /*\n   * Assignments of the form Integer a = n triggers the method valueOf.\n   * The valueOf method caches values between -128 and 127 (inclusive).\n   */\n  private static void testIntegerBuiltInEqualOperatorNonCachedValuesBad() {\n    Integer a = 128;\n    Integer b = 128;\n    Integer c = null;\n\n    // This is correct (a!=b should hold in this case as 128 is out of the cached interval)\n    if (a != b) {\n      c.intValue();\n    }\n  }\n\n  private static void testIntegerEqualsMethodMaxValueBad() {\n    Integer a = new Integer(2147483647);\n    Integer b = new Integer(2147483647);\n    Integer c = null;\n\n    if (a.equals(b)) {\n      c.intValue();\n    }\n  }\n\n  private static void testIntegerBuiltInEqualOperatorMaxValueOk() {\n    Integer a = new Integer(2147483647);\n    Integer b = null;\n\n    if (a != 2147483647) {\n      b.intValue();\n    }\n  }\n}\n"
    },
    {
      "testname": "InterExceptions.java",
      "testlanguage": "java",
      "expected-problems": 39,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nclass D extends Exception {\n  D(int data) {\n    this.data = data;\n  }\n\n  int data;\n}\n\npublic class InterExceptions {\n\n  /*\n      g conditionally throws an exception, which is caught by the caller.\n  */\n  private static int g(int x) throws D {\n    if (x < 0) {\n      throw new D(x);\n    }\n    return x + 22;\n  }\n\n  /*\n    caller_of_g(x) ==\n      x - 10  if x < 10\n      x + 12  if x >= 10\n  */\n  private static int caller_of_g(int x) {\n    try {\n      return g(x - 10);\n    } catch (D d) {\n      return d.data;\n    }\n  }\n\n  private static void testInterExceptions1Bad() {\n    Integer my_null_int = null;\n    if (caller_of_g(100) == 112) {\n      my_null_int.intValue();\n    }\n  }\n\n  private static void testInterExceptions1Good() {\n    Integer my_null_int = null;\n    if (caller_of_g(100) != 112) {\n      my_null_int.intValue();\n    }\n  }\n\n  private static void testInterExceptions2Bad() {\n    Integer my_null_int = null;\n    if (caller_of_g(0) == -10) {\n      my_null_int.intValue();\n    }\n  }\n\n  private static void testInterExceptions2Good() {\n    Integer my_null_int = null;\n    if (caller_of_g(0) != -10) {\n      my_null_int.intValue();\n    }\n  }\n\n  /*\n      thrower unconditionally throws an exception, which is caught by the caller.\n  */\n  private static int thrower(int x) throws D {\n    throw new D(x);\n  }\n\n  /*\n    caller_of_thrower(x) == x + 23\n  */\n  private static int caller_of_thrower(int x) {\n    try {\n      return thrower(x + 23);\n    } catch (D d) {\n      return d.data;\n    }\n  }\n\n  private static void testInterExceptions3Bad() {\n    Integer my_null_int = null;\n    if (caller_of_thrower(10) == 33) {\n      my_null_int.intValue();\n    }\n  }\n\n  private static void testInterExceptions3Good() {\n    Integer my_null_int = null;\n    if (caller_of_thrower(10) != 33) {\n      my_null_int.intValue();\n    }\n  }\n}\n"
    },
    {
      "testname": "IntraExceptions.java",
      "testlanguage": "java",
      "expected-problems": 26,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nclass E extends Exception {\n  E(int data) {\n    this.data = data;\n  }\n\n  int data;\n}\n\npublic class IntraExceptions {\n\n  // intra-exceptions #1\n  /*\n    try block conditionally throws an exception that is caught by the\n    catch block.\n  */\n  private static int intra_exceptions_1(int x) {\n    try {\n      int y = x + 10;\n      if (y < 0) throw new E(y);\n      return 10;\n    } catch (E e) {\n      return e.data;\n    }\n  }\n\n  private static void testIntraExceptions1Bad() {\n    Integer my_null_int = null;\n    if (intra_exceptions_1(-100) == -90) {\n      my_null_int.intValue();\n    }\n  }\n\n  private static void testIntraExceptions1Good() {\n    Integer my_null_int = null;\n    if (intra_exceptions_1(-100) == 0) {\n      my_null_int.intValue();\n    }\n  }\n\n  // intra-exceptions #2\n  /*\n    try block unconditionally throws an exception that is caught by the catch block.\n  */\n  private static int intra_exceptions_2(int x) {\n    try {\n      throw new E(x + 22);\n    } catch (E e) {\n      return e.data;\n    }\n  }\n\n  private static void testIntraExceptions2Bad() {\n    Integer my_null_int = null;\n    if (intra_exceptions_2(10) == 32) {\n      my_null_int.intValue();\n    }\n  }\n\n  private static void testIntraExceptions2Good() {\n    Integer my_null_int = null;\n    if (intra_exceptions_2(10) == 0) {\n      my_null_int.intValue();\n    }\n  }\n}\n"
    },
    {
      "testname": "InvokeDynamic.java",
      "testlanguage": "java",
      "expected-problems": 30,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class InvokeDynamic {\n\n  void invokeDynamicThenNpeBad(List<String> list) {\n    Object o = null;\n    Collections.sort(\n        list,\n        (String a, String b) -> {\n          return b.compareTo(a);\n        });\n    o.toString();\n  }\n\n  void npeInLambdaBad(List<String> list) {\n    Collections.sort(\n        list,\n        (String a, String b) -> {\n          Object o = null;\n          o.toString();\n          return b.compareTo(a);\n        });\n  }\n\n  // we still don't get this one (even with Javalib lambda rewriting)\n  // because Collections.sort is skipped\n  void FN_npeViaCaptureBad(List<String> list) {\n    String s = null;\n    Collections.sort(\n        list,\n        (String a, String b) -> {\n          return s.compareTo(a);\n        });\n  }\n\n  Integer npeViaSimpleCapture() {\n    String s = null;\n    Function<String, Integer> f = (s1) -> s.length();\n    return f.apply(null);\n  }\n\n  Integer npeViaSimpleParamPassing() {\n    Function<String, Integer> f = (s) -> s.length();\n    return f.apply(null);\n  }\n\n  static class A {\n    int val;\n  }\n\n  static class Fun1 {\n    Function<A, A> f1;\n\n    Fun1(Function<A, A> f1) {\n      this.f1 = f1;\n    }\n  }\n\n  static class Fun2 {\n    Fun1 f2;\n\n    Fun2(Fun1 f2) {\n      this.f2 = f2;\n    }\n  }\n\n  static class Box {\n    A a;\n\n    public Box(A a) {\n      this.a = a;\n    }\n\n    public Box map(Function<A, A> f) {\n      return new Box(f.apply(this.a));\n    }\n\n    public Box mapWithFun(Fun2 fun) {\n      return new Box(fun.f2.f1.apply(this.a));\n    }\n  }\n\n  public static A mix(A a1, A a2) {\n    if (a1 == null && a2 == null) return null;\n    else return new A();\n  }\n\n  // this one uses abduction\n  public static A sum(A a1, A a2) {\n    A a = new A();\n    a.val = a1.val + a2.val;\n    return a;\n  }\n\n  int testBoxMapMixBad() {\n    A a0 = null;\n    Box b = new Box(null);\n    Function<A, A> f = (a) -> mix(a0, a);\n    return b.map(f).a.val;\n  }\n\n  int testBoxMapMixGood(A a0) {\n    Box b = new Box(new A());\n    Function<A, A> f = (a) -> mix(a0, a);\n    return b.map(f).a.val;\n  }\n\n  int testBoxMapSum1Bad(A a0) {\n    Box b = new Box(null);\n    Function<A, A> f = (a) -> sum(a0, a);\n    return b.map(f).a.val;\n  }\n\n  int testBoxMapSum2Bad(A a1) {\n    Box b = new Box(a1);\n    Function<A, A> f = (a) -> sum(null, a);\n    return b.map(f).a.val;\n  }\n\n  int testBoxMapSumGood() {\n    Box b = new Box(new A());\n    A a0 = new A();\n    Function<A, A> f = (a) -> sum(a0, a);\n    return b.map(f).a.val;\n  }\n\n  // closure in a field\n  int testBoxMapFunMixBad() {\n    A a0 = null;\n    Box b = new Box(null);\n    Function<A, A> f = (a) -> mix(a0, a);\n    return b.mapWithFun(new Fun2(new Fun1(f))).a.val;\n  }\n\n  int testBoxMapFunMixGood(A a0) {\n    Box b = new Box(new A());\n    Function<A, A> f = (a) -> mix(a0, a);\n    return b.mapWithFun(new Fun2(new Fun1(f))).a.val;\n  }\n\n  // nested closure\n  Box testBoxMapAuxiliaryGood(A a0, Box b, BiFunction<A, A, A> f) {\n    Function<A, A> g = (a) -> f.apply(a0, a);\n    return b.map(g);\n  }\n\n  int testBoxMapUseAuxiliaryBad() {\n    A a0 = null;\n    Box b = new Box(null);\n    BiFunction<A, A, A> f = (a1, a2) -> mix(a1, a2);\n    return testBoxMapAuxiliaryGood(a0, b, f).a.val;\n  }\n\n  int testBoxMapUseAuxiliaryGood(A a0) {\n    Box b = new Box(new A());\n    BiFunction<A, A, A> f = (a1, a2) -> mix(a1, a2);\n    return testBoxMapAuxiliaryGood(a0, b, f).a.val;\n  }\n}\n"
    },
    {
      "testname": "JunitAssertion.java",
      "testlanguage": "java",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport static junit.framework.Assert.assertFalse;\nimport static junit.framework.Assert.assertTrue;\n\npublic class JunitAssertion {\n  class A {\n    public void f() {}\n  }\n\n  // need model\n  public void FP_consistentAssertionOk(A a) {\n    assertTrue(a != null);\n    a.f();\n  }\n\n  public void inconsistentAssertionBad(A a) {\n    assertFalse(\"Should not happen!\", a != null);\n    a.f();\n  }\n}\n"
    },
    {
      "testname": "Lists.java",
      "testlanguage": "java",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.util.*;\n\nclass Lists {\n\n  void emptyRemembersOk(List l) {\n    boolean empty = l.isEmpty();\n    Object o = null;\n    if (empty != l.isEmpty()) {\n      o.toString();\n    }\n  }\n\n  void removeInvalidatesNonEmptinessNPEBad(List l) {\n    l.removeAll(l);\n    Object o = null;\n    if (l.isEmpty()) {\n      o.toString();\n    }\n  }\n\n  void clearCausesEmptinessNPEBad(List l) {\n    l.clear();\n    Object o = null;\n    if (l.isEmpty()) {\n      o.toString();\n    }\n  }\n\n  // it would be too noisy to report here\n  void plainGetOk(List l, int i) {\n    l.get(i).toString();\n  }\n\n  Object getElement(List l) {\n    return l.isEmpty() ? null : l.get(0);\n  }\n\n  void getElementOk(List l) {\n    if (l.isEmpty()) {\n      return;\n    }\n    getElement(l).toString();\n  }\n\n  void getElementNPEBad() {\n    List l = new ArrayList();\n    if (!l.isEmpty()) {\n      return;\n    }\n    getElement(l).toString();\n  }\n\n  void getElementOk() {\n    List l = new ArrayList();\n    if (!l.isEmpty()) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  void addInvalidatesEmptinessNPEBad(List l) {\n    l.add(0, new Object());\n    Object o = null;\n    if (!l.isEmpty()) {\n      o.toString();\n    }\n  }\n\n  void addAndRemoveEmptinessNPEBad() {\n    List l = new ArrayList();\n    Integer i = new Integer(1);\n    l.add(i);\n    l.remove(i);\n    if (l.isEmpty()) {\n      getElement(l).toString();\n    }\n  }\n\n  void FP_removeOnEmptyListOk() {\n    List l = new LinkedList();\n    Object removed = l.remove(0);\n    if (removed != null) {\n      getElement(l).toString();\n    }\n  }\n\n  void removeElementBad() {\n    List l = new LinkedList();\n    Integer i = new Integer(4);\n    l.add(i);\n    boolean removed = l.remove(i);\n    if (removed) {\n      Object o = null;\n      o.toString();\n    }\n  }\n}\n"
    },
    {
      "testname": "NeverNullSource.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// _AUTOMATICALLY_GENERATED_\n\npackage codetoanalyze.java.infer;\n\nimport javax.annotation.Nullable;\n\npublic class NeverNullSource {\n\n  @Nullable T t;\n\n  T get() {\n    return t == null ? null : t;\n  }\n}\n"
    },
    {
      "testname": "NullPointerExceptions.java",
      "testlanguage": "java",
      "expected-problems": 172,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport android.annotation.SuppressLint;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.text.TextUtils;\nimport com.facebook.infer.annotation.Assertions;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.util.HashMap;\nimport java.util.concurrent.locks.Lock;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\npublic class NullPointerExceptions {\n\n  class A {\n    int x;\n\n    int thisNotNullOk() {\n      if (this == null) {\n        A a = null;\n        return a.x;\n      }\n      return 0;\n    }\n\n    int thisNotNullBad() {\n      if (this != null) {\n        A a = null;\n        return a.x;\n      }\n      return 0;\n    }\n\n    public void method() {}\n  }\n\n  // npe local with field\n  public int nullPointerException() {\n    A a = null;\n    return a.x;\n  }\n\n  public A canReturnNullObject(boolean ok) {\n    A a = new A();\n    if (ok) return a;\n    else return null;\n  }\n\n  public static void expectNotNullObjectParameter(A a) {\n    a.method();\n  }\n\n  public static void expectNotNullArrayParameter(A[] array) {\n    array.clone();\n  }\n\n  // npe with branching, interprocedural\n  public int nullPointerExceptionInterProc() {\n    A a = canReturnNullObject(false);\n    return a.x;\n  }\n\n  // npe with exception handling\n  public int nullPointerExceptionWithExceptionHandling(boolean ok) {\n    A a = null;\n    try {\n      throw new Exception();\n    } catch (Exception e) {\n      return a.x;\n    }\n  }\n\n  class B {\n    A a;\n\n    public B() {}\n\n    public B(A a) {\n      this.a = a;\n    }\n\n    void test() {}\n  }\n\n  public static int nullPointerExceptionWithArray() {\n    A[] array = new A[] {null};\n    A t = array[0];\n    return t.x;\n  }\n\n  // npe with a chain of fields\n  class C {\n    B b;\n  }\n\n  public int FN_nullPointerExceptionWithNullByDefaultBad(C c) {\n    return (new B()).a.x;\n  }\n\n  public int nullPointerExceptionWithExplicitNullInitBad(C c) {\n    return (new B(null)).a.x;\n  }\n\n  public int FN_nullPointerExceptionWithAChainOfFields(C c) {\n    c.b = new B();\n    return c.b.a.x;\n  }\n\n  // npe with a null object parameter\n  public static void nullPointerExceptionWithNullObjectParameter() {\n    expectNotNullObjectParameter(null);\n  }\n\n  // npe with a null array parameter\n  public static void nullPointerExceptionWithNullArrayParameter() {\n    expectNotNullArrayParameter(null);\n  }\n\n  public static void nullPointerExceptionFromFaillingResourceConstructor() throws IOException {\n    FileInputStream fis = null;\n    try {\n      fis = new FileInputStream(new File(\"whatever.txt\"));\n    } catch (IOException e) {\n    } finally {\n      fis.close();\n    }\n  }\n\n  public static void nullPointerExceptionFromFailingFileOutputStreamConstructor()\n      throws IOException {\n    FileOutputStream fos = null;\n    try {\n      fos = new FileOutputStream(new File(\"whatever.txt\"));\n    } catch (IOException e) {\n    } finally {\n      fos.close();\n    }\n  }\n\n  int x;\n\n  public void nullPointerExceptionFromNotKnowingThatThisIsNotNull() {\n    if (this == null) {}\n    this.x = 4;\n  }\n\n  public <T> T id_generics(T o) {\n    o.toString();\n    return o;\n  }\n\n  public A frame(A x) {\n    return id_generics(x);\n  }\n\n  public void nullPointerExceptionUnlessFrameFails() {\n    String s = null;\n    Object a = frame(new A());\n    if (a instanceof A) {\n      s.length();\n    }\n  }\n\n  class D {\n    int x;\n  }\n\n  public int preconditionCheckStateTest(D d) {\n    Preconditions.checkState(d != null);\n    return d.x;\n  }\n\n  public void genericMethodSomewhereCheckingForNull(String s) {\n    if (s == null) {}\n  }\n\n  public void noNullPointerExceptionAfterSkipFunction() {\n    String t = new String(\"Hello!\");\n    String s = t.toString();\n    genericMethodSomewhereCheckingForNull(s);\n    s.length();\n  }\n\n  String hashmapNPE(HashMap h, Object o) {\n    return (h.get(o).toString());\n  }\n\n  String NPEhashmapProtectedByContainsKey(HashMap h, Object o) {\n    if (h.containsKey(o)) {\n      return (h.get(o).toString());\n    }\n    return \"aa\";\n  }\n\n  int NPEvalueOfFromHashmapBad(HashMap<Integer, Integer> h, int position) {\n    return h.get(position);\n  }\n\n  Integer NPEvalueOfFromHashmapGood(HashMap<Integer, Integer> h, int position) {\n    return h.get(position);\n  }\n\n  void nullPointerExceptionInArrayLengthLoop(Object[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      Object x = null;\n      x.toString();\n    }\n  }\n\n  Context mContext;\n  ContentResolver mContentResolver;\n\n  public void cursorFromContentResolverNPE(String customClause) {\n    String[] projection = {\"COUNT(*)\"};\n    String selectionClause = selectionClause = customClause;\n    Cursor cursor =\n        mContext.getContentResolver().query(null, projection, selectionClause, null, null);\n    cursor.close();\n  }\n\n  public int cursorQueryShouldNotReturnNull(SQLiteDatabase sqLiteDatabase) {\n    Cursor cursor = sqLiteDatabase.query(\"events\", null, null, null, null, null, null);\n    try {\n      return cursor.getCount();\n    } finally {\n      cursor.close();\n    }\n  }\n\n  Object[] arr = new Object[1];\n\n  Object arrayReadShouldNotCauseSymexMemoryError(int i) {\n    arr[i].toString();\n    return null;\n  }\n\n  void nullPointerExceptionCallArrayReadMethod() {\n    arr[0] = new Object();\n    arrayReadShouldNotCauseSymexMemoryError(0).toString();\n  }\n\n  public void sinkWithNeverNullSource() {\n    NeverNullSource source = new NeverNullSource();\n    T t = source.get();\n    t.f();\n  }\n\n  public void otherSinkWithNeverNullSource() {\n    SomeLibrary source = new SomeLibrary();\n    T t = source.get();\n    t.f();\n  }\n\n  private @Nullable Object mFld;\n\n  void FN_nullableFieldNPE() {\n    mFld.toString();\n  }\n\n  void guardedNullableFieldDeref() {\n    if (mFld != null) mFld.toString();\n  }\n\n  void allocNullableFieldDeref() {\n    mFld = new Object();\n    mFld.toString();\n  }\n\n  void nullableParamNPE(@Nullable Object param) {\n    param.toString();\n  }\n\n  void guardedNullableParamDeref(@Nullable Object param) {\n    if (param != null) param.toString();\n  }\n\n  void allocNullableParamDeref(@Nullable Object param) {\n    param = new Object();\n    param.toString();\n  }\n\n  native boolean test1();\n\n  native boolean test2();\n\n  Object getObj() {\n    if (test1()) {\n      return new Object();\n    } else {\n      return null;\n    }\n  }\n\n  Boolean getBool() {\n    if (test2()) {\n      return new Boolean(true);\n    } else {\n      return null;\n    }\n  }\n\n  void derefGetterAfterCheckShouldNotCauseNPE() {\n    if (getObj() != null) {\n      getObj().toString();\n    }\n  }\n\n  void derefBoxedGetterAfterCheckShouldNotCauseNPE() {\n    boolean b = getBool() != null && getBool();\n  }\n\n  static void derefNonThisGetterAfterCheckShouldNotCauseNPE() {\n    NullPointerExceptions c = new NullPointerExceptions();\n    if (c.getObj() != null) {\n      c.getObj().toString();\n    }\n  }\n\n  // latent because we don't know if test1() can return \"true\"\n  // arguably should be reported?\n  void badCheckShouldCauseNPE_latent() {\n    if (getBool() != null) {\n      getObj().toString();\n    }\n  }\n\n  void nullPointerExceptionArrayLength() {\n    Object[] arr = null;\n    int i = arr.length;\n  }\n\n  class $$Class$Name$With$Dollars {\n    void npeWithDollars() {\n      String s = null;\n      int n = s.length();\n    }\n  }\n\n  void nullableNonNullStringAfterTextUtilsIsEmptyCheckShouldNotCauseNPE(@Nullable String str) {\n    if (!TextUtils.isEmpty(str)) {\n      str.length();\n    }\n  }\n\n  void someNPEAfterResourceLeak() {\n    T t = CloseableAsResourceExample.sourceOfNullWithResourceLeak();\n    t.f();\n  }\n\n  private Object mOkObj = new Object();\n\n  public void nullableParamReassign1(@Nullable Object o) {\n    if (o == null) {\n      o = mOkObj;\n    }\n    o.toString();\n  }\n\n  public void nullableParamReassign2(@Nullable Object o, Object okObj) {\n    if (o == null) {\n      o = okObj;\n    }\n    o.toString();\n  }\n\n  private @Nullable Object mNullableField;\n\n  public void nullableFieldReassign1() {\n    if (mNullableField == null) {\n      mNullableField = mOkObj;\n    }\n    mNullableField.toString();\n  }\n\n  public void nullableFieldReassign2(Object okObj) {\n    if (mNullableField == null) {\n      mNullableField = okObj;\n    }\n    mNullableField.toString();\n  }\n\n  public void nullableFieldReassign3(Object param) {\n    mNullableField = param;\n    mNullableField.toString();\n  }\n\n  public Object nullableGetter() {\n    return mNullableField;\n  }\n\n  public void FN_derefNullableGetter() {\n    Object o = nullableGetter();\n    o.toString();\n  }\n\n  public @Nullable Object nullableRet(boolean b) {\n    if (b) {\n      return null;\n    }\n    return new Object();\n  }\n\n  public void derefNullableRet(boolean b) {\n    Object ret = nullableRet(b);\n    ret.toString();\n  }\n\n  public void derefNullableRetOK(boolean b) {\n    Object ret = nullableRet(b);\n    if (ret != null) {\n      ret.toString();\n    }\n  }\n\n  public native @Nullable Object undefNullableRet();\n\n  public void derefUndefNullableRet() {\n    Object ret = undefNullableRet();\n    ret.toString();\n  }\n\n  public void derefUndefNullableRetOK() {\n    Object ret = undefNullableRet();\n    if (ret != null) {\n      ret.toString();\n    }\n  }\n\n  void assumeUndefNullableIdempotentOk() {\n    if (undefNullableRet() != null) {\n      undefNullableRet().toString();\n    }\n  }\n\n  public Object undefNullableWrapper() {\n    return undefNullableRet();\n  }\n\n  public void derefUndefNullableRetWrapper() {\n    undefNullableWrapper().toString();\n  }\n\n  private int returnsThreeOnlyIfRetNotNull(Object obj) {\n    if (obj == null) {\n      return 2;\n    }\n    return 3;\n  }\n\n  public void testNullablePrecision() {\n    Object ret = undefNullableRet();\n    if (returnsThreeOnlyIfRetNotNull(ret) == 3) {\n      ret.toString(); // shouldn't warn here\n    }\n  }\n\n  public @Nullable String FN_testSystemGetPropertyArgument() {\n    String s = System.getProperty(null);\n    return s;\n  }\n\n  public void FN_testSystemGetPropertyReturn() {\n    String s = System.getProperty(\"\");\n    int n = s.length();\n  }\n\n  Object retUndefined() {\n    return \"\".toString(); // toString is a skip function\n  }\n\n  Object derefUndefinedCallee() {\n    // if retUndefined() is handled incorrectly, we get a symexec_memory_error here\n    retUndefined().toString();\n    return null;\n  }\n\n  void derefNull() {\n    // should be NPE, but will not be reported if we handled retUndefined() incorrectly\n    derefUndefinedCallee().toString();\n  }\n\n  @SuppressLint(\"NULL_DEREFERENCE\")\n  void shouldNotReportNPE() {\n    Object o = null;\n    o.toString();\n  }\n\n  void shouldNotReportOnSkippedSource() {\n    Object o = SkippedSourceFile.createdBySkippedFile();\n    o.toString();\n  }\n\n  int nullListFiles(String pathname) {\n    File dir = new File(pathname);\n    File[] files = dir.listFiles();\n    return files.length; // expect possible NullPointerException as files == null is possible\n  }\n\n  native Object unknownFunc();\n\n  void nullDerefernceReturnOfSkippedFunctionBad() {\n    Object object = unknownFunc();\n    if (object == null) {\n      object.toString();\n    }\n  }\n\n  native @Nonnull Object doesNotReturnNull();\n\n  void FP_noNPEWhenCallingSkippedNonnullAnnotatedMethodGood() {\n    Object object = doesNotReturnNull();\n    if (object == null) {\n      object.toString();\n    }\n  }\n\n  Object callUnknownFunc() {\n    return unknownFunc();\n  }\n\n  void dontReportOnNullableDirectReassignmentToUnknown(@Nullable Object o) {\n    o = unknownFunc();\n    o.toString();\n  }\n\n  void dontReportOnNullableIndirectReassignmentToUnknown(@Nullable Object o) {\n    o = callUnknownFunc();\n    o.toString();\n  }\n\n  @Nullable\n  Object wrapUnknownFuncWithNullable() {\n    return unknownFunc();\n  }\n\n  void deferenceNullableMethodCallingSkippedMethodBad() {\n    wrapUnknownFuncWithNullable().toString();\n  }\n\n  String nullTryLock(FileChannel chan) throws IOException {\n    FileLock lock = chan.tryLock();\n    return lock.toString(); // expect possible NullPointerException as lock == null is possible\n  }\n\n  String tryLockThrows(FileChannel chan) {\n    try {\n      FileLock lock = chan.tryLock();\n      return (lock != null ? lock.toString() : \"\");\n    } catch (IOException e) {\n      Object o = null;\n      return o.toString(); // expect NullPointerException as tryLock can throw\n    }\n  }\n\n  class L {\n    L next;\n  }\n\n  Object returnsNullAfterLoopOnList(L l) {\n    while (l != null) {\n      l = l.next;\n    }\n    return null;\n  }\n\n  void FN_dereferenceAfterLoopOnList(L l) {\n    Object obj = returnsNullAfterLoopOnList(l);\n    obj.toString();\n  }\n\n  void dereferenceAfterUnlock1(Lock l) {\n    l.unlock();\n    String s = l.toString();\n    s = null;\n    s.toString(); // Expect NPE here\n  }\n\n  void dereferenceAfterUnlock2(Lock l) {\n    synchronized (l) {\n      String b = null;\n    }\n    String s = l.toString();\n    s = null;\n    s.toString(); // Expect NPE here\n  }\n\n  void optionalNPE(Optional<Object> o) {\n    o.orNull().toString();\n  }\n\n  void FP_stringConstantEqualsTrueNotNPE() {\n    final String c1 = \"Test string!\";\n    final String c2 = \"Test string!\";\n    String s = null;\n    if (c1.equals(c1)) {\n      s = \"safe\";\n    }\n    s.toString(); // No NPE\n    s = null;\n    if (c1.equals(c2)) {\n      s = \"safe\";\n    }\n    s.toString(); // No NPE\n  }\n\n  void stringConstantEqualsFalseNotNPE_FP() {\n    // This won't actually cause an NPE, but our current model for String.equals\n    // returns boolean_undefined for all cases other than String constant\n    // equality. Consider handling constant inequality in the future.\n    final String c1 = \"Test string 1\";\n    final String c2 = \"Test string 2\";\n    String s = null;\n    if (!c1.equals(c2)) {\n      s = \"safe\";\n    }\n    s.toString(); // No NPE\n  }\n\n  String getString2() {\n    return \"string 2\";\n  }\n\n  void stringVarEqualsFalseNPE() {\n    final String c1 = \"Test string 1\";\n    String c2 = \"Test \" + getString2();\n    String s = null;\n    if (!c1.equals(c2)) {\n      s.toString(); // NPE\n    }\n  }\n\n  String assertParameterNotNullableOk(@Nullable Object object) {\n    return Assertions.assertNotNull(object).toString();\n  }\n\n  interface I {\n    @Nullable Object mObject = null;\n  }\n\n  class E implements I {\n\n    void FN_dereferenceNullableInterfaceFieldBad() {\n      mObject.toString();\n    }\n  }\n\n  Object getObject() {\n    return null;\n  }\n\n  void FN_addNullToImmutableListBuilderBad() {\n    ImmutableList.Builder<Object> listBuilder = ImmutableList.builder();\n    listBuilder.add(getObject());\n  }\n\n  void incr_deref(A a1, A a2) {\n    a1.x++;\n    a2.x++;\n  }\n\n  void call_incr_deref_with_alias_bad() {\n    A a = new A();\n    a.x = 0;\n    incr_deref(a, a);\n    if (a.x == 2) {\n      a = null;\n    }\n    a.x = 0;\n  }\n\n  void call_incr_deref_with_alias_Ok() {\n    A a = new A();\n    a.x = 0;\n    incr_deref(a, a);\n    if (a.x != 2) {\n      a = null;\n    }\n    a.x = 0;\n  }\n\n  // An other example wich require alias specialization, but with interfering calls\n  // with and without alias\n  void incr_deref2(A a1, A a2) {\n    a1.x++;\n    a2.x++;\n  }\n\n  void call_incr_deref2_bad() {\n    A a = new A();\n    A a1 = new A();\n    A a2 = new A();\n    a.x = 0;\n    a1.x = 0;\n    a2.x = 0;\n    incr_deref2(a, a);\n    incr_deref2(a1, a2);\n    if (a1.x == 1 && a2.x == 1 && a.x == 2) {\n      a1 = null;\n    }\n    a1.x = 0;\n  }\n\n  void call_incr_deref2_Ok() {\n    A a = new A();\n    A a1 = new A();\n    A a2 = new A();\n    a.x = 0;\n    a1.x = 0;\n    a2.x = 0;\n    incr_deref2(a, a);\n    incr_deref2(a1, a2);\n    if (!(a1.x == 1 && a2.x == 1 && a.x == 2)) {\n      a1 = null;\n    }\n    a1.x = 0;\n  }\n\n  // An other example wich require multiple alias specializations\n  void incr_deref3(A a1, A a2, A a3) {\n    a1.x++;\n  }\n\n  void call_incr_deref3_bad() {\n    A a1 = new A();\n    A a2 = new A();\n    A a3 = new A();\n    incr_deref3(null, null, null);\n  }\n\n  interface AFunction {\n    void run(A a);\n  }\n\n  // need combination of alias specialization and dynamic type specialization\n  void test_capture_alias_bad() {\n    A a = new A();\n    a.x = 0;\n    AFunction incr_deref =\n        (a2) -> {\n          a.x++;\n          a2.x++;\n        };\n    incr_deref.run(a);\n    A b = a;\n    if (a.x == 2) {\n      b = null;\n    }\n    b.x = 0;\n  }\n\n  void test_capture_alias_good() {\n    A a = new A();\n    a.x = 0;\n    AFunction incr_deref =\n        (a2) -> {\n          a.x++;\n          a2.x++;\n        };\n    incr_deref.run(a);\n    A b = a;\n    if (a.x != 2) {\n      b = null;\n    }\n    b.x = 0;\n  }\n}\n"
    },
    {
      "testname": "NullPointerExceptionsMoreTests.java",
      "testlanguage": "java",
      "expected-problems": 25,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n * checking for false positives and false negatives for infer\n * reporting on NuppPoint exceptions\n */\n\npackage codetoanalyze.java.infer;\n\nclass A {\n  int i;\n}\n\npublic class NullPointerExceptionsMoreTests {\n\n  int testNullStringDereferencedBad() {\n    String s = new String(\"abc\");\n    int j = s.length();\n    s = null;\n    j = j + s.length();\n    return 42;\n  }\n\n  int testBrachesAvoidNullPointerExceptionOK(int k) {\n    String s = new String(\"abc\");\n    int j = 100;\n    if (k > 10) {\n      s = null; /* DANGER? */\n    }\n    if (k == 10) {\n      /* looks as if infer realizes that when k==10,\n      we arrived here without executing the DANGER? branch,\n      and s is guaranteed not to be null  */\n      j = s.length();\n    }\n    return j;\n  }\n\n  int FN_testParameterRec(A arg, int k) {\n    /* should have inferrred the precondition that\n         a =/= null\n    and then should have seen that the recursive call\n    does not satisfy that precondition */\n    arg.i = 17;\n    if (k > 0) {\n      return this.FN_testParameterRec(null, k - 1);\n    } else {\n      return 430;\n    }\n  }\n\n  int FN_testParameterRecBool(A arg, boolean b) {\n    /* should have inferrred the precondition that\n         arg =/= null\n    and then should have seen that the recursive call\n    does not satisfy it */\n    arg.i = 17;\n    if (b) {\n      return this.FN_testParameterRecBool(null, false);\n    } else {\n      return 430;\n    }\n  }\n\n  void testParameterOk(A arg) {\n    /* this is not an error for infer,\n    because it infers that precondition is arg=/=null */\n    arg.i = 17;\n  }\n\n  int testArithmeticOk(int k) {\n    /* error cannot happen due to arithmetic argument */\n    String s = new String(\"abc\");\n    int j = 100;\n    if (k > 10) {\n      s = null; /* DANGER? */\n    }\n    if (k <= 10) {\n\n      /* infer does deduce that ik k>10 then NOT(k<=10), and\n      and therefore this branch will be taken only\n      if DANGER? was not  */\n      j = s.length();\n    }\n    return j;\n  }\n\n  int testArithmeticOneOK(int k) {\n    /* error cannot happen due to arithmetic argument  */\n    String s = new String(\"abc\");\n    int j = 100;\n    if (k > 10) {\n      s = null; /* DANGER? */\n    }\n    if ((2 * k) == 20) {\n      /* infer does deduce that ik k>10 then 2*k =/=20, and\n      and therefore this branch will be taken only\n      if DANGER? was not executed */\n      j = s.length();\n    }\n    return j;\n  }\n\n  int f_ident(int k) {\n    return k;\n  }\n\n  int FP_testArithmeticTwo(int k) {\n    /* error cannot happen due to arithmetic argument, but infer\n    does not see that */\n    String s = new String(\"abc\");\n    int j = 100;\n    if (k > 10) {\n      s = null; /* DANGER? */\n    }\n    if ((f_ident(k)) <= 10) {\n\n      /* looks as if infer does not realize  that if k>10\n      then NOT(f_ident(k)<=1o) and therefore we arrived here without executing\n      the DANGER? branch, and therefore\n      s is guaranteed not to be null  */\n      j = s.length();\n    }\n    return j;\n  }\n}\n"
    },
    {
      "testname": "NullSafeExample.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport com.facebook.infer.annotation.Nullsafe;\n\nclass OtherClass {\n\n  OtherClass x = null;\n\n  OtherClass canReturnNull() {\n    return this.x;\n  }\n\n  String buggyMethodBad() {\n    OtherClass o = new OtherClass();\n    return o.canReturnNull().toString();\n  }\n}\n\n/*\n * Pulse will not report NPEs on @Nullsafe classes if flag\n * --pulse-nullsafe-report-npe is set to false\n */\n\n@Nullsafe(Nullsafe.Mode.LOCAL)\nclass NullsafeExampleLocal {\n  void testingNullsafeLocalMode() {\n    OtherClass o = new OtherClass();\n    o = o.canReturnNull();\n    o.getClass();\n  }\n}\n\n@Nullsafe(Nullsafe.Mode.STRICT)\nclass NullsafeExampleStrict {\n  void testingNullsafeStrictMode() {\n    OtherClass o = new OtherClass();\n    o = o.canReturnNull();\n    o.toString();\n  }\n}\n"
    },
    {
      "testname": "PreconditionsExample.java",
      "testlanguage": "java",
      "expected-problems": 16,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\npackage codetoanalyze.java.infer;\n\nimport com.google.common.base.Preconditions;\n\npublic class PreconditionsExample {\n\n  Integer i1;\n\n  /*\n   * Note: Although the Guava checkNotNull method throws a NullPointerException when a given\n   * value x is null, Pulse will simply try to go ahead assuming that x != null.\n   * This means that it will not report NPEs on values passed to checkNotNull.\n   * The analogous approach has been taken for checkState and checkArgument.\n   */\n\n  void testCheckNotNullOnNullValueOk() {\n    PreconditionsExample x = null;\n    // This should not be reported due to the use of checkNotNull\n    Preconditions.checkNotNull(x);\n    Integer i1 = x.i1;\n  }\n\n  void testCheckNotNullOnNonNullValueOk() {\n    PreconditionsExample x = new PreconditionsExample();\n    x.i1 = new Integer(10);\n    PreconditionsExample y = Preconditions.checkNotNull(x);\n    // This should not cause bug, as y.i1 should be equal to x.i1\n    if (!y.i1.equals(10)) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  void testCheckNotNullPassingFurtherArgsOk() {\n    Object x = null;\n    Preconditions.checkNotNull(x, \"errorMsg\");\n    x.toString();\n  }\n\n  void testCheckNotNullOtherDerefOk() {\n    Object x = null;\n    Object y = null;\n    Preconditions.checkNotNull(x, \"errorMsg\");\n    y.toString();\n  }\n\n  void testCheckNotNullArgOk(Object x) {\n    Object y = null;\n    Preconditions.checkNotNull(x);\n    x.toString();\n  }\n\n  void testCheckNotNullArgBad(Object x) {\n    Object y = null;\n    Preconditions.checkNotNull(x);\n    y.toString();\n  }\n\n  void checkStateConditionSatBad() {\n    PreconditionsExample x = new PreconditionsExample();\n    PreconditionsExample y = null;\n    x.i1 = 1000;\n    Preconditions.checkState(x.i1.equals(1000));\n    y.toString();\n  }\n\n  void checkStateConditionUnsatOk() {\n    PreconditionsExample x = new PreconditionsExample();\n    PreconditionsExample y = null;\n    x.i1 = 1000;\n    Preconditions.checkState(x.i1.equals(100), \"errorMsg\");\n    y.toString();\n  }\n\n  void checkArgumentUnsatOk() {\n    int age = -18;\n    Object x = null;\n    Preconditions.checkArgument(age > 0);\n    x.getClass();\n  }\n\n  void checkAgeOver18(int age) {\n    Preconditions.checkArgument(age > 18, \"errorMsg\");\n  }\n\n  void checkArgumentSatBad() {\n    int age = 20;\n    Object x = null;\n    checkAgeOver18(age);\n    x.getClass();\n  }\n}\n"
    },
    {
      "testname": "ReaderLeaks.java",
      "testlanguage": "java",
      "expected-problems": 41,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PipedReader;\nimport java.io.PipedWriter;\nimport java.io.PushbackReader;\nimport java.io.Reader;\n\npublic class ReaderLeaks {\n\n  private void ignore(Object o) {}\n\n  // Reader  tests\n\n  public void readerNotClosedAfterReadBad() {\n    Reader r;\n    try {\n      r = new FileReader(\"testing.txt\");\n      r.read();\n      r.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void readerClosedOk() throws IOException {\n    Reader r = null;\n    try {\n      r = new FileReader(\"testing.txt\");\n      boolean ready = r.ready();\n      r.close();\n    } catch (IOException e) {\n    } finally {\n      if (r != null) r.close();\n    }\n  }\n\n  // BufferedReader  tests\n\n  public void bufferedReaderNotClosedAfterReadBad() {\n    BufferedReader reader;\n    try {\n      reader = new BufferedReader(new FileReader(\"testing.txt\"));\n      ignore(reader.read());\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void bufferedReaderClosedOk() throws IOException {\n    BufferedReader reader = null;\n    try {\n      reader = new BufferedReader(new FileReader(\"testing.txt\"));\n      ignore(reader.read());\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n    }\n  }\n\n  public void FN_tryWithBufferReaderWrapperBad(File file) throws IOException {\n    try (InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(file))) {\n      BufferedReader reader = new BufferedReader(inputStreamReader);\n      ignore(reader.readLine());\n    }\n  }\n\n  public void tryWithBufferReaderWrapperOk(File file) throws IOException {\n    try (InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(file));\n        BufferedReader reader = new BufferedReader(inputStreamReader); ) {\n      ignore(reader.readLine());\n    }\n  }\n\n  // InputStreamReader  tests\n\n  public void inputStreamReaderNotClosedAfterReadBad() {\n    InputStreamReader reader;\n    try {\n      reader = new InputStreamReader(new FileInputStream(\"testing.txt\"));\n      reader.read();\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void inputStreamReaderClosedOk() throws IOException {\n    InputStreamReader reader = null;\n    try {\n      reader = new InputStreamReader(new FileInputStream(\"testing.txt\"));\n      ignore(reader.read());\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n    }\n  }\n\n  // FileReader  tests\n\n  public void fileReaderNotClosedAfterReadBad() {\n    FileReader reader;\n    try {\n      reader = new FileReader(\"testing.txt\");\n      reader.read();\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void fileReaderClosedOk() throws IOException {\n    FileReader reader = null;\n    try {\n      reader = new FileReader(\"testing.txt\");\n      reader.read();\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n    }\n  }\n\n  // PushbackReader  tests\n\n  public void pushbackReaderNotClosedAfterReadBad() {\n    PushbackReader reader;\n    try {\n      reader = new PushbackReader(new InputStreamReader(new FileInputStream(\"testing.txt\")));\n      reader.read();\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pushbackReaderClosedOk() throws IOException {\n    PushbackReader reader = null;\n    try {\n      reader = new PushbackReader(new InputStreamReader(new FileInputStream(\"testing.txt\")));\n      reader.read();\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n    }\n  }\n\n  // PipedReader tests\n\n  public void pipedReaderNotClosedAfterConstructedWithWriterBad() {\n    PipedReader reader;\n    PipedWriter writer;\n    try {\n      writer = new PipedWriter();\n      reader = new PipedReader(writer);\n      reader.read();\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pipedReaderNotClosedAfterConnectOk(PipedWriter writer) {\n    PipedReader reader;\n    try {\n      reader = new PipedReader();\n      reader.connect(writer);\n      reader.read();\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void FN_pipedReaderNotConnectedBad(PipedWriter writer) {\n    PipedReader reader;\n    try {\n      reader = new PipedReader();\n      reader.connect(writer);\n      reader.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pipedReaderClosedOk(PipedWriter writer) throws IOException {\n    PipedReader reader = null;\n    try {\n      reader = new PipedReader();\n      reader.connect(writer);\n      reader.read();\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n    }\n  }\n\n  public void FN_pipedReaderWriterBad() throws IOException {\n    PipedReader reader = null;\n    PipedWriter writer = new PipedWriter();\n    try {\n      reader = new PipedReader(writer);\n      reader.read();\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n    }\n  }\n\n  public void pipedReaderWriterOk() throws IOException {\n    PipedReader reader = null;\n    PipedWriter writer = new PipedWriter();\n    try {\n      reader = new PipedReader(writer);\n      reader.read();\n    } catch (IOException e) {\n    } finally {\n      if (reader != null) reader.close();\n      else writer.close();\n    }\n  }\n}\n"
    },
    {
      "testname": "ResourceLeaks.java",
      "testlanguage": "java",
      "expected-problems": 235,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.json.UTF8StreamJsonParser;\nimport com.google.common.base.Preconditions;\nimport com.google.common.io.Closeables;\nimport java.io.BufferedInputStream;\nimport java.io.Closeable;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\nimport java.io.PrintWriter;\nimport java.io.RandomAccessFile;\nimport java.net.HttpURLConnection;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.channels.FileChannel;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.jar.JarFile;\nimport java.util.jar.JarInputStream;\nimport java.util.jar.JarOutputStream;\nimport java.util.zip.Deflater;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipFile;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class ResourceLeaks {\n\n  // FileOutputStream tests\n\n  public void fileOutputStreamNotClosedBad() throws IOException {\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n  }\n\n  public void fileOutputStreamNotClosedAfterWriteNoTryBad() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n    fis.write(arr);\n    fis.close();\n  }\n\n  public void fileOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      fis.write(arr);\n      fis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void fileOutputStreamClosedAfterWriteAlmostOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      fis.write(arr);\n      fis.close();\n    } catch (IOException e) {\n      if (fis != null) fis.close();\n      // there is stil a possible leakage if close() raises an exception but we\n      // ignore this case and mark this method as Ok.\n    }\n  }\n\n  public void fileOutputStreamClosedAfterWriteOk() throws IOException {\n    byte[] arr = {1, 2, 3};\n    FileOutputStream fis = null;\n    try {\n      fis = new FileOutputStream(\"file.txt\");\n      fis.write(arr);\n    } finally {\n      if (fis != null) fis.close();\n    }\n  }\n\n  public void fileOutputStreamClosedOk() throws IOException {\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n    fis.close();\n  }\n\n  public void fileOutputStreamOneLeakBad() throws IOException {\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n    if (fis != null) {\n    } else {\n    }\n  }\n\n  public int fileOutputStreamTwoLeaksBad1(boolean ok) throws IOException {\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n    if (ok) {\n      fis.write(1);\n      return 1;\n    } else {\n      fis.write(2);\n      return 2;\n    }\n  }\n\n  public void fileOutputStreamTwoLeaksBad2() throws IOException {\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n    if (fis != null) {\n    } else {\n    }\n    fis = new FileOutputStream(\"x\");\n  }\n\n  // TwoResources tests\n\n  public static void twoResourcesBad() throws IOException {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n      fis = new FileInputStream(new File(\"infile.txt\"));\n      fos = new FileOutputStream(new File(\"outfile.txt\"));\n      fos.write(fis.read());\n    } finally {\n      if (fis != null) fis.close();\n      if (fos != null) fos.close();\n    }\n  }\n\n  public static void twoResourcesHeliosFixOk() throws IOException {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n      fis = new FileInputStream(new File(\"whatever.txt\"));\n      try {\n        fos = new FileOutputStream(new File(\"everwhat.txt\"));\n        fos.write(fis.read());\n      } finally {\n        if (fos != null) fos.close();\n      }\n    } finally {\n      if (fis != null) fis.close();\n    }\n  }\n\n  public static void twoResourcesCommonFixOk() throws IOException {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n      fis = new FileInputStream(new File(\"infile.txt\"));\n      fos = new FileOutputStream(new File(\"outfile.txt\"));\n      fos.write(fis.read());\n    } finally {\n      try {\n        if (fis != null) fis.close();\n      } catch (Exception e) {\n      }\n      try {\n        if (fos != null) fos.close();\n      } catch (Exception e) {\n      }\n    }\n  }\n\n  public static void FN_twoResourcesServerSocketBad() throws IOException {\n    ServerSocket a = null;\n    ServerSocket b = null;\n    try {\n      a = new ServerSocket();\n      b = new ServerSocket();\n    } finally {\n      if (a != null) a.close();\n      if (b != null) b.close();\n    }\n  }\n\n  public static void FN_twoResourcesRandomAccessFileBad() throws IOException {\n    RandomAccessFile a = null;\n    RandomAccessFile b = null;\n    try {\n      a = new RandomAccessFile(\"\", \"rw\");\n      b = new RandomAccessFile(\"\", \"rw\");\n    } finally {\n      if (a != null) a.close();\n      if (b != null) b.close();\n    }\n  }\n\n  public static void twoResourcesRandomAccessFileCommonFixOk() throws IOException {\n    RandomAccessFile a = null;\n    RandomAccessFile b = null;\n    try {\n      a = new RandomAccessFile(\"\", \"rw\");\n      b = new RandomAccessFile(\"\", \"rw\");\n    } finally {\n      try {\n        if (a != null) a.close();\n      } catch (Exception e) {\n      }\n      try {\n        if (b != null) b.close();\n      } catch (Exception e) {\n      }\n    }\n  }\n\n  // NestedResource tests\n\n  // BufferedInputStream does not throw exception, and its close\n  // closes the FileInputStream as well\n  public void nestedOk() throws IOException {\n    BufferedInputStream b = new BufferedInputStream(new FileInputStream(\"file.txt\"));\n    b.close();\n  }\n\n  // GZipInputStream can throw IO Exception\n  // in which case the new FileInputStream will be dangling\n  public void nestedBad1() throws IOException {\n    GZIPInputStream g = new GZIPInputStream(new FileInputStream(\"file.txt\"));\n    g.close();\n  }\n\n  public void nestedBad2() throws IOException {\n    GZIPOutputStream g = new GZIPOutputStream(new FileOutputStream(\"file.txt\"));\n    g.close();\n  }\n\n  /* Fixed versions of this are below with ObjectInputStream tests */\n  public void objectInputStreamClosedNestedBad() throws IOException {\n    ObjectInputStream oin = null;\n    try {\n      oin = new ObjectInputStream(new FileInputStream(\"file.txt\"));\n      int a = oin.available();\n    } catch (IOException e) {\n    } finally {\n      if (oin != null) oin.close();\n    }\n  }\n\n  /* Fixed versions of this are below with ObjectInputStream tests */\n  public void objectOutputStreamClosedNestedBad() throws IOException {\n    ObjectOutputStream oin = null;\n    try {\n      oin = new ObjectOutputStream(new FileOutputStream(\"file.txt\"));\n      oin.write(3);\n    } catch (IOException e) {\n    } finally {\n      if (oin != null) oin.close();\n    }\n  }\n\n  // ZipFile tests      (Jarfile Tests also test Zipfiles)\n\n  public static void FN_zipFileLeakExceptionalBranchBad() throws IOException {\n    ZipFile j = null;\n    try {\n      j = new ZipFile(\"\");\n    } catch (IOException e) {\n      FileOutputStream fis = new FileOutputStream(\"file.txt\");\n      // The purpose of this is to cause a leak, from when ZipFile constructor throws\n    } finally {\n      if (j != null) j.close();\n    }\n  }\n\n  public static void zipFileNoLeakOk() throws IOException {\n    ZipFile j = null;\n    try {\n      j = new ZipFile(\"\");\n    } finally {\n      if (j != null) j.close();\n    }\n  }\n\n  // JarFile tests\n\n  public boolean jarFileClosedOk() {\n    JarFile jarFile = null;\n    try {\n      jarFile = new JarFile(\"\");\n    } catch (IOException e) {\n    } finally {\n      try {\n        if (jarFile != null) {\n          jarFile.close();\n        }\n      } catch (IOException e) {\n      }\n    }\n    return false;\n  }\n\n  public boolean FN_jarFileNotClosedBad() {\n    JarFile jarFile = null;\n    try {\n      jarFile = new JarFile(\"\");\n    } catch (IOException e) {\n    }\n    return false;\n  }\n\n  // FileInputStream tests\n\n  public void fileInputStreamNotClosedAfterReadBad() {\n    FileInputStream fis;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      fis.read();\n      fis.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void fileInputStreamClosedOk() throws IOException {\n    FileInputStream fis = null;\n    try {\n      fis = new FileInputStream(\"file.txt\");\n      fis.available();\n    } catch (IOException e) {\n    } finally {\n      if (fis != null) fis.close();\n    }\n  }\n\n  // PipedInputStream tests\n\n  public void FN_pipedInputStreamNotClosedAfterReadBad(PipedOutputStream pout) {\n    PipedInputStream pin;\n    try {\n      pin = new PipedInputStream(pout);\n      int data = pin.read();\n      pin.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pipedInputStreamClosedOk(PipedOutputStream pout) throws IOException {\n    PipedInputStream pin = null;\n    try {\n      pin = new PipedInputStream(pout);\n      int data = pin.read();\n    } catch (IOException e) {\n    } finally {\n      pin.close();\n    }\n  }\n\n  // PipedOutputStream tests\n\n  public void FN_pipedOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3, 4, 5};\n    PipedOutputStream pout;\n    try {\n      pout = new PipedOutputStream();\n      pout.write(arr);\n      pout.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pipedOutputStreamClosedOk(PipedInputStream pin) throws IOException {\n    PipedOutputStream pout = null;\n    try {\n      pout = new PipedOutputStream(pin);\n      pout.flush();\n    } catch (IOException e) {\n    } finally {\n      pout.close();\n    }\n  }\n\n  // ObjectOutputStream tests\n\n  public void objectOutputStreamNotClosedAfterWriteBad() {\n    byte[] arr = {1, 2, 3, 4, 5};\n    ObjectOutputStream oout;\n    try {\n      oout = new ObjectOutputStream(new FileOutputStream(\"file.txt\"));\n      oout.write(arr);\n      oout.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void objectOutputStreamClosedOk() throws IOException {\n    ObjectOutputStream oout = null;\n    FileOutputStream fis = new FileOutputStream(\"file.txt\");\n    try {\n      oout = new ObjectOutputStream(fis);\n      oout.flush();\n    } catch (IOException e) {\n    } finally {\n      if (oout != null) {\n        oout.close();\n      } else {\n        fis.close();\n      }\n    }\n  }\n\n  // ObjectInputStream tests\n\n  public void objectInputStreamNotClosedAfterReadBad() {\n    ObjectInputStream oin;\n    try {\n      oin = new ObjectInputStream(new FileInputStream(\"file.txt\"));\n      oin.read();\n      oin.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void objectInputStreamClosedOk() throws IOException {\n    ObjectInputStream oin = null;\n    FileInputStream fis = new FileInputStream(\"file.txt\");\n    try {\n      oin = new ObjectInputStream(fis);\n      int a = oin.available();\n    } catch (IOException e) {\n    } finally {\n      if (oin != null) {\n        oin.close();\n      } else {\n        fis.close();\n      }\n    }\n  }\n\n  public void objectInputStreamNotClosedBad() throws IOException {\n    ObjectInputStream oin = null;\n    FileInputStream fis = new FileInputStream(\"file.txt\");\n    try {\n      oin = new ObjectInputStream(fis);\n      int a = oin.available();\n    } catch (IOException e) {\n    } finally {\n      fis.close();\n    }\n  }\n\n  // JarInputStream tests\n\n  public static void jarInputStreamNoLeakOk() throws IOException {\n    FileInputStream fos = new FileInputStream(\"\");\n    try {\n      JarInputStream g = new JarInputStream(fos);\n      g.close();\n    } catch (IOException e) {\n      fos.close();\n    }\n  }\n\n  public static void jarInputStreamLeakBad() throws IOException {\n    FileInputStream fos = new FileInputStream(\"\");\n    try {\n      JarInputStream g = new JarInputStream(fos); //  Testing exceptional condition in constructor\n      g.close();\n    } catch (IOException e) {\n      // fos.close();\n    }\n  }\n\n  public static void nestedJarInputStreamBad(File file) throws IOException {\n    JarInputStream g = new JarInputStream(new FileInputStream(file));\n    g.close();\n  }\n\n  // JarOutputStream tests\n\n  public static void jarOutputStreamNoLeakOk() throws IOException {\n    FileOutputStream fos = new FileOutputStream(\"\");\n    try {\n      JarOutputStream g = new JarOutputStream(fos);\n      g.close();\n    } catch (IOException e) {\n      fos.close();\n    }\n  }\n\n  public static void jarOutputStreamLeakBad() throws IOException {\n    FileOutputStream fos = new FileOutputStream(\"\");\n    try {\n      JarOutputStream g = new JarOutputStream(fos); //  Testing exceptional condition in constructor\n      g.close();\n    } catch (IOException e) {\n      // fos.close();\n    }\n  }\n\n  public static void nestedJarOutputStreamBad() throws IOException {\n    JarOutputStream g = new JarOutputStream(new FileOutputStream(\"file.txt\"));\n    g.close();\n  }\n\n  // Socket tests\n\n  public void FN_socketNotClosedBad() {\n    Socket socket = new Socket();\n  }\n\n  public void socketClosedOk() throws IOException {\n    Socket socket = new Socket();\n    socket.close();\n  }\n\n  // Socket InputStream tests\n\n  public int FN_socketInputStreamNotClosedBad(Socket socket) throws IOException {\n    InputStream stream = socket.getInputStream();\n    return stream.read();\n  }\n\n  public void socketInputStreamClosedOk() throws IOException {\n    Socket socket = new Socket();\n    InputStream stream = socket.getInputStream();\n    try {\n      stream.close();\n    } catch (Exception e) {\n    }\n    socket.close();\n  }\n\n  // Socket OutputStream tests\n\n  public void FN_socketOutputStreamNotClosedBad(Socket socket) throws IOException {\n    OutputStream stream = socket.getOutputStream();\n    stream.write(10);\n  }\n\n  public void socketOutputStreamClosedOk() throws IOException {\n    Socket socket = new Socket();\n    OutputStream stream = socket.getOutputStream();\n    try {\n      stream.close();\n    } catch (Exception e) {\n    }\n    socket.close();\n  }\n\n  // ServerSocket tests\n\n  public void FN_serverSocketNotClosedBad() throws IOException {\n    ServerSocket listener = new ServerSocket(9090);\n    while (true) {\n      Socket socket = listener.accept();\n      try {\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        out.println(\"\");\n      } finally {\n        socket.close();\n      }\n      listener.close();\n    }\n  }\n\n  public void serverSocketClosedOk() throws IOException {\n    ServerSocket socket = new ServerSocket();\n    socket.close();\n  }\n\n  public void serverSocketWithSocketClosedOk() throws IOException {\n    ServerSocket listener = new ServerSocket(9090);\n    try {\n      while (true) {\n        Socket socket = listener.accept();\n        try {\n          PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n          out.println(\"\");\n        } finally {\n          socket.close();\n        }\n      }\n    } finally {\n      listener.close();\n    }\n  }\n\n  // HttpURLConnection\n\n  public void openHttpURLConnectionDisconnectedOk() throws IOException {\n    String content = \"TEXT\";\n    DataOutputStream outputStream = null;\n    HttpURLConnection connection = null;\n    URL address = new URL(\"http://www.facebook.com\");\n    connection = (HttpURLConnection) address.openConnection();\n    try {\n      outputStream = new DataOutputStream(connection.getOutputStream());\n      outputStream.writeBytes(content);\n      outputStream.flush();\n\n    } finally {\n      connection.disconnect();\n    }\n  }\n\n  public void FN_openHttpURLConnectionNotDisconnectedBad() throws IOException {\n    String content = \"TEXT\";\n    DataOutputStream outputStream = null;\n    HttpURLConnection connection = null;\n    URL address = new URL(\"http://www.facebook.com\");\n    connection = (HttpURLConnection) address.openConnection();\n\n    outputStream = new DataOutputStream(connection.getOutputStream());\n    outputStream.writeBytes(content);\n  }\n\n  public void FN_openHttpsURLConnectionNotDisconnectedBad() throws IOException {\n    HttpsURLConnection connection = null;\n    URL address = new URL(\"https://www.facebook.com\");\n    connection = (HttpsURLConnection) address.openConnection();\n  }\n\n  public void openHttpsURLConnectionDisconnectedOk() throws IOException {\n    HttpsURLConnection connection = null;\n    URL address = new URL(\"https://www.facebook.com\");\n    connection = (HttpsURLConnection) address.openConnection();\n    connection.disconnect();\n  }\n\n  public void closedWithCloseablesOk() throws IOException {\n    FileInputStream fs = new FileInputStream(\"file.txt\");\n    try {\n      fs.read();\n    } finally {\n      Closeables.close(fs, false);\n    }\n  }\n\n  public void closedQuietlyWithCloseablesOk() throws IOException {\n    FileInputStream fs = new FileInputStream(\"file.txt\");\n    try {\n      fs.read();\n    } finally {\n      Closeables.closeQuietly(fs);\n    }\n  }\n\n  public void closeNullWithCloseablesOk() throws IOException {\n    FileInputStream fs = null;\n    try {\n      fs = new FileInputStream(\"file.txt\");\n    } finally {\n      Closeables.close(fs, true);\n    }\n  }\n\n  public void closeNullQuietlyWithCloseablesOk() throws IOException {\n    FileInputStream fs = null;\n    try {\n      fs = new FileInputStream(\"file.txt\");\n    } finally {\n      Closeables.closeQuietly(fs);\n    }\n  }\n\n  private static void myClose(Closeable closeable, boolean swallowIOException) throws IOException {\n    if (closeable == null) {\n      return;\n    }\n    try {\n      closeable.close();\n    } catch (IOException e) {\n      if (!swallowIOException) {\n        throw e;\n      }\n    }\n  }\n\n  public void closeWithCloseablesNestedAllocOk() throws IOException {\n    BufferedInputStream b = null;\n    try {\n      b = new BufferedInputStream(new FileInputStream(\"file.txt\"));\n    } finally {\n      myClose(b, false);\n    }\n  }\n\n  // JsonParser tests\n\n  public void FN_parseFromStringAndNotCloseBad(JsonFactory factory) throws IOException {\n    UTF8StreamJsonParser parser = null;\n    try {\n      parser = (UTF8StreamJsonParser) factory.createParser(new File(\"[]\"));\n      Object o = parser.readValueAs(Object.class);\n      ignore(o);\n    } catch (Exception e) {\n    } finally {\n    }\n  }\n\n  public void parseFromInputStreamAndCloseOk(JsonFactory factory) throws IOException {\n    JsonParser parser = null;\n    FileInputStream in = null;\n    try {\n      in = new FileInputStream(\"\");\n      parser = factory.createParser(in);\n      Object o = parser.readValueAs(Object.class);\n      ignore(o);\n    } catch (Exception e) {\n    } finally {\n      if (in != null) in.close();\n    }\n    // parser does not own a resources which is closed externally\n  }\n\n  public void FN_parseFromInputStreamAndLeakBad(JsonFactory factory) throws IOException {\n    JsonParser parser = null;\n    FileInputStream in = null;\n    try {\n      in = new FileInputStream(\"\");\n      parser = factory.createParser(in);\n      Object o = parser.readValueAs(Object.class);\n      ignore(o);\n    } catch (Exception e) {\n    } finally {\n      if (parser != null) parser.close();\n    }\n    // parser does not own a resource which is leaked\n  }\n\n  private void ignore(Object o) {}\n\n  // Installation.java examples. Even the fix was a fp for a while\n  // for several reasons, so this test is just to make sure it remains\n  // banished forever\n\n  private String readInstallationFileOk(File installation) throws IOException {\n    RandomAccessFile f = new RandomAccessFile(installation, \"r\");\n    try {\n      byte[] bytes = new byte[(int) f.length()];\n      f.readFully(bytes);\n      return new String(bytes);\n    } finally {\n      f.close();\n    }\n  }\n\n  private String FN_readInstallationFileBad(File installation) throws IOException {\n    RandomAccessFile f = new RandomAccessFile(installation, \"r\");\n    byte[] bytes = new byte[(int) f.length()];\n    f.readFully(bytes);\n    f.close();\n    return new String(bytes);\n  }\n\n  private int readConfigCloseStreamOk(String mTurnConfigUrl) {\n    try {\n      URL url = new URL(mTurnConfigUrl);\n      URLConnection connection = url.openConnection();\n      InputStream stream = connection.getInputStream();\n      try {\n        return stream.read();\n      } finally {\n        stream.close();\n      }\n    } catch (Exception e) {\n    }\n    return 0;\n  }\n\n  private int FN_readConfigNotCloseStreamBad(String mTurnConfigUrl) {\n    try {\n      URL url = new URL(mTurnConfigUrl);\n      URLConnection connection = url.openConnection();\n      InputStream stream = connection.getInputStream();\n      return stream.read();\n    } catch (Exception e) {\n    }\n    return 0;\n  }\n\n  private void FN_readConfigNotClosedBad(String mTurnConfigUrl) {\n    try {\n      URL url = new URL(mTurnConfigUrl);\n      URLConnection connection = url.openConnection();\n      ignore(connection);\n    } catch (Exception e) {\n    }\n  }\n\n  // TypedArray\n\n  public void themeObtainTypedArrayAndRecycleOk(Resources.Theme theme) {\n    TypedArray array = theme.obtainStyledAttributes(new int[] {});\n    ignore(array);\n    array.recycle();\n  }\n\n  public void FN_themeObtainTypedArrayAndLeakBad(Resources.Theme theme) {\n    TypedArray array = theme.obtainStyledAttributes(new int[] {});\n    ignore(array);\n  }\n\n  public void activityObtainTypedArrayAndRecycleOk(Activity activity) {\n    TypedArray array = activity.obtainStyledAttributes(new int[] {});\n    ignore(array);\n    array.recycle();\n  }\n\n  public void FN_activityObtainTypedArrayAndLeakBad(Activity activity) {\n    TypedArray array = activity.obtainStyledAttributes(new int[] {});\n    ignore(array);\n  }\n\n  public void contextObtainTypedArrayAndRecycleOk(Context context) {\n    TypedArray array = context.obtainStyledAttributes(new int[] {});\n    ignore(array);\n    array.recycle();\n  }\n\n  public void FN_contextObtainTypedArrayAndLeakBad(Context context) {\n    TypedArray array = context.obtainStyledAttributes(new int[] {});\n    ignore(array);\n  }\n\n  // FileChannel\n\n  void FN_copyFileLeakBad(File src, File dst) throws IOException {\n    FileChannel inChannel = new FileInputStream(src).getChannel();\n    FileChannel outChannel = new FileOutputStream(dst).getChannel();\n    try {\n      inChannel.transferTo(0, inChannel.size(), outChannel);\n    } finally {\n      if (inChannel != null) inChannel.close();\n      if (outChannel != null) outChannel.close();\n    }\n  }\n\n  void copyFileCloseOk(File src, File dst) throws IOException {\n    FileChannel inChannel = new FileInputStream(src).getChannel();\n    try {\n      ignore(inChannel);\n    } finally {\n      inChannel.close();\n    }\n  }\n\n  protected long checkNotNullCauseNoLeakOk(URL mUrl) throws IOException {\n    URL url = new URL(\"http://www.facebook.com\");\n    HttpURLConnection serverConnection =\n        (HttpURLConnection) Preconditions.checkNotNull(url.openConnection());\n    try {\n      ignore(serverConnection);\n    } catch (NumberFormatException nfe) {\n    } finally {\n      serverConnection.disconnect();\n    }\n    return 0;\n  }\n\n  void scannerNotClosedBad() throws IOException {\n    Scanner scanner = new Scanner(new FileInputStream(\"file.txt\"));\n  }\n\n  void scannerClosedOk() throws IOException {\n    Scanner scanner = new Scanner(new FileInputStream(\"file.txt\"));\n    scanner.close();\n  }\n\n  void processDestroyedOk() {\n    Process process = null;\n    try {\n      process = Runtime.getRuntime().exec(\"\");\n    } catch (IOException e) {\n    } finally {\n      process.destroy(); // NPE ?\n    }\n  }\n\n  void processForciblyDestroyedOk() throws IOException {\n    Process process = null;\n    try {\n      process = Runtime.getRuntime().exec(\"\");\n    } finally {\n      ignore(process.destroyForcibly());\n    }\n  }\n\n  class Container {\n    FileInputStream inputStream;\n  }\n\n  native Container load(FileInputStream inputStream);\n\n  public Container resourceReturnedIndirectlyOk() {\n    FileInputStream inputStream;\n    Container container = null;\n    try {\n      inputStream = new FileInputStream(\"pif.txt\");\n      container = load(inputStream);\n    } catch (FileNotFoundException e) {\n      return null;\n    }\n    return container;\n  }\n\n  native void unknownClose(Closeable c);\n\n  public void resourceClosedBySkippedMethodOk() {\n    FileInputStream inputStream = null;\n    try {\n      inputStream = new FileInputStream(\"pif.txt\");\n    } catch (FileNotFoundException e) {\n      return;\n    } finally {\n      unknownClose(inputStream);\n    }\n  }\n\n  public int tryWithResourceOk() {\n    try (FileInputStream inputStream = new FileInputStream(\"paf.txt\")) {\n      return inputStream.read();\n    } catch (IOException e) {\n      return 0;\n    }\n  }\n\n  public InputStreamReader withCharsetOk(URLConnection urlConnection) {\n    InputStreamReader reader = null;\n    try {\n      reader = new InputStreamReader(urlConnection.getInputStream(), \"iso-8859-1\");\n    } catch (Exception e) {\n      return null;\n    } finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e) {\n          // do nothing\n        }\n      }\n    }\n    return reader;\n  }\n\n  public void FN_withZipFileBad() throws IOException {\n    ZipFile f = new ZipFile(\"hi\");\n    InputStream s = f.getInputStream(f.getEntry(\"there\"));\n    if (s != null) s.toString();\n    f.close();\n  }\n\n  public void FN_deflaterLeakBad() {\n    Deflater comp = new Deflater();\n  }\n\n  public void deflaternoLeakOk() {\n    Deflater comp = new Deflater();\n    comp.end();\n  }\n\n  public void FN_inflaterLeakBad() {\n    Inflater decomp = new Inflater();\n  }\n\n  public void inflaterNoLeakOk() {\n    Inflater decomp = new Inflater();\n    decomp.end();\n  }\n\n  void NoResourceLeakWarningAfterCheckStateOk(File f, int x) throws IOException {\n    InputStream stream = new FileInputStream(f);\n    Preconditions.checkState(x > 0);\n    stream.close();\n  }\n\n  static class RessourceInMap {\n    final Map<String, InputStream> map;\n\n    public RessourceInMap() {\n      map = new HashMap();\n    }\n\n    public void allocateOk(List<String> filenames) throws IOException {\n      for (String filename : filenames) map.put(filename, new FileInputStream(new File(filename)));\n    }\n\n    public void releaseAll() {\n      for (InputStream is : map.values())\n        try {\n          is.close();\n        } catch (IOException e) {\n\n        }\n    }\n  }\n\n  // to test reachability from a collection\n  static class Obj {\n    InputStream content;\n  }\n\n  static class RessourceInList {\n    final List<Obj> list;\n\n    public RessourceInList() {\n      list = new ArrayList();\n    }\n\n    public void allocateOk(List<String> filenames) throws IOException {\n      for (String filename : filenames) {\n        Obj o = new Obj();\n        o.content = new FileInputStream(new File(filename));\n        list.add(o);\n      }\n    }\n\n    public void releaseAll() {\n      for (Obj o : list)\n        try {\n          o.content.close();\n        } catch (IOException e) {\n\n        }\n    }\n  }\n\n  // interprocedural tests\n\n  class MyResource {\n    FileInputStream fis;\n\n    public MyResource(FileInputStream fis) {\n      this.fis = fis;\n    };\n\n    public native void unknownClose();\n\n    public void indirectCallToUnknownClose() {\n      unknownClose();\n    }\n  }\n\n  public void callUnknownOk() throws FileNotFoundException {\n    MyResource r;\n    r = new MyResource(new FileInputStream(\"testing.txt\"));\n    r.unknownClose();\n  }\n\n  public void indirectCallUnknownOk() throws FileNotFoundException {\n    MyResource r;\n    r = new MyResource(new FileInputStream(\"testing.txt\"));\n    r.indirectCallToUnknownClose();\n  }\n}\n"
    },
    {
      "testname": "ReturnValueIgnored.java",
      "testlanguage": "java",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class ReturnValueIgnored {\n\n  private int m() {\n    return 1;\n  }\n\n  public void returnValueIgnored() {\n    m();\n  }\n}\n"
    },
    {
      "testname": "SkippedSourceFile.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// _SHOULD_BE_SKIPPED_\n\npackage codetoanalyze.java.infer;\n\npublic class SkippedSourceFile {\n\n  static Object createdBySkippedFile() {\n    return null;\n  }\n}\n"
    },
    {
      "testname": "SomeLibrary.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class SomeLibrary {\n\n  class $$Z {}\n\n  T t;\n\n  T get() {\n    return t == null ? null : t;\n  }\n}\n"
    },
    {
      "testname": "SuppressLintExample.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport com.facebook.infer.annotation.SuppressLint;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n// @SuppressLint(\"Suppressing all the warnings in a class is not supported yet\")\nclass SuppressAllWarnigsInTheClass {\n\n  void shouldNotReportNPE() {\n    Object object = null;\n    object.toString();\n  }\n\n  void shouldNotReportResourceLeak() {\n    try {\n      FileInputStream fis = new FileInputStream(new File(\"whatever.txt\"));\n    } catch (IOException e) {\n    }\n  }\n}\n\npublic class SuppressLintExample {\n\n  @SuppressLint(\"null-dereference\")\n  SuppressLintExample() {\n    Object object = null;\n    object.toString();\n  }\n\n  void shouldReportNPE() {\n    Object object = null;\n    object.toString();\n  }\n\n  @SuppressLint(\"null-dereference\")\n  void shouldNotReportNPE() {\n    Object object = null;\n    object.toString();\n  }\n}\n"
    },
    {
      "testname": "T.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\npublic class T {\n  int x;\n\n  void f() {}\n}\n"
    },
    {
      "testname": "TextUtilsExample.java",
      "testlanguage": "java",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport android.text.TextUtils;\n\npublic class TextUtilsExample {\n\n  public void testTextUtilsIsEmptyBad(String s) {\n    if (TextUtils.isEmpty(s)) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testTextUtilsIsEmptyBad() {\n    String s = \"#@%^&%\";\n    if (!TextUtils.isEmpty(s)) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testTextUtilsIsEmptyEmptyStrBad() {\n    if (TextUtils.isEmpty(\"\")) {\n      Object o = null;\n      o.toString();\n    }\n  }\n\n  public void testTextUtilsIsEmptyNullBad() {\n    String s = null;\n    if (TextUtils.isEmpty(s)) {\n      Object o = null;\n      o.toString();\n    }\n  }\n}\n"
    },
    {
      "testname": "TransitiveAccess.java",
      "testlanguage": "java",
      "expected-problems": 103,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\npublic class TransitiveAccess {\n  public interface Callback {\n    public void call();\n  }\n\n  public static void caller(Callback lambda) {\n    lambda.call();\n  }\n\n  @Target({ElementType.METHOD})\n  @Retention(RetentionPolicy.CLASS)\n  @interface SinkAnno {}\n\n  @Target({ElementType.METHOD})\n  @Retention(RetentionPolicy.CLASS)\n  @interface SourceAnno {}\n\n  @Target({ElementType.METHOD})\n  @Retention(RetentionPolicy.CLASS)\n  @interface SomeRandomAnno {}\n\n  public static class Sinks {\n    public static void safe() {}\n\n    public static void sink() {}\n\n    @SinkAnno\n    public static void funcWithAnno() {}\n\n    @SomeRandomAnno\n    public static void safeWithAnno() {}\n\n    public static void sink_if_arg_true(boolean arg) {\n      if (arg) sink();\n      else safe();\n    }\n  }\n\n  abstract class BaseSinks {\n    @SinkAnno\n    public abstract void overrideAnnotated();\n  }\n\n  abstract class ChildSinks extends BaseSinks {\n    public void overrideAnnotated() {}\n  }\n\n  public static class Base {}\n\n  public static class Context extends Base {\n    public static void sourceOk() {\n      Sinks.safe();\n    }\n\n    public static void sourceBad() {\n      Sinks.sink();\n    }\n\n    public static void sourceConditionalOk() {\n      Sinks.sink_if_arg_true(false);\n    }\n\n    public static void sourceConditionalBad() {\n      Sinks.sink_if_arg_true(true);\n    }\n\n    public static void sourceWithLambdaOk() {\n      Callback lambda = () -> Sinks.safe();\n      lambda.call();\n    }\n\n    public static void sourceWithLambdaBad() {\n      Callback lambda = () -> Sinks.sink();\n      lambda.call();\n    }\n\n    // This is currently reported because the generated code\n    // corresponding to the lambda falls into the context\n    public static void sourceWithLambdaNoCallBad() {\n      Callback lambda = () -> Sinks.sink();\n    }\n\n    public static void sourceWithLambdaIndirectOk() {\n      caller(() -> Sinks.safe());\n    }\n\n    public static void sourceWithLambdaIndirectBad() {\n      caller(() -> Sinks.sink());\n    }\n\n    public static void sourceCallsFuncWithAnnoBad() {\n      Sinks.funcWithAnno();\n    }\n\n    public void sourceCallsOverrideAnnotatedBad(ChildSinks sink) {\n      sink.overrideAnnotated();\n    }\n\n    public void sourceCallsAbstractOverrideAnnotatedBad(BaseSinks sink) {\n      sink.overrideAnnotated();\n    }\n\n    public static void sourceCallsSafeWithAnnoOk() {\n      Sinks.safeWithAnno();\n    }\n  }\n\n  @SourceAnno\n  public static void sourceWithAnnoBad() {\n    Sinks.sink();\n  }\n\n  @SourceAnno\n  public static void sourceWithAnnoOk() {\n    Sinks.safe();\n  }\n\n  @SourceAnno\n  public static void sourceWithAnnoAndLambdaBad() {\n    caller(() -> Sinks.sink());\n  }\n\n  @SourceAnno\n  public static void sourceWithAnnoAndLambdaOk() {\n    caller(() -> Sinks.safe());\n  }\n\n  @SourceAnno\n  public static void sourceWithAnnoAndLambdaNoCallOk() {\n    Callback lambda = () -> Sinks.sink();\n  }\n\n  @SourceAnno\n  public static void sourceWithChainOfCallsBad() {\n    f1();\n  }\n\n  public static void f1() {\n    f2();\n  }\n\n  public static void f2() {\n    f3();\n  }\n\n  public static void f3() {\n    Sinks.funcWithAnno();\n  }\n}\n"
    },
    {
      "testname": "Utils.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.Closeable;\n\npublic class Utils {\n\n  public static void closeQuietly(Closeable closeable) {\n    try {\n      if (closeable != null) {\n        closeable.close();\n      }\n    } catch (Exception ex) {\n    }\n  }\n}\n"
    },
    {
      "testname": "WriterLeaks.java",
      "testlanguage": "java",
      "expected-problems": 30,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.infer;\n\nimport java.io.BufferedWriter;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PipedReader;\nimport java.io.PipedWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\n\npublic class WriterLeaks {\n\n  // Writer tests\n\n  public void writerNotClosedAfterWriteBad() {\n    Writer writer;\n    try {\n      writer = new PrintWriter(\"file.txt\");\n      writer.write(10);\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void writerClosedOk() throws IOException {\n    Writer writer = null;\n    try {\n      writer = new PrintWriter(\"file.txt\");\n      writer.write(10);\n    } catch (IOException e) {\n    } finally {\n      if (writer != null) writer.close();\n    }\n  }\n\n  // PrintWriter tests\n\n  public void printWriterNotClosedAfterAppendBad() {\n    PrintWriter writer;\n    try {\n      writer = new PrintWriter(\"file.txt\");\n      writer = writer.append('0');\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void printWriterClosedOk() throws IOException {\n    PrintWriter writer = null;\n    try {\n      writer = new PrintWriter(\"file.txt\");\n      writer = writer.append(null);\n\n    } finally {\n      if (writer != null) writer.close();\n    }\n  }\n\n  // BufferedWriter tests\n\n  public void bufferedWriterNotClosedAfterWriteBad() {\n    BufferedWriter writer;\n    try {\n      FileWriter fw = new FileWriter(\"file.txt\");\n      writer = new BufferedWriter(fw);\n      writer.write(\"word\");\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void bufferedWriterClosedOk() throws IOException {\n    BufferedWriter writer = null;\n    try {\n      FileWriter fw = new FileWriter(\"file.txt\");\n      writer = new BufferedWriter(fw);\n      writer.flush();\n    } catch (IOException e) {\n    } finally {\n      if (writer != null) writer.close();\n    }\n  }\n\n  // OutputStreamWriter tests\n\n  public void outputStreamWriterNotClosedAfterWriteBad() {\n    OutputStreamWriter writer;\n    try {\n      writer = new OutputStreamWriter(new FileOutputStream(\"file.txt\"));\n      writer.write(\"word\");\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void outputStreamWriterClosedOk() throws IOException {\n    OutputStreamWriter writer = null;\n    try {\n      writer = new OutputStreamWriter(new FileOutputStream(\"file.txt\"));\n      writer.write(10);\n    } catch (IOException e) {\n    } finally {\n      if (writer != null) writer.close();\n    }\n  }\n\n  // FileWriter tests\n\n  public void fileWriterNotClosedAfterWriteBad() {\n    FileWriter writer;\n    try {\n      writer = new FileWriter(\"file.txt\");\n      writer.write(\"word\");\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void fileWriterClosedOk() throws IOException {\n    FileWriter writer = null;\n    try {\n      writer = new FileWriter(\"file.txt\");\n      writer.write(10);\n    } catch (IOException e) {\n    } finally {\n      if (writer != null) writer.close();\n    }\n  }\n\n  // PipedWriter tests\n\n  public void pipedWriterNotClosedAfterConstructedWithReaderBad() {\n    PipedWriter writer;\n    PipedReader reader;\n    try {\n      reader = new PipedReader();\n      writer = new PipedWriter(reader);\n      writer.write(42);\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void FN_pipedWriterNotClosedAfterConnectBad(PipedReader reader) {\n    PipedWriter writer;\n    try {\n      writer = new PipedWriter();\n      writer.connect(reader);\n      writer.write(42);\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void FN_pipedWriterNotConnectedBad() {\n    PipedWriter writer;\n    try {\n      writer = new PipedWriter();\n      writer.close();\n    } catch (IOException e) {\n    }\n  }\n\n  public void pipedWriterClosedOk(PipedReader reader) throws IOException {\n    PipedWriter writer = null;\n    try {\n      writer = new PipedWriter();\n      writer.connect(reader);\n      writer.write(42);\n    } catch (IOException e) {\n    } finally {\n      if (writer != null) writer.close();\n    }\n  }\n}\n"
    },
    {
      "testname": "Annotations.java",
      "testlanguage": "java",
      "expected-problems": 28,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass Annotations {\n\n  static class Methods {\n\n    @SensitiveSourceMarker\n    String markedSource() {\n      return \"\";\n    }\n\n    @SensitiveSourceMarkerWithValue(SensitiveSourceMarkerType.EMAIL)\n    String email() {\n      return \"\";\n    }\n\n    @SensitiveSourceMarkerWithValue(SensitiveSourceMarkerType.LOCATION)\n    String location() {\n      return \"\";\n    }\n\n    @SensitiveSourceMarkerWithValue(SensitiveSourceMarkerType.OTHER)\n    String other() {\n      return \"\";\n    }\n\n    @SensitiveSinkMarker\n    void markedSink(String input) {}\n\n    @SanitizerMarker\n    String markedSanitizer(String input) {\n      return input;\n    }\n\n    String unmarkedSource() {\n      return \"\";\n    }\n\n    void unmarkedSink(String input) {}\n\n    String unmarkedSanitizer(String input) {\n      return input;\n    }\n\n    void markedSourceToMarkedSinkBad() {\n      markedSink(markedSource());\n    }\n\n    void markedSourceUsingMarkedSanitizerToMarkedSinkOk() {\n      markedSink(markedSanitizer(markedSource()));\n    }\n\n    void markedSourceUsingUnmarkedSanitizerToMarkedSinkBad() {\n      markedSink(unmarkedSanitizer(markedSource()));\n    }\n\n    void unmarkedSourceToMarkedSinkOk() {\n      markedSink(unmarkedSource());\n    }\n\n    void unmarkedSourceUsingMarkedSanitizerToMarkedSinkOk() {\n      markedSink(markedSanitizer(unmarkedSource()));\n    }\n\n    void markedSourceToUnmarkedSinkOk() {\n      unmarkedSink(markedSource());\n    }\n\n    void emailToSinkBad() {\n      markedSink(email());\n    }\n\n    void locationToSinkBad() {\n      markedSink(location());\n    }\n\n    void otherToSinkOk() {\n      markedSink(other());\n    }\n  }\n\n  static class Fields {\n\n    @SensitiveSourceMarker static String markedSource;\n\n    @SensitiveSinkMarker static String markedSink;\n\n    @SensitiveSourceMarkerWithValue(SensitiveSourceMarkerType.EMAIL)\n    static String email;\n\n    @SensitiveSourceMarkerWithValue(SensitiveSourceMarkerType.LOCATION)\n    static String location;\n\n    @SensitiveSourceMarkerWithValue(SensitiveSourceMarkerType.OTHER)\n    static String other;\n\n    static String unmarked;\n\n    void markedSourceToMarkedSinkBad() {\n      markedSink = markedSource;\n    }\n\n    void unmarkedSourceToMarkedSinkOk() {\n      markedSink = unmarked;\n    }\n\n    void markedSourceToUnmarkedSinkOk() {\n      unmarked = markedSource;\n    }\n\n    void emailToMarkedSinkBad() {\n      markedSink = email;\n    }\n\n    void locationToMarkedSinkBad() {\n      markedSink = location;\n    }\n\n    void otherToMarkedSinkOk() {\n      markedSink = other;\n    }\n  }\n}\n"
    },
    {
      "testname": "Arrays.java",
      "testlanguage": "java",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class Arrays {\n\n  static class Obj {\n    Object f;\n    Object[] arr;\n  }\n\n  /** should report on these tests */\n  void viaArrayBad() {\n    Object[] arr = new Object[1];\n    arr[0] = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(arr[0]);\n  }\n\n  void viaArrayThenFieldBad() {\n    Obj[] arr = new Obj[1];\n    arr[0].f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(arr[0].f);\n  }\n\n  void viaFieldThenArrayBad1(Obj obj) {\n    obj.arr[0] = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.arr[0]);\n  }\n\n  void viaFieldThenArrayBad2() {\n    Obj obj = new Obj();\n    obj.arr = new Obj[1];\n    obj.arr[0] = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.arr[0]);\n  }\n\n  /** should not report on these tests */\n  void viaArrayOk() {\n    Object[] arr = new Object[1];\n    arr[0] = new Object();\n    InferTaint.inferSensitiveSink(arr[0]);\n  }\n\n  void viaArrayOk1(Object y, Object[] z) {\n    Object[] arr = new Object[2];\n    arr[0] = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(arr[1]);\n  }\n\n  void viaArrayOk2(Object y, Object[] z) {\n    Object[] arr = new Object[1];\n    arr[0] = InferTaint.inferSecretSource();\n    arr[0] = null;\n    InferTaint.inferSensitiveSink(arr[0]);\n  }\n}\n"
    },
    {
      "testname": "Basics.java",
      "testlanguage": "java",
      "expected-problems": 54,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/** testing basic intraprocedural functionality: assignment, ifs, loops, casts */\npublic class Basics {\n\n  native Object notASource();\n\n  native void notASink(Object o);\n\n  /** should report on these tests */\n  void directBad() {\n    InferTaint.inferSensitiveSink(InferTaint.inferSecretSource());\n  }\n\n  void viaVarBad1() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void viaVarBad2() {\n    Object src = InferTaint.inferSecretSource();\n    Object alias = src;\n    InferTaint.inferSensitiveSink(alias);\n  }\n\n  void viaVarBad3() {\n    Object src = InferTaint.inferSecretSource();\n    Object alias = src;\n    src = null;\n    InferTaint.inferSensitiveSink(alias);\n  }\n\n  void viaCastBad1() {\n    InferTaint.inferSensitiveSink((String) InferTaint.inferSecretSource());\n  }\n\n  void viaCastBad2() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink((String) src);\n  }\n\n  void ifBad1(boolean b) {\n    Object src = null;\n    if (b) {\n      src = InferTaint.inferSecretSource();\n    }\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void ifBad2(boolean b) {\n    Object src = InferTaint.inferSecretSource();\n    if (b) {\n      src = null;\n    }\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void ifBad3(boolean b) {\n    Object src;\n    if (b) {\n      src = new Object();\n    } else {\n      src = InferTaint.inferSecretSource();\n    }\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void ifBad4(boolean b1, boolean b2) {\n    Object src;\n    if (b1) {\n      src = new Object();\n    } else if (b2) {\n      src = InferTaint.inferSecretSource();\n    } else {\n      src = null;\n    }\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void ifBad5(boolean b) {\n    Object src = InferTaint.inferSecretSource();\n    if (b) {\n      InferTaint.inferSensitiveSink(src);\n    }\n  }\n\n  void switchBad1(int i) {\n    Object src = InferTaint.inferSecretSource();\n    switch (i) {\n      case 1:\n        InferTaint.inferSensitiveSink(src);\n        break;\n      case 2:\n        break;\n      default:\n        break;\n    }\n  }\n\n  void switchBad2(int i) {\n    Object src = InferTaint.inferSecretSource();\n    switch (i) {\n      case 1:\n        break;\n      case 2:\n        InferTaint.inferSensitiveSink(src);\n        break;\n      default:\n        break;\n    }\n  }\n\n  void switchBad3(int i) {\n    Object src = null;\n    switch (i) {\n      case 1:\n        src = InferTaint.inferSecretSource();\n        // fallthrough\n      case 2:\n        InferTaint.inferSensitiveSink(src);\n        break;\n      default:\n        break;\n    }\n  }\n\n  void whileBad1(int i) {\n    Object src = InferTaint.inferSecretSource();\n    while (i < 10) {\n      InferTaint.inferSensitiveSink(src);\n      i++;\n    }\n  }\n\n  void whileBad2(int i) {\n    Object src = null;\n    while (i < 10) {\n      src = InferTaint.inferSecretSource();\n      i++;\n    }\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  // this should report only two alarms, not three\n  void noTripleReportBad() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(src);\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void arrayWithTaintedContentsBad() {\n    Object src = InferTaint.inferSecretSource();\n    Object[] arr = new Object[] {src};\n    InferTaint.inferSensitiveSink(arr);\n  }\n\n  void passToSinkOk(int x, Object src) {\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void funCallBad() {\n    Object src = InferTaint.inferSecretSource();\n    passToSinkOk(2, src);\n  }\n\n  /** should not report on these tests */\n  void directOk1() {\n    notASink(notASource());\n  }\n\n  void directOk2() {\n    notASink(InferTaint.inferSecretSource());\n  }\n\n  void directOk3() {\n    InferTaint.inferSensitiveSink(notASource());\n  }\n\n  void viaVarOk() {\n    Object src = new Object();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void viaVarStrongUpdateOk() {\n    Object src = InferTaint.inferSecretSource();\n    src = null;\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  Object exceptionOk(boolean b, Object o) {\n    if (b) {\n      throw new AssertionError(\"exception\");\n    }\n    o.toString();\n    return o;\n  }\n\n  void synchronizedOk(Object o) {\n    synchronized (o) {\n    }\n  }\n\n  // this is to test that we don't crash due to the slightly odd translation of synchronized\n  void callSynchronizedOk(Object o) {\n    synchronizedOk(o);\n  }\n\n  void deadCodeOk() {\n    Object src = InferTaint.inferSecretSource();\n    boolean b = false;\n    if (b) {\n      InferTaint.inferSensitiveSink(src);\n    }\n  }\n\n  void loopInvariantOk() {\n    Object src = InferTaint.inferSecretSource();\n    for (int i = 0; i < 10; i++) {\n      src = null;\n    }\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void taintedToSanitizedToSinkOk() {\n    InferTaint.inferSensitiveSink(\n        InferTaint.inferUniversalSanitizer(InferTaint.inferSecretSource()));\n  }\n\n  Object inferUniversalSanitizer() {\n    return InferTaint.inferSecretSource();\n  }\n\n  // sanitizer should take precedence\n  void FP_returnedFromSanitizedTaintedToSinkOk() {\n    InferTaint.inferSensitiveSink(inferUniversalSanitizer());\n  }\n\n  void taintOnUnrelatedBoolOk(boolean notTaintedFlag) {\n    boolean taintedFlag = (boolean) InferTaint.inferSecretSource();\n    boolean uberFlag = notTaintedFlag || taintedFlag;\n    if (!uberFlag) {\n      InferTaint.inferSensitiveSink(notTaintedFlag);\n    }\n  }\n}\n"
    },
    {
      "testname": "Callback.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic interface Callback {\n\n  void onCompletion(Object result);\n}\n"
    },
    {
      "testname": "ClassLoading.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.content.ClipboardManager;\n\npublic class ClassLoading {\n  ClipboardManager clipboard;\n\n  public String getUserControlledString() {\n    return this.clipboard.getText().toString();\n  }\n\n  public void clipboardToClassForNameBad() {\n    try {\n      Class cls = Class.forName(this.getUserControlledString());\n    } catch (Exception e) {\n      System.out.println(\"Exception: \" + e);\n    }\n  }\n\n  /*\n    We don't want to report it as we consider that string concatenation\n    sanitizes the user-controlled string for class loading.\n  */\n  public void clipboardToClassForNameWithConcatenationGood() {\n    String javaFileName = \"blabla.\" + this.getUserControlledString();\n    try {\n      Class cls = Class.forName(javaFileName);\n    } catch (Exception e) {\n      System.out.println(\"Exception: \" + e);\n    }\n  }\n}\n"
    },
    {
      "testname": "Constants.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass Constants {\n\n  void source(Object request) {}\n\n  void nullNotTaintedOk() {\n    source(null);\n    InferTaint.inferSensitiveSink(null);\n  }\n\n  void stringLiteralNotTaintedOk() {\n    source(\"asdf\");\n    InferTaint.inferSensitiveSink(\"asdf\");\n  }\n\n  void nonLiteralTaintedBad() {\n    Object obj = new Object();\n    source(obj);\n    InferTaint.inferSensitiveSink(obj);\n  }\n}\n"
    },
    {
      "testname": "ContentProviders.java",
      "testlanguage": "java",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.content.ContentProvider;\nimport android.content.ContentValues;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.ParcelFileDescriptor;\nimport java.io.File;\n\npublic abstract class ContentProviders extends ContentProvider {\n\n  File mFile;\n\n  /* NOTE: all methods below should produce a taint warning. Their names do not follow our standard\n   * naming convention because they are overrides */\n\n  @Override\n  public int bulkInsert(Uri uri, ContentValues[] values) {\n    mFile = new File(uri.toString());\n    return 0;\n  }\n\n  @Override\n  public Bundle call(String method, String args, Bundle extras) {\n    mFile = new File(method);\n    return extras;\n  }\n\n  @Override\n  public int delete(Uri uri, String selection, String[] selectionArgs) {\n    mFile = new File(uri.toString());\n    return 0;\n  }\n\n  @Override\n  public Uri insert(Uri uri, ContentValues values) {\n    mFile = new File(uri.toString());\n    return null;\n  }\n\n  @Override\n  public String getType(Uri uri) {\n    mFile = new File(uri.toString());\n    return null;\n  }\n\n  @Override\n  public AssetFileDescriptor openAssetFile(Uri uri, String mode, CancellationSignal signal) {\n    mFile = new File(uri.toString());\n    return null;\n  }\n\n  @Override\n  public ParcelFileDescriptor openFile(Uri uri, String mode, CancellationSignal signal) {\n    mFile = new File(uri.toString());\n    return null;\n  }\n\n  @Override\n  public AssetFileDescriptor openTypedAssetFile(\n      Uri uri, String mimeTypeFilter, Bundle opts, CancellationSignal signal) {\n    mFile = new File(uri.toString());\n    return null;\n  }\n\n  @Override\n  public Cursor query(\n      Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\n    mFile = new File(uri.toString());\n    return null;\n  }\n\n  @Override\n  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n    mFile = new File(uri.toString());\n    return 0;\n  }\n}\n"
    },
    {
      "testname": "DynamicDispatch.java",
      "testlanguage": "java",
      "expected-problems": 53,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class DynamicDispatch {\n\n  static interface Interface {\n    public Object returnSource();\n\n    public void callSink(Object o);\n\n    public Object propagate(Object o);\n  }\n\n  static class BadInterfaceImpl1 implements Interface {\n    @Override\n    public Object returnSource() {\n      return InferTaint.inferSecretSource();\n    }\n\n    @Override\n    public void callSink(Object o) {\n      InferTaint.inferSensitiveSink(o);\n    }\n\n    @Override\n    public Object propagate(Object o) {\n      return o;\n    }\n  }\n\n  static class BadInterfaceImpl2 implements Interface {\n    @Override\n    public Object returnSource() {\n      return InferTaint.inferSecretSource();\n    }\n\n    @Override\n    public void callSink(Object o) {\n      InferTaint.inferSensitiveSink(o);\n    }\n\n    @Override\n    public Object propagate(Object o) {\n      return o;\n    }\n  }\n\n  static class OkInterfaceImpl implements Interface {\n    @Override\n    public Object returnSource() {\n      return null;\n    }\n\n    @Override\n    public void callSink(Object o) {}\n\n    @Override\n    public Object propagate(Object o) {\n      return null;\n    }\n  }\n\n  /**\n   * interface tests. for all of these, we should see a warning for both BadInterfaceImpl1 and\n   * BadInterfaceImpl2, but not OkInterfaceImpl\n   */\n  static void FN_returnSourceViaInterfaceBad(Interface i) {\n    Object source = i.returnSource();\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  static void FN_callSinkViaInterfaceBad(Interface i) {\n    Object source = InferTaint.inferSecretSource();\n    i.callSink(source);\n  }\n\n  static void propagateViaInterfaceBad(Interface i) {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource = i.propagate(source);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  static void interfaceOk() {\n    Interface i = new OkInterfaceImpl();\n    Object source1 = i.returnSource();\n    InferTaint.inferSensitiveSink(source1);\n\n    Object source2 = InferTaint.inferSecretSource();\n    i.callSink(source2);\n\n    Object launderedSource = i.propagate(source2);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  static class Supertype {\n    public Object returnSource() {\n      return null;\n    }\n\n    public void callSink(Object o) {}\n\n    public Object propagate(Object o) {\n      return null;\n    }\n  }\n\n  static class BadSubtype extends Supertype {\n    @Override\n    public Object returnSource() {\n      return InferTaint.inferSecretSource();\n    }\n\n    @Override\n    public void callSink(Object o) {\n      InferTaint.inferSensitiveSink(o);\n    }\n\n    @Override\n    public Object propagate(Object o) {\n      return o;\n    }\n  }\n\n  static void FN_returnSourceViaSubtypeBad(Supertype s) {\n    Object source = s.returnSource();\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  static void FN_callSinkViaSubtypeBad(Supertype s) {\n    Object source = InferTaint.inferSecretSource();\n    s.callSink(source);\n  }\n\n  static void FN_propagateViaSubtypeBad(Supertype s) {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource = s.propagate(source);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  // need to look and see if we know the concrete type of the receiver to get this one\n  static void propagateViaConcreteTypeOk() {\n    Supertype s = new Supertype();\n\n    Object source1 = s.returnSource();\n    InferTaint.inferSensitiveSink(source1);\n\n    Object source2 = InferTaint.inferSecretSource();\n    s.callSink(source2);\n\n    Object launderedSource = s.propagate(source2);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n}\n"
    },
    {
      "testname": "Exceptions.java",
      "testlanguage": "java",
      "expected-problems": 42,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass Exceptions {\n\n  static native void mayExcept() throws Exception;\n\n  public static void FN_sinkInCatchBad1() {\n    Object source = InferTaint.inferSecretSource();\n    try {\n      mayExcept();\n    } catch (Exception e) {\n      InferTaint.inferSensitiveSink(source);\n    }\n  }\n\n  public static void FN_sinkInCatchBad2() {\n    Object source = null;\n    try {\n      source = InferTaint.inferSecretSource();\n      mayExcept();\n    } catch (Exception e) {\n      InferTaint.inferSensitiveSink(source);\n    }\n  }\n\n  public static void FN_sinkAfterCatchBad() {\n    Object source = InferTaint.inferSecretSource();\n    try {\n      mayExcept();\n      source = null;\n    } catch (Exception e) {\n    }\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  public static void sinkAfterCatchOk() {\n    Object source = InferTaint.inferSecretSource();\n    try {\n      mayExcept();\n      source = null;\n    } catch (Exception e) {\n      source = null;\n    }\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  public static void sinkInFinallyBad1() throws Exception {\n    Object source = InferTaint.inferSecretSource();\n    try {\n      mayExcept();\n    } finally {\n      InferTaint.inferSensitiveSink(source);\n    }\n  }\n\n  public static void sinkInFinallyBad2() throws Exception {\n    Object source = null;\n    try {\n      mayExcept();\n      source = InferTaint.inferSecretSource();\n    } finally {\n      InferTaint.inferSensitiveSink(source);\n    }\n  }\n\n  public static void FN_sinkInFinallyBad3() {\n    Object source = null;\n    try {\n      mayExcept();\n    } catch (Exception e) {\n      source = InferTaint.inferSecretSource();\n    } finally {\n      InferTaint.inferSensitiveSink(source);\n    }\n  }\n\n  public static void sinkAfterFinallyOk1() throws Exception {\n    Object source = InferTaint.inferSecretSource();\n    try {\n      mayExcept();\n    } finally {\n      source = null;\n    }\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  public static void sinkAfterFinallyOk2() {\n    Object source = null;\n    try {\n      mayExcept();\n      source = InferTaint.inferSecretSource();\n    } catch (Exception e) {\n      source = InferTaint.inferSecretSource();\n    } finally {\n      source = null;\n    }\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  public static void callSinkThenThrow(Object param) throws Exception {\n    InferTaint.inferSensitiveSink(param);\n    throw new Exception();\n  }\n\n  public static void callSinkThenThrowBad() throws Exception {\n    callSinkThenThrow(InferTaint.inferSecretSource());\n  }\n\n  public static void doThrow(Object param) throws RuntimeException {\n    throw new RuntimeException(param.toString());\n  }\n\n  // FN because object initialization of the exception thrown in doThrow(), which is\n  // [java.lang.RuntimeException.<init>], is treated as an unknown function. The unknown function\n  // heuristic is defeated by this form of call. We should revisit the unknown function heuristic to\n  // be more like the taint unknown function heuristic and detect assignment via the first argument,\n  // or just model [<init>] unknown functions separately\n  public static void FN_callSinkWithSourceInsideExceptionObjectBad() {\n    try {\n      doThrow(InferTaint.inferSecretSource());\n    } catch (RuntimeException e) {\n      InferTaint.inferSensitiveSink(e);\n    }\n  }\n}\n"
    },
    {
      "testname": "ExternalSpecs.java",
      "testlanguage": "java",
      "expected-problems": 68,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.util.Log;\n\n/** Testing that sources and sinks specified in external JSON work correctly */\npublic class ExternalSpecs {\n\n  // we specify this as a source with kind PrivateData in .inferconfig\n  private static Object privateDataSource() {\n    return new Object();\n  }\n\n  public static void logExternalSourceBad() {\n    Log.e(\"\", (String) privateDataSource());\n  }\n\n  // we specified that this is a private data source, so passing it an intent sink like\n  // startActivity() is fine\n  public static void externalSourceAsIntentOk(Activity activity) {\n    activity.startActivity((Intent) privateDataSource());\n  }\n\n  // we specify that index 1 is an external sink with type Logging in .inferconfig\n  public static void loggingSink1(Object notASink, Object sink) {}\n\n  public static void callExternalSinkBad() {\n    loggingSink1(null, privateDataSource());\n  }\n\n  // passing to non-tainted param\n  public static void callExternalSinkOk1() {\n    loggingSink1(privateDataSource(), null);\n  }\n\n  // passing intent source to logging sink is fine\n  public static void callExternalSinkOk2(Activity activity) {\n    loggingSink1(null, activity.getIntent());\n  }\n\n  // we specify that all the indices are tainted with type Logging in .inferconfig\n  public static void loggingSink2(Object sink1, Object sink2) {}\n\n  public static void callExternalSink2Bad1() {\n    loggingSink2(privateDataSource(), null);\n  }\n\n  public static void callExternalSink2Bad2() {\n    loggingSink2(null, privateDataSource());\n  }\n\n  // passing intent sources to logging sink is fine\n  public static void callExternalSink2Ok(Activity activity) {\n    loggingSink2(activity.getIntent(), activity.getIntent());\n  }\n\n  static Object sanitizer(Object o) {\n    return o;\n  }\n\n  void viaSanitizerOk() {\n    Object source = InferTaint.inferSecretSource();\n    Object sanitized = sanitizer(source);\n    InferTaint.inferSensitiveSink(sanitized);\n  }\n\n  void sanitizeFootprint(Object o) {\n    Object sanitized = sanitizer(o);\n    InferTaint.inferSensitiveSink(sanitized);\n  }\n\n  void callSanitizeFootprintOk() {\n    sanitizeFootprint(InferTaint.inferSecretSource());\n  }\n\n  Object returnSanitizedSource() {\n    Object source = InferTaint.inferSecretSource();\n    return sanitizer(source);\n  }\n\n  void callSinkOnSanitizedSourceOk() {\n    InferTaint.inferSensitiveSink(returnSanitizedSource());\n  }\n\n  Object aliasSanitizerOk() {\n    Object source = InferTaint.inferSecretSource();\n    Object sanitized = sanitizer(source);\n    InferTaint.inferSensitiveSink(source);\n    return sanitized;\n  }\n\n  void sanitizeOneBranchBad(boolean b) {\n    Object source = InferTaint.inferSecretSource();\n    Object o;\n    if (b) {\n      o = sanitizer(source);\n    } else {\n      o = source;\n    }\n    InferTaint.inferSensitiveSink(o);\n  }\n\n  Object sanitizeOneBranchInCallee(Object o, boolean b) {\n    if (b) {\n      return sanitizer(o);\n    } else {\n      return o;\n    }\n  }\n\n  void sanitizerWeakUpdateBad(boolean b) {\n    Object source = InferTaint.inferSecretSource();\n    Object o = sanitizeOneBranchInCallee(source, b);\n    InferTaint.inferSensitiveSink(o);\n  }\n\n  // if theres' a procedure with the same name defined in .inferconfig as a sink on parameter 1,\n  // we shouldn't crash\n  public static void loggingSink1() {}\n\n  // we shouldn't fail when calling this either\n  public static void loggingSink1(Object notASink) {}\n\n  void callLoggingSink1sOk(Object o) {\n    loggingSink1();\n    loggingSink1(o);\n  }\n\n  public static Object sinkThatPropagates(Object o) {\n    return o;\n  }\n\n  void callSinkThatPropagatesBad() {\n    Object source = privateDataSource();\n    Object sourceAgain = sinkThatPropagates(source); // should report\n    loggingSink1(null, sourceAgain); // should report here too\n  }\n\n\n  // the source is sanitized *after* the sink, which is bad\n  Object sinkAndThenSanitizer(Object source) {\n    InferTaint.inferSensitiveSink(source);\n    return sanitizer(source);\n  }\n\n  // we do not check the order in which sink and sanitizer have been\n  // encountered in the same procedure\n  Object FN_callSinkAndThenSanitizerBad() {\n    return sinkAndThenSanitizer(InferTaint.inferSecretSource());\n  }\n}\n\ninterface InterfaceSpec {\n\n  // marked as source in .inferconfig\n  public Object source();\n\n  // marked as sink in .inferconfig\n  public void sink(Object o);\n}\n\nclass InterfaceSpecImpl implements InterfaceSpec {\n\n  @Override\n  public Object source() {\n    return new Object();\n  }\n\n  @Override\n  public void sink(Object o) {}\n\n  public void externalSpecBad() {\n    sink(source());\n  }\n}\n\nclass ConstructorSink {\n\n  // specified as a source in .inferconfig\n  public ConstructorSink(Object o) {}\n\n  public static ConstructorSink constructorSinkBad() {\n    Object source = InferTaint.inferSecretSource();\n    return new ConstructorSink(source);\n  }\n}\n"
    },
    {
      "testname": "Fields.java",
      "testlanguage": "java",
      "expected-problems": 29,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class Fields {\n\n  static class Obj {\n    Object f;\n    Obj g;\n  }\n\n  Object mFld;\n  static Object sFld;\n\n  static Object sourceField;\n  static Object sinkField;\n  static Object regularField;\n\n  /** should report on these tests */\n  void instanceFieldBad() {\n    this.mFld = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(this.mFld);\n  }\n\n  void staticFieldBad() {\n    sFld = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(sFld);\n  }\n\n  void viaFieldBad1(Obj obj) {\n    obj.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.f);\n  }\n\n  void viaFieldBad2() {\n    Obj obj = new Obj();\n    obj.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.f);\n  }\n\n  void viaFieldBad3() {\n    Obj obj = new Obj();\n    obj.f = InferTaint.inferSecretSource();\n    Object src = obj.f;\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void viaNestedFieldBad1(Obj obj) {\n    obj.g.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.g.f);\n  }\n\n  void viaNestedFieldBad2() {\n    Obj obj = new Obj();\n    obj.g = new Obj();\n    obj.g.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.g.f);\n  }\n\n  /** should not report on these tests */\n  void viaFieldOk() {\n    Obj obj = new Obj();\n    obj.f = InferTaint.inferSecretSource();\n    obj.g = new Obj();\n    InferTaint.inferSensitiveSink(obj.g);\n  }\n\n  void viaFieldStrongUpdateOk() {\n    Obj obj = new Obj();\n    obj.f = InferTaint.inferSecretSource();\n    obj.f = null;\n    InferTaint.inferSensitiveSink(obj.f);\n  }\n\n  void viaNestedFieldOK1(Obj obj) {\n    obj.g.f = InferTaint.inferSecretSource();\n    obj.g.f = null;\n    InferTaint.inferSensitiveSink(obj.g.f);\n  }\n\n  void viaNestedFieldOK2() {\n    Obj obj = new Obj();\n    obj.g = new Obj();\n    obj.g.f = InferTaint.inferSecretSource();\n    obj.g.f = null;\n    InferTaint.inferSensitiveSink(obj.g.f);\n  }\n\n  void aliasBad1() {\n    Obj obj1 = new Obj();\n    Obj obj2 = obj1;\n    obj2.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj1.f);\n  }\n\n  void aliasBad2(Obj obj) {\n    Obj x = obj.g;\n    x.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(obj.g.f);\n  }\n\n  void loopFieldTwoIterationsBad(Obj obj, int i) {\n    Obj loopObj = obj;\n    while (i < 10) {\n      loopObj.f = InferTaint.inferSecretSource();\n      loopObj = loopObj.g;\n      i++;\n    }\n    InferTaint.inferSensitiveSink(obj.g.f);\n  }\n\n  void FN_loopFieldFiveIterationsBad(Obj obj, int i) {\n    Obj loopObj = obj;\n    while (i < 10) {\n      loopObj.f = InferTaint.inferSecretSource();\n      loopObj = loopObj.g;\n      i++;\n    }\n    InferTaint.inferSensitiveSink(obj.g.g.g.g.f);\n  }\n\n  void fieldAsSourceOk() {\n    InferTaint.inferSensitiveSink(regularField);\n  }\n\n  void fieldAsSinkOk() {\n    Object source = InferTaint.inferSecretSource();\n    regularField = source;\n  }\n\n  void fieldAsSourceBad() {\n    InferTaint.inferSensitiveSink(sourceField);\n  }\n\n  void fieldAsSinkBad() {\n    Object source = InferTaint.inferSecretSource();\n    sinkField = source;\n  }\n}\n"
    },
    {
      "testname": "Files.java",
      "testlanguage": "java",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.io.File;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class Files {\n\n  public File fileConstructorSinkBad() {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    return new File(taintedString);\n  }\n\n  public Path fileSystemConstructorSinkBad1() {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    return FileSystems.getDefault().getPath(taintedString);\n  }\n\n  public Path fileSystemConstructorSinkBad2() {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    return FileSystems.getDefault().getPath(\"\", taintedString);\n  }\n\n  public Path pathsSinkBad1() {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    return Paths.get(taintedString);\n  }\n\n  public Path pathsSinkBad2() {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    return Paths.get(\"\", taintedString);\n  }\n}\n"
    },
    {
      "testname": "FlowSensitivity.java",
      "testlanguage": "java",
      "expected-problems": 23,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/** making sure the traces we report respect control-flow */\nclass FlowSensitivity {\n\n  static class Obj {\n    Object f;\n  }\n\n  static void callSink(Obj o) {\n    InferTaint.inferSensitiveSink(o.f);\n  }\n\n  static void returnSource(Obj o) {\n    o.f = InferTaint.inferSecretSource();\n  }\n\n  static void interproceduralFlowSensitivityOk1(Obj o) {\n    InferTaint.inferSensitiveSink(o.f);\n    returnSource(o);\n  }\n\n  static void interproceduralFlowSensitivityOk2(Obj o) {\n    callSink(o);\n    o.f = InferTaint.inferSecretSource();\n  }\n\n  static void interproceduralFlowSensitivityOk3(Obj o) {\n    callSink(o);\n    returnSource(o);\n  }\n\n  static void interproceduralFlowSensitivityBad(Obj o) {\n    returnSource(o);\n    callSink(o);\n  }\n\n  static void sourceAndSink(Obj o) {\n    InferTaint.inferSensitiveSink(o.f);\n    o.f = InferTaint.inferSecretSource();\n  }\n\n  static void callSourceAndSinkOk(Obj o) {\n    sourceAndSink(o);\n  }\n\n  static void callSourceAndSinkBad1(Obj o) {\n    sourceAndSink(o);\n    InferTaint.inferSensitiveSink(o.f);\n  }\n\n  static void callSourceAndSinkBad2(Obj o) {\n    o.f = InferTaint.inferSecretSource();\n    sourceAndSink(o);\n  }\n}\n"
    },
    {
      "testname": "InferBaseSource.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/**\n * To test taint config based a class name and method return type. In that case only methods\n * returning `String` are considered as sources.\n */\npublic class InferBaseSource {\n\n  public String inferBaseSecretSource() {\n    return \"secret\";\n  }\n\n  public Object inferBaseNotSource() {\n    return new Object();\n  }\n}\n"
    },
    {
      "testname": "InferChildSource.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/**\n * To test taint config based a class name and method return type. In that case only methods\n * returning `String` are considered as sources.\n */\npublic class InferChildSource extends InferBaseSource {\n\n  public String inferChildSecretSource() {\n    return \"secret\";\n  }\n\n  public Object inferChildNotSource() {\n    return new Object();\n  }\n}\n"
    },
    {
      "testname": "InferTaint.java",
      "testlanguage": "java",
      "expected-problems": 34,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/**\n * WARNING! These methods are for testing the taint analysis only! Don't use them in models or in\n * real code.\n */\npublic class InferTaint {\n\n  public static Object object_undefined() {\n    return new Object();\n  }\n\n  // these are to test whether we can add a taint spec to methods that have an implementation\n  public static Object inferSecretSource() {\n    Object o = object_undefined();\n    return o;\n  }\n\n  public static String inferSecretStringSource() {\n    return \"secret\";\n  }\n\n  public static void inferSensitiveSink(Object iMightBeTainted) {}\n\n  public static Object inferUniversalSanitizer(Object iMightBeTainted) {\n    return iMightBeTainted;\n  }\n\n  // these are to test whether we can add a taint spec to undefined methods\n  public static native Object inferSecretSourceUndefined();\n\n  public static native void inferSensitiveSinkUndefined(Object iMightBeTainted);\n\n  // these are to test that only calls of functions with the same names from InferTaintSinks are\n  // recognized as sinks based on class_name_regex config\n  public static void sink1(Object iMightBeTainted) {}\n\n  public static void sink2(Object iMightBeTainted) {}\n\n  public static void addCallback(Callback callback) {}\n\n  // these are to test class name + method name regexes matcher combination\n  public static void regexSink(Object iMightBeTainted) {}\n\n  public static void notRegexSink(Object iMightBeTainted) {}\n}\n"
    },
    {
      "testname": "InferTaintSinks.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse.sinks;\n\n/**\n * WARNING! These methods are for testing the taint analysis only! Don't use them in models or in\n * real code.\n */\npublic class InferTaintSinks {\n\n  public static void sink1(Object iMightBeTainted) {}\n\n  public static void sink2(Object iMightBeTainted) {}\n}\n"
    },
    {
      "testname": "InferTaintSources.java",
      "testlanguage": "java",
      "expected-problems": 24,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/**\n * WARNING! These methods are for testing the taint analysis only! Don't use them in models or in\n * real code.\n */\npublic class InferTaintSources {\n\n  @SensitiveSourceMarker\n  static class Sources {\n\n    static Object source1() {\n      return new Object();\n    }\n\n    static Object source2() {\n      return new Object();\n    }\n  }\n\n  static class NotSources {\n\n    static Object notSource() {\n      return new Object();\n    }\n\n    static Object sourceButNotReally() {\n      return new Object();\n    }\n  }\n\n  static class RegexSources {\n\n    static Object source1() {\n      return new Object();\n    }\n\n    static Object source2() {\n      return new Object();\n    }\n\n    static Object notSource() {\n      return new Object();\n    }\n  }\n\n  @SensitiveSourceMarker2\n  static class RegexAndAnnotationSources {\n\n    static Object source1() {\n      return new Object();\n    }\n\n    static Object source2() {\n      return new Object();\n    }\n\n    static Object notSource() {\n      return new Object();\n    }\n  }\n\n  static class RegexAndAnnotationNotSources {\n\n    static Object sourceButNotReally() {\n      return new Object();\n    }\n\n    static Object notSource() {\n      return new Object();\n    }\n  }\n}\n"
    },
    {
      "testname": "Intents.java",
      "testlanguage": "java",
      "expected-problems": 55,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.app.Activity;\nimport android.app.Service;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentSender.SendIntentException;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport java.util.List;\nimport org.xmlpull.v1.XmlPullParserException;\n\nclass IntentSubclass extends Intent {}\n\nabstract class ContextSubclass extends Context {}\n\nclass MyActivity extends Activity {\n\n  @Override\n  // intent is modeled as tainted\n  public void onActivityResult(int requestCode, int resultCode, Intent intent) {\n    startService(intent);\n  }\n\n  @Override\n  // intent is modeled as tainted\n  public void onNewIntent(Intent intent) {\n    startService(intent);\n  }\n\n  private BroadcastReceiver mReceiver;\n  private Uri mUri;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState) {\n    mReceiver =\n        new BroadcastReceiver() {\n          @Override\n          // intent is modeled as tainted\n          public void onReceive(Context context, Intent intent) {\n            mUri = intent.getData();\n          }\n        };\n    registerReceiver(mReceiver, null);\n  }\n\n  @Override\n  public void onResume() {\n    startServiceWithTaintedIntent();\n  }\n\n  void startServiceWithTaintedIntent() {\n    Intent taintedIntent = new Intent(\"\", mUri);\n    startService(taintedIntent);\n  }\n}\n\nclass MyBroadcastReceiver extends BroadcastReceiver {\n\n  Activity mActivity;\n\n  @Override\n  // intent is modeled as tainted\n  public void onReceive(Context context, Intent intent) {\n    mActivity.startService(intent);\n  }\n}\n\nclass MyService extends Service {\n\n  Activity mActivity;\n\n  @Override\n  // intent is modeled as tainted\n  public IBinder onBind(Intent intent) {\n    mActivity.startService(intent);\n    return null;\n  }\n\n  @Override\n  // intent is modeled as tainted\n  public void onRebind(Intent intent) {\n    mActivity.startService(intent);\n  }\n\n  @Override\n  // intent is modeled as tainted\n  public void onStart(Intent intent, int startId) {\n    mActivity.startService(intent);\n  }\n\n  @Override\n  // intent is modeled as tainted\n  public int onStartCommand(Intent intent, int flags, int startId) {\n    mActivity.startService(intent);\n    return 0;\n  }\n\n  @Override\n  // intent is modeled as tainted\n  public void onTaskRemoved(Intent intent) {\n    mActivity.startService(intent);\n  }\n\n  @Override\n  // intent is modeled as tainted\n  public boolean onUnbind(Intent intent) {\n    mActivity.startService(intent);\n    return false;\n  }\n}\n\npublic class Intents {\n\n  private native int rand();\n\n  public void callAllActivitySinksBad(Activity activity)\n      throws SendIntentException, IOException, URISyntaxException, XmlPullParserException {\n    Uri taintedUri = (Uri) InferTaint.inferSecretSource();\n    Intent intent = new Intent(\"\", taintedUri);\n\n    // 20 sinks, 20 expected reports\n    activity.bindService(intent, null, 0);\n    activity.sendBroadcast(intent);\n    activity.sendBroadcastAsUser(intent, null);\n    activity.sendOrderedBroadcast(intent, null);\n    activity.sendOrderedBroadcastAsUser(intent, null, null, null, null, 0, null, null);\n    activity.sendStickyBroadcast(intent);\n    activity.sendStickyBroadcastAsUser(intent, null);\n    activity.sendStickyOrderedBroadcast(intent, null, null, 0, null, null);\n    activity.sendStickyOrderedBroadcastAsUser(intent, null, null, null, 0, null, null);\n    activity.startActivities(new Intent[] {intent});\n    activity.startActivity(intent);\n    activity.startActivityForResult(intent, 0);\n    activity.startActivityIfNeeded(intent, 0);\n    activity.startActivityFromChild(null, intent, 0);\n    activity.startActivityFromFragment(null, intent, 0);\n    activity.startIntentSender(null, intent, 0, 0, 0);\n    activity.startIntentSenderForResult(null, 0, intent, 0, 0, 0);\n    activity.startIntentSenderFromChild(null, null, 0, intent, 0, 0, 0);\n    activity.startService(intent);\n    activity.stopService(intent);\n  }\n\n  public void callAllIntentSinks() throws IOException, URISyntaxException, XmlPullParserException {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    Intent.parseUri(taintedString, 0);\n    Intent.getIntent(taintedString);\n    Intent.getIntentOld(taintedString);\n\n    Uri taintedUri = (Uri) InferTaint.inferSecretSource();\n    Intent i = new Intent();\n    i.setClassName(taintedString, \"\");\n    i.setData(taintedUri);\n    i.setDataAndNormalize(taintedUri);\n    i.setDataAndType(taintedUri, \"\");\n    i.setDataAndTypeAndNormalize(taintedUri, \"\");\n    i.setPackage(taintedString); // 9 sinks, 9 expected reports\n  }\n\n  // make sure the rules apply to subclasses of Intent and Context too\n  void subclassCallBad(IntentSubclass intent, ContextSubclass context) {\n    String taintedString = (String) InferTaint.inferSecretSource();\n    intent.setAction(taintedString);\n    context.startActivity(intent);\n  }\n\n  void reuseIntentBad(Activity activity) {\n    activity.startActivity(activity.getIntent());\n  }\n\n  Activity mActivity;\n\n  void extraToDataBad() {\n    Intent taintedIntent = (Intent) InferTaint.inferSecretSource();\n    String extra = taintedIntent.getStringExtra(\"foo\");\n\n    Intent newIntent1 = new Intent();\n    newIntent1.setData(Uri.parse(extra)); // should report\n    Intent newIntent2 = new Intent();\n    newIntent2.setData(Uri.parse(extra)); // should report\n  }\n\n  void extraToExtraBad() {\n    Intent taintedIntent = (Intent) InferTaint.inferSecretSource();\n    String extra = taintedIntent.getStringExtra(\"foo\");\n\n    Intent newIntent = new Intent();\n    newIntent.putExtra(\"foo\", extra);\n    mActivity.startActivity(newIntent);\n  }\n\n  List<Intent> mIntents;\n\n  Context mContext;\n\n  void callStartWithArrayOk() {\n    Intent[] intents = mIntents.toArray(new Intent[mIntents.size()]);\n    intents[0] = new Intent(intents[0]).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    if (startWithArrayOk(mContext, intents)) {\n      mContext.startActivity(intents[1]);\n    }\n  }\n\n  boolean startWithArrayOk(Context context, Intent[] newIntents) {\n    context.startActivities(newIntents, null);\n    return true;\n  }\n\n  void startWithClassLiteralOk() {\n    mActivity.startActivity(new Intent(mActivity, MyActivity.class));\n  }\n\n  void startWithUri1Bad(Uri uri) {\n    mActivity.startActivity(new Intent(\"action\", uri));\n  }\n\n  void startWithUri2Bad(Uri uri) {\n    mActivity.startActivity(new Intent(\"action\", uri, mActivity, MyActivity.class));\n  }\n}\n"
    },
    {
      "testname": "Interprocedural.java",
      "testlanguage": "java",
      "expected-problems": 184,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass Interprocedural {\n\n  Object f;\n\n  static Object sGlobal;\n\n  static class Obj {\n    Object f;\n  }\n\n  public static Object id(Object param) {\n    return param;\n  }\n\n  /** source tests */\n  public static Object returnSourceDirect() {\n    return InferTaint.inferSecretSource();\n  }\n\n  public static Object returnSourceIndirect() {\n    return returnSourceDirect();\n  }\n\n  public static void returnSourceDirectBad() {\n    InferTaint.inferSensitiveSink(returnSourceDirect());\n  }\n\n  public static void returnSourceDirectViaVarBad() {\n    Object source = returnSourceDirect();\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  public static void returnSourceIndirectBad() {\n    InferTaint.inferSensitiveSink(returnSourceIndirect());\n  }\n\n  public static Obj returnSourceViaField() {\n    Obj o = new Obj();\n    o.f = InferTaint.inferSecretSource();\n    return o;\n  }\n\n  public static void returnSourceViaFieldBad() {\n    InferTaint.inferSensitiveSink(returnSourceViaField().f);\n  }\n\n  public static void returnSourceViaParameter1(Obj o) {\n    o.f = InferTaint.inferSecretSource();\n  }\n\n  public static void returnSourceViaParameter1Bad(Obj o) {\n    returnSourceViaParameter1(o);\n    InferTaint.inferSensitiveSink(o.f);\n  }\n\n  public static void returnSourceViaParameter2(Obj o1, Obj o2) {\n    o2.f = o1.f;\n  }\n\n  public static void returnSourceViaParameter2Bad(Obj o1, Obj o2) {\n    o1.f = InferTaint.inferSecretSource();\n    returnSourceViaParameter2(o1, o2);\n    InferTaint.inferSensitiveSink(o2.f);\n  }\n\n  public static void returnSourceViaParameterOk(Obj o1, Obj o2) {\n    o1.f = InferTaint.inferSecretSource();\n    returnSourceViaParameter2(o2, o1);\n    InferTaint.inferSensitiveSink(o2.f);\n  }\n\n  public static void returnSourceViaGlobal() {\n    sGlobal = InferTaint.inferSecretSource();\n  }\n\n  public void returnSourceViaGlobalBad() {\n    returnSourceViaGlobal();\n    InferTaint.inferSensitiveSink(sGlobal);\n  }\n\n  public void returnSourceViaGlobalOk() {\n    returnSourceViaGlobal();\n    sGlobal = null;\n    InferTaint.inferSensitiveSink(sGlobal);\n  }\n\n  /** sink tests */\n  public static void callSinkParam1(Object param1, Object param2) {\n    InferTaint.inferSensitiveSink(param1);\n  }\n\n  public static void callSinkParam1Bad() {\n    callSinkParam1(InferTaint.inferSecretSource(), null);\n  }\n\n  public static void callSinkParam1Ok() {\n    callSinkParam1(null, InferTaint.inferSecretSource());\n  }\n\n  public static void callSinkParam2(Object param1, Object param2) {\n    InferTaint.inferSensitiveSink(param2);\n  }\n\n  public static void callSinkParam2Bad() {\n    callSinkParam2(null, InferTaint.inferSecretSource());\n  }\n\n  public static void callSinkParam2Ok() {\n    callSinkParam2(InferTaint.inferSecretSource(), null);\n  }\n\n  public void callSinkOnFieldDirect() {\n    InferTaint.inferSensitiveSink(this.f);\n  }\n\n  public void callSinkOnFieldDirectBad() {\n    this.f = InferTaint.inferSecretSource();\n    callSinkOnFieldDirect();\n  }\n\n  public static void callSinkOnFieldIndirect(Obj param) {\n    InferTaint.inferSensitiveSink(param.f);\n  }\n\n  public static void callSinkOnFieldIndirectBad() {\n    Obj obj = new Obj();\n    obj.f = InferTaint.inferSecretSource();\n    callSinkOnFieldIndirect(obj);\n  }\n\n  public Object getF() {\n    return f;\n  }\n\n  void callSinkOnLocal() {\n    Object local = this.getF();\n    InferTaint.inferSensitiveSink(local);\n  }\n\n  void callSinkOnLocalBad() {\n    this.f = InferTaint.inferSecretSource();\n    callSinkOnLocal();\n  }\n\n  public static void callSinkOnGlobal() {\n    InferTaint.inferSensitiveSink(sGlobal);\n  }\n\n  public static void callSinkOnGlobalBad() {\n    sGlobal = InferTaint.inferSecretSource();\n    callSinkOnGlobal();\n  }\n\n  public static void callSinkOnGlobalOk() {\n    sGlobal = InferTaint.inferSecretSource();\n    sGlobal = null;\n    callSinkOnGlobal();\n  }\n\n  public static void setGlobal(Object o) {\n    sGlobal = o;\n  }\n\n  public static void setGlobalThenCallSinkBad() {\n    setGlobal(InferTaint.inferSecretSource());\n    callSinkOnGlobal();\n  }\n\n  public static Object getGlobal() {\n    return sGlobal;\n  }\n\n  public static void getGlobalThenCallSink() {\n    Object local = getGlobal();\n    InferTaint.inferSensitiveSink(sGlobal);\n  }\n\n  public static void getGlobalThenCallSinkBad() {\n    sGlobal = InferTaint.inferSecretSource();\n    getGlobalThenCallSink();\n  }\n\n  // this should report two alarms, not three\n  public void callSinkNoTripleReportBad() {\n    Object source = InferTaint.inferSecretSource();\n    callSinkParam1(source, null);\n    callSinkParam2(null, source);\n  }\n\n  /** passthrough tests */\n  public static void singlePassthroughBad() {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource = id(source);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  public static void doublePassthroughBad() {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource1 = id(source);\n    Object launderedSource2 = id(launderedSource1);\n    InferTaint.inferSensitiveSink(launderedSource2);\n  }\n\n  /** false positives: an ideal analysis would not report these, but we will */\n  public static Object returnSourceConditional(boolean b) {\n    if (b) return InferTaint.inferSecretSource();\n    return null;\n  }\n\n  public static void trackParamsOk() {\n    InferTaint.inferSensitiveSink(returnSourceConditional(false));\n  }\n\n  public static void reassignInCallee(Obj o) {\n    o.f = null;\n  }\n\n  public static void reassignInCallee() {\n    Obj o = new Obj();\n    o.f = InferTaint.inferSecretSource();\n    reassignInCallee(o);\n    InferTaint.inferSensitiveSink(o.f);\n  }\n\n  static Object relevantPassthrough(Object param) {\n    return param;\n  }\n\n  static Object irrelevantPassthrough(Object param) {\n    return param;\n  }\n\n  // the following tests should show only \"relevantPassthrough\" in their traces\n  public static Object irrelevantPassthroughsIntraprocedural(Object param) {\n    Object irrelevant = irrelevantPassthrough(param);\n    Object source = InferTaint.inferSecretSource();\n    Object relevant = relevantPassthrough(source);\n    InferTaint.inferSensitiveSink(relevant);\n    return irrelevantPassthrough(relevant);\n  }\n\n  public static Object returnSourceIrrelevantPassthrough(Object param) {\n    Object irrelevant = irrelevantPassthrough(param);\n    Object source = InferTaint.inferSecretSource();\n    return relevantPassthrough(source);\n  }\n\n  public static Object irrelevantPassthroughsSourceInterprocedural(Object o) {\n    Object irrelevant = irrelevantPassthrough(o);\n    Object source = returnSourceIrrelevantPassthrough(irrelevant);\n    Object relevant = relevantPassthrough(source);\n    InferTaint.inferSensitiveSink(relevant);\n    return irrelevantPassthrough(source);\n  }\n\n  public static Object callSinkIrrelevantPassthrough(Object param) {\n    Object relevant = relevantPassthrough(param);\n    InferTaint.inferSensitiveSink(relevant);\n    Object irrelevant = irrelevantPassthrough(param);\n    return irrelevant;\n  }\n\n  public static Object irrelevantPassthroughsSinkInterprocedural(Object o) {\n    Object source = InferTaint.inferSecretSource();\n    Object relevant = relevantPassthrough(source);\n    callSinkIrrelevantPassthrough(relevant);\n    return irrelevantPassthrough(relevant);\n  }\n\n  public static Object irrelevantPassthroughsSourceAndSinkInterprocedural(Object o) {\n    Object irrelevant = irrelevantPassthrough(o);\n    Object source = returnSourceIrrelevantPassthrough(irrelevant);\n    Object relevant = relevantPassthrough(source);\n    callSinkIrrelevantPassthrough(relevant);\n    return irrelevantPassthrough(relevant);\n  }\n\n  public static void callSinkVariadic(Object... params) {\n    InferTaint.inferSensitiveSink(params);\n  }\n\n  public static void callSinkVariadicBad() {\n    callSinkVariadic(null, null, InferTaint.inferSecretSource());\n  }\n\n  void diverge() {\n    for (; ; ) ;\n  }\n\n  public void divergenceInCallee() {\n    Object source = InferTaint.inferSecretSource();\n    diverge();\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  public static void callSinkThenDiverge(Object param) {\n    InferTaint.inferSensitiveSink(param);\n    for (; ; ) ;\n  }\n\n  public void FN_callSinkThenDivergeBad() {\n    callSinkThenDiverge(InferTaint.inferSecretSource());\n  }\n\n  public void callSinkOnParam(Object o) {\n    InferTaint.inferSensitiveSink(o);\n  }\n\n  public void callSinkIndirectOnParam(Object o) {\n    callSinkOnParam(o);\n  }\n\n  Obj propagate(Object param) {\n    Obj o = new Obj();\n    o.f = param;\n    return o;\n  }\n\n  static Obj id2(Obj o) {\n    return o;\n  }\n\n  void callSinkA(Obj o) {\n    callSink1(o);\n  }\n\n  void callSinkB(Obj o) {\n    callSink2(o);\n  }\n\n  void callSinkC(Obj o) {\n    callSink3(o);\n  }\n\n  void callSinkD(Obj o) {\n    callSink4(o);\n  }\n\n  void callSink1(Obj o) {\n    InferTaint.inferSensitiveSink(id(o));\n  }\n\n  void callSink2(Obj o) {\n    InferTaint.inferSensitiveSink(id2(o).f);\n  }\n\n  void callSink3(Obj o) {\n    InferTaint.inferSensitiveSink(id(o.f));\n  }\n\n  void callSink4(Obj o) {\n    InferTaint.inferSensitiveSink(o.f);\n  }\n\n  public void callDeepSinkIndirectBad() {\n    Object source = InferTaint.inferSecretSource();\n    callSinkIndirectOnParam(source);\n  }\n\n  // the sink is on source but source.f is tainted, not source\n  public void FN_callDeepSink1Bad() {\n    Obj source = propagate(InferTaint.inferSecretSource());\n    callSinkA(source);\n  }\n\n  public void callDeepSink2Bad() {\n    Obj source = propagate(InferTaint.inferSecretSource());\n    callSinkB(source);\n  }\n\n  void callShallowSinkBad(Obj o) {\n    o.f = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(id2(o).f);\n  }\n\n  public void callDeepSink3Bad() {\n    Obj source = propagate(InferTaint.inferSecretSource());\n    callSinkC(source);\n  }\n\n  public void callDeepSink4Bad() {\n    Obj source = propagate(InferTaint.inferSecretSource());\n    callSinkD(source);\n  }\n\n  public static void swapParams(Object o1, Object o2) {\n    o1 = o2;\n  }\n\n  public static void assignSourceToParam(Object o) {\n    o = InferTaint.inferSecretSource();\n  }\n\n  public static void swapParamsOk() {\n    Object notASource = null;\n    Object source = InferTaint.inferSecretSource();\n    swapParams(notASource, source);\n    InferTaint.inferSensitiveSink(notASource);\n  }\n\n  public static void assignSourceToParamOk() {\n    Object o = null;\n    assignSourceToParam(o);\n    InferTaint.inferSensitiveSink(o);\n  }\n}\n"
    },
    {
      "testname": "InterproceduralInterfileKind.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class InterproceduralInterfileKind {\n  public static final int PHONE = 0;\n}\n"
    },
    {
      "testname": "InterproceduralInterfileLoggerWrapper.java",
      "testlanguage": "java",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass Logger {\n  static void log(int s) {}\n}\n\npublic class InterproceduralInterfileLoggerWrapper {\n  static void log(int s) {\n    Logger.log(s);\n  }\n}\n"
    },
    {
      "testname": "InterproceduralInterfileTaint.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass InterprocedurlaInterfileTaint {\n  void taintedUserToLogBad() {\n    InterproceduralInterfileLoggerWrapper.log(\n        InterproceduralInterfileUserInfo.getUserInfo(InterproceduralInterfileKind.PHONE));\n  }\n}\n"
    },
    {
      "testname": "InterproceduralInterfileUser.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class InterproceduralInterfileUser {\n  String name;\n\n  InterproceduralInterfileUser(String name) {\n    name = name;\n  }\n\n  int getPhoneNumber() {\n    return 42;\n  }\n}\n"
    },
    {
      "testname": "InterproceduralInterfileUserInfo.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class InterproceduralInterfileUserInfo {\n  static int getUserInfo(int k) {\n    InterproceduralInterfileUser user = new InterproceduralInterfileUser(\"Martha\");\n    if (k == InterproceduralInterfileKind.PHONE) {\n      return InterproceduralInterfileUserWrapper.getPhoneNumber(user);\n    }\n    return 0;\n  }\n}\n"
    },
    {
      "testname": "InterproceduralInterfileUserWrapper.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class InterproceduralInterfileUserWrapper {\n  static Integer getPhoneNumber(InterproceduralInterfileUser user) {\n    return user.getPhoneNumber();\n  }\n}\n"
    },
    {
      "testname": "Lambdas.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.util.function.Function;\n\npublic class Lambdas {\n\n  Function<Integer, String> createFunctionWithTaintedParam() {\n    Object object = InferTaint.inferSecretSource();\n    return n -> {\n      InferTaint.inferSensitiveSink(object);\n      return String.valueOf(n);\n    };\n  }\n\n  String invokeFunction(Function<Integer, String> function) {\n    return function.apply(42);\n  }\n\n  String createAndInvokeFunctionBad() {\n    Function<Integer, String> function = createFunctionWithTaintedParam();\n    return invokeFunction(function);\n  }\n\n  String createAndInvokeFunctionBad2() {\n    Function<Integer, String> function = createFunctionWithTaintedParam();\n    return function.apply(42);\n  }\n\n  Function<Integer, String> createFunctionFromAnonymousClassWithTaintedParam() {\n    Object object = InferTaint.inferSecretSource();\n    return new Function<Integer, String>() {\n      @Override\n      public String apply(Integer n) {\n        InferTaint.inferSensitiveSink(object);\n        return String.valueOf(n);\n      }\n    };\n  }\n\n  String createAndInvokeFunctionFromAnonymousClassBad() {\n    Function<Integer, String> function = createFunctionFromAnonymousClassWithTaintedParam();\n    return invokeFunction(function);\n  }\n\n  String createAndInvokeFunctionFromAnonymousClassBad2() {\n    Function<Integer, String> function = createFunctionFromAnonymousClassWithTaintedParam();\n    return function.apply(42);\n  }\n}\n"
    },
    {
      "testname": "LoggingPrivateData.java",
      "testlanguage": "java",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.location.Location;\nimport android.telephony.TelephonyManager;\nimport android.util.Log;\n\npublic class LoggingPrivateData {\n\n  private native int rand();\n\n  public void logAllSourcesBad(Location l, TelephonyManager t) {\n    String source = null;\n    switch (rand()) {\n      case 1:\n        source = String.valueOf(l.getAltitude());\n        break;\n      case 2:\n        source = String.valueOf(l.getBearing());\n        break;\n      case 3:\n        source = String.valueOf(l.getLatitude());\n        break;\n      case 4:\n        source = String.valueOf(l.getLongitude());\n        break;\n      case 5:\n        source = String.valueOf(l.getSpeed());\n        break;\n      case 6:\n        source = t.getDeviceId();\n        break;\n      case 7:\n        source = t.getLine1Number();\n        break;\n      case 8:\n        source = t.getSimSerialNumber();\n        break;\n      case 9:\n        source = t.getSubscriberId();\n        break;\n      case 10:\n        source = t.getVoiceMailNumber();\n        break;\n    }\n\n    String TAG = \"tag\";\n    Log.e(TAG, source);\n    Log.println(0, TAG, source);\n    Log.w(TAG, source);\n    Log.wtf(TAG, source); // 10 sources * 4 sinks = 40 expected reports\n  }\n}\n"
    },
    {
      "testname": "MapExamples.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.util.Map;\n\npublic class MapExamples {\n\n  native Map<String, String> split1(Object s);\n\n  void propagateTaintOnMap1Bad_FN() {\n    Object object = InferTaint.inferSecretSource();\n    Map<String, String> map = split1(object);\n    String value = map.get(\"Whatever\");\n    InferTaint.inferSensitiveSink(value); // Taint flow not reported here\n  }\n\n  native Map<String, String[]> split2(Object s);\n\n  // doesn't work with pulse-taint-check-history flag\n  void propagateTaintOnMap2Bad_FN() {\n    Object object = InferTaint.inferSecretSource();\n    Map<String, String[]> map = split2(object);\n    String value = \"\";\n    if (!map.isEmpty()) {\n      String[] whatever = map.get(\"Whatever\");\n      if (whatever != null) value = whatever[0];\n    }\n    InferTaint.inferSensitiveSink(value);\n  }\n\n  static void wrapper(String s) {\n    InferTaint.inferSensitiveSink(s);\n  }\n\n  // doesn't work with pulse-taint-check-history flag\n  void propagateTaintOnMap3Bad_FN() {\n    Object object = InferTaint.inferSecretSource();\n    Map<String, String[]> map = split2(object);\n    String value = null;\n    if (!map.isEmpty()) {\n      String[] whatever = map.get(\"Whatever\");\n      if (whatever != null) value = whatever[0];\n    }\n    wrapper(value);\n  }\n\n  void propagateTaintOnMap4Bad_FN() {\n    Object object = InferTaint.inferSecretSource();\n    Map<String, String[]> map = split2(object);\n    String value = \"\";\n    if (!map.isEmpty()) {\n      String[] whatever = map.get(\"Whatever\");\n      if (whatever != null) value = whatever[0];\n    }\n    wrapper(value); // Taint flow not reported here\n  }\n}\n"
    },
    {
      "testname": "Recursion.java",
      "testlanguage": "java",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class Recursion {\n\n  public static void divergeOk() {\n    divergeOk();\n  }\n\n  public static void callSinkThenDiverge(Object param) {\n    InferTaint.inferSensitiveSink(param);\n    callSinkThenDiverge(param);\n  }\n\n  public static void callSinkThenDivergeBad() {\n    callSinkThenDiverge(InferTaint.inferSecretSource());\n  }\n\n  public static void safeRecursionCallSink(int i, Object param) {\n    if (i == 0) return;\n    InferTaint.inferSensitiveSink(param);\n    safeRecursionCallSink(i - 1, param);\n  }\n\n  public static void safeRecursionCallSinkBad() {\n    safeRecursionCallSink(5, InferTaint.inferSecretSource());\n  }\n\n  // TODO (#16595757): Requires support for recursion in Ondemand\n  public static void FN_recursionBad(int i, Object param) {\n    if (i == 0) return;\n    InferTaint.inferSensitiveSink(param);\n    FN_recursionBad(i - 1, InferTaint.inferSecretSource());\n  }\n}\n"
    },
    {
      "testname": "SanitizerMarker.java",
      "testlanguage": "java",
      "expected-problems": 0,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n@interface SanitizerMarker {}\n"
    },
    {
      "testname": "SensitiveSinkMarker.java",
      "testlanguage": "java",
      "expected-problems": 0,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n@interface SensitiveSinkMarker {}\n"
    },
    {
      "testname": "SensitiveSourceMarker.java",
      "testlanguage": "java",
      "expected-problems": 0,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n@interface SensitiveSourceMarker {}\n"
    },
    {
      "testname": "SensitiveSourceMarker2.java",
      "testlanguage": "java",
      "expected-problems": 0,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n@interface SensitiveSourceMarker2 {}\n"
    },
    {
      "testname": "SensitiveSourceMarkerType.java",
      "testlanguage": "java",
      "expected-problems": 1,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic enum SensitiveSourceMarkerType {\n  LOCATION,\n  EMAIL,\n  OTHER\n}\n"
    },
    {
      "testname": "SensitiveSourceMarkerWithValue.java",
      "testlanguage": "java",
      "expected-problems": 0,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n@interface SensitiveSourceMarkerWithValue {\n\n  SensitiveSourceMarkerType value();\n}\n"
    },
    {
      "testname": "Serialization.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\n\npublic class Serialization {\n\n  // we could warn on only particular calls to the tainted ObjectInputStream (e.g., readObject,\n  // readUnshared), but nothing good can come from creating a tainted ObjectInputStream\n  Object taintedObjectInputStreamBad() throws IOException, ClassNotFoundException {\n    Object source = InferTaint.inferSecretSource();\n    ObjectInputStream stream = new ObjectInputStream((InputStream) source); // report here\n    return stream.readObject();\n  }\n}\n"
    },
    {
      "testname": "Services.java",
      "testlanguage": "java",
      "expected-problems": 35,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nclass Services {}\n\n@Retention(RetentionPolicy.CLASS)\n@interface ThriftService {}\n\n@ThriftService\ninterface GeneratedServiceInterface {\n  public void serviceMethodBad(String s) throws IOException;\n\n  public void paramToSql1Bad(String s) throws SQLException;\n\n  public void paramToSql2Bad(String s) throws SQLException;\n\n  public void paramToSql3Bad(String s) throws SQLException;\n\n  public void paramToSql4Bad(String s) throws SQLException;\n\n  public void paramToSql5Bad(String s) throws SQLException;\n\n  void packageProtectedServiceMethodBad(String s) throws IOException;\n}\n\nclass Service1 implements GeneratedServiceInterface {\n\n  @Override\n  public void serviceMethodBad(String s) throws IOException {\n    Runtime.getRuntime().exec(s); // RCE if s is tainted, we should warn\n  }\n\n  Statement mStatement;\n\n  @Override\n  public void paramToSql1Bad(String s) throws SQLException {\n    mStatement.execute(s);\n  }\n\n  @Override\n  public void paramToSql2Bad(String s) throws SQLException {\n    mStatement.executeLargeUpdate(s);\n  }\n\n  @Override\n  public void paramToSql3Bad(String s) throws SQLException {\n    mStatement.executeQuery(s);\n  }\n\n  @Override\n  public void paramToSql4Bad(String s) throws SQLException {\n    mStatement.executeUpdate(s);\n  }\n\n  @Override\n  public void paramToSql5Bad(String s) throws SQLException {\n    mStatement.addBatch(s);\n    mStatement.executeBatch();\n  }\n\n  @Override\n  public void packageProtectedServiceMethodBad(String s) throws IOException {\n    Runtime.getRuntime().exec(s);\n  }\n\n  // doesn't override a method from the service interface; not an endpoint\n  public void publicMethodNotEndpointOk(String s) throws IOException {\n    Runtime.getRuntime().exec(s);\n  }\n\n  // same\n  protected void protectedMethodNotEndpointOk(String s) throws IOException {\n    Runtime.getRuntime().exec(s);\n  }\n\n  void packageProtectedMethodNotEndpointOk(String s) throws IOException {\n    Runtime.getRuntime().exec(s);\n  }\n\n  // same\n  private void privateMethodNotEndpointOk(String s) throws IOException {\n    Runtime.getRuntime().exec(s);\n  }\n}\n"
    },
    {
      "testname": "Streams.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Streams {\n\n  int bufferSize = 1024;\n\n  void copyBad() throws IOException {\n    InputStream tainted = (InputStream) InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(read(tainted.toString().getBytes()));\n  }\n\n  void copyBadFN() throws IOException {\n    InputStream tainted = (InputStream) InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(read(tainted));\n  }\n\n  void copyBad1FN() throws IOException {\n    InputStream tainted = (InputStream) InferTaint.inferSecretSource();\n    byte[] data = new byte[24];\n    tainted.read(data);\n    InferTaint.inferSensitiveSink(data);\n  }\n\n  void systemArrayCopyBadFN() throws IOException {\n    InputStream tainted = (InputStream) InferTaint.inferSecretSource();\n    byte[] data = read(tainted.toString().getBytes());\n    byte[] buffer = new byte[bufferSize];\n    System.arraycopy(data, 0, buffer, 0, data.length);\n    InferTaint.inferSensitiveSink(buffer);\n  }\n\n  byte[] read(InputStream is) throws IOException {\n    return read(is.toString().getBytes());\n  }\n\n  byte[] read(byte[] data) {\n    byte[] buffer = new byte[bufferSize];\n    for (int i = 0; i < data.length; ++i) {\n      buffer[i] = data[i];\n    }\n    return buffer;\n  }\n}\n"
    },
    {
      "testname": "Strings.java",
      "testlanguage": "java",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport java.util.Formatter;\n\n/**\n * a lot of tainted values are strings, so propagation through StringBuilder's and the like is very\n * important.\n */\npublic class Strings {\n\n  void viaStringBuilderSugarBad() {\n    Object source = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(source + \"\");\n  }\n\n  void viaStringBuilderBad() {\n    Object source = InferTaint.inferSecretSource();\n    StringBuilder builder = new StringBuilder();\n    InferTaint.inferSensitiveSink(builder.append(source).append(\"\").toString());\n  }\n\n  void viaStringBuilderIgnoreReturnBad() {\n    Object source = InferTaint.inferSecretSource();\n    StringBuilder builder = new StringBuilder();\n    // builder should be tainted after this call even though we ignore the return value\n    builder.append(source);\n    InferTaint.inferSensitiveSink(builder.toString());\n  }\n\n  void viaStringBufferBad() {\n    Object source = InferTaint.inferSecretSource();\n    StringBuffer buffer = new StringBuffer();\n    InferTaint.inferSensitiveSink(buffer.append(\"\").append(source).toString());\n  }\n\n  void viaStringBufferIgnoreReturnBad() {\n    Object source = InferTaint.inferSecretSource();\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(source);\n    InferTaint.inferSensitiveSink(buffer.toString());\n  }\n\n  void viaFormatterBad() {\n    Object source = InferTaint.inferSecretSource();\n    Formatter formatter = new Formatter();\n    InferTaint.inferSensitiveSink(formatter.format(\"%s\", source).toString());\n  }\n\n  void viaFormatterIgnoreReturnBad() {\n    Object source = InferTaint.inferSecretSource();\n    Formatter formatter = new Formatter();\n    formatter.format(\"%s\", source);\n    InferTaint.inferSensitiveSink(formatter.toString());\n  }\n\n  void viaStringFormatVarArgsDirectBad() {\n    Object source = InferTaint.inferSecretSource();\n    String tainted = String.format(\"%s%s\", \"hi\", source);\n    InferTaint.inferSensitiveSink(tainted);\n  }\n\n  void viaStringFormatVarArgsIndirect(Object param) {\n    String tainted = String.format(\"%s%s\", \"hi\", param);\n    InferTaint.inferSensitiveSink(tainted);\n  }\n\n  void viaStringFormatVarArgsIndirectBad() {\n    viaStringFormatVarArgsIndirect(InferTaint.inferSecretSource());\n  }\n}\n"
    },
    {
      "testname": "TaintedFormals.java",
      "testlanguage": "java",
      "expected-problems": 26,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport java.net.URISyntaxException;\n\nclass Obj {\n  Object f;\n}\n\npublic class TaintedFormals {\n\n  public Activity mActivity;\n\n  public void callSink(Object formal) {\n    InferTaint.inferSensitiveSink(formal);\n  }\n\n  // taintedFormal1 and taintedFormal2 are modeled as tainted\n  public void taintedContextBad(\n      String taintedFormal1, Intent untaintedFormal, Integer taintedFormal2) {\n    InferTaint.inferSensitiveSink(taintedFormal1); // should report here\n    InferTaint.inferSensitiveSink(taintedFormal2); // should report here\n    callSink(taintedFormal1); // should report here\n    callSink(taintedFormal2); // should report here\n\n    // using different sink to avoid confusion with the above\n    mActivity.startService(untaintedFormal); // should not report here\n  }\n\n  public Object taintedContextBad(String taintedFormal) {\n    return taintedFormal;\n  }\n\n  public void callTaintedContextBad1(String formal) {\n    Object tainted = taintedContextBad(formal);\n    InferTaint.inferSensitiveSink(tainted);\n  }\n\n  public void callTaintedContextBad2() throws URISyntaxException {\n    Intent intent = Intent.parseUri(\"\", 0);\n    taintedContextBad(null, intent, null);\n  }\n\n  public void callTaintedContextOk1() {\n    taintedContextBad(\"foo\", null, null);\n  }\n\n  // shouldn't report here, otherwise we will double report\n  public void callTaintedContextOk2() {\n    taintedContextBad(null, null, new Integer(1));\n  }\n\n  // first parameter is tainted based on the config\n  void firstParameterTainted(Object tainted, Object notTainted) {\n    // should be tainted\n    InferTaint.inferSensitiveSink(tainted);\n    // should not be tainted\n    InferTaint.inferSensitiveSink(notTainted);\n  }\n\n  void callbackAnonymousClassTaintedBad() {\n    InferTaint.addCallback(\n        new Callback() {\n          // result parameter is tainted based on the config\n          public void onCompletion(Object result) {\n            InferTaint.inferSensitiveSink(result);\n          }\n        });\n  }\n\n  void callbackLambdaTaintedBad() {\n    InferTaint.addCallback(\n        // result parameter is tainted based on the config\n        result -> {\n          InferTaint.inferSensitiveSink(result);\n        });\n  }\n\n  // first parameter of constructor is tainted\n  TaintedFormals(Object tainted) {\n    InferTaint.inferSensitiveSink(tainted);\n  }\n\n  static void staticFirstParameterTainted(Object tainted) {\n    InferTaint.inferSensitiveSink(tainted);\n  }\n\n  void instanceFirstParameterTainted(Object tainted) {\n    InferTaint.inferSensitiveSink(tainted);\n  }\n}\n"
    },
    {
      "testname": "TaintedThis.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\npublic class TaintedThis {\n  private String field = \"instanceField\";\n\n  void taintThisBad() {\n    InferTaint.inferSensitiveSink(field);\n  }\n\n  void thisIsNotTaintedOk() {\n    InferTaint.inferSensitiveSink(field);\n  }\n}\n"
    },
    {
      "testname": "TaintExample.java",
      "testlanguage": "java",
      "expected-problems": 70,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.content.ContentValues;\nimport android.content.SharedPreferences;\nimport com.facebook.infer.annotation.IntegritySink;\nimport com.facebook.infer.annotation.IntegritySource;\nimport com.facebook.infer.annotation.PrivacySink;\nimport com.facebook.infer.annotation.PrivacySource;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class TaintExample {\n\n  public InputStream socketNotVerifiedSimple_FN(SSLSocketFactory f) throws IOException {\n    Socket socket = f.createSocket();\n    return socket.getInputStream();\n  }\n\n  public InputStream socketVerifiedForgotToCheckRetval_FN(\n      SSLSocketFactory f, HostnameVerifier v, SSLSession session) throws IOException {\n\n    Socket socket = f.createSocket();\n    v.verify(\"hostname\", session);\n    return socket.getInputStream();\n  }\n\n  public InputStream socketVerifiedOk1(SSLSocketFactory f, HostnameVerifier v, SSLSession session)\n      throws IOException {\n\n    Socket socket = f.createSocket();\n    if (v.verify(\"hostname\", session)) {\n      return socket.getInputStream();\n    } else {\n      return null;\n    }\n  }\n\n  HostnameVerifier mHostnameVerifier;\n\n  public void throwExceptionIfNoVerify(SSLSocket sslSocket, String host) throws IOException {\n\n    if (!mHostnameVerifier.verify(host, sslSocket.getSession())) {\n      throw new SSLException(\"Couldn't verify!\");\n    }\n  }\n\n  public InputStream socketVerifiedOk2(SSLSocketFactory f) throws IOException {\n    SSLSocket s = (SSLSocket) f.createSocket();\n    throwExceptionIfNoVerify(s, \"hostname\");\n    return s.getInputStream();\n  }\n\n  public InputStream socketIgnoreExceptionNoVerify_FN(SSLSocketFactory f) throws IOException {\n\n    SSLSocket s = (SSLSocket) f.createSocket();\n    try {\n      throwExceptionIfNoVerify(s, \"hostname\");\n    } catch (SSLException e) {\n      // ignore the fact that verifying the socket failed\n    }\n    return s.getInputStream();\n  }\n\n  public InputStream taintingShouldNotPreventInference1_FN(SSLSocketFactory f) throws IOException {\n    socketNotVerifiedSimple_FN(f).toString();\n    // failing to infer a post for socketNotVerifiedSimple will hide this error\n    Socket s = f.createSocket();\n    return s.getInputStream();\n  }\n\n  public InputStream readInputStream(Socket socket) throws IOException {\n    return socket.getInputStream();\n  }\n\n  // if we're not careful, postcondition inference will fail for this function\n  Socket callReadInputStreamCauseTaintError_FN(SSLSocketFactory f) throws IOException {\n    Socket socket = f.createSocket();\n    InputStream s = readInputStream(socket);\n    s.toString(); // to avoid RETURN_VALUE_IGNORED warning\n    return f.createSocket();\n  }\n\n  InputStream taintingShouldNotPreventInference2(SSLSocketFactory f) throws IOException {\n    // if inference fails for this callee, we won't report an error here\n    Socket s = callReadInputStreamCauseTaintError_FN(f);\n    return s.getInputStream();\n  }\n\n  public void simpleTaintErrorWithModelMethods() {\n    Object o = InferTaint.inferSecretSource();\n    InferTaint.inferSensitiveSink(o);\n  }\n\n  public Object returnTaintedSourceModelMethods() {\n    return InferTaint.inferSecretSource();\n  }\n\n  public void callSinkMethodModelMethods(Object o) {\n    InferTaint.inferSensitiveSink(o);\n  }\n\n  public void interprocTaintErrorWithModelMethods1() {\n    InferTaint.inferSensitiveSink(returnTaintedSourceModelMethods());\n  }\n\n  public void interprocTaintErrorWithModelMethods2() {\n    callSinkMethodModelMethods(InferTaint.inferSecretSource());\n  }\n\n  public void interprocTaintErrorWithModelMethods3() {\n    callSinkMethodModelMethods(returnTaintedSourceModelMethods());\n  }\n\n  public void simpleTaintErrorWithModelMethodsUndefined() {\n    Object o = InferTaint.inferSecretSourceUndefined();\n    InferTaint.inferSensitiveSinkUndefined(o);\n  }\n\n  public Object returnTaintedSourceModelMethodsUndefined() {\n    return InferTaint.inferSecretSourceUndefined();\n  }\n\n  public void callSinkMethodModelMethodsUndefined(Object o) {\n    InferTaint.inferSensitiveSinkUndefined(o);\n  }\n\n  public void interprocTaintErrorWithModelMethodsUndefined1() {\n    InferTaint.inferSensitiveSinkUndefined(returnTaintedSourceModelMethodsUndefined());\n  }\n\n  public void interprocTaintErrorWithModelMethodsUndefined2() {\n    callSinkMethodModelMethodsUndefined(InferTaint.inferSecretSourceUndefined());\n  }\n\n  public void interprocTaintErrorWithModelMethodsUndefined3() {\n    callSinkMethodModelMethodsUndefined(returnTaintedSourceModelMethodsUndefined());\n  }\n\n  public void contentValuesPutWithTaintedString_FN(\n      ContentValues values, SharedPreferences prefs, String key, String value) {\n    values.put(key, prefs.getString(key, value));\n  }\n\n  public void contentValuesPutOk(ContentValues values, String key, String value) {\n    values.put(key, value);\n  }\n\n  @PrivacySource\n  public String privacySource() {\n    return \"source\";\n  }\n\n  public void testPrivacySourceAnnot_FN() {\n    InferTaint.inferSensitiveSinkUndefined(privacySource()); // should report\n  }\n\n  public void instancePrivacySink(@PrivacySink String s1, String s2) {}\n\n  public static void staticPrivacySink(@PrivacySink String s1, String s2) {}\n\n  public void testPrivacySinkAnnot1_FN() {\n    String source = privacySource();\n    instancePrivacySink(source, \"\"); // should report\n  }\n\n  public void testPrivacySinkAnnot2() {\n    String source = privacySource();\n    instancePrivacySink(\"\", source); // should not report\n  }\n\n  public void testPrivacySinkAnnot3_FN() {\n    String source = privacySource();\n    staticPrivacySink(source, \"\"); // should report\n  }\n\n  public void testPrivacySinkAnnot4() {\n    String source = privacySource();\n    staticPrivacySink(\"\", source); // should not report\n  }\n\n  @PrivacySource String mPrivacySource;\n\n  @PrivacySource String sPrivacySource;\n\n  public void testPrivacySourceInstanceFieldAnnot_FN() {\n    String source = mPrivacySource;\n    InferTaint.inferSensitiveSinkUndefined(source); // should report\n  }\n\n  public void testPrivacySourceStaticFieldAnnot_FN() {\n    String source = sPrivacySource;\n    InferTaint.inferSensitiveSinkUndefined(source); // should report\n  }\n\n  String aFieldWithoutAnnotations;\n\n  public void testPrivacySourceFieldAnnotPropagation_FN() {\n    aFieldWithoutAnnotations = mPrivacySource;\n    InferTaint.inferSensitiveSinkUndefined(aFieldWithoutAnnotations); // should report\n  }\n\n  @IntegritySource\n  public String integritySource() {\n    return \"source\";\n  }\n\n  @IntegritySource String mIntegritySource;\n\n  @IntegritySource String sIntegritySource;\n\n  public void testIntegritySourceAnnot_FN() {\n    InferTaint.inferSensitiveSinkUndefined(integritySource()); // should report\n  }\n\n  public void testIntegritySourceInstanceFieldAnnot_FN() {\n    String source = mIntegritySource;\n    InferTaint.inferSensitiveSinkUndefined(source); // should report\n  }\n\n  public void testIntegritySourceStaticFieldAnnot_FN() {\n    String source = sIntegritySource;\n    InferTaint.inferSensitiveSinkUndefined(source); // should report\n  }\n\n  public void integritySink(@IntegritySink String s1, String s2) {}\n\n  void testIntegritySinkAnnotReport_FN(String s) {\n    integritySink(integritySource(), s); // should report\n  }\n\n  void testIntegritySinkAnnotNoReport(String s) {\n    integritySink(s, integritySource()); // should not report\n  }\n}\n"
    },
    {
      "testname": "TaintMatchers.java",
      "testlanguage": "java",
      "expected-problems": 22,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\n/* testing advanced source/sink matchers */\nimport codetoanalyze.java.pulse.sinks.InferTaintSinks;\n\npublic class TaintMatchers {\n  void taintedBasedOnClassNameRegexBad() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaintSinks.sink1(src);\n    InferTaintSinks.sink2(src);\n  }\n\n  void notTaintedBasedOnClassNameRegexOk() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaint.sink1(src);\n    InferTaint.sink2(src);\n  }\n\n  void taintedFromInferBaseSourceBad() {\n    InferChildSource ics = new InferChildSource();\n    Object source = ics.inferBaseSecretSource();\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  void notTaintedFromInferBaseNotSourceGood() {\n    InferChildSource ics = new InferChildSource();\n    Object notSource = ics.inferBaseNotSource();\n    InferTaint.inferSensitiveSink(notSource);\n  }\n\n  void taintedFromInferChildSourceBad() {\n    InferChildSource ics = new InferChildSource();\n    Object source = ics.inferChildSecretSource();\n    InferTaint.inferSensitiveSink(source);\n  }\n\n  void notTaintedFromInferChildNotSourceGood() {\n    InferChildSource ics = new InferChildSource();\n    Object notSource = ics.inferChildNotSource();\n    InferTaint.inferSensitiveSink(notSource);\n  }\n\n  void taintedBasedOnClassNameAndMethodRegexBad() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaint.regexSink(src);\n  }\n\n  void notTaintedBasedOnClassNameAndMethodRegexBad() {\n    Object src = InferTaint.inferSecretSource();\n    InferTaint.notRegexSink(src);\n  }\n\n  void taintedBasedOnClassAnnotationBad1() {\n    Object src = InferTaintSources.Sources.source1();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void taintedBasedOnClassAnnotationBad2() {\n    Object src = InferTaintSources.Sources.source2();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void notTaintedBasedOnClassAnnotationGood() {\n    Object src = InferTaintSources.NotSources.notSource();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void taintedBasedOnClassAndProcedureRegexBad1() {\n    Object src = InferTaintSources.RegexSources.source1();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void taintedBasedOnClassAndProcedureRegexBad2() {\n    Object src = InferTaintSources.RegexSources.source2();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void notTaintedBasedOnClassAndProcedureRegexOk1() {\n    Object src = InferTaintSources.RegexSources.notSource();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void notTaintedBasedOnClassAndProcedureRegexOk2() {\n    Object src = InferTaintSources.NotSources.sourceButNotReally();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void taintedBasedOnClassAnnotationAndClassAndProcedureRegexBad1() {\n    Object src = InferTaintSources.RegexAndAnnotationSources.source1();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void taintedBasedOnClassAnnotationAndClassAndProcedureRegexBad2() {\n    Object src = InferTaintSources.RegexAndAnnotationSources.source2();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void notTaintedBasedOnClassAnnotationAndClassAndProcedureRegexGood1() {\n    Object src = InferTaintSources.RegexAndAnnotationSources.notSource();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void notTaintedBasedOnClassAnnotationAndClassAndProcedureRegexGood2() {\n    Object src = InferTaintSources.RegexAndAnnotationNotSources.notSource();\n    InferTaint.inferSensitiveSink(src);\n  }\n\n  void notTaintedBasedOnClassAnnotationAndClassAndProcedureRegexGood3() {\n    Object src = InferTaintSources.RegexAndAnnotationNotSources.sourceButNotReally();\n    InferTaint.inferSensitiveSink(src);\n  }\n}\n"
    },
    {
      "testname": "Traces.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nclass Traces {\n  void sourceMethodBad() {\n    Obj source = (Obj) InferTaint.inferSecretSource();\n    callSameSink(null, source, null, null);\n  }\n\n  void callSameSink(Obj o1, Obj o2, Obj o3, Obj o4) {\n    callMySink(o1);\n    callMySinkIndirect(o2); // test that we expand this sink in the trace\n    callMySink(o3);\n    callMySink(o4);\n  }\n\n  void callMySinkIndirect(Obj o) {\n    callMySink(o);\n  }\n\n  void callMySink(Obj o) {\n    InferTaint.inferSensitiveSink(o);\n  }\n}\n"
    },
    {
      "testname": "UnknownCode.java",
      "testlanguage": "java",
      "expected-problems": 30,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.content.Intent;\nimport android.os.Parcel;\n\nclass SensitiveClass {\n  native Object getId();\n}\n\n/** testing how the analysis handles missing/unknown code */\npublic abstract class UnknownCode {\n\n  static native Object nativeMethod(Object o);\n\n  abstract Object abstractMethod(Object o);\n\n  static void inferSensitiveSink(Object o) {}\n\n  static interface Interface {\n    Object interfaceMethod(Object o);\n  }\n\n  static void propagateViaUnknownConstructorBad() {\n    String source = InferTaint.inferSecretStringSource();\n    // we don't analyze the code for the core Java libraries, so this constructor will be unknown\n    String unknownConstructor = new String(source);\n    InferTaint.inferSensitiveSink(unknownConstructor);\n  }\n\n  static void propagateViaUnknownConstructorOk() {\n    String unknownConstructor = new String(\"\");\n    InferTaint.inferSensitiveSink(unknownConstructor);\n  }\n\n  void propagateViaUnknownCodeOk(Interface i) {\n    Object notASource = new Object();\n    Object launderedSource1 = nativeMethod(notASource);\n    Object launderedSource2 = abstractMethod(launderedSource1);\n    Object launderedSource3 = i.interfaceMethod(launderedSource2);\n    InferTaint.inferSensitiveSink(launderedSource3);\n  }\n\n  void callUnknownSetterBad(Intent i) {\n    Object source = InferTaint.inferSecretSource();\n    // we don't analyze the source code for Android, so this will be unknown\n    i.writeToParcel((Parcel) source, 0);\n    InferTaint.inferSensitiveSink(i);\n  }\n\n  void propagateEmptyBad() {\n    String source = InferTaint.inferSecretStringSource();\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(source); // buffer is now tainted\n    // even though \"\" is not tainted, buffer and alias should still be tainted\n    StringBuffer alias = buffer.append(\"\");\n    InferTaint.inferSensitiveSink(buffer); // should report\n    InferTaint.inferSensitiveSink(alias); // should report\n  }\n\n  void propagateFootprint(String param) {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(param);\n    InferTaint.inferSensitiveSink(buffer);\n  }\n\n  void callPropagateFootprintBad() {\n    propagateFootprint(InferTaint.inferSecretStringSource());\n  }\n\n  static native Object nativeMethod2(Object o, int i);\n\n  String propagateTaint(String param) {\n    String a = param;\n    int i = 1234;\n    return (String) nativeMethod2(a, i);\n  }\n\n  void callPropagateThenPropagateFootprintBad() {\n    String source = InferTaint.inferSecretStringSource();\n    propagateFootprint(propagateTaint(source));\n  }\n\n  static void propagateViaInterfaceCodeBad(Interface i) {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource = i.interfaceMethod(source);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  void propagateViaUnknownNativeCodeBad() {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource = nativeMethod(source);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  static void propagateViaUnknownAbstractCodeBad() {\n    Object source = InferTaint.inferSecretSource();\n    Object launderedSource = nativeMethod(source);\n    InferTaint.inferSensitiveSink(launderedSource);\n  }\n\n  static void propagatedTaintUnrelated(SensitiveClass sc) {\n    Object t1 = nativeMethod(sc.getId());\n    Object t2 = nativeMethod(null);\n    if (t1 == t2) {\n      InferTaint.inferSensitiveSink(t2);\n    }\n  }\n\n  static String returnToString(Object param) {\n    return param.toString();\n  }\n\n  static void sourceIndirectToStringToSink() {\n    String tainted = returnToString(InferTaint.inferSecretSource());\n    InferTaint.inferSensitiveSink(tainted);\n  }\n}\n"
    },
    {
      "testname": "UserControlledStrings.java",
      "testlanguage": "java",
      "expected-problems": 4,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.content.ClipboardManager;\nimport android.text.Html;\nimport android.text.Spanned;\nimport android.widget.EditText;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UserControlledStrings {\n  ClipboardManager clipboard;\n\n  Spanned clipboardToHtmlBad() {\n    return Html.fromHtml(clipboard.getText().toString());\n  }\n\n  EditText mEditText;\n\n  Spanned editTextToHtmlBad() {\n    return Html.fromHtml(mEditText.getText().toString());\n  }\n\n  void clipboardToShellDirectBad() throws IOException {\n    Runtime.getRuntime().exec(clipboard.getText().toString());\n  }\n\n  void clipboardToShellArrayBad() throws IOException {\n    String[] cmds = new String[] {\"ls\", clipboard.getText().toString()};\n    Runtime.getRuntime().exec(cmds);\n  }\n\n  ProcessBuilder clipboardToProcessBuilder1Bad() {\n    return new ProcessBuilder(clipboard.getText().toString());\n  }\n\n  ProcessBuilder clipboardToProcessBuilder2Bad() {\n    return new ProcessBuilder(\"sh\", clipboard.getText().toString());\n  }\n\n  ProcessBuilder clipboardToProcessBuilder3Bad(ProcessBuilder builder) {\n    return builder.command(clipboard.getText().toString());\n  }\n\n  ProcessBuilder clipboardToProcessBuilder4Bad(ProcessBuilder builder) {\n    List<String> cmds = new ArrayList();\n    cmds.add(clipboard.getText().toString());\n    return builder.command(cmds);\n  }\n}\n"
    },
    {
      "testname": "WebViews.java",
      "testlanguage": "java",
      "expected-problems": 23,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage codetoanalyze.java.pulse;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.webkit.JavascriptInterface;\nimport android.webkit.JsPromptResult;\nimport android.webkit.JsResult;\nimport android.webkit.WebChromeClient;\nimport android.webkit.WebResourceRequest;\nimport android.webkit.WebResourceResponse;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport java.io.File;\nimport java.net.URISyntaxException;\n\npublic class WebViews {\n\n  void callWebviewSinks(WebView webview) {\n    String stringSource = (String) InferTaint.inferSecretSource();\n\n    webview.evaluateJavascript(stringSource, null);\n    webview.loadData(stringSource, \"\", \"\");\n    webview.loadDataWithBaseURL(\"\", stringSource, \"\", \"\", \"\");\n    webview.loadUrl(stringSource);\n    webview.postUrl(stringSource, null);\n    webview.postWebMessage(null, (Uri) InferTaint.inferSecretSource());\n  }\n\n  // make sure all of the rules apply to subclasses as well\n  class MyWebView extends WebView {\n    public MyWebView(Context c) {\n      super(c);\n    }\n  }\n\n  Activity mActivity;\n\n  class MyWebViewClient extends WebViewClient {\n\n    @Override\n    public void onLoadResource(WebView w, String url) {\n      try {\n        Intent i = Intent.parseUri(url, 0);\n        mActivity.startActivity(i); // should report\n      } catch (URISyntaxException e) {\n      }\n    }\n\n    @Override\n    public WebResourceResponse shouldInterceptRequest(WebView w, WebResourceRequest request) {\n      mActivity.startActivity(new Intent(\"action\", request.getUrl())); // should report\n      return null;\n    }\n\n    File webResourceToFileBad(WebResourceRequest request) {\n      return new File(request.getUrl().getPath());\n    }\n\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView w, String url) {\n      try {\n        Intent i = Intent.parseUri(url, 0);\n        mActivity.startActivity(i); // should report\n      } catch (URISyntaxException e) {\n      }\n      return false;\n    }\n  }\n\n  class MyWebChromeClient extends WebChromeClient {\n\n    @Override\n    public boolean onJsAlert(WebView w, String url, String message, JsResult result) {\n      try {\n        Intent i = Intent.parseUri(url, 0);\n        mActivity.startActivity(i);\n      } catch (URISyntaxException e) {\n      }\n      return false;\n    }\n\n    @Override\n    public boolean onJsBeforeUnload(WebView w, String url, String m, JsResult result) {\n      try {\n        Intent i = Intent.parseUri(url, 0);\n        mActivity.startActivity(i);\n      } catch (URISyntaxException e) {\n      }\n      return false;\n    }\n\n    @Override\n    public boolean onJsConfirm(WebView w, String url, String m, JsResult result) {\n      try {\n        Intent i = Intent.parseUri(url, 0);\n        mActivity.startActivity(i);\n      } catch (URISyntaxException e) {\n      }\n      return false;\n    }\n\n    @Override\n    public boolean onJsPrompt(WebView w, String url, String m, String s, JsPromptResult result) {\n      try {\n        Intent i = Intent.parseUri(url, 0);\n        mActivity.startActivity(i);\n      } catch (URISyntaxException e) {\n      }\n      return false;\n    }\n  }\n\n  void callWebviewSubclassSink(MyWebView webview) {\n    String stringSource = (String) InferTaint.inferSecretSource();\n    webview.evaluateJavascript(stringSource, null);\n  }\n\n  class JsObject {\n    @JavascriptInterface\n    Object returnSource() {\n      return InferTaint.inferSecretSource();\n    }\n  }\n\n  // in order to get this, we have to understand that addJavaScriptInterface can evaluate the\n  // JsObject.returnSource method\n  void FN_addJavascriptInterface(MyWebView webview) {\n    // should warn here\n    webview.addJavascriptInterface(new JsObject(), \"injectedObject\");\n  }\n}\n"
    },
    {
      "testname": "assert_capture.py",
      "testlanguage": "python",
      "expected-problems": 6,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom not_captured import id_not_captured\nfrom dir1.dir3.testmod import id as id_captured\nfrom dir1.dir4.skipped import id as id_skipped\n\n#expected since id_not_captured is not captured\ndef FP_assert_true_with_id_not_captured_ok():\n    assert id_not_captured(True)\n\n\ndef assert_false_with_id_not_captured_bad():\n    assert id_not_captured(False)\n\n\ndef assert_true_with_id_captured_ok():\n    assert id_captured(True)\n\n\ndef assert_false_with_id_captured_bad():\n    assert id_captured(False)\n\n\n#expected since id_skipped is not captured (see .inferconfig and option\ndef FP_assert_true_with_id_skipped_ok():\n    assert id_skipped(True)\n\n\ndef assert_false_with_id_skipped_bad():\n    assert id_skipped(False)\n"
    },
    {
      "testname": "assert_level0.py",
      "testlanguage": "python",
      "expected-problems": 3,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n\ndef assert_true_bad():\n    assert False\n\n\ndef assert_true_ok():\n    assert True\n\n\n# the assert-error issue is not latent: we consider such a partial\n# function should be considered bad\ndef run_assert_latent_bad(b):\n    assert b\n"
    },
    {
      "testname": "assert_oo_basic.py",
      "testlanguage": "python",
      "expected-problems": 8,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nclass A:\n    def __init__(self, val):\n        self.attr = val\n\n    def get(self):\n        return self.attr\n\n    def set(self, val):\n        self.attr = val\n\n\ndef get_attr_after_init_bad():\n    a = A(False)\n    assert a.get()\n\n\ndef get_attr_after_init_ok():\n    a = A(True)\n    assert a.get()\n\n\ndef get_attr_after_set_bad():\n    a = A(True)\n    a.set(False)\n    assert a.get()\n\n\ndef get_attr_after_set_ok():\n    a = A(False)\n    a.set(True)\n    assert a.get()\n"
    },
    {
      "testname": "assert_oo_single_inheritance.py",
      "testlanguage": "python",
      "expected-problems": 25,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nclass A:\n    class_attrA_false = False\n    class_attrA_true = True\n    def __init__(self, val):\n        self.attrA = val\n\n    def get_attrA(self):\n        return self.attrA\n\n    def set_attrA(self, val):\n        self.attrA = val\n\n\nclass B(A):\n    class_attrB_false = False\n    class_attrB_true = True\n    def get_attrB(self):\n        return self.attrB\n\n    def set_attrB(self, val):\n        self.attrB = val\n\n\ndef not_inherited_attribute_bad():\n    b = B()\n    b.attrB = False\n    assert b.attrB\n\n\ndef not_inherited_attribute_ok():\n    b = B()\n    b.attrB = True\n    assert b.attrB\n\n\ndef not_inherited_method_bad():\n    b = B()\n    b.set_attrB(False)\n    assert b.get_attrB()\n\n\ndef not_inherited_method_ok():\n    b = B()\n    b.set_attrB(True)\n    assert b.get_attrB()\n\n\ndef inherited_class_attribute_B_bad():\n    b = B()\n    assert b.class_attrB_false\n\n\ndef inherited_class_attribute_B_ok():\n    b = B()\n    assert b.class_attrB_true\n\n\ndef inherited_class_attribute_A_bad():\n    b = B()\n    assert b.class_attrA_false\n\n\ndef inherited_class_attribute_A_ok():\n    b = B()\n    assert b.class_attrA_true\n\n\ndef inherited_method_bad():\n    b = B()\n    b.set_attrA(False)\n    assert b.get_attrA()\n\n\ndef inherited_method_ok():\n    b = B()\n    b.set_attrA(True)\n    assert b.get_attrA()\n\n\ndef inherited_class_modified_attribute_B_1_bad():\n    B.class_attrB_true = False\n    b = B()\n    assert b.class_attrB_true\n\n\ndef inherited_class_modified_attribute_B_1_ok():\n    B.class_attrB_false = True\n    b = B()\n    assert b.class_attrB_false\n\n\ndef inherited_class_modified_attribute_B_2_bad():\n    b = B()\n    B.class_attrB_true = False\n    assert b.class_attrB_true\n\n\ndef inherited_class_modified_attribute_B_2_ok():\n    b = B()\n    B.class_attrB_false = True\n    assert b.class_attrB_false\n\n\ndef FN_inherited_class_modified_attribute_A_1_bad():\n    A.class_attrA_true = False\n    b = B()\n    assert b.class_attrA_true\n\n\ndef FP_inherited_class_modified_attribute_A_1_ok():\n    A.class_attrA_false = True\n    b = B()\n    assert b.class_attrA_false\n\n\ndef FN_inherited_class_modified_attribute_A_2_bad():\n    b = B()\n    A.class_attrA_true = False\n    assert b.class_attrA_true\n\n\ndef FP_inherited_class_modified_attribute_A_2_ok():\n    b = B()\n    A.class_attrA_false = True\n    assert b.class_attrA_false\n"
    },
    {
      "testname": "async_classes.py",
      "testlanguage": "python",
      "expected-problems": 6,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\n\n\nclass Car:\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n\n    def drive(self):\n        return 0\n\n    async def refuel(self):\n        await asyncio.sleep(2)\n\n\nasync def car_instance_ok():\n    my_car = Car(\"Fusca\", \"1999\")\n    my_car.drive()\n    await my_car.refuel()\n\n\nasync def fn_car_instance_bad():\n    my_car = Car(\"Fusca\", \"1999\")\n    my_car.drive()\n    return my_car.refuel()\n"
    },
    {
      "testname": "async_dict.py",
      "testlanguage": "python",
      "expected-problems": 4,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\n\n\ndef int_key_access_ok():\n    d = {\"ABC\": 1, 2: asyncio.sleep(1)}\n    return d[2]\n\n\ndef str_key_access_ok():\n    d = {\"ABC\": 1, \"DEF\": asyncio.sleep(1)}\n    return d[\"DEF\"]\n\n\ndef fn_int_key_access_bad():\n    d = {123: 1, 456: asyncio.sleep(1)}\n    return d[123]\n\n\nasync def str_key_access_bad():\n    d = {\"ABC\": asyncio.sleep(), 123: 456, \"DEF\": await asyncio.sleep(1)}\n    return d[\"DEF\"]\n"
    },
    {
      "testname": "async_global.py",
      "testlanguage": "python",
      "expected-problems": 2,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\n\n\nasync def set_unwaited_global():\n    global g\n    g = asyncio.sleep()\n\n\nasync def await_global():\n    global g\n    await g\n\n#ok\nasyncio.run(set_unwaited_global())\nasyncio.run(await_global())\ng = 0\n\n#bad\nasyncio.run(set_unwaited_global())\ng = 0\n"
    },
    {
      "testname": "async_import_simple.py",
      "testlanguage": "python",
      "expected-problems": 11,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\nimport async_utils as utils\nfrom async_utils import (\n    await_it as async_await,\n    dont_await_it as async_dont_await,\n    sleep,\n    C\n)\nfrom not_captured import unknown\nfrom await_sync_lib import await_sync_decorator\n\nasync def with_import_bad():\n    await utils.dont_await_it(sleep())\n\n\nasync def with_import_ok():\n    await utils.await_it(sleep())\n\n\nasync def with_from_import_bad():\n    await async_dont_await(sleep())\n\n\nasync def with_from_import_ok():\n    await async_await(sleep())\n\n\nasync def with_imported_class_bad():\n    await async_dont_await(C.sleep())\n\n\nasync def with_imported_class_ok():\n    await async_await(C.sleep())\n\n\nasync def asyncio_gather_3_elements_ok():\n    await asyncio.gather(\n        *[\n            sleep(),\n            sleep(),\n            sleep(),\n        ]\n    )\n\n\nasync def asyncio_gather_unknown_list_ok(l):\n    tasks = [asyncio.sleep(i) for i in l]\n    await asyncio.gather(*tasks)\n\n\nasync def make_awaitables_dict(cond):\n    awaitables_dict = {}\n    if cond:\n        awaitables_dict[\"a key\"] = sleep()\n    return awaitables_dict\n\n\ndef unknown_call():\n    unknown(asyncio.sleep(1))\n\n\n@await_sync_decorator\nasync def main_ok(x, y ):\n    pass\n\nmain_ok(x, y)\n"
    },
    {
      "testname": "async_import_with_package.py",
      "testlanguage": "python",
      "expected-problems": 29,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\nfrom dir1.testmod import (\n    await_it as await_it1,\n    dont_await_it as dont_await_it1,\n)\nfrom dir1.dir3.testmod import (\n    await_it as await_it3,\n    dont_await_it as dont_await_it3,\n    C,\n    wait,\n    deep_wait\n)\nfrom not_captured.helper import (\n    not_captured_wait,\n    not_captured_deep_wait\n)\nimport dir1.dir4.testmod\nfrom dir2.testmod import (\n    await_it as await_it2,\n    dont_await_it as dont_await_it2,\n)\nimport dir2.dir5.testmod as import5\nfrom dir2.dir6 import testmod as import6\nfrom not_captured.dir import unknown_module1 as unknown_module\nfrom not_captured.dir.unknown_module2 import unknown\n\nasync def bad1():\n    await dont_await_it1(asyncio.sleep(1))\n\n\nasync def ok1():\n    await await_it1(asyncio.sleep(1))\n\n\nasync def bad2():\n    await dont_await_it2(asyncio.sleep(1))\n\n\nasync def ok2():\n    await await_it2(asyncio.sleep(1))\n\n\nasync def bad3():\n    await dont_await_it3(asyncio.sleep(1))\n\n\nasync def ok3():\n    await await_it3(asyncio.sleep(1))\n\n\nasync def from_class_bad3():\n    await dont_await_it3(C.async_fun())\n\n\nasync def from_class_ok3():\n    await await_it3(C.async_fun())\n\n\nasync def fn_bad4():\n    await dir1.dir4.testmod.dont_await_it(asyncio.sleep(1))\n# we still need this explicit toplevel call until we adapt specialization\n# types to import-packages without alias names but this is not a frequent\n# pattern in our experiments so far\n#asyncio.run(bad4())\n\nasync def ok4():\n    await dir1.dir4.testmod.await_it(asyncio.sleep(1))\nasyncio.run(ok4())\n\n\nasync def bad5():\n    await import5.dont_await_it(asyncio.sleep(1))\n\n\nasync def ok5():\n    await import5.await_it(asyncio.sleep(1))\n\n\nasync def bad6():\n    await import6.dont_await_it(asyncio.sleep(1))\n\n\nasync def ok6():\n    await import6.await_it(asyncio.sleep(1))\n\n\ndef use_pulse_model_release_option_ok():\n    wait(asyncio.sleep())\n\n\ndef use_pulse_model_release_option_not_captured_ok():\n    not_captured_wait(asyncio.sleep())\n\n\ndef use_pulse_model_deep_release_option_args_ok(l):\n    deep_wait(*[\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        ])\n\n\ndef use_pulse_model_deep_release_option_not_captured_args_ok():\n    not_captured_deep_wait(*[\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        ])\n\ndef use_pulse_model_deep_release_option_ok(l):\n    deep_wait(\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        )\n\n\ndef use_pulse_model_deep_release_option_not_captured_ok():\n    not_captured_deep_wait(\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        asyncio.sleep(1),\n        )\n\ndef use_pulse_model_deep_release_option_generator_ok(l):\n    deep_wait(\n        asyncio.sleep(i) for i in l\n    )\n\n# we don't try to track  precisely generators for now\ndef FN_generator_with_unwaited_bad(l):\n    l = (\n        asyncio.sleep(i) for i in l\n    )\n\n\ndef use_pulse_model_deep_release_option_dict_ok(l):\n    deep_wait({ x.key: asyncio.sleep(x.i) for x in l})\n\n\ndef use_pulse_model_deep_release_option_set_ok(l):\n    deep_wait({ asyncio.sleep(i) for i in l})\n\n\ndef use_pulse_model_deep_release_option_constant_dict_ok(key1, key2, key3, key4):\n    deep_wait(\n        {\n            key1: asyncio.sleep(1),\n            key2: asyncio.sleep(1),\n            key3: asyncio.sleep(1),\n            key4: asyncio.sleep(1),\n        }\n    )\n\n\ndef use_pulse_model_deep_release_option_constant_set_ok():\n    deep_wait(\n        {\n            asyncio.sleep(1),\n            asyncio.sleep(1),\n            asyncio.sleep(1),\n            asyncio.sleep(1),\n        }\n    )\n\n\ndef use_pulse_model_deep_release_option_constant_list_ok(key1, key2):\n    deep_wait(\n        [\n            asyncio.sleep(1),\n            asyncio.sleep(1),\n            asyncio.sleep(1),\n            asyncio.sleep(1),\n        ]\n    )\n\n\ndef unknown_call1_ok():\n    unknown_module.foo(asyncio.sleep(1))\n\n\ndef unknown_call2_ok():\n    unknown(asyncio.sleep(1))\n"
    },
    {
      "testname": "async_lambda.py",
      "testlanguage": "python",
      "expected-problems": 5,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\n\n\nasync def foo():\n    await asyncio.sleep(1)\n\n\nasync def lambda_bad():\n    x = lambda: foo()\n    x()\n\n\nasync def lambda_good():\n    x = lambda: foo()\n    await x()\n\n\nasync def lambda_param_bad(f):\n    f()\n\n\nasync def lambda_param_bad_call_bad():\n    lambda_param_bad(lambda: foo())\n\n\nlambda_param_bad(lambda: foo())\n"
    },
    {
      "testname": "async_level0.py",
      "testlanguage": "python",
      "expected-problems": 73,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\nfrom unknown import (_async_fun, async_fun)\n\nasync def sleep(i):\n    await asyncio.sleep(i)\n\n\nasync def sleep_bad(i):\n    asyncio.sleep(i)\n\n\nasync def call_sleep_ok():\n    await sleep(1)\n\n\nasync def call_sleep_bad():\n    sleep(1)\n\n\nasync def call_sleep_unknown_call_ok():\n    unknown(sleep(1))\n\n\nasync def call_sleep_with_temp_ok():\n    temp = sleep(1)\n    await temp\n\n\nasync def call_sleep_with_branchs_ok(b):\n    temp = sleep(1)\n    if b:\n        await temp\n    else:\n        await temp\n\n\nasync def call_sleep_with_branchs_bad1(b):\n    temp = sleep(1)\n    if b:\n        await temp\n\n\nasync def call_sleep_with_branchs_bad2(b):\n    temp = sleep(1)\n    if b:\n        return\n    await temp\n\n\nasync def tuple0_bad():\n    t = (sleep(1), sleep(2))\n    await t[0]\n\n\nasync def tuple1_bad():\n    t = (sleep(1), sleep(2))\n    await t[1]\n\n\nasync def tuple_ok():\n    t = (sleep(1), sleep(2))\n    await t[0]\n    await t[1]\n\n\nasync def with_str_bad():\n    unwaited = sleep(1)\n    return str(unwaited)\n\n\nasync def with_str_ok():\n    unwaited = sleep(1)\n    s = str(unwaited)\n    awaited = await unwaited\n    return (awaited, s)\n\n\ndef fst(x: int, y: int) -> int:\n    return x\n\n\nasync def call_fst_ok(i):\n    await fst(sleep(1), i)\n\n\nasync def call_fst_bad(i):\n    return fst(i, sleep(1))\n\n\nasync def compare_lt_bad():\n    i = sleep()\n    if i < 0:\n        pass\n\n\nasync def compare_lt_ok():\n    i = await sleep()\n    if i < 0:\n        pass\n\n\nasync def compare_gt_bad():\n    i = sleep()\n    if i > 0:\n        pass\n\n\nasync def compare_gt_ok():\n    i = await sleep()\n    if i > 0:\n        pass\n\n\nasync def use_py_bool_bad(b):\n    x = sleep()\n    return x if b else None\n\n\nasync def use_py_bool_ok(b):\n    x = await sleep()\n    return x if b else None\n\n\ndef true():\n    return True\n\n\nasync def use_py_bool_true_ok():\n    x = sleep()\n    if true():\n        await x\n\n\ndef false():\n    return False\n\n\nasync def use_py_bool_false_ok():\n    x = sleep()\n    if false():\n        pass\n    else:\n        await x\n\n\n# FN because of py_store_subscript model\ndef FN_set_dict_with_unwaited_bad(key):\n    d = {}\n    d[key] = asyncio.sleep(0)\n\n\nasync def use_py_get_iter_bad():\n    x = sleep()\n    return [a.f for a in x]\n\n\nasync def use_py_get_iter_ok():\n    x = await sleep()\n    return [a.f for a in x]\n\n\n# we decide that boolification of an unawaited awaitable is too dangerous\nasync def gather_condition_awaitable_bad():\n    awaitable = sleep()\n    asyncio.gather(awaitable if awaitable else sleep())\n\n\nasync def concat_list_left_ok(l):\n    return [sleep()] + l\n\n\nasync def concat_list_right_ok(l):\n    return l + [sleep()]\n\n\nasync def concat_tuple_left_ok(l):\n    return (sleep(), sleep()) + l\n\n\nasync def concat_tuple_right_ok(l):\n    return l + (sleep(), sleep())\n\n\nasync def do_not_await_arg(arg):\n    pass\n\n\nasync def await_arg(arg):\n    await arg\n\n\nasync def use_await_arg_ok():\n    unawaited = async_fun()\n    await await_arg(unawaited)\n\n\nasync def use_do_not_await_arg_bad():\n    unawaited = async_fun()\n    await do_not_await_arg(unawaited)\n\n\nasync def use_await_arg_named_arg_ok():\n    unawaited = async_fun()\n    await await_arg(arg=unawaited)\n\n\nasync def use_do_not_await_arg_named_arg_bad():\n    unawaited = async_fun()\n    await do_not_await_arg(arg=unawaited)\n\n\nasync def do_not_await_arg2_with_star(arg1, *, arg2):\n    pass\n\n\nasync def await_arg2_with_star(arg1, *, arg2):\n    await arg2\n\n\nasync def use_await_arg2_named_arg_with_star_ok():\n    unawaited = async_fun()\n    await await_arg2_with_star(None, arg2=unawaited)\n\n\nasync def FN_use_do_not_await_arg2_named_arg_with_star_bad():\n    unawaited = async_fun()\n    await do_not_await_arg2_with_star(None, arg2=unawaited)\n\n\ndef get_option_awaitable(b):\n    if b:\n        return asyncio.sleep(1)\n    else:\n        return None\n\n\nasync def FP_3_12_call_get_option_awaitable_eq_test_none_ok(b):\n    unawaited = get_option_awaitable(b)\n    if unawaited is None:\n        return None\n    return await unawaited\n\n\nasync def call_get_option_awaitable_eq_test_none_bad(b):\n    unawaited = get_option_awaitable(b)\n    if unawaited is None:\n        return await unawaited\n\n\nasync def async_naming_convention_test1_bad():\n    _async_fun()\n\n\nasync def async_naming_convention_test1_ok():\n    await _async_fun()\n\n\nasync def async_naming_convention_test2_bad():\n    async_fun()\n\n\nasync def async_naming_convention_test2_ok():\n    await async_fun()\n\nclass C:\n    async def async_instance_method(self):\n        pass\n\n    async def async_naming_convention_test3_bad(self):\n        self.async_instance_method()\n\n\n    async def async_naming_convention_test3_ok():\n        await self.async_instance_method()\n\n\n    async def _async_private_instance_method(self):\n        pass\n\n    async def async_naming_convention_test4_bad(self):\n        self._async_private_instance_method()\n\n\n    async def async_naming_convention_test4_ok():\n        await self._async_private_instance_method()\n\n\nasync def iter_arg_bad(f):\n    iter = async_fun()\n    for i in iter:\n        f(i)\n    return iter\n\n\nasync def iter_arg_ok(f):\n    iter = await async_fun()\n    for i in iter:\n        f(i)\n    return iter\n\n\ndef my_iter(f, l):\n    for x in l:\n        f(x)\n\n\nasync def my_iter_arg_bad(f):\n    l = async_fun()\n    my_iter(f, l)\n    return l\n\n\nasync def my_iter_arg_ok(f):\n    l = await async_fun()\n    my_iter(f, l)\n    return l\n\n\nasync def FN_3_10_none_test_bad():\n    opt = async_fun()\n    if opt is None:\n        do()\n    return opt\n\n\nasync def not_none_test_bad():\n    opt = async_fun()\n    if opt is not None:\n        do()\n    return opt\n\n\nasync def none_test_ok():\n    opt = await async_fun()\n    if opt is None:\n        do()\n    return opt\n\nasync def not_none_test_ok():\n    opt = await async_fun()\n    if opt is not None:\n        do()\n    return opt\n\n\ndef main_ok():\n    asyncio.run(sleep(10))\n\n\nasync def multi_tasks_ok():\n    asyncio.gather(sleep(1), sleep(2))\n\n\nmain_ok()\n\n# no FP here\nasyncio.run(sleep(10))\nasyncio.run(multi_tasks_ok())\n"
    },
    {
      "testname": "async_level1.py",
      "testlanguage": "python",
      "expected-problems": 7,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nclass C:\n\n    async def gen():\n        pass\n\n\nclass D:\n    def __init__(self):\n        self.unawaited = C.gen()\n\n    def main():\n        x = C.gen()\n\n\nasync def instantiate_D_ok():\n    d = D()\n    await d.unawaited\n\n\ndef instantiate_D_bad():\n    d = D()\n\n\nif __name__ == '__main__':\n    # common pattern\n    pass\n"
    },
    {
      "testname": "async_typing.py",
      "testlanguage": "python",
      "expected-problems": 17,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport asyncio\nimport types\n\n\nasync def await_condition_typing_int_ok():\n    x = int(5)\n    if type(x) == int:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_typing_int_bad():\n    if type(5) == str:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_typing_str_ok():\n    x = str(\"abc\")\n    if type(x) == str and type(x) is str:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_typing_with_arg_bad(x):\n    if type(x) == str:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nclass Name:\n    def __init__(self, name):\n        self.name = name\n\n\nasync def fp_await_condition_typing_user_defined_ok():\n    x = Name(\"foo\")\n    if type(x) == Name:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def fp_await_condition_typing_fun_ok():\n    def x():\n        return -1\n\n    if type(x) == types.FunctionType:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_is_none_bad():\n    x = None\n    if x is None:\n        asyncio.sleep(1)\n    else:\n        await asyncio.sleep(1)\n\n\nasync def await_condition_is_none_ok():\n    x = None\n    if x is None:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_bool_none_bad():\n    x = None\n    if x:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_bool_none_ok():\n    x = None\n    if x:\n        asyncio.sleep(1)\n    else:\n        await asyncio.sleep(1)\n\n\nasync def fp_await_condition_val_equal_ok():\n    x = Name(\"foo\")\n    y = Name(\"foo\")\n    if x == y:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n\n\nasync def await_condition_phys_equal_bad():\n    x = Name(\"foo\")\n    y = Name(\"foo\")\n    if x is y:\n        await asyncio.sleep(1)\n    else:\n        asyncio.sleep(1)\n"
    },
    {
      "testname": "async_utils.py",
      "testlanguage": "python",
      "expected-problems": 5,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nasync def sleep():\n    pass\n\n\nasync def await_it(arg):\n    await arg\n\n\nasync def dont_await_it(arg):\n    pass\n\n@final\nclass C:\n\n    @staticmethod\n    async def sleep():\n        pass\n"
    },
    {
      "testname": "builtins.py",
      "testlanguage": "python",
      "expected-problems": 4,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nfrom pathlib import Path\n\n\ndef main():\n    print(int(\"0b110\", 2))\n    print(int(\"42\", 10))\n    print(str(\"42\"))\n    print(str(Path(\"/my/dir/\", \"test.py\"), \"utf-8\"))\n    print(dict())\n    print(dict(name=\"Alice\", city=\"New York\"))\n    print(dict({\"name\": \"Alice\", \"city\": \"New York\"}))\n    print(dict([]))\n    print(dict({}))\n    print(dict([(\"x\", 10)], y=20, z=30))\n\n\ndef fp_dict_comp_ok():\n    print(dict((i, i**2) for i in range(3)))\n"
    },
    {
      "testname": "cyclic_import.py",
      "testlanguage": "python",
      "expected-problems": 3,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nfrom cyclic_import import B\n\nclass A:\n    pass\n\nclass B(A):\n    pass\n\n\nclass C(B):\n    pass\n"
    },
    {
      "testname": "dict_import.py",
      "testlanguage": "python",
      "expected-problems": 12,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\nimport dir1.dir4.testmod as Imported\nfrom dir1.dir3.testmod import D as ImportedD\n\n\ndef read_class_companion_property_with_import_bad():\n    my_dict = {'key2': 0, \"key\": 1}\n    return my_dict[Imported.C.class_property]\n\n\ndef read_class_companion_property_with_import_ok():\n    my_dict = {'testmod.C.class_property': 0, \"key\": 1}\n    return my_dict[Imported.C.class_property]\n\n\ndef instance_attribute_from_class_companion_with_import_bad():\n    my_dict = {'key2': 0, \"key\": 1}\n    o = Imported.C()\n    return my_dict[o.class_property]\n\n\ndef instance_attribute_from_class_companion_with_import_ok():\n    my_dict = {'testmod.C.class_property': 0, \"key\": 1}\n    o = Imported.C()\n    return my_dict[o.class_property]\n\n\ndef instance_attribute_with_import_bad():\n    my_dict = {'key2': 0, \"key\": 1}\n    o = Imported.C()\n    return my_dict[o.property]\n\n\ndef instance_attribute_with_import_ok():\n    my_dict = {'testmod.C.instance_property': 0, \"key\": 1}\n    o = Imported.C()\n    return my_dict[o.property]\n\n\ndef read_class_companion_property_with_import_from_bad():\n    my_dict = {'key2': 0, \"key\": 1}\n    return my_dict[ImportedD.class_property]\n\n\ndef read_class_companion_property_with_import_from_ok():\n    my_dict = {'testmod.D.class_property': 0, \"key\": 1}\n    return my_dict[ImportedD.class_property]\n\n\ndef instance_attribute_from_class_companion_with_import_from_bad():\n    my_dict = {'key2': 0, \"key\": 1}\n    o = ImportedD()\n    return my_dict[o.class_property]\n\n\ndef instance_attribute_from_class_companion_with_import_from_ok():\n    my_dict = {'testmod.D.class_property': 0, \"key\": 1}\n    o = ImportedD()\n    return my_dict[o.class_property]\n\n\ndef instance_attribute_with_import_from_bad():\n    my_dict = {'key2': 0, \"key\": 1}\n    o = ImportedD()\n    return my_dict[o.property]\n\n\ndef instance_attribute_with_import_from_ok():\n    my_dict = {'testmod.D.instance_property': 0, \"key\": 1}\n    o = ImportedD()\n    return my_dict[o.property]\n"
    },
    {
      "testname": "dict_level0.py",
      "testlanguage": "python",
      "expected-problems": 28,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n\ndef dict_missing_key_const_str_ok():\n    d = dict(name=\"Alice\", age=25, city=\"New York\")\n    return d[\"name\"]\n\n\ndef dict_missing_key_const_str_bad():\n    d = {\"John\": 30, \"Mary\": 28}\n    return d[\"Samantha\"]\n\n\ndef dict_size1_missing_key_const_str_bad():\n    d = {\"John\": 30}  # use build_map instead of build_const_key_map\n    return d[\"Samantha\"]\n\n\ndef dict_missing_key_const_str_with_int_key_bad():\n    d = {\"John\": 30, \"Mary\": 28, 1: 234}\n    return d[\"Samantha\"]\n\n\ndef dict_missing_key_const_str_store_int_key_bad():\n    d = {\"John\": 30, \"Mary\": 28}\n    d[1] = 234\n    return d[\"Samantha\"]\n\n\ndef dict_missing_key_const_str_store_str_key_ok(s):\n    d = {\"John\": 30, \"Mary\": 28}\n    s = str(s)\n    d[s] = 234\n    return d[\"Samantha\"]\n\n\ndef dict_set_key_after_init_ok():\n    d = {\"John\": 30, \"Mary\": 28}\n    d[\"Samantha\"] = 60\n    return d[\"Samantha\"]\n\n\ndef get_dict():\n    return {\"John\": 30, \"Mary\": 28}\n\n\ndef dict_access_fun_call_ok():\n    ages = get_dict()\n    return ages[\"John\"]\n\n\ndef dict_access_fun_call_bad():\n    ages = get_dict()\n    return ages[\"Samantha\"]\n\n\ndef get_val():\n    return 1\n\n\ndef dict_missing_key_var_ok():\n    y = get_val()\n    d = {\"ABC\": 1, y: 2}\n    return d[1]\n\n\ndef dict_missing_key_dict_builtin_const_map_bad():\n    d = dict({\"John\": 30, \"Mary\": 28, 1: 234})\n    return d[\"missing_key\"]\n\n\ndef dict_missing_key_builtin_empty_bad():\n    d = dict()\n    return d[\"missing_key\"]\n\n\ndef fn_dict_missing_key_builtin_empty_list_bad():\n    d = dict([])\n    return d[\"missing_key\"]\n\n\ndef fn_dict_missing_key_builtin_list_comp_bad():\n    d = dict([(x, x) for x in range(10)])\n    return d[\"missing_key\"]\n\n\ndef fn_dict_missing_key_named_arguments_bad():\n    d = dict(name=\"Alice\", city=\"New York\")\n    return d[\"missing_key\"]\n\n\ndef dict_missing_str_key_in_op_ok():\n    d = dict({\"John\": 30, \"Mary\": 28, 1: 234})\n    if \"missing_key\" in d:\n        return d[\"missing_key\"]\n    else:\n        return 0\n\n\ndef dict_missing_str_key_in_op_bad():\n    d = dict({\"John\": None, \"Mary\": 28, 1: 234})\n    if \"John\" in d:\n        return d[\"missing_key\"]\n    else:\n        return 0\n\n\ndef dict_missing_str_key_not_const_in_op_ok(x):\n    k = str(x)\n    d = dict({\"John\": None, \"Mary\": 28, 1: 234, k: \"unknown\"})\n    if \"missing_key\" in d:\n        return d[\"missing_key\"]\n    else:\n        return 0\n\n\ndef dict_missing_str_key_not_const_in_op_ok2(x):\n    d = dict({\"John\": None, \"Mary\": 28, 1: 234})\n    k = str(x)\n    d[k] = \"unknown\"\n    if \"John\" in d:\n        return d[\"missing_key\"]\n    else:\n        return 0\n\n\ndef dict_missing_int_key_in_op_ok():\n    d = dict({\"John\": 30, \"Mary\": 28, 1: 234})\n    if 1 in d:\n        return d[1]\n    else:\n        return 0\n\n\ndef fp_dict_missing_int_key_in_op_ok():\n    d = dict({\"John\": 30, \"Mary\": 28, 1: 234})\n    if 2 in d:\n        return d[\"missing\"]\n    else:\n        return 0\n\n\ndef fp_test_dict_kwargs_ok():\n    key_dict = {\n        \"key1\": 1,\n        **({}),\n        \"key2\": 2,\n    }\n    return key_dict[\"key2\"]\n\n\ndef fn_test_str_key_access_with_loop_bad():\n    d = {\"a\": 1, \"b\": 2}\n    keys = [\"a\", \"b\", \"c\"]\n    for key in keys:\n        print(d[key])\n\n\ndef get_val(d, key):\n    return d[key]\n\n\ndef fn_test_str_key_param_bad():\n    d = {\"a\": 1, \"b\": 2}\n    print(get_val(d, \"c\"))\n\n\ndef fp_with_exec_ok():\n    ns = {}\n    code = \"ns['inner'] = 1\"\n    exec(code)\n    return ns[\"inner\"]\n"
    },
    {
      "testname": "dict_object_oriented.py",
      "testlanguage": "python",
      "expected-problems": 28,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nclass Box:\n    def __init__(self, key):\n        self.key = key\n\n    def get_key(self):\n        return self.key\n\n    def set_key(self, val):\n        self.key = val\n\n\ndef set_attribute_with_init_bad():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key2\")\n    return my_dict[box.key]\n\n\ndef set_attribute_with_init_ok():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key0\")\n    return my_dict[box.key]\n\n\ndef set_attribute_with_init_read_with_getter_bad():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key2\")\n    return my_dict[box.get_key()]\n\n\ndef set_attribute_with_init_read_with_getter_ok():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key0\")\n    return my_dict[box.get_key()]\n\n\ndef set_attribute_with_setter_read_with_getter_bad():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key0\")\n    box.set_key(\"key2\")\n    return my_dict[box.get_key()]\n\n\ndef set_attribute_with_setter_read_with_getter_ok():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key2\")\n    box.set_key(\"key0\")\n    return my_dict[box.get_key()]\n\n\n# requires specialization because box could be anything\ndef return_get_key(box):\n    return box.get_key()\n\n\ndef set_attribute_with_init_read_with_return_get_key_bad():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key2\")\n    return my_dict[return_get_key(box)]\n\n\ndef set_attribute_with_init_read_with_return_get_key_ok():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key0\")\n    return my_dict[return_get_key(box)]\n\n\n# requires specialization because box and dict could be anything\n# the generated summary returns an unknown value because of subscript builtin\ndef read_dict_using_get_key(d, box):\n    return d[box.get_key()]\n\n\ndef fn_set_attribute_with_init_read_with_external_call_bad():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key2\")\n    return read_dict_using_get_key(my_dict, box)\n\n\ndef set_attribute_with_init_read_with_external_call_ok():\n    my_dict = {\"key0\": 0, \"key1\": 1}\n    box = Box(\"key0\")\n    return read_dict_using_get_key(my_dict, box)\n\n\nclass D:\n    class_property1 = \"key1\"\n\n    def __init__(self):\n        self.key = \"instance_key\"\n\n\ndef read_class_companion_property_bad():\n    my_dict = {\"key2\": 0, \"key\": 1}\n    return my_dict[D.class_property1]\n\n\ndef read_class_companion_property_ok():\n    my_dict = {\"key1\": 0, \"key\": 1}\n    return my_dict[D.class_property1]\n\n\ndef instance_attribute_from_class_companion_bad():\n    my_dict = {\"key2\": 0, \"key\": 1}\n    d = D()\n    return my_dict[d.class_property1]\n\n\ndef instance_attribute_from_class_companion_ok():\n    my_dict = {\"key1\": 0, \"key\": 1}\n    d = D()\n    return my_dict[d.class_property1]\n\n\ndef instance_attribute_bad():\n    my_dict = {\"key2\": 0, \"key\": 1}\n    d = D()\n    return my_dict[d.key]\n\n\ndef instance_attribute_ok():\n    my_dict = {\"key1\": 0, \"instance_key\": 1}\n    d = D()\n    return my_dict[d.key]\n\n\n# TODO: implement missing-attribute logic\n# (we will need to make sure the capture is deep enough regarding inherited class)\n# TODO: decide if missing-attribute deserves a specific signal, distinct from dict-missing-key\ndef fn_neither_instance_nor_class_attribute_bad():\n    d = D()\n    return d.unknown\n\n\nclass DictField:\n\n    def get_key_bad(self):\n        self.d = {\"name\": \"Alice\", \"city\": \"New York\"}\n        return self.d[\"bla\"]\n"
    },
    {
      "testname": "unusual_compiler_patterns.py",
      "testlanguage": "python",
      "expected-problems": 1,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n# the purpose of these tests is not to raise Infer signals,\n# but rather to check for absence of crashes\n\ndef long_opstack_with_duplicated_calls():\n    l = make(\n        x1 = e1,\n        x2 = e2,\n        x3 = e3,\n        x4 = e4,\n        x5 = e5,\n        x6 = e6,\n        x7 = e7,\n        x8 = e8,\n        x_cond = v_true if b else v_false,\n        x9 = e9,\n        x10 = e10,\n        x11 = e11,\n        x12 = e12,\n        x13 = e13,\n        x14 = e14,\n        x15 = e15,\n    )\n    return [ f(x) for x in l ]\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n"
    },
    {
      "testname": "demo0.py",
      "testlanguage": "python",
      "expected-problems": 4,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n# InferPython has a new checker: assertion error detection\n\ndef returns_false():\n    return False\n\n\ndef returns_true():\n    return True\n\n\ndef assert_ok():\n    assert returns_true()\n\n\ndef assert_bad():\n    assert returns_false()\n"
    },
    {
      "testname": "demo1.py",
      "testlanguage": "python",
      "expected-problems": 6,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n# InferPython now supports objects instanciation and duck typing\n\nclass Duck:\n    def quack(self):\n        return True\n\n\nclass Cow:\n    def quack(self):\n        return False\n\n\ndef a_duck_can_quack_ok():\n    duck = Duck()\n    assert duck.quack()\n\n\ndef a_cow_can_not_quack_bad():\n    cow = Cow()\n    assert cow.quack()\n"
    },
    {
      "testname": "demo2.py",
      "testlanguage": "python",
      "expected-problems": 7,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nclass Duck:\n    def quack(self):\n        return True\n\n\nclass Cow:\n    def quack(self):\n        return False\n\n\n# InferPython tries to do without type annotations hints\n# Remark we really don't know much about 'animal' param here\ndef animal_can_quack(animal):\n    return animal.quack()\n\n\ndef a_duck_can_quack_ok():\n    duck = Duck()\n    assert animal_can_quack(duck)\n\n\ndef a_cow_can_not_quack_bad():\n    cow = Cow()\n    assert animal_can_quack(cow)\n"
    },
    {
      "testname": "demo3.py",
      "testlanguage": "python",
      "expected-problems": 8,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n#InferPython now supports single inheritance\n\nclass Animal:\n    def can_quack(self):\n        return self.quack()\n\n\nclass Duck(Animal):\n    def quack(self):\n        return True\n\n\nclass Cow(Animal):\n    def quack(self):\n        return False\n\n\ndef a_duck_can_quack_ok():\n    duck = Duck()\n    assert duck.can_quack()\n\n\ndef a_cow_can_not_quack_bad():\n    cow = Cow()\n    assert cow.can_quack()\n"
    },
    {
      "testname": "demo4.py",
      "testlanguage": "python",
      "expected-problems": 8,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n#InferPython now supports method overriding\n\nclass Animal:\n    def quack(self):\n        return False\n\n\n    def can_quack(self):\n        return self.quack()\n\n\n\nclass Duck(Animal):\n    # we ovveride quack()\n    def quack(self):\n        return True\n\n\nclass Cow(Animal):\n    # quack() in inherited from Animal\n    pass\n\n\ndef a_duck_can_quack_ok():\n    duck = Duck()\n    assert duck.can_quack()\n\n\ndef a_cow_can_not_quack_bad():\n    cow = Cow()\n    assert cow.can_quack()\n"
    },
    {
      "testname": "demo5.py",
      "testlanguage": "python",
      "expected-problems": 7,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nclass Animal:\n    quack = False\n\n    def can_quack(self):\n        return self.quack\n\nclass Duck(Animal):\n    def __init__(self):\n        self.quack = True\n\nclass Cow(Animal):\n    pass\n\n\n# This is too hard for us right now.\n# In the corresponding duck-specialized summary of Animal.can_quack, we make\n# a wrong assumption about the localization of 'quack' attribute\n# I would liek to invalidate such a wrong assumption with a new kind of\n# specialization kay, but this is further work\ndef FP_a_duck_can_quack_ok():\n    duck = Duck()\n    assert duck.can_quack()\n\n\ndef a_cow_can_not_quack_bad():\n    cow = Cow()\n    assert cow.can_quack()\n"
    },
    {
      "testname": "testmod.py",
      "testlanguage": "python",
      "expected-problems": 2,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nasync def await_it(arg):\n    await arg\n\nasync def dont_await_it(arg):\n    pass\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": ""
    },
    {
      "testname": "testmod.py",
      "testlanguage": "python",
      "expected-problems": 9,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nasync def await_it(arg):\n    await arg\n\nasync def dont_await_it(arg):\n    pass\n\n@final\nclass C:\n\n    @staticmethod\n    async def async_fun():\n        pass\n\n\nclass D:\n    class_property = \"testmod.D.class_property\"\n    def __init__(self):\n        self.property = \"testmod.D.instance_property\"\n\n\ndef wait(arg):\n    \"\"\"\n    This function is expected to be modeled as awaiting its argument because of .inferconfig\n    \"\"\"\n    pass\n\ndef deep_wait(*arg):\n    \"\"\"\n    This function is expected to be modeled as awaiting deeply its arguments because of .inferconfig\n    \"\"\"\n    pass\n\n\ndef id(b):\n    return b\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": ""
    },
    {
      "testname": "skipped.py",
      "testlanguage": "python",
      "expected-problems": 1,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\ndef id(b):\n    return b\n"
    },
    {
      "testname": "testmod.py",
      "testlanguage": "python",
      "expected-problems": 4,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nasync def await_it(arg):\n    await arg\n\nasync def dont_await_it(arg):\n    pass\n\n\nclass C:\n    class_property = \"testmod.C.class_property\"\n    def __init__(self):\n        self.property = \"testmod.C.instance_property\"\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": ""
    },
    {
      "testname": "testmod.py",
      "testlanguage": "python",
      "expected-problems": 2,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nasync def await_it(arg):\n    await arg\n\nasync def dont_await_it(arg):\n    pass\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": ""
    },
    {
      "testname": "testmod.py",
      "testlanguage": "python",
      "expected-problems": 2,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nasync def await_it(arg):\n    await arg\n\nasync def dont_await_it(arg):\n    pass\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": ""
    },
    {
      "testname": "testmod.py",
      "testlanguage": "python",
      "expected-problems": 2,
      "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nasync def await_it(arg):\n    await arg\n\nasync def dont_await_it(arg):\n    pass\n"
    },
    {
      "testname": "__init__.py",
      "testlanguage": "python",
      "expected-problems": 0,
      "code": ""
    }
  ]
}