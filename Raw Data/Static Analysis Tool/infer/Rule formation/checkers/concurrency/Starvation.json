{
  "name": "Starvation",
  "language": [
    "clang",
    "java"
  ],
  "description": "Detect various kinds of situations when no progress is being made because of \\\n           concurrency errors.",
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "OCaml",
  "loc": 865,
  "branches": 102,
  "apis": 144,
  "test": [
    {
      "testname": "basic.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct BasicMut {\n  int blah;\n};\nvoid pthread_mutex_lock(struct BasicMut*);\nvoid pthread_mutex_lock1(struct BasicMut*);\nvoid pthread_mutex_unlock(struct BasicMut*);\n\nstruct BasicMut m1;\nstruct BasicMut m2;\n\nint simple_null_pointer() {\n  pthread_mutex_lock1(&m1);\n  pthread_mutex_lock(&m2);\n  pthread_mutex_unlock(&m2);\n  pthread_mutex_unlock(&m1);\n  return 0;\n}\n\nint null_pointer_interproc() {\n  pthread_mutex_lock(&m2);\n  pthread_mutex_lock1(&m1);\n  pthread_mutex_unlock(&m1);\n  pthread_mutex_unlock(&m2);\n  return 1;\n}\n"
    },
    {
      "testname": "dynamic_alloc.c",
      "testlanguage": "c",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct FakeMut {\n  int blah;\n};\nvoid pthread_mutex_lock(struct FakeMut*);\nvoid pthread_mutex_lock1(struct FakeMut*);\nvoid pthread_mutex_unlock(struct FakeMut*);\nvoid* malloc(unsigned long);\n\nstruct FakeMut global_m1;\n\nstruct MutexWrapper {\n  struct FakeMut* mutex;\n};\n\nstruct Wrapper {\n  struct FakeMut* m1;\n  struct MutexWrapper m2;\n  void (*fn1)(struct Wrapper*);\n};\n\nstruct SomethingElse {\n  int foo;\n};\n\nstruct SomethingElse some_global;\n\nvoid mutex_wrapper_lock(struct MutexWrapper w) { pthread_mutex_lock(w.mutex); }\n\nvoid lock_m2_and_do_soemthing_else(struct SomethingElse* other) {\n  pthread_mutex_lock(&global_m1);\n}\n\nvoid wrap_lock_direct(struct FakeMut* m) { pthread_mutex_lock(m); }\n\nvoid wrap_locking_m2(struct Wrapper* str) { mutex_wrapper_lock(str->m2); }\n\nint m1_then_m2(struct Wrapper* s) {\n  wrap_lock_direct(s->m1);\n  struct Wrapper s1 = *s;\n  (*s1.fn1)(s);\n  struct SomethingElse* other = malloc(100);\n  lock_m2_and_do_soemthing_else(other);\n  pthread_mutex_unlock(&global_m1);\n  pthread_mutex_unlock(s->m2.mutex);\n  pthread_mutex_unlock(s->m1);\n  return 0;\n}\n\nint simple_locking(struct Wrapper* s) {\n  pthread_mutex_lock(&global_m1);\n  pthread_mutex_lock(s->m2.mutex);\n  pthread_mutex_lock(s->m1);\n  pthread_mutex_unlock(s->m1);\n  pthread_mutex_unlock(s->m2.mutex);\n  pthread_mutex_unlock(&global_m1);\n  return 1;\n}\n"
    },
    {
      "testname": "function_pointer.c",
      "testlanguage": "c",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct FakeMut {\n  int blah;\n};\nvoid pthread_mutex_lock(struct FakeMut*);\nvoid pthread_mutex_unlock(struct FakeMut*);\n\nstruct FakeMut m1_fptr;\nstruct FakeMut m2_fptr;\n\nvoid lock_m2_fptr_indirectly() { pthread_mutex_lock(&m2_fptr); }\n\nvoid (*LOCK_M2_INDIRECTLY)(void) = &lock_m2_fptr_indirectly;\n\nint lock_m2_fptr_m1_fptr_function_pointer() {\n  pthread_mutex_lock(&m1_fptr);\n  (*LOCK_M2_INDIRECTLY)();\n  pthread_mutex_unlock(&m2_fptr);\n  pthread_mutex_unlock(&m1_fptr);\n  return 0;\n}\n\nint lock_m2_fptr_m1_fptr_no_function_pointer() {\n  pthread_mutex_lock(&m2_fptr);\n  pthread_mutex_lock(&m1_fptr);\n  pthread_mutex_unlock(&m1_fptr);\n  pthread_mutex_unlock(&m2_fptr);\n  return 1;\n}\n"
    },
    {
      "testname": "interproc_dedup.c",
      "testlanguage": "c",
      "expected-problems": 6,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct FakeMut {\n  int blah;\n};\nvoid pthread_mutex_lock(struct FakeMut*);\nvoid pthread_mutex_unlock(struct FakeMut*);\n\nstruct FakeMut dedup_m1;\nstruct FakeMut dedup_m2;\n\n/*\n * This might deadlock or might not, depending on functions\n * direct_one_way_bad and indirect_one_way_bad always being run on the\n * same thread or not.\n *\n * --starvation-whole-program assumes these can run in parallel\n */\n\nint direct_one_way_bad() {\n  pthread_mutex_lock(&dedup_m1);\n  pthread_mutex_lock(&dedup_m2);\n  pthread_mutex_unlock(&dedup_m2);\n  pthread_mutex_unlock(&dedup_m1);\n  return 0;\n}\n\nvoid indirect_one_way_bad() {\n  direct_one_way_bad();\n}\n\nint main() {\n  pthread_mutex_lock(&dedup_m2);\n  indirect_one_way_bad();\n  pthread_mutex_unlock(&dedup_m2);\n  return 0;\n}\n"
    },
    {
      "testname": "nested_unbalanced_locks.c",
      "testlanguage": "c",
      "expected-problems": 14,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct FakeMut {\n  int blah;\n};\nvoid pthread_mutex_lock(struct FakeMut*);\nvoid pthread_mutex_lock1(struct FakeMut*);\nvoid pthread_mutex_unlock(struct FakeMut*);\n\nstruct FakeMut m1;\nstruct FakeMut m2;\n\nvoid lock_m1() { pthread_mutex_lock(&m1); }\nvoid unlock_m1() { pthread_mutex_unlock(&m1); }\n\nstruct Ctx {\n  int some_data;\n};\n\nstruct Ctx ctx;\nstruct Ctx ctx2;\nvoid lock_m2(struct Ctx* c) { pthread_mutex_lock(&m2); }\n\n// spec: C: 0, H: m1, U: 0\nvoid wrap_lock_m1() {\n  // A: 0, H: 0, U: 0\n  lock_m1(); // lock(m1)\n  // A: {m1}, H: {m1}, U: 0\n  // C: {0, {m1}}\n  // C \\ H: 0, H: 0, U: 0\n}\n\nvoid wrap_unlock_m1() { pthread_mutex_unlock(&m1); }\n\nvoid wrap_lock_m2(struct Ctx* c) { lock_m2(&ctx); }\n\nvoid wrap_unlock_m2() { pthread_mutex_unlock(&m2); }\n// This should deadlock with direct_m2_m1(), but the analysis needs to\n// see lock_m1() acquires the lock and apply that interprocedurally\n// spec: C: {0, m1}, {{m1}, m2}}, H: 0, U: 0\nint nested_unbalanced_lock() {\n  // A: 0, H: 0, U: 0\n  wrap_lock_m1(); // lock(m1);\n  // A: {m1}, H: {m1}, U: 0\n  wrap_lock_m2(&ctx2);\n  // A: {m1, m2}, H: {m1, m2}, U: 0\n  wrap_unlock_m2();\n  // A: {m1, m2}, H: {m1}, U: 0\n  wrap_unlock_m1();\n  // A: {m1, m2}, H: 0, U: 0\n  // C: {{0, m1}, {{m2}, m1}}\n\n  return 0;\n}\n\nint direct_m2_m1_lock() {\n  pthread_mutex_lock(&m2);\n  pthread_mutex_lock(&m1);\n  pthread_mutex_unlock(&m1);\n  pthread_mutex_unlock(&m2);\n  return 1;\n}\n"
    },
    {
      "testname": "unbalanced_locks.c",
      "testlanguage": "c",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nstruct AMutex {\n  int blah;\n};\nvoid pthread_mutex_lock(struct AMutex*);\nvoid pthread_mutex_lock1(struct AMutex*);\nvoid pthread_mutex_unlock(struct AMutex*);\n\nstruct AMutex m1;\nstruct AMutex m2;\n\nvoid lock_m1_wrap() { pthread_mutex_lock(&m1); }\nvoid unlock_m1_wrap() { pthread_mutex_unlock(&m1); }\n\n// This should deadlock with direct_m2_m1(), but the analysis needs to\n// see lock_m1() acquires the lock and apply that interprocedurally\nint simple_unbalanced_lock() {\n  lock_m1_wrap();\n  pthread_mutex_lock(&m2);\n  pthread_mutex_unlock(&m2);\n  pthread_mutex_unlock(&m1);\n  return 0;\n}\n\nint balanced_m2_m1_lock() {\n  pthread_mutex_lock(&m2);\n  pthread_mutex_lock(&m1);\n  pthread_mutex_unlock(&m1);\n  pthread_mutex_unlock(&m2);\n  return 1;\n}\n\n// This shouldn't deadlock, because m1 and m2 are never held togehter\n// But the analysis must see unlock_m1 unlocks m1, otherwise it would\n// report deadlock\nint indirect_unlock_m1() {\n  pthread_mutex_lock(&m1);\n  unlock_m1_wrap();\n  pthread_mutex_lock(&m2);\n  return 1;\n}\n"
    },
    {
      "testname": "basics.cpp",
      "testlanguage": "c++",
      "expected-problems": 34,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nnamespace basics {\n\nclass Basic {\n public:\n  Basic() {}\n\n  // deadlock between thread1_bad() and thread2_bad()\n  void thread1_bad() {\n    mutex_1.lock();\n    mutex_2.lock();\n\n    mutex_2.unlock();\n    mutex_1.unlock();\n  }\n\n  void thread2_bad() {\n    mutex_2.lock();\n    mutex_1.lock();\n\n    mutex_1.unlock();\n    mutex_2.unlock();\n  }\n\n private:\n  std::mutex mutex_1;\n  std::mutex mutex_2;\n};\n\nclass WithGuard {\n public:\n  WithGuard() {}\n\n  // deadlock between thread1_bad() and thread2_bad()\n  void thread1_bad() {\n    std::lock_guard<std::mutex> lock1(mutex_1);\n    std::lock_guard<std::mutex> lock2(mutex_2);\n  }\n\n  void thread2_bad() {\n    std::lock_guard<std::mutex> lock2(mutex_2);\n    std::lock_guard<std::mutex> lock1(mutex_1);\n  }\n\n private:\n  std::mutex mutex_1;\n  std::mutex mutex_2;\n};\n\nclass DeferredGuard {\n public:\n  DeferredGuard() {}\n\n  // NO deadlock between thread1_bad() and thread2_bad()\n  void thread1_ok() {\n    std::unique_lock<std::mutex> lock1(mutex_1, std::defer_lock);\n    std::unique_lock<std::mutex> lock2(mutex_2);\n  }\n\n  void thread2_ok() {\n    std::lock_guard<std::mutex> lock2(mutex_2);\n    std::lock_guard<std::mutex> lock1(mutex_1);\n  }\n\n private:\n  std::mutex mutex_1;\n  std::mutex mutex_2;\n};\n\nclass StdLock {\n public:\n  StdLock() {}\n\n  // no reports, std::lock magically avoids deadlocks\n  void foo_ok() {\n    std::lock<std::mutex>(mutex_1, mutex_2);\n    mutex_1.unlock();\n    mutex_2.unlock();\n  }\n\n  void bar_ok() {\n    std::lock<std::mutex>(mutex_2, mutex_1);\n    mutex_2.unlock();\n    mutex_1.unlock();\n  }\n\n private:\n  std::mutex mutex_1;\n  std::mutex mutex_2;\n};\n\nclass SelfDeadlock {\n public:\n  SelfDeadlock() {}\n\n  void thread_bad() {\n    mutex_.lock();\n    mutex_.lock();\n    mutex_.unlock();\n    mutex_.unlock();\n  }\n\n  void interproc2_bad() { std::lock_guard<std::mutex> lock(mutex_); }\n\n  void interproc1_bad() {\n    std::lock_guard<std::mutex> lock(mutex_);\n    interproc2_bad();\n  }\n\n  void foo_ok() {\n    { std::lock_guard<std::mutex> lock(mutex_); }\n    int i = 0;\n    { std::lock_guard<std::mutex> lock(mutex_); }\n  }\n\n  void bar_ok() {\n    std::unique_lock<std::mutex> lock1(mutex_, std::defer_lock);\n    std::lock_guard<std::mutex> lock2(mutex_);\n  }\n\n  void complicated_bad() {\n    std::unique_lock<std::mutex> lock1(mutex_, std::defer_lock);\n    std::lock_guard<std::mutex> lock2(mutex_);\n    lock1.lock();\n  }\n\n private:\n  std::mutex mutex_;\n};\n\nclass PathSensitive {\n public:\n  void FP_ok() {\n    std::lock_guard<std::mutex> l(mutex_);\n    bool flag = false;\n\n    if (flag) {\n      std::lock_guard<std::mutex> l(mutex_);\n    }\n  }\n\n private:\n  std::mutex mutex_;\n};\n} // namespace basics\n"
    },
    {
      "testname": "crossfile-1.cpp",
      "testlanguage": "c++",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"crossfile-1.h\"\n\n// a deadlock should be reported here\nvoid CrossFileOne::lock_my_mutex_first_then_the_other(CrossFileTwo* other) {\n  _mutex.lock();\n  other->just_lock_my_mutex();\n  _mutex.unlock();\n}\n\nvoid CrossFileOne::just_lock_my_mutex() {\n  _mutex.lock();\n  _mutex.unlock();\n}\n"
    },
    {
      "testname": "crossfile-2.cpp",
      "testlanguage": "c++",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"crossfile-2.h\"\n\n// a deadlock should be reported here\nvoid CrossFileTwo::lock_my_mutex_first_then_the_other(CrossFileOne* other) {\n  _mutex.lock();\n  other->just_lock_my_mutex();\n  _mutex.unlock();\n}\n\nvoid CrossFileTwo::just_lock_my_mutex() {\n  _mutex.lock();\n  _mutex.unlock();\n}\n"
    },
    {
      "testname": "guarded_interprocedural_locks.cpp",
      "testlanguage": "c++",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <mutex>\nstd::mutex mtx1;\nstd::mutex mtx2;\n\nvoid mtx1_mtx2() {\n  std::unique_lock<std::mutex> g1(mtx1);\n  std::unique_lock<std::mutex> g2(mtx2);\n}\n\nstd::unique_lock<std::mutex> lock_with_unique() {\n  return std::unique_lock<std::mutex>(mtx2);\n}\n\nvoid unlock_lck(std::unique_lock<std::mutex>& l) { l.unlock(); }\n\n// This test is meant to demostrate that starvation\n// doesn't work with guards. It's not supposed to deadlock\n// becuase guard is unlocked with unlock_lck(g1), but guards\n// aren't tracked interprocredurally, so this doesn't work.\n// For now, we just disabled guarded locks in interprocedural setting\n// to fix this issue\n\nvoid mtx2_mtx1() {\n  auto g1 = lock_with_unique();\n  unlock_lck(g1);\n  std::unique_lock<std::mutex> g2(mtx1);\n  // Need to unlock here, because otherwise mtx2 is unbalanced and\n  //  it would be filtered due to that\n  mtx2.unlock();\n}\n"
    },
    {
      "testname": "recursive.cpp",
      "testlanguage": "c++",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\nstruct UnknownMutex {\n  UnknownMutex() {}\n\n  void lock() {}\n\n  void unlock() {}\n\n  UnknownMutex(const UnknownMutex&) = delete;\n  UnknownMutex& operator=(const UnknownMutex&) = delete;\n};\n\nclass Recursive {\n public:\n  Recursive() {}\n\n  void multi_ok() {\n    std::lock_guard<std::recursive_mutex> l(recursive_mutex_);\n    { std::lock_guard<std::recursive_mutex> l(recursive_mutex_); }\n  }\n\n  void unknown_ok() {\n    std::lock_guard<UnknownMutex> l(umutex_);\n    { std::lock_guard<UnknownMutex> l(umutex_); }\n  }\n\n private:\n  std::recursive_mutex recursive_mutex_;\n  UnknownMutex umutex_;\n};\n"
    },
    {
      "testname": "skip.cpp",
      "testlanguage": "c++",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include <mutex>\n\n// the deadlocks here are masked by the starvation-skip-analysis option in\n// .inferconfig\nnamespace skipped {\nclass Skip {\n public:\n  Skip() {}\n\n  void skipped_ok() { private_deadlock(); }\n\n  void not_skipped_bad() { private_deadlock(); }\n\n private:\n  std::mutex mutex_;\n\n  void private_deadlock() {\n    std::lock_guard<std::mutex> l(mutex_);\n    { std::lock_guard<std::mutex> l(mutex_); }\n  }\n};\n\ntemplate <class T>\nclass SkipTemplate {\n private:\n  T* a_;\n  std::mutex mutex_;\n\n  void private_deadlock() {\n    std::lock_guard<std::mutex> l(mutex_);\n    { std::lock_guard<std::mutex> l(mutex_); }\n  }\n\n public:\n  void skipped_ok() { private_deadlock(); }\n\n  void not_skipped_bad() { private_deadlock(); }\n};\n\nclass UseTemplate {\n public:\n  void foo() {\n    x.skipped_ok();\n    x.not_skipped_bad();\n  }\n\n private:\n  SkipTemplate<void> x;\n};\n\n} // namespace skipped\n"
    },
    {
      "testname": "AsyncTaskGet.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.AsyncTask;\nimport android.support.annotation.UiThread;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nclass AsyncTaskGet {\n  CountTask task;\n  Object lock;\n\n  @UiThread\n  void taskGetOnUiThreadBad() throws InterruptedException, ExecutionException {\n    task.get();\n  }\n\n  @UiThread\n  void taskGetWithTimeoutOnUiThreadOk()\n      throws TimeoutException, InterruptedException, ExecutionException {\n    task.get(1000, TimeUnit.NANOSECONDS);\n  }\n\n  @UiThread\n  void lockOnUiThreadBad() {\n    synchronized (lock) {\n    }\n  }\n\n  void taskGetUnderLock() throws InterruptedException, ExecutionException {\n    synchronized (lock) {\n      task.get();\n    }\n  }\n\n  void taskGetonBGThreadOk() throws InterruptedException, ExecutionException {\n    task.get();\n  }\n}\n\nclass CountTask extends AsyncTask<Integer, Void, Long> {\n  protected Long doInBackground(Integer... ints) {\n    long totalSize = 0;\n    for (int i = 0; i < ints.length; i++) {\n      totalSize += ints[i];\n      if (isCancelled()) break;\n    }\n    return totalSize;\n  }\n}\n"
    },
    {
      "testname": "Binders.java",
      "testlanguage": "java",
      "expected-problems": 18,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.content.Context;\nimport android.media.AudioManager;\nimport android.net.ConnectivityManager;\nimport android.net.wifi.WifiManager;\nimport android.os.Binder;\nimport android.os.RemoteException;\nimport android.support.annotation.UiThread;\nimport android.view.Display;\n\nclass Binders {\n  Binder b;\n\n  void doTransact() throws RemoteException {\n    b.transact(0, null, null, 0);\n  }\n\n  void doOneWayTransact() throws RemoteException {\n    b.transact(0, null, null, 1);\n  }\n\n  // assert happens after bad call so thread status is still unknown\n  void FN_interBad() throws RemoteException {\n    b.transact(0, null, null, 0);\n    forceMainThread();\n  }\n\n  void interBad() throws RemoteException {\n    forceMainThread();\n    b.transact(0, null, null, 0);\n  }\n\n  void intraBad() throws RemoteException {\n    OurThreadUtils.assertMainThread();\n    doTransact();\n  }\n\n  @UiThread\n  void annotationBad() throws RemoteException {\n    doTransact();\n  }\n\n  void intraOk() throws RemoteException {\n    b.transact(0, null, null, 0);\n  }\n\n  void interOk() throws RemoteException {\n    doTransact();\n  }\n\n  void oneWayOk() throws RemoteException {\n    OurThreadUtils.assertMainThread();\n    doOneWayTransact();\n  }\n\n  void forceMainThread() {\n    OurThreadUtils.assertMainThread();\n  }\n\n  @UiThread\n  void getActiveNetworkInfoBad(ConnectivityManager c) {\n    c.getActiveNetworkInfo();\n  }\n\n  @UiThread\n  int doGetStreamVolumeBad(AudioManager a) {\n    return a.getStreamVolume(0);\n  }\n\n  @UiThread\n  int doGetRingerModeBad(AudioManager a) {\n    return a.getRingerMode();\n  }\n\n  @UiThread\n  int doCheckPermissionBad(Context c) {\n    return c.checkPermission(\"\", 0, 0);\n  }\n\n  @UiThread\n  int doCheckSelfPermissionBad(Context c) {\n    return c.checkSelfPermission(\"\");\n  }\n\n  @UiThread\n  void doGetConnectionInfoBad(WifiManager w) {\n    w.getConnectionInfo();\n  }\n\n  @UiThread\n  void doGetRealSizeBad(Display d) {\n    d.getRealSize(null);\n  }\n}\n"
    },
    {
      "testname": "Countdwn.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport java.util.concurrent.CountDownLatch;\n\nclass Countdwn {\n  CountDownLatch latch;\n\n  void awaitOnMainByCallBad() throws InterruptedException {\n    OurThreadUtils.assertMainThread();\n    latch.await();\n  }\n\n  @UiThread\n  void awaitOnMainByAnnotBad() throws InterruptedException {\n    latch.await();\n  }\n\n  void countDownOk() throws InterruptedException {\n    OurThreadUtils.assertMainThread();\n    latch.countDown();\n  }\n\n  void awaitOnAnyThreadOk() throws InterruptedException {\n    latch.await();\n  }\n}\n"
    },
    {
      "testname": "FutureGet.java",
      "testlanguage": "java",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport com.google.common.base.Preconditions;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nclass FutureGet {\n  Future future;\n  Object lock;\n\n  @UiThread\n  void getDirectBad() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n\n  @UiThread\n  void getIndirectBad() {\n    synchronized (lock) {\n    }\n  }\n\n  void getUnderLock() throws InterruptedException, ExecutionException {\n    synchronized (lock) {\n      future.get();\n    }\n  }\n\n  void getOnOtherThreadOk() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n\n  @UiThread\n  void getTimeoutOneDayBad() throws InterruptedException, ExecutionException {\n    try {\n      future.get(1L, TimeUnit.DAYS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  void getTimeoutOneSecondOk() throws InterruptedException, ExecutionException {\n    try {\n      future.get(1L, TimeUnit.SECONDS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  void getTimeoutOneHourBad() throws InterruptedException, ExecutionException {\n    try {\n      future.get(1L, TimeUnit.HOURS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  void getTimeoutFourSecondsOk() throws InterruptedException, ExecutionException {\n    try {\n      future.get(4L, TimeUnit.SECONDS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  void getTimeout4999MilliSecondsOk() throws InterruptedException, ExecutionException {\n    try {\n      future.get(4999L, TimeUnit.MILLISECONDS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  void getTimeout50000001MicroSecondsBad() throws InterruptedException, ExecutionException {\n    try {\n      future.get(5000001L, TimeUnit.MICROSECONDS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  void getTimeout64BitsBad() throws InterruptedException, ExecutionException {\n    try {\n      future.get(9223372036854775807L, TimeUnit.MICROSECONDS);\n    } catch (TimeoutException e) {\n    }\n  }\n\n  @UiThread\n  Object sensitivityOnIsDoneOk() throws InterruptedException, ExecutionException {\n    if (future.isDone()) {\n      return future.get();\n    } else {\n      return null;\n    }\n  }\n\n  @UiThread\n  Object getFuturesDoneOk(Future<Object> future) throws InterruptedException, ExecutionException {\n    Preconditions.checkState(future.isDone());\n    return future.get();\n  }\n\n  Object assertNotOnUIThreadOk(Future<Object> future)\n      throws InterruptedException, ExecutionException {\n    Preconditions.checkArgument(!OurThreadUtils.isMainThread());\n    return future.get();\n  }\n}\n"
    },
    {
      "testname": "IndirectBlock.java",
      "testlanguage": "java",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.Binder;\nimport android.os.RemoteException;\nimport android.support.annotation.UiThread;\n\nclass IndirectBlock {\n  Object expensiveLock;\n  Binder binder;\n\n  void takeExpensiveLockOk() {\n    synchronized (expensiveLock) {\n    }\n  }\n\n  @UiThread\n  void takeExpensiveLockOnUiThreadBad() {\n    synchronized (expensiveLock) {\n    }\n  }\n\n  void doTransactUnderLock() throws RemoteException {\n    synchronized (expensiveLock) {\n      binder.transact(0, null, null, 0);\n    }\n  }\n\n  @UiThread\n  void takeRemoteExpensiveLockOnUiThreadBad(IndirectInterproc i) {\n    i.takeLock();\n  }\n}\n\nclass IndirectInterproc {\n  public synchronized void takeLock() {}\n\n  public synchronized void doTransactUnderLock(Binder binder) throws RemoteException {\n    binder.transact(0, null, null, 0);\n  }\n}\n"
    },
    {
      "testname": "InnerClass.java",
      "testlanguage": "java",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass InnerClass {\n  // shouldn't be flagged\n  // we don't know that [a.this$0 == this] and even if it were\n  // this will simply lock this twice\n  synchronized void outerInnerOk(InnerClassA a) {\n    a.lockOuter();\n  }\n\n  synchronized void lockOuter() {}\n\n  // following is flagged currently but shouldn't\n  // we don't known that [a.this$0 == this]!\n  synchronized void FP_outerInnerOk(InnerClassA a) {\n    a.lockInner();\n  }\n\n  class InnerClassA {\n    void lockOuter() {\n      synchronized (InnerClass.this) {\n      }\n    }\n\n    void outerInnerOk() {\n      synchronized (InnerClass.this) {\n        InnerClass.this.lockOuter();\n      }\n    }\n\n    synchronized void lockInner() {}\n\n    synchronized void innerOuterBad() {\n      InnerClass.this.lockOuter();\n    }\n\n    // constructors generate different access paths so test these too\n    // TODO these tests do not generate yet different access paths to the above :(\n\n    // following should not be flagged -- it's a double lock on [this.this$0]\n    InnerClassA() {\n      synchronized (InnerClass.this) {\n        InnerClass.this.lockOuter();\n      }\n    }\n\n    // following would be flagged with outerInnerBad but should not\n    // because [this] is not accessible yet to any other thread!\n    InnerClassA(Object o) {\n      synchronized (this) {\n        InnerClass.this.lockOuter();\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "Interclass.java",
      "testlanguage": "java",
      "expected-problems": 12,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass Interclass {\n  synchronized void interclass1Bad(InterclassA a) {\n    a.interclass1Bad();\n  }\n\n  synchronized void interclass2Bad() {}\n\n  synchronized void interclass1Ok(InterclassB b) {\n    b.interclass1Ok();\n  }\n\n  void interclass2Ok(InterclassB b) {\n    synchronized (b) {\n    }\n  }\n\n  void reentrantOk(InterclassB b) {\n    synchronized (this) {\n      synchronized (b) {\n        b.interclass1Ok();\n      }\n    }\n  }\n}\n\nclass InterclassA {\n  synchronized void interclass1Bad() {}\n\n  synchronized void interclass2Bad(Interclass i) {\n    i.interclass2Bad();\n  }\n}\n\nclass InterclassB {\n  synchronized void interclass1Ok() {}\n\n  void interclass2_ok(Interclass c) {\n    synchronized (c) {\n      c.interclass2Ok(this);\n    }\n  }\n}\n"
    },
    {
      "testname": "Interproc.java",
      "testlanguage": "java",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass Interproc {\n  synchronized void lockThisThenParamBad(InterprocA a) {\n    lockParamA(a);\n  }\n\n  void lockParamA(InterprocA b) {\n    synchronized (b) {\n    }\n  }\n\n  synchronized void lockThisThenParamOk(InterprocB a) {\n    lockParamB(a);\n  }\n\n  void lockParamB(InterprocB b) {\n    synchronized (b) {\n    }\n  }\n\n  void lockThisTwiceOk(InterprocB b) {\n    synchronized (this) {\n      synchronized (b) {\n        lockThis();\n      }\n    }\n  }\n\n  synchronized void lockThis() {}\n}\n\nclass InterprocA {\n  synchronized void lockThisThenParamBad(Interproc c) {\n    lockParam(c);\n  }\n\n  void lockParam(Interproc d) {\n    synchronized (d) {\n    }\n  }\n}\n\nclass InterprocB {\n  void lockParamThenThisOk(Interproc c) {\n    synchronized (c) {\n      lockThis(c);\n    }\n  }\n\n  synchronized void lockThis(Interproc d) {}\n}\n"
    },
    {
      "testname": "Intraproc.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass Intraproc {\n  void intraBad(IntraprocA o) {\n    synchronized (this) {\n      synchronized (o) {\n      }\n    }\n  }\n\n  void intraOk(IntraprocB o) {\n    synchronized (this) {\n      synchronized (o) {\n      }\n    }\n  }\n\n  void reentrantOk(IntraprocB b) {\n    synchronized (this) {\n      synchronized (b) {\n        synchronized (this) {\n        }\n      }\n    }\n  }\n}\n\nclass IntraprocA {\n  void intraBad(Intraproc o) {\n    synchronized (this) {\n      synchronized (o) {\n      }\n    }\n  }\n}\n\nclass IntraprocB {\n  void intraOk(Intraproc o) {\n    synchronized (o) {\n      synchronized (this) {\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "JavaIO.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\nclass JavaIO {\n  FileReader reader;\n  DataInputStream inputStream;\n  FileWriter writer;\n  DataOutputStream outputStream;\n\n  int doFileRead() throws IOException {\n    return reader.read();\n  }\n\n  String doStreamRead() throws IOException {\n    return inputStream.readUTF();\n  }\n\n  @UiThread\n  void FN_fileReadBad() throws IOException {\n    doFileRead();\n  }\n\n  @UiThread\n  void FN_streamReadBad() throws IOException {\n    doStreamRead();\n  }\n\n  @UiThread\n  void writerMethodsOk() throws IOException {\n    writer = new FileWriter(\"bla\");\n    writer.write('a');\n    writer.append('b');\n    String enc = writer.getEncoding();\n  }\n\n  @UiThread\n  void readerMethodsOk() throws IOException {\n    reader = new FileReader(\"bla\");\n    String enc = reader.getEncoding();\n    reader.markSupported();\n    reader.reset();\n    reader.close();\n  }\n\n  @UiThread\n  void outputStreamMethodsOk() throws IOException {\n    outputStream.write('a');\n    outputStream.size();\n  }\n\n  @UiThread\n  void inputStreamMethodsOk() throws IOException {\n    inputStream.available();\n    inputStream.reset();\n    inputStream.close();\n  }\n}\n"
    },
    {
      "testname": "LazyInit.java",
      "testlanguage": "java",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.Binder;\nimport android.os.RemoteException;\nimport android.support.annotation.UiThread;\n\nclass LazyInit {\n  Binder b;\n\n  void doTransact() {\n    try {\n      b.transact(0, null, null, 0);\n    } catch (RemoteException e) {\n    }\n  }\n\n  Object init() {\n    doTransact();\n    return new Object();\n  }\n\n  @UiThread\n  Object baselineBad() {\n    return init();\n  }\n\n  Object f;\n\n  @UiThread\n  void normalLazyOk() {\n    if (f == null) {\n      f = init();\n    }\n  }\n\n  Object g;\n\n  @UiThread\n  void notLazyInitBad() {\n    if (g == null) {\n      f = init();\n    }\n  }\n\n  @UiThread\n  void notEqualsLazyOk() {\n    if (f != null) {\n    } else {\n      f = init();\n    }\n  }\n\n  @UiThread\n  void negatedEqualsLazyOk() {\n    if (!(f == null)) {\n    } else {\n      f = init();\n    }\n  }\n\n  @UiThread\n  void lazyFirstOk() {\n    if (f == null) {\n      doTransact();\n      f = new Object();\n    }\n  }\n}\n"
    },
    {
      "testname": "LegacySync.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport java.util.Hashtable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\nclass LegacySync {\n  Hashtable table;\n  Future future;\n\n  void notOnUiThreadSyncedBad() throws InterruptedException, ExecutionException {\n    synchronized (table) {\n      future.get();\n    }\n  }\n\n  @UiThread\n  Object onUiThreadOpBad() {\n    return table.get(\"blabla\");\n  }\n}\n"
    },
    {
      "testname": "LocalLock.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass LocalLock {\n  Object lock1, lock2;\n\n  Object getLock1() {\n    return lock1;\n  }\n\n  void localLockOuterOk() {\n    synchronized (getLock1()) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  Object getLock2() {\n    return lock2;\n  }\n\n  void localLockInnerOk() {\n    synchronized (this) {\n      synchronized (getLock2()) {\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "LocklessTests.java",
      "testlanguage": "java",
      "expected-problems": 20,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport com.facebook.infer.annotation.Lockless;\n\nclass LocklessTests {}\n\ninterface Listener {\n  @Lockless\n  void locklessMethod();\n\n  void normalMethod();\n}\n\nclass LocklessTestsA implements Listener {\n  // should warn\n  @Override\n  public void locklessMethod() {\n    synchronized (this) {\n    }\n  }\n\n  // no warnings here\n  @Override\n  public void normalMethod() {\n    synchronized (this) {\n    }\n  }\n}\n\nclass LocklessTestsB implements Listener {\n  // should warn\n  @Lockless\n  @Override\n  public synchronized void locklessMethod() {}\n\n  // no warnings here\n  @Override\n  public synchronized void normalMethod() {}\n}\n\nclass LocklessTestsC implements Listener {\n  private synchronized void takeLock() {}\n\n  // should warn\n  @Override\n  public void locklessMethod() {\n    takeLock();\n  }\n\n  // no warnings here\n  @Override\n  public synchronized void normalMethod() {}\n}\n"
    },
    {
      "testname": "LockSensitivity.java",
      "testlanguage": "java",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Tests documenting FPs and FNs due to lack of sensitivity in starvation analysis\n\nimport java.util.concurrent.locks.Lock;\n\nclass LockSensitivity {\n  Lock lockA, lockB;\n\n  // In the following two methods, AB vs BA deadlock pattern\n  // remains undetected since one of the locks happens via `tryLock` and result check.\n\n  public void FN_tryLockDeadlockAB_Bad() {\n    boolean locked = lockA.tryLock();\n    if (locked) {\n      lockB.lock();\n      lockB.unlock();\n      lockA.unlock();\n    } else {\n    }\n  }\n\n  public void FN_tryLockDeadlockBA_Bad() {\n    lockB.lock();\n    lockA.lock(); // deadlock: `lockA` may be locked via `tryLock()` above\n    lockA.unlock();\n    lockB.unlock();\n  }\n\n  // Asserting a lock is held is not the same as taking it wrt deadlocks.\n  // In the following two methods, AB vs BA pattern correctly not reported\n  // because the locks/unlocks would not be balanced within the method\n\n  Object monitorA, monitorB;\n\n  public void assertHoldsLockAB_Ok() {\n    OurThreadUtils.assertHoldsLock(monitorA);\n    OurThreadUtils.assertHoldsLock(monitorB);\n  }\n\n  public void assertHoldsLockBA_Ok() {\n    OurThreadUtils.assertHoldsLock(monitorB);\n    OurThreadUtils.assertHoldsLock(monitorA);\n  }\n}\n"
    },
    {
      "testname": "MainThreadTest.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.Binder;\nimport android.support.annotation.MainThread;\n\nclass MainThreadTest {\n  Binder b;\n\n  void doTransact() {\n    try {\n      b.transact(0, null, null, 0);\n    } catch (Exception e) {\n    }\n  }\n\n  @MainThread\n  void callTransactBad() {\n    doTransact();\n  }\n}\n\n@MainThread\nclass AnnotatedClass {\n  void callTransactBad(MainThreadTest m) {\n    m.doTransact();\n  }\n}\n"
    },
    {
      "testname": "MasterLock.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass MasterLock {\n  Object a, b;\n\n  // classic deadlock between 2 methods\n  // 1st method has a and wants b\n  void oneWayBad() {\n    synchronized (a) {\n      synchronized (b) {\n      }\n    }\n  }\n\n  // 2nd method has b and wants a\n  void theOtherWayBad() {\n    synchronized (b) {\n      synchronized (a) {\n      }\n    }\n  }\n\n  Object master, x, y;\n\n  // both methods hold the master lock so cannot interleave\n  // and thus cannot deadlock\n  void oneWayOk() {\n    synchronized (master) {\n      synchronized (x) {\n        synchronized (y) {\n        }\n      }\n    }\n  }\n\n  void theOtherWayOk() {\n    synchronized (master) {\n      synchronized (y) {\n        synchronized (x) {\n        }\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "MyActivity.java",
      "testlanguage": "java",
      "expected-problems": 16,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.app.Activity;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.RemoteException;\n\n// test is for recognizing Activity lifecycle methods\nclass MyActivity extends Activity {\n  Binder b;\n\n  private void bad() {\n    try {\n      b.transact(0, null, null, 0);\n    } catch (RemoteException r) {\n    }\n  }\n\n  // overrides so no Bad suffixes\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    bad();\n  }\n\n  @Override\n  public void onStart() {\n    bad();\n  }\n\n  @Override\n  public void onRestart() {\n    bad();\n  }\n\n  @Override\n  public void onResume() {\n    bad();\n  }\n\n  @Override\n  public void onPause() {\n    bad();\n  }\n\n  @Override\n  public void onStop() {\n    bad();\n  }\n\n  @Override\n  public void onDestroy() {\n    bad();\n  }\n}\n"
    },
    {
      "testname": "NonBlk.java",
      "testlanguage": "java",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport com.facebook.infer.annotation.NonBlocking;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\nclass NonBlk {\n  Future future;\n\n  @NonBlocking\n  void doGet() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n\n  @UiThread\n  void onUiThreadIndirectOk() throws InterruptedException, ExecutionException {\n    doGet();\n  }\n\n  @NonBlocking\n  @UiThread\n  void onUiThreadDirectOk() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n\n  @NonBlocking\n  synchronized void deadlockABBad() {\n    synchronized (future) {\n    }\n  }\n\n  @NonBlocking\n  void deadlockBABad() {\n    synchronized (future) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  private void privateDoGetOk() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n\n  @NonBlocking\n  @UiThread\n  void onUiThreadCalleeOk() throws InterruptedException, ExecutionException {\n    privateDoGetOk();\n  }\n}\n"
    },
    {
      "testname": "NotUnderLock.java",
      "testlanguage": "java",
      "expected-problems": 8,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport com.google.common.util.concurrent.SettableFuture;\n\npublic class NotUnderLock {\n  SettableFuture future = null;\n\n  private void callFutureSetOk() {\n    future.set(null);\n  }\n\n  private synchronized void firstAcquisitionBad() {\n    callFutureSetOk();\n  }\n\n  private void secondAcquisitionOk(Object o) {\n    synchronized (o) {\n      firstAcquisitionBad();\n    }\n  }\n}\n"
    },
    {
      "testname": "ObjWait.java",
      "testlanguage": "java",
      "expected-problems": 9,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\n\nclass ObjWait {\n  Object z;\n\n  void waitOnAnyWithoutTimeoutOk() throws InterruptedException {\n    synchronized (z) {\n      z.wait();\n    }\n  }\n\n  Object o;\n\n  @UiThread\n  void waitOnMainWithoutTimeoutBad() throws InterruptedException {\n    synchronized (o) {\n      o.wait();\n    }\n  }\n\n  @UiThread\n  void waitOnMainWithExcessiveTimeout1Bad() throws InterruptedException {\n    synchronized (o) {\n      o.wait(5001);\n    }\n  }\n\n  @UiThread\n  void waitOnMainWithExcessiveTimeout2Bad() throws InterruptedException {\n    synchronized (o) {\n      o.wait(4000, 2000000000);\n    }\n  }\n\n  Object lock, x;\n\n  @UiThread\n  void indirectWaitOnMainWithoutTimeoutBad() throws InterruptedException {\n    synchronized (lock) {\n    }\n  }\n\n  void lockAndWaitOnAnyWithoutTimeoutBad() throws InterruptedException {\n    synchronized (lock) {\n      synchronized (x) {\n        x.wait();\n      }\n    }\n  }\n\n  Object y;\n\n  @UiThread\n  void indirectWaitSameLockOnMainOk() throws InterruptedException {\n    synchronized (y) {\n    }\n  }\n\n  void lockAndWaitSameLockOnAnyOk() throws InterruptedException {\n    synchronized (y) {\n      y.wait();\n    }\n  }\n}\n"
    },
    {
      "testname": "OurThreadUtils.java",
      "testlanguage": "java",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass OurThreadUtils {\n  static native boolean isMainThread();\n\n  static native boolean isUiThread();\n\n  static void assertMainThread() {}\n\n  static void assertOnUiThread() {}\n\n  static void assertOnBackgroundThread() {}\n\n  static void assertHoldsLock(Object lock) {}\n}\n"
    },
    {
      "testname": "Parameters.java",
      "testlanguage": "java",
      "expected-problems": 15,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass Parameters {\n  private static void syncOnParam(Object x) {\n    synchronized (x) {\n    }\n  }\n\n  // Next two methods will deadlock\n  public synchronized void oneWaySyncOnParamBad(Object x) {\n    syncOnParam(x);\n  }\n\n  public void otherWaySyncOnParamBad(Object x) {\n    synchronized (x) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  private static void emulateSynchronized(Parameters self) {\n    synchronized (self) {\n    }\n  }\n\n  Parameters someObject;\n\n  // Next two methods will deadlock\n  public synchronized void oneWayEmulateSyncBad() {\n    emulateSynchronized(someObject);\n  }\n\n  public void anotherWayEmulateSyncBad() {\n    synchronized (someObject) {\n      synchronized (this) {\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "PubPriv.java",
      "testlanguage": "java",
      "expected-problems": 21,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.Binder;\nimport android.os.RemoteException;\nimport android.support.annotation.UiThread;\n\nclass PubPriv {\n  Binder b;\n\n  @UiThread\n  private void doTransactOk() throws RemoteException {\n    b.transact(0, null, null, 0);\n  }\n\n  public void transactBad() throws RemoteException {\n    doTransactOk();\n  }\n\n  public void alsoBad() throws RemoteException {\n    transactBad();\n  }\n\n  private void chainOK() throws RemoteException {\n    alsoBad();\n  }\n\n  Object lockA, lockB;\n\n  private void oneWayOk() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n      }\n    }\n  }\n\n  private void anotherWayOk() {\n    synchronized (lockB) {\n      synchronized (lockA) {\n      }\n    }\n  }\n\n  public void callOneWayBad() {\n    oneWayOk();\n  }\n\n  public void callAnotherWayBad() {\n    anotherWayOk();\n  }\n\n  private void callOneWayOk() {\n    oneWayOk();\n  }\n\n  private void callAnotherWayOk() {\n    anotherWayOk();\n  }\n}\n"
    },
    {
      "testname": "Regexp.java",
      "testlanguage": "java",
      "expected-problems": 7,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport android.support.annotation.WorkerThread;\nimport java.util.regex.Pattern;\n\n// Mostly after https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html\nclass Regexp {\n  void potentiallyCostly() {\n    Pattern.compile(\"a regexp\");\n\n    int flags = 0;\n    Pattern.compile(\"a regexp\", flags);\n\n    Pattern.matches(\"a regexp\", \"a CharSequence\");\n  }\n\n  @UiThread\n  void annotatedBad() {\n    potentiallyCostly();\n  }\n\n  // no evidence on main thread so OK\n  void noThreadOk() {\n    potentiallyCostly();\n  }\n\n  @WorkerThread\n  void workerThreadOk() {\n    potentiallyCostly();\n  }\n\n  void assertedBad() {\n    OurThreadUtils.assertMainThread();\n    potentiallyCostly();\n  }\n}\n"
    },
    {
      "testname": "ServiceOnUIThread.java",
      "testlanguage": "java",
      "expected-problems": 10,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.app.IntentService;\nimport android.app.Service;\nimport android.content.Intent;\nimport android.os.IBinder;\nimport android.os.RemoteException;\n\nclass ServiceOnUIThread extends Service {\n  private final IBinder mBinder = null;\n\n  @Override\n  public IBinder onBind(Intent intent) {\n    transactBad();\n    return mBinder;\n  }\n\n  void transactBad() {\n    try {\n      mBinder.transact(0, null, null, 0);\n    } catch (RemoteException e) {\n    }\n  }\n}\n\nclass IntentServiceNotOnUIThread extends IntentService {\n  private final IBinder mBinder = null;\n\n  public IntentServiceNotOnUIThread() {\n    super(\"Intent service\");\n  }\n\n  @Override\n  public void onHandleIntent(Intent intent) {\n    transactOk();\n  }\n\n  void transactOk() {\n    try {\n      mBinder.transact(0, null, null, 0);\n    } catch (RemoteException e) {\n    }\n  }\n}\n"
    },
    {
      "testname": "SkipAnalysis.java",
      "testlanguage": "java",
      "expected-problems": 3,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.Binder;\nimport android.os.RemoteException;\nimport android.support.annotation.UiThread;\n\nclass SkipAnalysis {\n  Binder b;\n\n  void doTransact() throws RemoteException {\n    b.transact(0, null, null, 0);\n  }\n\n  @UiThread\n  void callTransact() throws RemoteException {\n    doTransact();\n  }\n}\n"
    },
    {
      "testname": "StaticLock.java",
      "testlanguage": "java",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass StaticLock {\n  static synchronized void staticSynced() {}\n\n  void lockSameClassOneWayOk() {\n    synchronized (StaticLock.class) {\n      staticSynced();\n    }\n  }\n\n  static synchronized void lockSameClassAnotherWayOk() {\n    synchronized (StaticLock.class) {\n    }\n  }\n\n  void lockOtherClassOneWayBad() {\n    synchronized (StaticLock.class) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  synchronized void lockOtherClassAnotherWayBad() {\n    staticSynced();\n  }\n}\n"
    },
    {
      "testname": "StrictModeViolation.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport java.io.File;\nimport java.io.IOException;\n\nclass StrictModeViolation {\n  File f;\n\n  @UiThread\n  void violateStrictModeBad() throws IOException {\n    f.canRead();\n    f.canWrite();\n    f.createNewFile();\n    f.createTempFile(\"a\", \"b\");\n    f.delete();\n    f.getCanonicalPath();\n    f.getFreeSpace();\n    f.getTotalSpace();\n    f.getUsableSpace();\n    f.isDirectory();\n    f.isFile();\n    f.isHidden();\n    f.lastModified();\n    f.length();\n    f.list();\n    f.listFiles();\n    f.mkdir();\n    f.renameTo(f);\n    f.setExecutable(true);\n    f.setLastModified(1L);\n    f.setReadable(true);\n    f.setReadOnly();\n    f.setWritable(true);\n  }\n}\n"
    },
    {
      "testname": "SuppLint.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.annotation.SuppressLint;\nimport android.support.annotation.UiThread;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\nclass SuppLint {\n  Future future;\n\n  @UiThread\n  @SuppressLint(\"starvation\")\n  void onUiThreadSuppressed() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n\n  @UiThread\n  @SuppressLint(\"someOtherString\")\n  void onUiThreadBad() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n}\n\n@SuppressLint(\"STARVATION\")\nclass SuppLintClass {\n  Future future;\n\n  @UiThread\n  void onUiThreadSuppressed() throws InterruptedException, ExecutionException {\n    future.get();\n  }\n}\n"
    },
    {
      "testname": "ThreadCalls.java",
      "testlanguage": "java",
      "expected-problems": 11,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\n\nclass ThreadCalls {\n  void sleepOnAnyThreadOk() throws InterruptedException {\n    Thread.sleep(60);\n  }\n\n  @UiThread\n  void sleepOnUIThreadBad() throws InterruptedException {\n    Thread.sleep(60);\n  }\n\n  Object lock;\n\n  @UiThread\n  void indirectSleepOnUIThreadBad() {\n    synchronized (lock) {\n    }\n  }\n\n  void lockAndSleepOnNonUIThread() throws InterruptedException {\n    synchronized (lock) {\n      sleepOnAnyThreadOk();\n    }\n  }\n\n  void joinOnAnyThreadOk(Thread thread) throws InterruptedException {\n    thread.join();\n  }\n\n  @UiThread\n  void joinOnUIThreadBad(Thread thread) throws InterruptedException {\n    thread.join();\n  }\n\n  @UiThread\n  void joinWithTimeout1OnUIThreadOk(Thread thread) throws InterruptedException {\n    // 50 milliseconds\n    thread.join(50);\n  }\n\n  @UiThread\n  void joinWithTimeout2OnUIThreadOk(Thread thread) throws InterruptedException {\n    // 500 milliseconds + 10000 nanoseconds\n    thread.join(500, 10000);\n  }\n\n  Object joinLock;\n\n  @UiThread\n  void indirectJoinOnUIThreadBad() {\n    synchronized (joinLock) {\n    }\n  }\n\n  void lockAndSleepOnNonUIThread(Thread thread) throws InterruptedException {\n    synchronized (joinLock) {\n      joinOnAnyThreadOk(thread);\n    }\n  }\n}\n"
    },
    {
      "testname": "ThreadDeadlock.java",
      "testlanguage": "java",
      "expected-problems": 21,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.support.annotation.UiThread;\nimport android.support.annotation.WorkerThread;\n\nclass ThreadDeadlock {\n  Object lockA;\n\n  // methods cannot run in parallel because both are on UI thread, thus no deadlock\n\n  @UiThread\n  public synchronized void noParallelismAOk() {\n    synchronized (lockA) {\n    }\n  }\n\n  @UiThread\n  public void noParallelismBOk() {\n    synchronized (lockA) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  Object lockB;\n\n  // deadlock, one method on UI thread, one on Worker thread\n\n  @UiThread\n  public synchronized void annotatedUiThreadBad() {\n    synchronized (lockB) {\n    }\n  }\n\n  @WorkerThread\n  public void annotatedWorkerThreadBad() {\n    synchronized (lockB) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  Object lockC;\n\n  // deadlock as above, but here assertions are used to determine thread status\n\n  public synchronized void assertOnUIThreadBad() {\n    OurThreadUtils.assertOnUiThread();\n    synchronized (lockC) {\n    }\n  }\n\n  public void assertOnBackgroundThreadBad() {\n    OurThreadUtils.assertOnBackgroundThread();\n    synchronized (lockC) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  Object lockD;\n\n  // deadlock as above, though less certain because the only hint of concurrency is that\n  // methods take locks\n\n  public synchronized void notAnnotatedBadA() {\n    synchronized (lockD) {\n    }\n  }\n\n  public void notAnnotatedBBad() {\n    synchronized (lockD) {\n      synchronized (this) {\n      }\n    }\n  }\n\n  Object lockE, lockF, lockG;\n\n  public void sequentialEandGOk() {\n    synchronized (lockE) {\n      synchronized (lockF) {\n      }\n    }\n    synchronized (lockG) {\n    }\n  }\n\n  public void nestedGthenEOk() {\n    synchronized (lockG) {\n      synchronized (lockE) {\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "ThreadSensitivity.java",
      "testlanguage": "java",
      "expected-problems": 13,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Examples where the code checks what thread it's currently running on.\nclass ThreadSensitivity {\n  Object monitorA, monitorB;\n\n  void conditionalAssertMainThread_Bad(boolean b) {\n    if (b) {\n      // this branch asserts on Main thread\n      OurThreadUtils.assertMainThread();\n      synchronized (monitorA) {\n        synchronized (monitorB) {\n        }\n      }\n    } else {\n      // this branch asserts nothing, so may run in parallel with the other branch\n      synchronized (monitorB) {\n        synchronized (monitorA) {\n        }\n      }\n    }\n  }\n\n  Object monitorC, monitorD;\n\n  // the branches in the following two methods are both on main/UI thread so cannot deadlock\n\n  void conditionalIsMainThread_Ok() {\n    if (OurThreadUtils.isMainThread()) {\n      synchronized (monitorC) {\n        synchronized (monitorD) {\n        }\n      }\n    }\n  }\n\n  void conditionalIsUiThread_Ok() {\n    if (OurThreadUtils.isUiThread()) {\n      synchronized (monitorD) {\n        synchronized (monitorC) {\n        }\n      }\n    }\n  }\n\n  Object monitorE, monitorF;\n  // identical to the first case above but negated\n  void conditionalNegatedIsMainThread_Bad() {\n    if (!OurThreadUtils.isMainThread()) {\n      synchronized (monitorE) {\n        synchronized (monitorF) {\n        }\n      }\n    } else {\n      synchronized (monitorF) {\n        synchronized (monitorE) {\n        }\n      }\n    }\n  }\n\n  Object monitorG, monitorH;\n\n  public void confusedAssertBad(boolean b, boolean c) {\n    if (b) {\n      OurThreadUtils.assertOnBackgroundThread();\n    } else {\n      OurThreadUtils.assertOnUiThread();\n    }\n\n    // not sure if we're on UI or background, should report\n    if (c) {\n      synchronized (monitorG) {\n        synchronized (monitorH) {\n        }\n      }\n    } else {\n      synchronized (monitorH) {\n        synchronized (monitorG) {\n        }\n      }\n    }\n  }\n\n  Object monitorI, monitorJ;\n\n  public void FP_confusedAssertOk(boolean b) {\n    if (b) {\n      OurThreadUtils.assertOnBackgroundThread();\n    }\n\n    // b determines if running on UI thread, should NOT report\n    if (b) {\n      synchronized (monitorI) {\n        synchronized (monitorJ) {\n        }\n      }\n    }\n\n    if (b) {\n      synchronized (monitorJ) {\n        synchronized (monitorI) {\n        }\n      }\n    }\n  }\n}\n"
    },
    {
      "testname": "UiLock.java",
      "testlanguage": "java",
      "expected-problems": 2,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport android.support.annotation.UiThread;\n\nclass UiLock {\n  @UiThread\n  void lockOnUiThreadWarning() {\n    synchronized (this) {\n    }\n  }\n}\n"
    },
    {
      "testname": "Workers.java",
      "testlanguage": "java",
      "expected-problems": 5,
      "code": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport android.os.Binder;\nimport android.os.RemoteException;\nimport android.support.annotation.UiThread;\nimport android.support.annotation.WorkerThread;\n\nclass Workers {\n  Binder b;\n\n  void doTransact() throws RemoteException {\n    b.transact(0, null, null, 0);\n  }\n\n  @WorkerThread\n  void workerOk() throws RemoteException {\n    doTransact();\n  }\n\n  // WorkerThread does not propagate up the call stack\n  // We don't report here, however, since this is an annotation/assertion error,\n  // not starvation/deadlock.\n  @UiThread\n  void FN_uiThreadBad() throws RemoteException {\n    workerOk();\n  }\n\n  // WorkerThread wins\n  @WorkerThread\n  @UiThread\n  void bothOk() throws RemoteException {\n    workerOk();\n  }\n}\n"
    }
  ]
}