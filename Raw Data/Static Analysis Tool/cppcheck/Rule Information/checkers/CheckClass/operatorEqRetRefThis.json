{
  "name": "operatorEqRetRefThis",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 15,
  "branches": 5,
  "apis": 13,
  "test": [
    {
      "description": null,
      "expected-problems": 7,
      "expected-linenumbers": [
        1219,
        1417,
        1519,
        1580,
        1590,
        1642,
        1658
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"check.h\"\n#include \"checkclass.h\"\n#include \"ctu.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n#include <list>\n#include <string>\n#include <vector>\n\nclass TestClass : public TestFixture {\npublic:\n    TestClass() : TestFixture(\"TestClass\") {}\n\nprivate:\n    const Settings settings0 = settingsBuilder().severity(Severity::style).library(\"std.cfg\").build();\n    const Settings settings1 = settingsBuilder().severity(Severity::warning).library(\"std.cfg\").build();\n    const Settings settings2 = settingsBuilder().severity(Severity::style).library(\"std.cfg\").certainty(Certainty::inconclusive).build();\n    const Settings settings3 = settingsBuilder().severity(Severity::style).library(\"std.cfg\").severity(Severity::warning).build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(virtualDestructor1);      // Base class not found => no error\n        TEST_CASE(virtualDestructor2);      // Base class doesn't have a destructor\n        TEST_CASE(virtualDestructor3);      // Base class has a destructor, but it's not virtual\n        TEST_CASE(virtualDestructor4);      // Derived class doesn't have a destructor => no error\n        TEST_CASE(virtualDestructor5);      // Derived class has empty destructor => no error\n        TEST_CASE(virtualDestructor6);      // only report error if base class pointer that points at derived class is deleted\n        TEST_CASE(virtualDestructorProtected);\n        TEST_CASE(virtualDestructorInherited);\n        TEST_CASE(virtualDestructorTemplate);\n\n        TEST_CASE(virtualDestructorInconclusive); // ticket # 5807\n\n        TEST_CASE(copyConstructor1);\n        TEST_CASE(copyConstructor2); // ticket #4458\n        TEST_CASE(copyConstructor3); // defaulted/deleted\n        TEST_CASE(copyConstructor4); // base class with private constructor\n        TEST_CASE(copyConstructor5); // multiple inheritance\n        TEST_CASE(copyConstructor6); // array of pointers\n        TEST_CASE(deletedMemberPointer); // deleted member pointer in destructor\n        TEST_CASE(noOperatorEq); // class with memory management should have operator eq\n        TEST_CASE(noDestructor); // class with memory management should have destructor\n\n        TEST_CASE(operatorEqRetRefThis1);\n        TEST_CASE(operatorEqRetRefThis2); // ticket #1323\n        TEST_CASE(operatorEqRetRefThis3); // ticket #1405\n        TEST_CASE(operatorEqRetRefThis4); // ticket #1451\n        TEST_CASE(operatorEqRetRefThis5); // ticket #1550\n        TEST_CASE(operatorEqRetRefThis6); // ticket #2479\n        TEST_CASE(operatorEqRetRefThis7); // ticket #5782 endless recursion\n        TEST_CASE(operatorEqToSelf1);   // single class\n        TEST_CASE(operatorEqToSelf2);   // nested class\n        TEST_CASE(operatorEqToSelf3);   // multiple inheritance\n        TEST_CASE(operatorEqToSelf4);   // nested class with multiple inheritance\n        TEST_CASE(operatorEqToSelf5);   // ticket # 1233\n        TEST_CASE(operatorEqToSelf6);   // ticket # 1550\n        TEST_CASE(operatorEqToSelf7);\n        TEST_CASE(operatorEqToSelf8);   // ticket #2179\n        TEST_CASE(operatorEqToSelf9);   // ticket #2592\n\n        TEST_CASE(memsetOnStruct);\n        TEST_CASE(memsetVector);\n        TEST_CASE(memsetOnClass);\n        TEST_CASE(memsetOnInvalid);    // Ticket #5425: Crash upon invalid\n        TEST_CASE(memsetOnStdPodType); // Ticket #5901 - std::uint8_t\n        TEST_CASE(memsetOnFloat);      // Ticket #5421\n        TEST_CASE(memsetOnUnknown);    // Ticket #7183\n        TEST_CASE(mallocOnClass);\n\n        TEST_CASE(this_subtraction);    // warn about \"this-x\"\n\n        // can member function be made const\n        TEST_CASE(const1);\n        TEST_CASE(const2);\n        TEST_CASE(const3);\n        TEST_CASE(const4);\n        TEST_CASE(const5); // ticket #1482\n        TEST_CASE(const6); // ticket #1491\n        TEST_CASE(const7);\n        TEST_CASE(const8); // ticket #1517\n        TEST_CASE(const9); // ticket #1515\n        TEST_CASE(const10); // ticket #1522\n        TEST_CASE(const11); // ticket #1529\n        TEST_CASE(const12); // ticket #1552\n        TEST_CASE(const13); // ticket #1519\n        TEST_CASE(const14);\n        TEST_CASE(const15);\n        TEST_CASE(const16); // ticket #1551\n        TEST_CASE(const17); // ticket #1552\n        TEST_CASE(const18);\n        TEST_CASE(const19); // ticket #1612\n        TEST_CASE(const20); // ticket #1602\n        TEST_CASE(const21); // ticket #1683\n        TEST_CASE(const22);\n        TEST_CASE(const23); // ticket #1699\n        TEST_CASE(const24); // ticket #1708\n        TEST_CASE(const25); // ticket #1724\n        TEST_CASE(const26); // ticket #1847\n        TEST_CASE(const27); // ticket #1882\n        TEST_CASE(const28); // ticket #1883\n        TEST_CASE(const29); // ticket #1922\n        TEST_CASE(const30);\n        TEST_CASE(const31);\n        TEST_CASE(const32); // ticket #1905 - member array is assigned\n        TEST_CASE(const33);\n        TEST_CASE(const34); // ticket #1964\n        TEST_CASE(const35); // ticket #2001\n        TEST_CASE(const36); // ticket #2003\n        TEST_CASE(const37); // ticket #2081 and #2085\n        TEST_CASE(const38); // ticket #2135\n        TEST_CASE(const39);\n        TEST_CASE(const40); // ticket #2228\n        TEST_CASE(const41); // ticket #2255\n        TEST_CASE(const42); // ticket #2282\n        TEST_CASE(const43); // ticket #2377\n        TEST_CASE(const44); // ticket #2595\n        TEST_CASE(const45); // ticket #2664\n        TEST_CASE(const46); // ticket #2636\n        TEST_CASE(const47); // ticket #2670\n        TEST_CASE(const48); // ticket #2672\n        TEST_CASE(const49); // ticket #2795\n        TEST_CASE(const50); // ticket #2943\n        TEST_CASE(const51); // ticket #3040\n        TEST_CASE(const52); // ticket #3048\n        TEST_CASE(const53); // ticket #3049\n        TEST_CASE(const54); // ticket #3052\n        TEST_CASE(const55);\n        TEST_CASE(const56); // ticket #3149\n        TEST_CASE(const57); // tickets #2669 and #2477\n        TEST_CASE(const58); // ticket #2698\n        TEST_CASE(const59); // ticket #4646\n        TEST_CASE(const60); // ticket #3322\n        TEST_CASE(const61); // ticket #5606\n        TEST_CASE(const62); // ticket #5701\n        TEST_CASE(const63); // ticket #5983\n        TEST_CASE(const64); // ticket #6268\n        TEST_CASE(const65); // ticket #8693\n        TEST_CASE(const66); // ticket #7714\n        TEST_CASE(const67); // ticket #9193\n        TEST_CASE(const68); // ticket #6471\n        TEST_CASE(const69); // ticket #9806\n        TEST_CASE(const70); // variadic template can receive more arguments than in its definition\n        TEST_CASE(const71); // ticket #10146\n        TEST_CASE(const72); // ticket #10520\n        TEST_CASE(const73); // ticket #10735\n        TEST_CASE(const74); // ticket #10671\n        TEST_CASE(const75); // ticket #10065\n        TEST_CASE(const76); // ticket #10825\n        TEST_CASE(const77); // ticket #10307, #10311\n        TEST_CASE(const78); // ticket #10315\n        TEST_CASE(const79); // ticket #9861\n        TEST_CASE(const80); // ticket #11328\n        TEST_CASE(const81); // ticket #11330\n        TEST_CASE(const82); // ticket #11513\n        TEST_CASE(const83);\n        TEST_CASE(const84);\n        TEST_CASE(const85);\n        TEST_CASE(const86);\n        TEST_CASE(const87);\n        TEST_CASE(const88);\n        TEST_CASE(const89);\n        TEST_CASE(const90);\n        TEST_CASE(const91);\n        TEST_CASE(const92);\n        TEST_CASE(const93);\n        TEST_CASE(const94);\n        TEST_CASE(const95); // #13320 - do not warn about r-value ref method\n        TEST_CASE(const96);\n        TEST_CASE(const97);\n        TEST_CASE(const98);\n        TEST_CASE(const99);\n        TEST_CASE(const100);\n\n        TEST_CASE(const_handleDefaultParameters);\n        TEST_CASE(const_passThisToMemberOfOtherClass);\n        TEST_CASE(assigningPointerToPointerIsNotAConstOperation);\n        TEST_CASE(assigningArrayElementIsNotAConstOperation);\n        TEST_CASE(constoperator1);  // operator< can often be const\n        TEST_CASE(constoperator2);  // operator<<\n        TEST_CASE(constoperator3);\n        TEST_CASE(constoperator4);\n        TEST_CASE(constoperator5); // ticket #3252\n        TEST_CASE(constoperator6); // ticket #8669\n        TEST_CASE(constincdec);     // increment/decrement => non-const\n        TEST_CASE(constassign1);\n        TEST_CASE(constassign2);\n        TEST_CASE(constincdecarray);     // increment/decrement array element => non-const\n        TEST_CASE(constassignarray);\n        TEST_CASE(constReturnReference);\n        TEST_CASE(constDelete);     // delete member variable => not const\n        TEST_CASE(constLPVOID);     // a function that returns LPVOID can't be const\n        TEST_CASE(constFunc); // a function that calls const functions can be const\n        TEST_CASE(constVirtualFunc);\n        TEST_CASE(constIfCfg);  // ticket #1881 - fp when there are #if\n        TEST_CASE(constFriend); // ticket #1921 - fp for friend function\n        TEST_CASE(constUnion);  // ticket #2111 - fp when there is a union\n        TEST_CASE(constArrayOperator); // #4406\n        TEST_CASE(constRangeBasedFor); // #5514\n        TEST_CASE(const_shared_ptr);\n        TEST_CASE(constPtrToConstPtr);\n        TEST_CASE(constTrailingReturnType);\n        TEST_CASE(constRefQualified);\n        TEST_CASE(staticArrayPtrOverload);\n        TEST_CASE(qualifiedNameMember); // #10872\n\n        TEST_CASE(initializerListOrder);\n        TEST_CASE(initializerListArgument);\n        TEST_CASE(initializerListUsage);\n        TEST_CASE(selfInitialization);\n\n        TEST_CASE(virtualFunctionCallInConstructor);\n        TEST_CASE(pureVirtualFunctionCall);\n        TEST_CASE(pureVirtualFunctionCallOtherClass);\n        TEST_CASE(pureVirtualFunctionCallWithBody);\n        TEST_CASE(pureVirtualFunctionCallPrevented);\n\n        TEST_CASE(duplInheritedMembers);\n        TEST_CASE(explicitConstructors);\n        TEST_CASE(copyCtorAndEqOperator);\n\n        TEST_CASE(override1);\n        TEST_CASE(overrideCVRefQualifiers);\n\n        TEST_CASE(uselessOverride);\n\n        TEST_CASE(thisUseAfterFree);\n\n        TEST_CASE(unsafeClassRefMember);\n\n        TEST_CASE(ctuOneDefinitionRule);\n\n        TEST_CASE(testGetFileInfo);\n\n        TEST_CASE(returnByReference);\n    }\n\n#define checkCopyCtorAndEqOperator(...) checkCopyCtorAndEqOperator_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkCopyCtorAndEqOperator_(const char* file, int line, const char (&code)[size]) {\n        const Settings settings = settingsBuilder().severity(Severity::warning).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings, this);\n        (checkClass.checkCopyCtorAndEqOperator)();\n    }\n\n    void copyCtorAndEqOperator() {\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"    A(const A& other) { }\\n\"\n                                   \"    A& operator=(const A& other) { return *this; }\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"    A(const A& other) { }\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"    A& operator=(const A& other) { return *this; }\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"    A(const A& other) { }\\n\"\n                                   \"    int x;\\n\"\n                                   \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:1]: (warning) The class 'A' has 'copy constructor' but lack of 'operator='.\\n\", \"\", errout_str());\n        // TODO the error message should be clarified. It should say something like 'copy constructor is empty and will not assign i and therefore the behaviour is different to the default assignment operator'\n\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"    A& operator=(const A& other) { return *this; }\\n\"\n                                   \"    int x;\\n\"\n                                   \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:1]: (warning) The class 'A' has 'operator=' but lack of 'copy constructor'.\\n\", \"\", errout_str());\n        // TODO the error message should be clarified. It should say something like 'assignment operator does not assign i and therefore the behaviour is different to the default copy constructor'\n\n        checkCopyCtorAndEqOperator(\"class A\\n\"\n                                   \"{\\n\"\n                                   \"    A& operator=(const int &x) { this->x = x; return *this; }\\n\"\n                                   \"    int x;\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyCtorAndEqOperator(\"class A {\\n\"\n                                   \"public:\\n\"\n                                   \"    A() : x(0) { }\\n\"\n                                   \"    A(const A & a) { x = a.x; }\\n\"\n                                   \"    A & operator = (const A & a) {\\n\"\n                                   \"        x = a.x;\\n\"\n                                   \"        return *this;\\n\"\n                                   \"    }\\n\"\n                                   \"private:\\n\"\n                                   \"    int x;\\n\"\n                                   \"};\\n\"\n                                   \"class B : public A {\\n\"\n                                   \"public:\\n\"\n                                   \"    B() { }\\n\"\n                                   \"    B(const B & b) :A(b) { }\\n\"\n                                   \"private:\\n\"\n                                   \"    static int i;\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7987 - Don't show warning when there is a move constructor\n        checkCopyCtorAndEqOperator(\"struct S {\\n\"\n                                   \"  std::string test;\\n\"\n                                   \"  S(S&& s) : test(std::move(s.test)) { }\\n\"\n                                   \"  S& operator = (S &&s) {\\n\"\n                                   \"    test = std::move(s.test);\\n\"\n                                   \"    return *this;\\n\"\n                                   \"  }\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8337 - False positive in copy constructor detection\n        checkCopyCtorAndEqOperator(\"struct StaticListNode {\\n\"\n                                   \"  StaticListNode(StaticListNode*& prev) : m_next(0) {}\\n\"\n                                   \"  StaticListNode* m_next;\\n\"\n                                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkExplicitConstructors(...) checkExplicitConstructors_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkExplicitConstructors_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings0, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings0, this);\n        (checkClass.checkExplicitConstructors)();\n    }\n\n    void explicitConstructors() {\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    Class() = delete;\\n\"\n                                  \"    Class(const Class& other) { }\\n\"\n                                  \"    Class(Class&& other) { }\\n\"\n                                  \"    explicit Class(int i) { }\\n\"\n                                  \"    explicit Class(const std::string&) { }\\n\"\n                                  \"    Class(int a, int b) { }\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    Class() = delete;\\n\"\n                                  \"    explicit Class(const Class& other) { }\\n\"\n                                  \"    explicit Class(Class&& other) { }\\n\"\n                                  \"    virtual int i() = 0;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    Class() = delete;\\n\"\n                                  \"    Class(const Class& other) = delete;\\n\"\n                                  \"    Class(Class&& other) = delete;\\n\"\n                                  \"    virtual int i() = 0;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    Class(int i) { }\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Class 'Class' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]\\n\", errout_str());\n\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    Class(const Class& other) { }\\n\"\n                                  \"    virtual int i() = 0;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    Class(Class&& other) { }\\n\"\n                                  \"    virtual int i() = 0;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6585\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    private: Class(const Class&);\\n\"\n                                  \"    virtual int i() = 0;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Class {\\n\"\n                                  \"    public: Class(const Class&);\\n\"\n                                  \"    virtual int i() = 0;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7465: Error properly reported in templates\n        checkExplicitConstructors(\"template <class T> struct Test {\\n\"\n                                  \"  Test(int) : fData(0) {}\\n\"\n                                  \"  T fData;\\n\"\n                                  \"};\\n\"\n                                  \"int main() {\\n\"\n                                  \"  Test <int> test;\\n\"\n                                  \"  return 0;\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (style) Struct 'Test < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]\\n\", errout_str());\n\n        // #7465: No error for copy or move constructors\n        checkExplicitConstructors(\"template <class T> struct Test {\\n\"\n                                  \"  Test() : fData(0) {}\\n\"\n                                  \"  Test (const Test<T>& aOther) : fData(aOther.fData) {}\\n\"\n                                  \"  Test (Test<T>&& aOther) : fData(std::move(aOther.fData)) {}\\n\"\n                                  \"  T fData;\\n\"\n                                  \"};\\n\"\n                                  \"int main() {\\n\"\n                                  \"  Test <int> test;\\n\"\n                                  \"  return 0;\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8600\n        checkExplicitConstructors(\"struct A { struct B; };\\n\"\n                                  \"struct A::B {\\n\"\n                                  \"    B() = default;\\n\"\n                                  \"    B(const B&) {}\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"struct A{\"\n                                  \"    A(int, int y=2) {}\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:1:14]: (style) Struct 'A' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]\\n\", errout_str());\n\n        checkExplicitConstructors(\"struct Foo {\\n\" // #10515\n                                  \"    template <typename T>\\n\"\n                                  \"    explicit constexpr Foo(T) {}\\n\"\n                                  \"};\\n\"\n                                  \"struct Bar {\\n\"\n                                  \"    template <typename T>\\n\"\n                                  \"    constexpr explicit Bar(T) {}\\n\"\n                                  \"};\\n\"\n                                  \"struct Baz {\\n\"\n                                  \"    explicit constexpr Baz(int) {}\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Token;\\n\" // #11126\n                                  \"struct Branch {\\n\"\n                                  \"    Branch(Token* tok = nullptr) : endBlock(tok) {}\\n\"\n                                  \"    Token* endBlock = nullptr;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Struct 'Branch' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]\\n\", errout_str());\n\n        checkExplicitConstructors(\"struct S {\\n\"\n                                  \"    S(std::initializer_list<int> il) : v(il) {}\\n\"\n                                  \"    std::vector<int> v;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"template<class T>\\n\" // #10977\n                                  \"struct A {\\n\"\n                                  \"    template<class... Ts>\\n\"\n                                  \"    A(Ts&&... ts) {}\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkExplicitConstructors(\"class Color {\\n\" // #7176\n                                  \"public:\\n\"\n                                  \"    Color(unsigned int rgba);\\n\"\n                                  \"    Color(std::uint8_t r = 0, std::uint8_t g = 0, std::uint8_t b = 0, std::uint8_t a = 255);\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Class 'Color' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]\\n\"\n                      \"[test.cpp:4:5]: (style) Class 'Color' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]\\n\",\n                      errout_str());\n\n        checkExplicitConstructors(\"template <typename T>\\n\" // #13878\n                                  \"struct S {\\n\"\n                                  \"    S(std::nullptr_t) {}\\n\"\n                                  \"    explicit S(T* p) : m(p) {}\\n\"\n                                  \"    T* m{};\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkDuplInheritedMembers(...) checkDuplInheritedMembers_( __FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkDuplInheritedMembers_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings1, this);\n        (checkClass.checkDuplInheritedMembers)();\n    }\n\n    void duplInheritedMembers() {\n        checkDuplInheritedMembers(\"class Base {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : Base {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base {\\n\"\n                                  \"   protected:\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : Base {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:6:8]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'. [duplInheritedMember]\\n\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base {\\n\"\n                                  \"   protected:\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : public Base {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:6:8]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base'. [duplInheritedMember]\\n\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base0 {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"class Base1 {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : Base0, Base1 {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base0 {\\n\"\n                                  \"   protected:\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"class Base1 {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : Base0, Base1 {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:9:8]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'. [duplInheritedMember]\\n\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base0 {\\n\"\n                                  \"   protected:\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"class Base1 {\\n\"\n                                  \"   public:\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : Base0, Base1 {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:10:8]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base0'. [duplInheritedMember]\\n\"\n                      \"[test.cpp:7:8] -> [test.cpp:10:8]: (warning) The struct 'Derived' defines member variable with name 'x' also defined in its parent class 'Base1'. [duplInheritedMember]\\n\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct Derived : Base {\\n\"\n                                  \"   int y;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"class A {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"struct B {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown 'Base' class\n        checkDuplInheritedMembers(\"class Derived : public UnknownBase {\\n\"\n                                  \"  int x;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base {\\n\"\n                                  \"   int x;\\n\"\n                                  \"};\\n\"\n                                  \"class Derived : public Base {\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6692\n        checkDuplInheritedMembers(\"namespace test1 {\\n\"\n                                  \"   struct SWibble{};\\n\"\n                                  \"   typedef SWibble wibble;\\n\"\n                                  \"}\\n\"\n                                  \"namespace test2 {\\n\"\n                                  \"   struct SWibble : public test1::wibble {\\n\"\n                                  \"   int Value;\\n\"\n                                  \"   };\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9957\n        checkDuplInheritedMembers(\"class Base {\\n\"\n                                  \"    public:\\n\"\n                                  \"        int i;\\n\"\n                                  \"};\\n\"\n                                  \"class Derived1: public Base {\\n\"\n                                  \"    public:\\n\"\n                                  \"        int j;\\n\"\n                                  \"};\\n\"\n                                  \"class Derived2 : public Derived1 {\\n\"\n                                  \"    int i;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:13] -> [test.cpp:10:9]: (warning) The class 'Derived2' defines member variable with name 'i' also defined in its parent class 'Base'. [duplInheritedMember]\\n\", errout_str());\n\n        // don't crash on recursive template\n        checkDuplInheritedMembers(\"template<size_t N>\\n\"\n                                  \"struct BitInt : public BitInt<N+1> { };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // don't crash on recursive template\n        checkDuplInheritedMembers(\"namespace _impl {\\n\"\n                                  \"    template <typename AlwaysVoid, typename>\\n\"\n                                  \"    struct fn_traits;\\n\"\n                                  \"}\\n\"\n                                  \"template <typename T>\\n\"\n                                  \"struct function_traits\\n\"\n                                  \"    : public _impl::fn_traits<void, std::remove_reference_t<T>> {};\\n\"\n                                  \"namespace _impl {\\n\"\n                                  \"    template <typename T>\\n\"\n                                  \"    struct fn_traits<decltype(void(&T::operator())), T>\\n\"\n                                  \"        : public fn_traits<void, decltype(&T::operator())> {};\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10594\n        checkDuplInheritedMembers(\"template<int i> struct A { bool a = true; };\\n\"\n                                  \"struct B { bool a; };\\n\"\n                                  \"template<> struct A<1> : B {};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"struct B {\\n\"\n                                  \"    int g() const;\\n\"\n                                  \"    virtual int f() const { return g(); }\\n\"\n                                  \"};\\n\"\n                                  \"struct D : B {\\n\"\n                                  \"    int g() const;\\n\"\n                                  \"    int f() const override { return g(); }\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:6:9]: (warning) The struct 'D' defines member function with name 'g' also defined in its parent struct 'B'. [duplInheritedMember]\\n\",\n                      errout_str());\n\n        checkDuplInheritedMembers(\"struct B {\\n\"\n                                  \"    int g() const;\\n\"\n                                  \"};\\n\"\n                                  \"struct D : B {\\n\"\n                                  \"    int g(int) const;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"struct S {\\n\"\n                                  \"    struct T {\\n\"\n                                  \"        T() {}\\n\"\n                                  \"    };\\n\"\n                                  \"};\\n\"\n                                  \"struct T : S::T {\\n\"\n                                  \"    T() : S::T() {}\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"struct S {};\\n\" // #11827\n                                  \"struct SPtr {\\n\"\n                                  \"    virtual S* operator->() const { return p; }\\n\"\n                                  \"    S* p = nullptr;\\n\"\n                                  \"};\\n\"\n                                  \"struct T : public S {};\\n\"\n                                  \"struct TPtr : public SPtr {\\n\"\n                                  \"    T* operator->() const { return (T*)p; }\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"struct B { virtual int& get() = 0; };\\n\" // #12311\n                                  \"struct D : B {\\n\"\n                                  \"    int i{};\\n\"\n                                  \"    int& get() override { return i; }\\n\"\n                                  \"    const int& get() const { return i; }\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkDuplInheritedMembers(\"class Base {\\n\" // #12353\n                                  \"    public:\\n\"\n                                  \"        void One();\\n\"\n                                  \"        void Two();\\n\"\n                                  \"};\\n\"\n                                  \"class Derived : public Base {\\n\"\n                                  \"public:\\n\"\n                                  \"    void Two() = delete;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkCopyConstructor(...) checkCopyConstructor_( __FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkCopyConstructor_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings3, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings3, this);\n        checkClass.copyconstructors();\n    }\n\n    void copyConstructor1() {\n        checkCopyConstructor(\"class F\\n\"\n                             \"{\\n\"\n                             \"   public:\\n\"\n                             \"   char *c,*p,*d;\\n\"\n                             \"   F(const F &f) : p(f.p), c(f.c)\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(strlen(f.p)+1);\\n\"\n                             \"      strcpy(p,f.p);\\n\"\n                             \"   }\\n\"\n                             \"   F(char *str)\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,str);\\n\"\n                             \"   }\\n\"\n                             \"   F&operator=(const F&);\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\\n\", \"\", errout_str());\n\n        checkCopyConstructor(\"class F {\\n\"\n                             \"   char *p;\\n\"\n                             \"   F(const F &f) {\\n\"\n                             \"      p = f.p;\\n\"\n                             \"   }\\n\"\n                             \"   F(char *str) {\\n\"\n                             \"      p = malloc(strlen(str)+1);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:7]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory. [copyCtorPointerCopying]\\n\"\n                           \"[test.cpp:3] -> [test.cpp:7]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\\n\",\n                           \"[test.cpp:4:7]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory. [copyCtorPointerCopying]\\n\"\n                           , errout_str());\n\n        checkCopyConstructor(\"class F\\n\"\n                             \"{\\n\"\n                             \"   public:\\n\"\n                             \"   char *c,*p,*d;\\n\"\n                             \"   F(const F &f) :p(f.p)\\n\"\n                             \"   {\\n\"\n                             \"   }\\n\"\n                             \"   F(char *str)\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,str);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (warning) Value of pointer 'p', which points to allocated memory, is copied in copy constructor instead of allocating new memory.\\n\"\n                           \"[test.cpp:5] -> [test.cpp:10]: (warning) Copy constructor does not allocate memory for member 'p' although memory has been allocated in other constructors.\\n\",\n                           \"\"\n                           , errout_str());\n\n        checkCopyConstructor(\"class kalci\\n\"\n                             \"{\\n\"\n                             \"   public:\\n\"\n                             \"   char *c,*p,*d;\\n\"\n                             \"   kalci()\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(100);\\n\"\n                             \"      strcpy(p,\\\"hello\\\");\\n\"\n                             \"      c=(char *)malloc(100);\\n\"\n                             \"      strcpy(p,\\\"hello\\\");\\n\"\n                             \"      d=(char *)malloc(100);\\n\"\n                             \"      strcpy(p,\\\"hello\\\");\\n\"\n                             \"   }\\n\"\n                             \"   kalci(const kalci &f)\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,f.p);\\n\"\n                             \"      c=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,f.p);\\n\"\n                             \"      d=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,f.p);\\n\"\n                             \"   }\\n\"\n                             \"   ~kalci();\\n\"\n                             \"   kalci& operator=(const kalci&kalci);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class F\\n\"\n                             \"{\\n\"\n                             \"   public:\\n\"\n                             \"   char *c,*p,*d;\\n\"\n                             \"   F(char *str,char *st,char *string)\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(100);\\n\"\n                             \"      strcpy(p,str);\\n\"\n                             \"      c=(char *)malloc(100);\\n\"\n                             \"      strcpy(p,st);\\n\"\n                             \"      d=(char *)malloc(100);\\n\"\n                             \"      strcpy(p,string);\\n\"\n                             \"   }\\n\"\n                             \"   F(const F &f)\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,f.p);\\n\"\n                             \"      c=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(p,f.p);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:14] -> [test.cpp:11]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\\n\", \"\", errout_str());\n\n        checkCopyConstructor(\"class F {\\n\"\n                             \"   char *c;\\n\"\n                             \"   F(char *str,char *st,char *string) {\\n\"\n                             \"      p=(char *)malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"   F(const F &f)\\n\"\n                             \"      : p(malloc(size))\\n\"\n                             \"   {\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class F {\\n\"\n                             \"   char *c;\\n\"\n                             \"   F(char *str,char *st,char *string)\\n\"\n                             \"      : p(malloc(size))\\n\"\n                             \"   {\\n\"\n                             \"   }\\n\"\n                             \"   F(const F &f)\\n\"\n                             \"   {\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7] -> [test.cpp:4]: (warning) Copy constructor does not allocate memory for member 'd' although memory has been allocated in other constructors.\\n\", \"\", errout_str());\n\n        checkCopyConstructor(\"class F\\n\"\n                             \"{\\n\"\n                             \"   public:\\n\"\n                             \"   char *c,*p,*d;\\n\"\n                             \"   F()\\n\"\n                             \"   {\\n\"\n                             \"      p=(char *)malloc(100);\\n\"\n                             \"      c=(char *)malloc(100);\\n\"\n                             \"      d=(char*)malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:8]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource management.\\n\", \"\", errout_str());\n\n        checkCopyConstructor(\"class F\\n\"\n                             \"{\\n\"\n                             \"   public:\\n\"\n                             \"   char *c;\\n\"\n                             \"   const char *p,*d;\\n\"\n                             \"   F(char *str,char *st,char *string)\\n\"\n                             \"   {\\n\"\n                             \"      p=str;\\n\"\n                             \"      d=st;\\n\"\n                             \"      c=(char *)malloc(strlen(string)+1);\\n\"\n                             \"      strcpy(d,string);\\n\"\n                             \"   }\\n\"\n                             \"   F(const F &f)\\n\"\n                             \"   {\\n\"\n                             \"      p=f.p;\\n\"\n                             \"      d=f.d;\\n\"\n                             \"      c=(char *)malloc(strlen(str)+1);\\n\"\n                             \"      strcpy(d,f.p);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class F : E\\n\"\n                             \"{\\n\"\n                             \"   char *p;\\n\"\n                             \"   F() {\\n\"\n                             \"      p = malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class E { E(E&); };\\n\" // non-copyable\n                             \"class F : E\\n\"\n                             \"{\\n\"\n                             \"   char *p;\\n\"\n                             \"   F() {\\n\"\n                             \"      p = malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class E {};\\n\"\n                             \"class F : E {\\n\"\n                             \"   char *p;\\n\"\n                             \"   F() {\\n\"\n                             \"      p = malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource management. [noCopyConstructor]\\n\", errout_str());\n\n        checkCopyConstructor(\"class F {\\n\"\n                             \"   char *p;\\n\"\n                             \"   F() {\\n\"\n                             \"      p = malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"   F(F& f);\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class F {\\n\"\n                             \"   char *p;\\n\"\n                             \"   F() : p(malloc(100)) {}\\n\"\n                             \"   ~F();\\n\"\n                             \"   F& operator=(const F&f);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Class 'F' does not have a copy constructor which is recommended since it has dynamic memory/resource management. [noCopyConstructor]\\n\", errout_str());\n\n        // #7198\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   static char* c;\\n\"\n                             \"   F() {\\n\"\n                             \"      p = malloc(100);\\n\"\n                             \"   }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void copyConstructor2() { // ticket #4458\n        checkCopyConstructor(\"template <class _Tp>\\n\"\n                             \"class Vector\\n\"\n                             \"{\\n\"\n                             \"public:\\n\"\n                             \"    Vector() {\\n\"\n                             \"        _M_finish = new _Tp[ 42 ];\\n\"\n                             \"    }\\n\"\n                             \"    Vector( const Vector<_Tp>& v ) {\\n\"\n                             \"    }\\n\"\n                             \"     ~Vector();\\n\"\n                             \"     Vector& operator=(const Vector&v);\\n\"\n                             \"    _Tp* _M_finish;\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void copyConstructor3() {\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f) = delete;\\n\"\n                             \"   F&operator=(const F &f);\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f) = default;\\n\"\n                             \"   F&operator=(const F &f);\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The copy constructor is explicitly defaulted but the default copy constructor does not work well. It is recommended to define or delete the copy constructor. [noCopyConstructor]\\n\", errout_str());\n    }\n\n    void copyConstructor4() {\n        checkCopyConstructor(\"class noncopyable {\\n\"\n                             \"protected:\\n\"\n                             \"    noncopyable() {}\\n\"\n                             \"    ~noncopyable() {}\\n\"\n                             \"\\n\"\n                             \"private:\\n\"\n                             \"    noncopyable( const noncopyable& );\\n\"\n                             \"    const noncopyable& operator=( const noncopyable& );\\n\"\n                             \"};\\n\"\n                             \"\\n\"\n                             \"class Base : private noncopyable {};\\n\"\n                             \"\\n\"\n                             \"class Foo : public Base {\\n\"\n                             \"public:\\n\"\n                             \"    Foo() : m_ptr(new int) {}\\n\"\n                             \"    ~Foo() { delete m_ptr; }\\n\"\n                             \"private:\\n\"\n                             \"    int* m_ptr;\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void copyConstructor5() {\n        checkCopyConstructor(\"class Copyable {};\\n\"\n                             \"\\n\"\n                             \"class Foo : public Copyable, public UnknownType {\\n\"\n                             \"public:\\n\"\n                             \"    Foo() : m_ptr(new int) {}\\n\"\n                             \"    ~Foo() { delete m_ptr; }\\n\"\n                             \"private:\\n\"\n                             \"    int* m_ptr;\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"class Copyable {};\\n\"\n                             \"\\n\"\n                             \"class Foo : public UnknownType, public Copyable {\\n\"\n                             \"public:\\n\"\n                             \"    Foo() : m_ptr(new int) {}\\n\"\n                             \"    ~Foo() { delete m_ptr; }\\n\"\n                             \"private:\\n\"\n                             \"    int* m_ptr;\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void copyConstructor6() {\n        checkCopyConstructor(\"struct S {\\n\"\n                             \"    S() {\\n\"\n                             \"        for (int i = 0; i < 5; i++)\\n\"\n                             \"            a[i] = new char[3];\\n\"\n                             \"    }\\n\"\n                             \"    char* a[5];\\n\"\n                             \"};\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (warning) Struct 'S' does not have a copy constructor which is recommended since it has dynamic memory/resource management.\\n\"\n                           \"[test.cpp:4]: (warning) Struct 'S' does not have a operator= which is recommended since it has dynamic memory/resource management.\\n\"\n                           \"[test.cpp:4]: (warning) Struct 'S' does not have a destructor which is recommended since it has dynamic memory/resource management.\\n\",\n                           \"\",\n                           errout_str());\n    }\n\n    void deletedMemberPointer() {\n\n        // delete ...\n        checkCopyConstructor(\"struct P {};\\n\"\n                             \"class C {\\n\"\n                             \"    P *p;\\n\"\n                             \"public:\\n\"\n                             \"    explicit C(P *p) : p(p) {}\\n\"\n                             \"    ~C() { delete p; }\\n\"\n                             \"    void f() {}\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:19]: (warning) Class 'C' does not have a copy constructor which is recommended since it has dynamic memory/resource management. [noCopyConstructor]\\n\"\n                      \"[test.cpp:6:19]: (warning) Class 'C' does not have a operator= which is recommended since it has dynamic memory/resource management. [noOperatorEq]\\n\", errout_str());\n\n        // free(...)\n        checkCopyConstructor(\"struct P {};\\n\"\n                             \"class C {\\n\"\n                             \"    P *p;\\n\"\n                             \"public:\\n\"\n                             \"    explicit C(P *p) : p(p) {}\\n\"\n                             \"    ~C() { free(p); }\\n\"\n                             \"    void f() {}\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:17]: (warning) Class 'C' does not have a copy constructor which is recommended since it has dynamic memory/resource management. [noCopyConstructor]\\n\"\n                      \"[test.cpp:6:17]: (warning) Class 'C' does not have a operator= which is recommended since it has dynamic memory/resource management. [noOperatorEq]\\n\", errout_str());\n    }\n\n    void noOperatorEq() {\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Struct 'F' does not have a operator= which is recommended since it has dynamic memory/resource management. [noOperatorEq]\\n\", errout_str());\n\n        // defaulted operator=\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F &operator=(const F &f) = default;\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The operator= is explicitly defaulted but the default operator= does not work well. It is recommended to define or delete the operator=. [noOperatorEq]\\n\", errout_str());\n\n        // deleted operator=\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F &operator=(const F &f) = delete;\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // base class deletes operator=\n        checkCopyConstructor(\"struct F : NonCopyable {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   ~F();\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void noDestructor() {\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F&operator=(const F&);\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource management. [noDestructor]\\n\", errout_str());\n\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   C* c;\\n\"\n                             \"   F() { c = new C; }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F&operator=(const F&);\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   int* i;\\n\"\n                             \"   F() { i = new int(); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F& operator=(const F&);\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource management. [noDestructor]\\n\", errout_str());\n\n        checkCopyConstructor(\"struct Data { int x; int y; };\\n\"\n                             \"struct F {\\n\"\n                             \"   Data* c;\\n\"\n                             \"   F() { c = new Data; }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F&operator=(const F&);\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (warning) Struct 'F' does not have a destructor which is recommended since it has dynamic memory/resource management. [noDestructor]\\n\", errout_str());\n\n        // defaulted destructor\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F &operator=(const F &f);\\n\"\n                             \"   ~F() = default;\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Struct 'F' has dynamic memory/resource allocation(s). The destructor is explicitly defaulted but the default destructor does not work well. It is recommended to define the destructor. [noDestructor]\\n\", errout_str());\n\n        // deleted destructor\n        checkCopyConstructor(\"struct F {\\n\"\n                             \"   char* c;\\n\"\n                             \"   F() { c = malloc(100); }\\n\"\n                             \"   F(const F &f);\\n\"\n                             \"   F &operator=(const F &f);\\n\"\n                             \"   ~F() = delete;\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Check that operator Equal returns reference to this\n#define checkOpertorEqRetRefThis(...) checkOpertorEqRetRefThis_( __FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkOpertorEqRetRefThis_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings0, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings0, this);\n        checkClass.operatorEqRetRefThis();\n    }\n\n    void operatorEqRetRefThis1() {\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) { return *this; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) { return a; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { return a; }\");\n        ASSERT_EQUALS(\"[test.cpp:6:8]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { return a; }\");\n        ASSERT_EQUALS(\"[test.cpp:6:8]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &b) { return *this; }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &b) { return b; }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:7:13]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b) { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:10:14]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class B;\\n\"\n            \"};\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  B & operator=(const B & b) { return b; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:7]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class B;\\n\"\n            \"};\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  B & operator=(const B &);\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B & b) { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class B;\\n\"\n            \"};\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  A::B & operator=(const A::B & b) { return b; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class B;\\n\"\n            \"};\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  A::B & operator=(const A::B &);\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B & b) { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace A {\\n\"\n            \"    class B;\\n\"\n            \"}\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  B & operator=(const B & b) { return b; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:7]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace A {\\n\"\n            \"    class B;\\n\"\n            \"}\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  B & operator=(const B &);\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B & b) { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace A {\\n\"\n            \"    class B;\\n\"\n            \"}\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  A::B & operator=(const A::B & b) { return b; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace A {\\n\"\n            \"    class B;\\n\"\n            \"}\\n\"\n            \"class A::B\\n\"\n            \"{\\n\"\n            \"  A::B & operator=(const A::B &);\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B & b) { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis( // #11380\n            \"struct S {\\n\"\n            \"    S& operator=(const S& other) {\\n\"\n            \"        i = []() { return 42; }();\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"    int i;\\n\"\n            \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqRetRefThis2() {\n        // ticket # 1323\n        checkOpertorEqRetRefThis(\n            \"class szp\\n\"\n            \"{\\n\"\n            \"  szp &operator =(int *other) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class szp\\n\"\n            \"{\\n\"\n            \"  szp &operator =(int *other);\\n\"\n            \"};\\n\"\n            \"szp &szp::operator =(int *other) {}\");\n        ASSERT_EQUALS(\"[test.cpp:5:11]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace NS {\\n\"\n            \"    class szp;\\n\"\n            \"}\\n\"\n            \"class NS::szp\\n\"\n            \"{\\n\"\n            \"  szp &operator =(int *other) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:8]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace NS {\\n\"\n            \"    class szp;\\n\"\n            \"}\\n\"\n            \"class NS::szp\\n\"\n            \"{\\n\"\n            \"  szp &operator =(int *other);\\n\"\n            \"};\\n\"\n            \"NS::szp &NS::szp::operator =(int *other) {}\");\n        ASSERT_EQUALS(\"[test.cpp:8:19]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace NS {\\n\"\n            \"    class szp;\\n\"\n            \"}\\n\"\n            \"class NS::szp\\n\"\n            \"{\\n\"\n            \"  NS::szp &operator =(int *other) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:12]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"namespace NS {\\n\"\n            \"    class szp;\\n\"\n            \"}\\n\"\n            \"class NS::szp\\n\"\n            \"{\\n\"\n            \"  NS::szp &operator =(int *other);\\n\"\n            \"};\\n\"\n            \"NS::szp &NS::szp::operator =(int *other) {}\");\n        ASSERT_EQUALS(\"[test.cpp:8:19]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class szp;\\n\"\n            \"};\\n\"\n            \"class A::szp\\n\"\n            \"{\\n\"\n            \"  szp &operator =(int *other) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:8]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class szp;\\n\"\n            \"};\\n\"\n            \"class A::szp\\n\"\n            \"{\\n\"\n            \"  szp &operator =(int *other);\\n\"\n            \"};\\n\"\n            \"A::szp &A::szp::operator =(int *other) {}\");\n        ASSERT_EQUALS(\"[test.cpp:8:17]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class szp;\\n\"\n            \"};\\n\"\n            \"class A::szp\\n\"\n            \"{\\n\"\n            \"  A::szp &operator =(int *other) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:11]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"    class szp;\\n\"\n            \"};\\n\"\n            \"class A::szp\\n\"\n            \"{\\n\"\n            \"  A::szp &operator =(int *other);\\n\"\n            \"};\\n\"\n            \"A::szp &A::szp::operator =(int *other) {}\");\n        ASSERT_EQUALS(\"[test.cpp:8:17]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n    }\n\n    void operatorEqRetRefThis3() {\n        // ticket # 1405\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"  inline A &operator =(int *other) { return (*this); };\\n\"\n            \"  inline A &operator =(long *other) { return (*this = 0); };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"  A &operator =(int *other);\\n\"\n            \"  A &operator =(long *other);\\n\"\n            \"};\\n\"\n            \"A &A::operator =(int *other) { return (*this); };\\n\"\n            \"A &A::operator =(long *other) { return (*this = 0); };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"  inline A &operator =(int *other) { return (*this); };\\n\"\n            \"  inline A &operator =(long *other) { return operator = (*(int *)other); };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"  A &operator =(int *other);\\n\"\n            \"  A &operator =(long *other);\\n\"\n            \"};\\n\"\n            \"A &A::operator =(int *other) { return (*this); };\\n\"\n            \"A &A::operator =(long *other) { return operator = (*(int *)other); };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"  A &operator =(int *other);\\n\"\n            \"  A &operator =(long *other);\\n\"\n            \"};\\n\"\n            \"A &A::operator =(int *other) { return (*this); };\\n\"\n            \"A &A::operator =(long *other) { return this->operator = (*(int *)other); };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqRetRefThis( // #9045\n            \"class V {\\n\"\n            \"public:\\n\"\n            \"    V& operator=(const V& r) {\\n\"\n            \"        if (this == &r) {\\n\"\n            \"            return ( *this );\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqRetRefThis4() {\n        // ticket # 1451\n        checkOpertorEqRetRefThis(\n            \"P& P::operator = (const P& pc)\\n\"\n            \"{\\n\"\n            \"  return (P&)(*this += pc);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqRetRefThis5() {\n        // ticket # 1550\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) { }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"protected:\\n\"\n            \"    A & operator=(const A &a) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"private:\\n\"\n            \"    A & operator=(const A &a) {}\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) 'operator=' should return reference to 'this' instance. [operatorEqRetRefThis]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) {\\n\"\n            \"        rand();\\n\"\n            \"        throw std::exception();\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented. [operatorEqShouldBeLeftUnimplemented]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) {\\n\"\n            \"        rand();\\n\"\n            \"        abort();\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) 'operator=' should either return reference to 'this' instance or be declared private and left unimplemented. [operatorEqShouldBeLeftUnimplemented]\\n\", errout_str());\n\n        checkOpertorEqRetRefThis(\n            \"class A {\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A :: operator=(const A &a) { }\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) No 'return' statement in non-void function causes undefined behavior. [operatorEqMissingReturnStatement]\\n\", errout_str());\n    }\n\n    void operatorEqRetRefThis6() { // ticket #2478 (segmentation fault)\n        checkOpertorEqRetRefThis(\n            \"class UString {\\n\"\n            \"public:\\n\"\n            \"    UString& assign( const char* c_str );\\n\"\n            \"    UString& operator=( const UString& s );\\n\"\n            \"};\\n\"\n            \"UString& UString::assign( const char* c_str ) {\\n\"\n            \"    std::string tmp( c_str );\\n\"\n            \"    return assign( tmp );\\n\"\n            \"}\\n\"\n            \"UString& UString::operator=( const UString& s ) {\\n\"\n            \"    return assign( s );\\n\"\n            \"}\");\n    }\n\n    void operatorEqRetRefThis7() { // ticket #5782 Endless recursion in CheckClass::checkReturnPtrThis()\n        checkOpertorEqRetRefThis(\n            \"class basic_fbstring {\\n\"\n            \"  basic_fbstring& operator=(int il) {\\n\"\n            \"    return assign();\\n\"\n            \"  }\\n\"\n            \"  basic_fbstring& assign() {\\n\"\n            \"    return replace();\\n\"\n            \"  }\\n\"\n            \"  basic_fbstring& replaceImplDiscr() {\\n\"\n            \"    return replace();\\n\"\n            \"  }\\n\"\n            \"  basic_fbstring& replace() {\\n\"\n            \"    return replaceImplDiscr();\\n\"\n            \"  }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Check that operator Equal checks for assignment to self\n#define checkOpertorEqToSelf(...) checkOpertorEqToSelf_( __FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkOpertorEqToSelf_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings1, this);\n        checkClass.operatorEqToSelf();\n    }\n\n    void operatorEqToSelf1() {\n        // this test has an assignment test but it is not needed\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) { if (&a != this) { } return *this; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test doesn't have an assignment test but it is not needed\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) { return *this; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test and has it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if (&a != this)\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this class needs an assignment test but doesn't have it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test has an assignment test but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { if (&a != this) { } return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test doesn't have an assignment test but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test and has it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if (&a != this)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if (&a == this)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if ((&a == this) == true)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if ((&a == this) != false)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if (!((&a == this) == false))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if ((&a != this) == false)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if (&a != this)\\n\"\n            \"    {\\n\"\n            \"    }\\n\"\n            \"    else\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test needs an assignment test and has the inverse test\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if (&a != this)\\n\"\n            \"        free(s);\\n\"\n            \"    else\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n\n        // this test needs an assignment test but doesn’t have it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    free(s);\\n\"\n            \"    s = strdup(a.s);\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // ticket #1224\n        checkOpertorEqToSelf(\n            \"const SubTree &SubTree::operator= (const SubTree &b)\\n\"\n            \"{\\n\"\n            \"    CodeTree *oldtree = tree;\\n\"\n            \"    tree = new CodeTree(*b.tree);\\n\"\n            \"    delete oldtree;\\n\"\n            \"    return *this;\\n\"\n            \"}\\n\"\n            \"const SubTree &SubTree::operator= (const CodeTree &b)\\n\"\n            \"{\\n\"\n            \"    CodeTree *oldtree = tree;\\n\"\n            \"    tree = new CodeTree(b);\\n\"\n            \"    delete oldtree;\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void operatorEqToSelf2() {\n        // this test has an assignment test but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &b) { if (&b != this) { } return *this; }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test doesn't have an assignment test but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &b) { return *this; }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test but has it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        char *s;\\n\"\n            \"        B & operator=(const B &b)\\n\"\n            \"        {\\n\"\n            \"            if (&b != this)\\n\"\n            \"            {\\n\"\n            \"            }\\n\"\n            \"            return *this;\\n\"\n            \"        }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test but doesn't have it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        char *s;\\n\"\n            \"        B & operator=(const B &b)\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(b.s);\\n\"\n            \"            return *this;\\n\"\n            \"        }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:8:13]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        // this test has an assignment test but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b) { if (&b != this) { } return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test doesn't have an assignment test but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test and has it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        char * s;\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b)\\n\"\n            \"{\\n\"\n            \"    if (&b != this)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(b.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \" }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test needs an assignment test but doesn't have it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        char * s;\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b)\\n\"\n            \"{\\n\"\n            \"    free(s);\\n\"\n            \"    s = strdup(b.s);\\n\"\n            \"    return *this;\\n\"\n            \" }\");\n        ASSERT_EQUALS(\"[test.cpp:11:14]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n    }\n\n    void operatorEqToSelf3() {\n        // this test has multiple inheritance so there is no trivial way to test for self assignment but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A : public B, public C\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a) { return *this; }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test has multiple inheritance and needs an assignment test but there is no trivial way to test for it\n        checkOpertorEqToSelf(\n            \"class A : public B, public C\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test has multiple inheritance so there is no trivial way to test for self assignment but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A : public B, public C\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test has multiple inheritance and needs an assignment test but there is no trivial way to test for it\n        checkOpertorEqToSelf(\n            \"class A : public B, public C\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    free(s);\\n\"\n            \"    s = strdup(a.s);\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqToSelf4() {\n        // this test has multiple inheritance so there is no trivial way to test for self assignment but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B : public C, public D\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &b) { return *this; }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test has multiple inheritance and needs an assignment test but there is no trivial way to test for it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B : public C, public D\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        char * s;\\n\"\n            \"        B & operator=(const B &b)\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(b.s);\\n\"\n            \"            return *this;\\n\"\n            \"        }\\n\"\n            \"    };\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test has multiple inheritance so there is no trivial way to test for self assignment but doesn't need it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B : public C, public D\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b) { return *this; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // this test has multiple inheritance and needs an assignment test but there is no trivial way to test for it\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    class B : public C, public D\\n\"\n            \"    {\\n\"\n            \"    public:\\n\"\n            \"        char * s;\\n\"\n            \"        B & operator=(const B &);\\n\"\n            \"    };\\n\"\n            \"};\\n\"\n            \"A::B & A::B::operator=(const A::B &b)\\n\"\n            \"{\\n\"\n            \"    free(s);\\n\"\n            \"    s = strdup(b.s);\\n\"\n            \"    return *this;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqToSelf5() {\n        // ticket # 1233\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if((&a!=this))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if((this!=&a))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if(!(&a==this))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if(!(this==&a))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if(false==(&a==this))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if(false==(this==&a))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if(true!=(&a==this))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        if(true!=(this==&a))\\n\"\n            \"        {\\n\"\n            \"            free(s);\\n\"\n            \"            s = strdup(a.s);\\n\"\n            \"        }\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if((&a!=this))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if((this!=&a))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if(!(&a==this))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if(!(this==&a))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if(false==(&a==this))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if(false==(this==&a))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if(true!=(&a==this))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    char *s;\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    if(true!=(this==&a))\\n\"\n            \"    {\\n\"\n            \"        free(s);\\n\"\n            \"        s = strdup(a.s);\\n\"\n            \"    }\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"struct A {\\n\"\n            \"    char *s;\\n\"\n            \"    A& operator=(const B &b);\\n\"\n            \"};\\n\"\n            \"A& A::operator=(const B &b) {\\n\"\n            \"    free(s);\\n\"\n            \"    s = strdup(a.s);\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqToSelf6() {\n        // ticket # 1550\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        delete [] data;\\n\"\n            \"        data = new char[strlen(a.data) + 1];\\n\"\n            \"        strcpy(data, a.data);\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"private:\\n\"\n            \"    char * data;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"private:\\n\"\n            \"    char * data;\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    delete [] data;\\n\"\n            \"    data = new char[strlen(a.data) + 1];\\n\"\n            \"    strcpy(data, a.data);\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:8:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        delete data;\\n\"\n            \"        data = new char;\\n\"\n            \"        *data  = *a.data;\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"private:\\n\"\n            \"    char * data;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & operator=(const A &a);\\n\"\n            \"private:\\n\"\n            \"    char * data;\\n\"\n            \"};\\n\"\n            \"A & A::operator=(const A &a)\\n\"\n            \"{\\n\"\n            \"    delete data;\\n\"\n            \"    data = new char;\\n\"\n            \"    *data = *a.data;\\n\"\n            \"    return *this;\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"[test.cpp:8:8]: (warning) 'operator=' should check for assignment to self to avoid problems with dynamic memory. [operatorEqToSelf]\\n\", errout_str());\n    }\n\n    void operatorEqToSelf7() {\n        checkOpertorEqToSelf(\n            \"class A\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    A & assign(const A & a)\\n\"\n            \"    {\\n\"\n            \"        return *this;\\n\"\n            \"    }\\n\"\n            \"    A & operator=(const A &a)\\n\"\n            \"    {\\n\"\n            \"        return assign(a);\\n\"\n            \"    }\\n\"\n            \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqToSelf8() {\n        checkOpertorEqToSelf(\n            \"class FMat\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    FMat& copy(const FMat& rhs);\\n\"\n            \"    FMat& operator=(const FMat& in);\\n\"\n            \"};\\n\"\n            \"FMat& FMat::copy(const FMat& rhs)\\n\"\n            \"{\\n\"\n            \"    return *this;\\n\"\n            \"}\\n\"\n            \"FMat& FMat::operator=(const FMat& in)\\n\"\n            \"{\\n\"\n            \"    return copy(in);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorEqToSelf9() {\n        checkOpertorEqToSelf(\n            \"class Foo\\n\"\n            \"{\\n\"\n            \"public:\\n\"\n            \"    Foo& operator=(Foo* pOther);\\n\"\n            \"    Foo& operator=(Foo& other);\\n\"\n            \"};\\n\"\n            \"Foo& Foo::operator=(Foo* pOther)\\n\"\n            \"{\\n\"\n            \"    return *this;\\n\"\n            \"}\\n\"\n            \"Foo& Foo::operator=(Foo& other)\\n\"\n            \"{\\n\"\n            \"    return Foo::operator=(&other);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    struct CheckVirtualDestructorOptions\n    {\n        CheckVirtualDestructorOptions() = default;\n        bool inconclusive = false;\n    };\n\n    // Check that base classes have virtual destructors\n#define checkVirtualDestructor(...) checkVirtualDestructor_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkVirtualDestructor_(const char* file, int line, const char (&code)[size], const CheckVirtualDestructorOptions& options = make_default_obj()) {\n        const Settings s = settingsBuilder(settings0).certainty(Certainty::inconclusive, options.inconclusive).severity(Severity::warning).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(s, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &s, this);\n        checkClass.virtualDestructor();\n    }\n\n    void virtualDestructor1() {\n        // Base class not found\n\n        checkVirtualDestructor(\"class Derived : public Base { };\\n\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualDestructor(\"class Derived : Base { };\\n\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void virtualDestructor2() {\n        // Base class doesn't have a destructor\n\n        checkVirtualDestructor(\"class Base { };\\n\"\n                               \"class Derived : public Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base { };\\n\"\n                               \"class Derived : protected Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base { };\\n\"\n                               \"class Derived : private Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualDestructor(\"class Base { };\\n\"\n                               \"class Derived : Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9104\n        checkVirtualDestructor(\"struct A\\n\"\n                               \"{\\n\"\n                               \"    A()  { cout << \\\"A is constructing\\\\n\\\"; }\\n\"\n                               \"    ~A() { cout << \\\"A is destructing\\\\n\\\"; }\\n\"\n                               \"};\\n\"\n                               \" \\n\"\n                               \"struct Base {};\\n\"\n                               \" \\n\"\n                               \"struct Derived : Base\\n\"\n                               \"{\\n\"\n                               \"    A a;\\n\"\n                               \"};\\n\"\n                               \" \\n\"\n                               \"int main(void)\\n\"\n                               \"{\\n\"\n                               \"    Base* p = new Derived();\\n\"\n                               \"    delete p;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"using namespace std;\\n\"\n                               \"struct A\\n\"\n                               \"{\\n\"\n                               \"    A()  { cout << \\\"A is constructing\\\\n\\\"; }\\n\"\n                               \"    ~A() { cout << \\\"A is destructing\\\\n\\\"; }\\n\"\n                               \"};\\n\"\n                               \" \\n\"\n                               \"struct Base {};\\n\"\n                               \" \\n\"\n                               \"struct Derived : Base\\n\"\n                               \"{\\n\"\n                               \"    A a;\\n\"\n                               \"};\\n\"\n                               \" \\n\"\n                               \"int main(void)\\n\"\n                               \"{\\n\"\n                               \"    Base* p = new Derived();\\n\"\n                               \"    delete p;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:1]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n    }\n\n    void virtualDestructor3() {\n        // Base class has a destructor, but it's not virtual\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : public Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : protected Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : private Fred, public Base { public: ~Derived() { (void)11; } };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n    }\n\n    void virtualDestructor4() {\n        // Derived class doesn't have a destructor => undefined behaviour according to paragraph 3 in [expr.delete]\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : public Base { };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : private Fred, public Base { };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n    }\n\n    void virtualDestructor5() {\n        // Derived class has empty destructor => undefined behaviour according to paragraph 3 in [expr.delete]\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : public Base { public: ~Derived() {} };\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : public Base { public: ~Derived(); }; Derived::~Derived() {}\"\n                               \"Base *base = new Derived;\\n\"\n                               \"delete base;\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n    }\n\n    void virtualDestructor6() {\n        // Only report error if base class pointer is deleted that\n        // points at derived class\n\n        checkVirtualDestructor(\"class Base { public: ~Base(); };\\n\"\n                               \"class Derived : public Base { public: ~Derived() { (void)11; } };\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void virtualDestructorProtected() {\n        // Base class has protected destructor, it makes Base *p = new Derived(); fail\n        // during compilation time, so error is not possible. => no error\n        checkVirtualDestructor(\"class A\\n\"\n                               \"{\\n\"\n                               \"protected:\\n\"\n                               \"    ~A() { }\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"class B : public A\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~B() { int a; }\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void virtualDestructorInherited() {\n        // class A inherits virtual destructor from class Base -> no error\n        checkVirtualDestructor(\"class Base\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"virtual ~Base() {}\\n\"\n                               \"};\\n\"\n                               \"class A : private Base\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~A() { }\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"class B : public A\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~B() { int a; }\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // class A inherits virtual destructor from struct Base -> no error\n        // also notice that public is not given, but destructor is public, because\n        // we are using struct instead of class\n        checkVirtualDestructor(\"struct Base\\n\"\n                               \"{\\n\"\n                               \"virtual ~Base() {}\\n\"\n                               \"};\\n\"\n                               \"class A : public Base\\n\"\n                               \"{\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"class B : public A\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~B() { int a; }\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown Base class -> it could have virtual destructor, so ignore\n        checkVirtualDestructor(\"class A : private Base\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~A() { }\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"class B : public A\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~B() { int a; }\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Virtual destructor is inherited -> no error\n        checkVirtualDestructor(\"class Base2\\n\"\n                               \"{\\n\"\n                               \"virtual ~Base2() {}\\n\"\n                               \"};\\n\"\n                               \"class Base : public Base2\\n\"\n                               \"{\\n\"\n                               \"};\\n\"\n                               \"class A : private Base\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~A() { }\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"class B : public A\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~B() { int a; }\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // class A doesn't inherit virtual destructor from class Base -> error\n        checkVirtualDestructor(\"class Base\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~Base() {}\\n\"\n                               \"};\\n\"\n                               \"class A : private Base\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~A() { }\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"class B : public A\\n\"\n                               \"{\\n\"\n                               \"public:\\n\"\n                               \"    ~B() { int a; }\\n\"\n                               \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7]: (error) Class 'Base' which is inherited by class 'B' does not have a virtual destructor.\\n\",\n                           \"\", errout_str());\n    }\n\n    void virtualDestructorTemplate() {\n        checkVirtualDestructor(\"template <typename T> class A\\n\"\n                               \"{\\n\"\n                               \" public:\\n\"\n                               \" virtual ~A(){}\\n\"\n                               \"};\\n\"\n                               \"template <typename T> class AA\\n\"\n                               \"{\\n\"\n                               \" public:\\n\"\n                               \" ~AA(){}\\n\"\n                               \"};\\n\"\n                               \"class B : public A<int>, public AA<double>\\n\"\n                               \"{\\n\"\n                               \" public:\\n\"\n                               \" ~B(){int a;}\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"AA<double> *p = new B; delete p;\");\n        ASSERT_EQUALS(\"[test.cpp:9:3]: (error) Class 'AA < double >' which is inherited by class 'B' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n    }\n\n    void virtualDestructorInconclusive() {\n        checkVirtualDestructor(\"class Base {\\n\"\n                               \"public:\\n\"\n                               \"    ~Base(){}\\n\"\n                               \"    virtual void foo(){}\\n\"\n                               \"};\\n\", dinit(CheckVirtualDestructorOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (warning, inconclusive) Class 'Base' which has virtual members does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        checkVirtualDestructor(\"class Base {\\n\"\n                               \"public:\\n\"\n                               \"    ~Base(){}\\n\"\n                               \"    virtual void foo(){}\\n\"\n                               \"};\\n\"\n                               \"class Derived : public Base {\\n\"\n                               \"public:\\n\"\n                               \"    ~Derived() { bar(); }\\n\"\n                               \"};\\n\"\n                               \"void foo() {\\n\"\n                               \"    Base * base = new Derived();\\n\"\n                               \"    delete base;\\n\"\n                               \"}\\n\", dinit(CheckVirtualDestructorOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor. [virtualDestructor]\\n\", errout_str());\n\n        // class Base destructor is not virtual but protected -> no error\n        checkVirtualDestructor(\"class Base {\\n\"\n                               \"public:\\n\"\n                               \"    virtual void foo(){}\\n\"\n                               \"protected:\\n\"\n                               \"    ~Base(){}\\n\"\n                               \"};\\n\", dinit(CheckVirtualDestructorOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualDestructor(\"class C {\\n\"\n                               \"private:\\n\"\n                               \"    C();\\n\"\n                               \"    virtual ~C();\\n\"\n                               \"};\\n\", dinit(CheckVirtualDestructorOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n#define checkNoMemset(...) checkNoMemset_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkNoMemset_(const char* file, int line, const char (&code)[size]) {\n        const Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::portability).library(\"std.cfg\").library(\"posix.cfg\").build();\n        checkNoMemset_(file, line, code, settings);\n    }\n\n    template<size_t size>\n    void checkNoMemset_(const char* file, int line, const char (&code)[size], const Settings &settings) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings, this);\n        checkClass.checkMemset();\n    }\n\n    void memsetOnClass() {\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    static std::string b;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    std::string * b;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    std::string b;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    mutable std::string b;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred {\\n\"\n                      \"    std::string b;\\n\"\n                      \"    void f();\\n\"\n                      \"};\\n\"\n                      \"void Fred::f() {\\n\"\n                      \"    memset(this, 0, sizeof(*this));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    std::string s;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    std::string s;\\n\"\n                      \"};\\n\"\n                      \"class Pebbles: public Fred {};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Pebbles pebbles;\\n\"\n                      \"    memset(&pebbles, 0, sizeof(pebbles));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    virtual ~Fred();\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Using 'memset' on class that contains a virtual function. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"    virtual ~Fred();\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    static Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Using 'memset' on class that contains a virtual function. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class Fred\\n\"\n                      \"{\\n\"\n                      \"};\\n\"\n                      \"class Wilma\\n\"\n                      \"{\\n\"\n                      \"    virtual ~Wilma();\\n\"\n                      \"};\\n\"\n                      \"class Pebbles: public Fred, Wilma {};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Pebbles pebbles;\\n\"\n                      \"    memset(&pebbles, 0, sizeof(pebbles));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:12:5]: (error) Using 'memset' on class that contains a virtual function. [memsetClass]\\n\", errout_str());\n\n        // Fred not defined in scope\n        checkNoMemset(\"namespace n1 {\\n\"\n                      \"    class Fred\\n\"\n                      \"    {\\n\"\n                      \"        std::string b;\\n\"\n                      \"    };\\n\"\n                      \"}\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Fred with namespace qualifier\n        checkNoMemset(\"namespace n1 {\\n\"\n                      \"    class Fred\\n\"\n                      \"    {\\n\"\n                      \"        std::string b;\\n\"\n                      \"    };\\n\"\n                      \"}\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    n1::Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(n1::Fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        // Fred with namespace qualifier\n        checkNoMemset(\"namespace n1 {\\n\"\n                      \"    class Fred\\n\"\n                      \"    {\\n\"\n                      \"        std::string b;\\n\"\n                      \"    };\\n\"\n                      \"}\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    n1::Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:5]: (error) Using 'memset' on class that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class A {\\n\"\n                      \"  virtual ~A() { }\\n\"\n                      \"  std::string s;\\n\"\n                      \"};\\n\"\n                      \"int f() {\\n\"\n                      \"  const int N = 10;\\n\"\n                      \"  A** arr = new A*[N];\\n\"\n                      \"  memset(arr, 0, N * sizeof(A*));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class A {\\n\" // #5116 - nested class data is mixed in the SymbolDatabase\n                      \"  std::string s;\\n\"\n                      \"  struct B { int x; };\\n\"\n                      \"};\\n\"\n                      \"void f(A::B *b) {\\n\"\n                      \"  memset(b,0,4);\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4461 Warn about memset/memcpy on class with references as members\n        checkNoMemset(\"class A {\\n\"\n                      \"  std::string &s;\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"  A a;\\n\"\n                      \"  memset(&a, 0, sizeof(a));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:3]: (error) Using 'memset' on class that contains a reference. [memsetClassReference]\\n\", errout_str());\n        checkNoMemset(\"class A {\\n\"\n                      \"  const B&b;\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"  A a;\\n\"\n                      \"  memset(&a, 0, sizeof(a));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:3]: (error) Using 'memset' on class that contains a reference. [memsetClassReference]\\n\", errout_str());\n\n        // #7456\n        checkNoMemset(\"struct A {\\n\"\n                      \"  A() {}\\n\"\n                      \"  virtual ~A() {}\\n\"\n                      \"};\\n\"\n                      \"struct B {\\n\"\n                      \"  A* arr[4];\\n\"\n                      \"};\\n\"\n                      \"void func() {\\n\"\n                      \"  B b[4];\\n\"\n                      \"  memset(b, 0, sizeof(b));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8619\n        checkNoMemset(\"struct S { std::vector<int> m; };\\n\"\n                      \"void f() {\\n\"\n                      \"    std::vector<S> v(5);\\n\"\n                      \"    memset(&v[0], 0, sizeof(S) * v.size());\\n\"\n                      \"    memset(&v[0], 0, v.size() * sizeof(S));\\n\"\n                      \"    memset(&v[0], 0, 5 * sizeof(S));\\n\"\n                      \"    memset(&v[0], 0, sizeof(S) * 5);\\n\"\n                      \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\"\n                      \"[test.cpp:5:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\"\n                      \"[test.cpp:6:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\"\n                      \"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\",\n                      errout_str());\n\n        // #1655\n        const Settings s = settingsBuilder().library(\"std.cfg\").build();\n        checkNoMemset(\"void f() {\\n\"\n                      \"    char c[] = \\\"abc\\\";\\n\"\n                      \"    std::string s;\\n\"\n                      \"    memcpy(&s, c, strlen(c) + 1);\\n\"\n                      \"}\\n\", s);\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Using 'memcpy' on std::string. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"template <typename T>\\n\"\n                      \"    void f(T* dst, const T* src, int N) {\\n\"\n                      \"    std::memcpy(dst, src, N * sizeof(T));\\n\"\n                      \"}\\n\"\n                      \"void g() {\\n\"\n                      \"    typedef std::vector<int>* P;\\n\"\n                      \"    P Src[2]{};\\n\"\n                      \"    P Dst[2];\\n\"\n                      \"    f<P>(Dst, Src, 2);\\n\"\n                      \"}\\n\", s);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"void f() {\\n\"\n                      \"    std::array<char, 4> a;\\n\"\n                      \"    std::memset(&a, 0, 4);\\n\"\n                      \"}\\n\", s);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memsetOnInvalid() { // Ticket #5425\n        checkNoMemset(\"union ASFStreamHeader {\\n\"\n                      \"  struct AVMPACKED {\\n\"\n                      \"    union  {\\n\"\n                      \"      struct AVMPACKED {\\n\"\n                      \"        int width;\\n\"\n                      \"      } vid;\\n\"\n                      \"    };\\n\"\n                      \"  } hdr;\\n\"\n                      \"};\"\n                      \"void parseHeader() {\\n\"\n                      \"  ASFStreamHeader strhdr;\\n\"\n                      \"  memset(&strhdr, 0, sizeof(strhdr));\\n\"\n                      \"}\");\n    }\n\n    void memsetOnStruct() {\n        checkNoMemset(\"struct A\\n\"\n                      \"{\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    struct A a;\\n\"\n                      \"    memset(&a, 0, sizeof(struct A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    struct A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"void f()\\n\"\n                      \"{\\n\"\n                      \"    struct sockaddr_in6 fail;\\n\"\n                      \"    memset(&fail, 0, sizeof(struct sockaddr_in6));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{\\n\"\n                      \" void g( struct sockaddr_in6& a);\\n\"\n                      \"private:\\n\"\n                      \" std::string b;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \" struct A fail;\\n\"\n                      \" memset(&fail, 0, sizeof(struct A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:2]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct Fred\\n\"\n                      \"{\\n\"\n                      \"     std::string s;\\n\"\n                      \"};\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    Fred fred;\\n\"\n                      \"    memset(&fred, 0, sizeof(fred));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct Stringy {\\n\"\n                      \"    std::string inner;\\n\"\n                      \"};\\n\"\n                      \"struct Foo {\\n\"\n                      \"    Stringy s;\\n\"\n                      \"};\\n\"\n                      \"int main() {\\n\"\n                      \"    Foo foo;\\n\"\n                      \"    memset(&foo, 0, sizeof(Foo));\\n\"\n                      \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:9:5]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n    }\n\n    void memsetVector() {\n        checkNoMemset(\"class A\\n\"\n                      \"{ std::vector<int> ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on class that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{ std::vector<int> ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{ std::vector<int> ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(struct A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{ std::vector<int> ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(a));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"class A\\n\"\n                      \"{ std::vector< std::vector<int> > ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on class that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{ std::vector< std::vector<int> > ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{ std::vector< std::vector<int> > ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(a));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A\\n\"\n                      \"{ std::vector<int *> ints; };\\n\"\n                      \"\\n\"\n                      \"void f()\\n\"\n                      \"{\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Using 'memset' on struct that contains a 'std::vector'. [memsetClass]\\n\", errout_str());\n\n        checkNoMemset(\"struct A {\\n\"\n                      \"     std::vector<int *> buf;\\n\"\n                      \"     operator int*() {return &buf[0];}\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(a, 0, 100);\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // #4460\n\n        checkNoMemset(\"struct C {\\n\"\n                      \"    std::string s;\\n\"\n                      \"};\\n\"\n                      \"int foo() {\\n\"\n                      \"    C* c1[10][10];\\n\"\n                      \"    C* c2[10];\\n\"\n                      \"    C c3[10][10];\\n\"\n                      \"    C** c4 = new C*[10];\\n\"\n                      \"    memset(**c1, 0, 10);\\n\"\n                      \"    memset(*c1, 0, 10);\\n\"\n                      \"    memset(*c2, 0, 10);\\n\"\n                      \"    memset(*c3, 0, 10);\\n\"\n                      \"    memset(*c4, 0, 10);\\n\"\n                      \"    memset(c2, 0, 10);\\n\"\n                      \"    memset(c3, 0, 10);\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:5]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\"\n                      \"[test.cpp:11:5]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\"\n                      \"[test.cpp:12:5]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\"\n                      \"[test.cpp:13:5]: (error) Using 'memset' on struct that contains a 'std::string'. [memsetClass]\\n\", errout_str());\n\n        // Ticket #6953\n        checkNoMemset(\"typedef float realnum;\\n\"\n                      \"struct multilevel_data {\\n\"\n                      \"  realnum *GammaInv;\\n\"\n                      \"  realnum data[1];\\n\"\n                      \"};\\n\"\n                      \"void *new_internal_data() const {\\n\"\n                      \"  multilevel_data *d = (multilevel_data *) malloc(sizeof(multilevel_data));\\n\"\n                      \"  memset(d, 0, sizeof(multilevel_data));\\n\"\n                      \"  return (void*) d;\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:3]: (portability) Using memset() on struct which contains a floating point number. [memsetClassFloat]\\n\", errout_str());\n    }\n\n    void memsetOnStdPodType() { // Ticket #5901\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <podtype name=\\\"std::uint8_t\\\" sign=\\\"u\\\" size=\\\"1\\\"/>\\n\"\n                                   \"  <podtype name=\\\"std::atomic_bool\\\"/>\\n\"\n                                   \"</def>\";\n        const Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        checkNoMemset(\"class A {\\n\"\n                      \"    std::array<int, 10> ints;\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // std::array is POD (#5481)\n\n        checkNoMemset(\"struct st {\\n\"\n                      \"  std::uint8_t a;\\n\"\n                      \"  std::atomic_bool b;\\n\"\n                      \"};\\n\"\n                      \"\\n\"\n                      \"void f() {\\n\"\n                      \"  st s;\\n\"\n                      \"  std::memset(&s, 0, sizeof(st));\\n\"\n                      \"}\", settings);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memsetOnFloat() {\n        checkNoMemset(\"struct A {\\n\"\n                      \"    float f;\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (portability) Using memset() on struct which contains a floating point number. [memsetClassFloat]\\n\", errout_str());\n\n        checkNoMemset(\"struct A {\\n\"\n                      \"    float f[4];\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (portability) Using memset() on struct which contains a floating point number. [memsetClassFloat]\\n\", errout_str());\n\n        checkNoMemset(\"struct A {\\n\"\n                      \"    float f[4];\\n\"\n                      \"};\\n\"\n                      \"void f(const A& b) {\\n\"\n                      \"    A a;\\n\"\n                      \"    memcpy(&a, &b, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"struct A {\\n\"\n                      \"    float* f;\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    A a;\\n\"\n                      \"    memset(&a, 0, sizeof(A));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memsetOnUnknown() {\n        checkNoMemset(\"void clang_tokenize(CXToken **Tokens) {\\n\"\n                      \"  *Tokens = (CXToken *)malloc(sizeof(CXToken) * CXTokens.size());\\n\"\n                      \"  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mallocOnClass() {\n        checkNoMemset(\"class C { C() {} };\\n\"\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = malloc(sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:1:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors. [mallocOnClassWarning]\\n\", errout_str());\n\n        checkNoMemset(\"class C { C(int z, Foo bar) { bar(); } };\\n\"\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = malloc(sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:1:1]: (warning) Memory for class instance allocated with malloc(), but class provides constructors. [mallocOnClassWarning]\\n\", errout_str());\n\n        checkNoMemset(\"struct C { C() {} };\\n\"\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = realloc(p, sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:1:1]: (warning) Memory for class instance allocated with realloc(), but class provides constructors. [mallocOnClassWarning]\\n\", errout_str());\n\n        checkNoMemset(\"struct C { virtual void bar(); };\\n\"\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = malloc(sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:1:1]: (error) Memory for class instance allocated with malloc(), but class contains a virtual function. [mallocOnClassError]\\n\", errout_str());\n\n        checkNoMemset(\"struct C { std::string s; };\\n\"\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = malloc(sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:1:1]: (error) Memory for class instance allocated with malloc(), but class contains a 'std::string'. [mallocOnClassError]\\n\", errout_str());\n\n        checkNoMemset(\"class C { };\\n\" // C-Style class/struct\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = malloc(sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"struct C { C() {} };\\n\"\n                      \"void foo(C*& p) {\\n\"\n                      \"    p = new C();\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class C { C() {} };\\n\"\n                      \"void foo(D*& p) {\\n\" // Unknown type\n                      \"    p = malloc(sizeof(C));\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"class AutoCloseFD {\\n\"\n                      \"    int fd;\\n\"\n                      \"public:\\n\"\n                      \"    AutoCloseFD(int fd);\\n\"\n                      \"    ~AutoCloseFD();\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    AutoCloseFD fd = open(\\\"abc\\\", O_RDONLY | O_CLOEXEC);\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNoMemset(\"struct C {\\n\" // #12313\n                      \"    char* p;\\n\"\n                      \"    C(char* ptr) : p(ptr) {}\\n\"\n                      \"};\\n\"\n                      \"void f() {\\n\"\n                      \"    C c = strdup(\\\"abc\\\");\\n\"\n                      \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkThisSubtraction(...) checkThisSubtraction_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkThisSubtraction_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings1, this);\n        checkClass.thisSubtraction();\n    }\n\n    void this_subtraction() {\n        checkThisSubtraction(\"; this-x ;\");\n        ASSERT_EQUALS(\"[test.cpp:1:3]: (warning) Suspicious pointer subtraction. Did you intend to write '->'? [thisSubtraction]\\n\", errout_str());\n\n        checkThisSubtraction(\"; *this = *this-x ;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkThisSubtraction(\"; *this = *this-x ;\\n\"\n                             \"this-x ;\");\n        ASSERT_EQUALS(\"[test.cpp:2:1]: (warning) Suspicious pointer subtraction. Did you intend to write '->'? [thisSubtraction]\\n\", errout_str());\n\n        checkThisSubtraction(\"; *this = *this-x ;\\n\"\n                             \"this-x ;\\n\"\n                             \"this-x ;\");\n        ASSERT_EQUALS(\"[test.cpp:2:1]: (warning) Suspicious pointer subtraction. Did you intend to write '->'? [thisSubtraction]\\n\"\n                      \"[test.cpp:3:1]: (warning) Suspicious pointer subtraction. Did you intend to write '->'? [thisSubtraction]\\n\", errout_str());\n    }\n\n    struct CheckConstOptions\n    {\n        CheckConstOptions() = default;\n        const Settings *s = nullptr;\n        bool inconclusive = true;\n    };\n\n#define checkConst(...) checkConst_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkConst_(const char* file, int line, const char (&code)[size], const CheckConstOptions& options = make_default_obj()) {\n        const Settings settings = settingsBuilder(options.s ? *options.s : settings0).certainty(Certainty::inconclusive, options.inconclusive).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CheckClass checkClass(&tokenizer, &settings, this);\n        (checkClass.checkConst)();\n    }\n\n    void const1() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    int getA() { return a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style, inconclusive) Technically the member function 'Fred::getA' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    const std::string foo() { return \\\"\\\"; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    const std::string & foo() { return \\\"\\\"; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        // constructors can't be const..\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"public:\\n\"\n                   \"    Fred() { }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment through |=..\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    int setA() { a |= true; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // functions with a call to a member function can only be const, if that member function is const, too.. (#1305)\n        checkConst(\"class foo {\\n\"\n                   \"public:\\n\"\n                   \"    int x;\\n\"\n                   \"    void a() { x = 1; }\\n\"\n                   \"    void b() { a(); }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    int x;\\n\"\n                   \"    int a() const { return x; }\\n\"\n                   \"    void b() { a(); }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (style, inconclusive) Technically the member function 'Fred::b' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    int x;\\n\"\n                   \"    void b() { a(); }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (performance, inconclusive) Technically the member function 'Fred::b' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        // static functions can't be const..\n        checkConst(\"class foo\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    static unsigned get()\\n\"\n                   \"    { return 0; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    const std::string foo() const throw() { return \\\"\\\"; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const2() {\n        // ticket 1344\n        // assignment to variable can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo() { s = \\\"\\\"; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument reference can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a) { a = s; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a) { s = a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument references can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b) { a = s; b = s; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b) { s = a; s = b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b) { s = a; b = a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b) { a = s; s = b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const3() {\n        // assignment to function argument pointer can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    int s;\\n\"\n                   \"    void foo(int * a) { *a = s; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    int s;\\n\"\n                   \"    void foo(int * a) { s = *a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument pointers can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b) { *a = s; *b = s; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b) { s = *a; s = *b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b) { s = *a; *b = s; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b) { *a = s; s = b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const4() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    int getA();\\n\"\n                   \"};\\n\"\n                   \"int Fred::getA() { return a; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:5:11]: (style, inconclusive) Technically the member function 'Fred::getA' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    const std::string & foo();\\n\"\n                   \"};\\n\"\n                   \"const std::string & Fred::foo() { return \\\"\\\"; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:25] -> [test.cpp:5:27]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        // functions with a function call to a non-const member can't be const.. (#1305)\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    int x;\\n\"\n                   \"    void a() { x = 1; }\\n\"\n                   \"    void b();\\n\"\n                   \"};\\n\"\n                   \"void Fred::b() { a(); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // static functions can't be const..\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    static unsigned get();\\n\"\n                   \"};\\n\"\n                   \"static unsigned Fred::get() { return 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo();\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo() { s = \\\"\\\"; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument reference can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string & a) { a = s; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:5:12]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string & a) { s = a; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument references can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string & a, std::string & b) { a = s; b = s; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:5:12]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string & a, std::string & b) { s = a; s = b; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string & a, std::string & b) { s = a; b = a; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string & a, std::string & b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string & a, std::string & b) { a = s; s = b; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument pointer can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    int s;\\n\"\n                   \"    void foo(int * a);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(int * a) { *a = s; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:5:12]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    int s;\\n\"\n                   \"    void foo(int * a);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(int * a) { s = *a; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to function argument pointers can be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string * a, std::string * b) { *a = s; *b = s; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:5:12]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string * a, std::string * b) { s = *a; s = *b; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string * a, std::string * b) { s = *a; *b = s; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment to variable, can't be const\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo(std::string * a, std::string * b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo(std::string * a, std::string * b) { *a = s; s = b; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // check functions with same name\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo();\\n\"\n                   \"    void foo(std::string & a);\\n\"\n                   \"    void foo(const std::string & a);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo() { }\"\n                   \"void Fred::foo(std::string & a) { a = s; }\"\n                   \"void Fred::foo(const std::string & a) { s = a; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:7:12]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:4:10] -> [test.cpp:7:32]: (style, inconclusive) Technically the member function 'Fred::foo' can be const. [functionConst]\\n\", errout_str());\n\n        // check functions with different or missing parameter names\n        checkConst(\"class Fred {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void foo1(int, int);\\n\"\n                   \"    void foo2(int a, int b);\\n\"\n                   \"    void foo3(int, int b);\\n\"\n                   \"    void foo4(int a, int);\\n\"\n                   \"    void foo5(int a, int b);\\n\"\n                   \"};\\n\"\n                   \"void Fred::foo1(int a, int b) { }\\n\"\n                   \"void Fred::foo2(int c, int d) { }\\n\"\n                   \"void Fred::foo3(int a, int b) { }\\n\"\n                   \"void Fred::foo4(int a, int b) { }\\n\"\n                   \"void Fred::foo5(int, int) { }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:9:12]: (performance, inconclusive) Technically the member function 'Fred::foo1' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:4:10] -> [test.cpp:10:12]: (performance, inconclusive) Technically the member function 'Fred::foo2' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:5:10] -> [test.cpp:11:12]: (performance, inconclusive) Technically the member function 'Fred::foo3' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:6:10] -> [test.cpp:12:12]: (performance, inconclusive) Technically the member function 'Fred::foo4' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:7:10] -> [test.cpp:13:12]: (performance, inconclusive) Technically the member function 'Fred::foo5' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        // check nested classes\n        checkConst(\"class Fred {\\n\"\n                   \"    class A {\\n\"\n                   \"        int a;\\n\"\n                   \"        int getA() { return a; }\\n\"\n                   \"    };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    class A {\\n\"\n                   \"        int a;\\n\"\n                   \"        int getA();\\n\"\n                   \"    };\\n\"\n                   \"    int A::getA() { return a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:6:12]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    class A {\\n\"\n                   \"        int a;\\n\"\n                   \"        int getA();\\n\"\n                   \"    };\\n\"\n                   \"};\\n\"\n                   \"int Fred::A::getA() { return a; }\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:7:14]: (style, inconclusive) Technically the member function 'Fred::A::getA' can be const. [functionConst]\\n\", errout_str());\n\n        // check deeply nested classes\n        checkConst(\"class Fred {\\n\"\n                   \"    class B {\\n\"\n                   \"        int b;\\n\"\n                   \"        int getB() { return b; }\\n\"\n                   \"        class A {\\n\"\n                   \"            int a;\\n\"\n                   \"            int getA() { return a; }\\n\"\n                   \"        };\\n\"\n                   \"    };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const. [functionConst]\\n\"\n                      \"[test.cpp:7:17]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const. [functionConst]\\n\"\n                      , errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    class B {\\n\"\n                   \"        int b;\\n\"\n                   \"        int getB();\\n\"\n                   \"        class A {\\n\"\n                   \"            int a;\\n\"\n                   \"            int getA();\\n\"\n                   \"        };\\n\"\n                   \"        int A::getA() { return a; }\\n\"\n                   \"    };\\n\"\n                   \"    int B::getB() { return b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:11:12]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const. [functionConst]\\n\"\n                      \"[test.cpp:7:17] -> [test.cpp:9:16]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    class B {\\n\"\n                   \"        int b;\\n\"\n                   \"        int getB();\\n\"\n                   \"        class A {\\n\"\n                   \"            int a;\\n\"\n                   \"            int getA();\\n\"\n                   \"        };\\n\"\n                   \"    };\\n\"\n                   \"    int B::A::getA() { return a; }\\n\"\n                   \"    int B::getB() { return b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:11:12]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const. [functionConst]\\n\"\n                      \"[test.cpp:7:17] -> [test.cpp:10:15]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    class B {\\n\"\n                   \"        int b;\\n\"\n                   \"        int getB();\\n\"\n                   \"        class A {\\n\"\n                   \"            int a;\\n\"\n                   \"            int getA();\\n\"\n                   \"        };\\n\"\n                   \"    };\\n\"\n                   \"};\\n\"\n                   \"int Fred::B::A::getA() { return a; }\\n\"\n                   \"int Fred::B::getB() { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:12:14]: (style, inconclusive) Technically the member function 'Fred::B::getB' can be const. [functionConst]\\n\"\n                      \"[test.cpp:7:17] -> [test.cpp:11:17]: (style, inconclusive) Technically the member function 'Fred::B::A::getA' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    // operator< can often be const\n    void constoperator1() {\n        checkConst(\"struct Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    bool operator<(const Fred &f) { return a < f.a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'Fred::operator<' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    // operator<<\n    void constoperator2() {\n        checkConst(\"struct Foo {\\n\"\n                   \"    void operator<<(int);\\n\"\n                   \"};\\n\"\n                   \"struct Fred {\\n\"\n                   \"    Foo foo;\\n\"\n                   \"    void x()\\n\"\n                   \"    {\\n\"\n                   \"        foo << 123;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct Foo {\\n\"\n                   \"    void operator<<(int);\\n\"\n                   \"};\\n\"\n                   \"struct Fred {\\n\"\n                   \"    Foo foo;\\n\"\n                   \"    void x()\\n\"\n                   \"    {\\n\"\n                   \"        std::cout << foo << 123;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: (style, inconclusive) Technically the member function 'Fred::x' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constoperator3() {\n        checkConst(\"struct Fred {\\n\"\n                   \"    int array[10];\\n\"\n                   \"    int const & operator [] (unsigned int index) const { return array[index]; }\\n\"\n                   \"    int & operator [] (unsigned int index) { return array[index]; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct Fred {\\n\"\n                   \"    int array[10];\\n\"\n                   \"    int const & operator [] (unsigned int index) { return array[index]; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style, inconclusive) Technically the member function 'Fred::operator[]' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constoperator4() {\n        // #7953\n        checkConst(\"class A {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    operator int*() { return &c; };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    operator const int*() { return &c; };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style, inconclusive) Technically the member function 'A::operatorconstint*' can be const. [functionConst]\\n\", errout_str());\n\n        // #2375\n        checkConst(\"struct Fred {\\n\"\n                   \"    int array[10];\\n\"\n                   \"    typedef int* (Fred::*UnspecifiedBoolType);\\n\"\n                   \"    operator UnspecifiedBoolType() { };\\n\"\n                   \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (style, inconclusive) Technically the member function 'Fred::operatorint**' can be const.\\n\", \"\", errout_str());\n\n        checkConst(\"struct Fred {\\n\"\n                   \"    int array[10];\\n\"\n                   \"    typedef int* (Fred::*UnspecifiedBoolType);\\n\"\n                   \"    operator UnspecifiedBoolType() { array[0] = 0; };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constoperator5() { // ticket #3252\n        checkConst(\"class A {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    operator int& () {return c}\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    operator const int& () {return c}\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style, inconclusive) Technically the member function 'A::operatorconstint&' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    operator int () {return c}\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style, inconclusive) Technically the member function 'A::operatorint' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constoperator6() { // ticket #8669\n        checkConst(\"class A {\\n\"\n                   \"    int c;\\n\"\n                   \"    void f() { os >> *this; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const5() {\n        // ticket #1482\n        checkConst(\"class A {\\n\"\n                   \"    int a;\\n\"\n                   \"    bool foo(int i)\\n\"\n                   \"    {\\n\"\n                   \"        bool same;\\n\"\n                   \"        same = (i == a);\\n\"\n                   \"        return same;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'A::foo' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const6() {\n        // ticket #1491\n        checkConst(\"class foo {\\n\"\n                   \"public:\\n\"\n                   \"};\\n\"\n                   \"void bar() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    void foo() { }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (performance, inconclusive) Technically the member function 'Fred::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct fast_string\\n\"\n                   \"{\\n\"\n                   \"    union\\n\"\n                   \"    {\\n\"\n                   \"        char buff[100];\\n\"\n                   \"    };\\n\"\n                   \"    void set_type(char t);\\n\"\n                   \"};\\n\"\n                   \"inline void fast_string::set_type(char t)\\n\"\n                   \"{\\n\"\n                   \"    buff[10] = t;\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const7() {\n        checkConst(\"class foo {\\n\"\n                   \"    int a;\\n\"\n                   \"public:\\n\"\n                   \"    void set(int i) { a = i; }\\n\"\n                   \"    void set(const foo & f) { *this = f; }\\n\"\n                   \"};\\n\"\n                   \"void bar() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const8() {\n        // ticket #1517\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A():m_strValue(\\\"\\\"){}\\n\"\n                   \"    std::string strGetString() { return m_strValue; }\\n\"\n                   \"private:\\n\"\n                   \"    std::string m_strValue;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:17]: (style, inconclusive) Technically the member function 'A::strGetString' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const9() {\n        // ticket #1515\n        checkConst(\"class wxThreadInternal {\\n\"\n                   \"public:\\n\"\n                   \"    void SetExitCode(wxThread::ExitCode exitcode) { m_exitcode = exitcode; }\\n\"\n                   \"private:\\n\"\n                   \"    wxThread::ExitCode m_exitcode;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const10() {\n        // ticket #1522\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int foo() { return x = 0; }\\n\"\n                   \"private:\\n\"\n                   \"    int x;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int foo() { return x ? x : x = 0; }\\n\"\n                   \"private:\\n\"\n                   \"    int x;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int foo() { return x ? x = 0 : x; }\\n\"\n                   \"private:\\n\"\n                   \"    int x;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const11() {\n        // ticket #1529\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    void set(struct tm time) { m_time = time; }\\n\"\n                   \"private:\\n\"\n                   \"    struct tm m_time;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const12() {\n        // ticket #1525\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int foo() { x = 0; }\\n\"\n                   \"private:\\n\"\n                   \"    mutable int x;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style, inconclusive) Technically the member function 'A::foo' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const13() {\n        // ticket #1519\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::vector<int> GetVec()  {return m_vec;}\\n\"\n                   \"    std::pair<int,double> GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::vector<int> m_vec;\\n\"\n                   \"    std::pair<int,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:22]: (style, inconclusive) Technically the member function 'A::GetVec' can be const. [functionConst]\\n\"\n                      \"[test.cpp:5:27]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const std::vector<int> & GetVec()  {return m_vec;}\\n\"\n                   \"    const std::pair<int,double> & GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::vector<int> m_vec;\\n\"\n                   \"    std::pair<int,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:30]: (style, inconclusive) Technically the member function 'A::GetVec' can be const. [functionConst]\\n\"\n                      \"[test.cpp:5:35]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const14() {\n        // extends ticket 1519\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair<std::vector<int>,double> GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair<std::vector<int>,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:40]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair<std::vector<int>,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:47]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair<std::vector<int>,double>& GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair<std::vector<int>,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    pair<int ,double> GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    pair<int ,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:23]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const pair<int ,double> & GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    pair<int ,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:31]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    pair<int ,double> & GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    pair<int ,double> m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< int,std::vector<int> >  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< int,std::vector<int> >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:40]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< int,std::vector<int> >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:47]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< int,std::vector<int> >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< int,std::vector<int> >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    pair< vector<int>, int >  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    pair< vector<int>, int >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:31]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const pair< vector<int>, int >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    pair< vector<int>, int >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:38]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    pair< vector<int>, int >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    pair< vector<int>, int >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< std::vector<int>,std::vector<int> >  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< std::vector<int>,std::vector<int> >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:53]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< std::vector<int>,std::vector<int> >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:60]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< std::vector<int>,std::vector<int> >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< std::vector<int>,std::vector<int> >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< std::pair < int, char > , int >  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< std::pair < int, char > , int >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:49]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< std::pair < int, char > , int >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:56]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< std::pair < int, char > , int > & GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< std::pair < int, char > , int >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< int , std::pair < int, char > >  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< int , std::pair < int, char > >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:49]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< int , std::pair < int, char > >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:56]: (style, inconclusive) Technically the member function 'A::GetPair' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    std::pair< int , std::pair < int, char > >&  GetPair() {return m_pair;}\\n\"\n                   \"private:\\n\"\n                   \"    std::pair< int , std::pair < int, char > >  m_pair;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    vector<int>  GetVec() {return m_Vec;}\\n\"\n                   \"private:\\n\"\n                   \"    vector<int>  m_Vec;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (style, inconclusive) Technically the member function 'A::GetVec' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    const vector<int>&  GetVec() {return m_Vec;}\\n\"\n                   \"private:\\n\"\n                   \"    vector<int>  m_Vec;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:25]: (style, inconclusive) Technically the member function 'A::GetVec' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"using namespace std;\"\n                   \"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){}\\n\"\n                   \"    vector<int>&  GetVec() {return m_Vec;}\\n\"\n                   \"private:\\n\"\n                   \"    vector<int>  m_Vec;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int * * foo() { return &x; }\\n\"\n                   \"private:\\n\"\n                   \"    const int * x;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    const int ** foo() { return &x; }\\n\"\n                   \"private:\\n\"\n                   \"    const int * x;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (style, inconclusive) Technically the member function 'A::foo' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const15() {\n        checkConst(\"class Fred {\\n\"\n                   \"    unsigned long long int a;\\n\"\n                   \"    unsigned long long int getA() { return a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:28]: (style, inconclusive) Technically the member function 'Fred::getA' can be const. [functionConst]\\n\", errout_str());\n\n        // constructors can't be const..\n        checkConst(\"class Fred {\\n\"\n                   \"    unsigned long long int a;\\n\"\n                   \"public:\\n\"\n                   \"    Fred() { }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment through |=..\n        checkConst(\"class Fred {\\n\"\n                   \"    unsigned long long int a;\\n\"\n                   \"    unsigned long long int setA() { a |= true; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // static functions can't be const..\n        checkConst(\"class foo\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    static unsigned long long int get()\\n\"\n                   \"    { return 0; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const16() {\n        // ticket #1551\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void set(int i) { Fred::a = i; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const17() {\n        // ticket #1552\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    void set(int i, int j) { a[i].k = i; }\\n\"\n                   \"private:\\n\"\n                   \"    struct { int k; } a[4];\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const18() {\n        checkConst(\"class Fred {\\n\"\n                   \"static int x;\\n\"\n                   \"public:\\n\"\n                   \"    void set(int i) { x = i; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (performance, inconclusive) Technically the member function 'Fred::set' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const19() {\n        // ticket #1612\n        checkConst(\"using namespace std;\\n\"\n                   \"class Fred {\\n\"\n                   \"private:\\n\"\n                   \"    std::string s;\\n\"\n                   \"public:\\n\"\n                   \"    void set(std::string ss) { s = ss; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const20() {\n        // ticket #1602\n        checkConst(\"class Fred {\\n\"\n                   \"    int x : 3;\\n\"\n                   \"public:\\n\"\n                   \"    void set(int i) { x = i; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    list<int *> x;\\n\"\n                   \"public:\\n\"\n                   \"    list<int *> get() { return x; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    list<const int *> x;\\n\"\n                   \"public:\\n\"\n                   \"    list<const int *> get() { return x; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:23]: (style, inconclusive) Technically the member function 'Fred::get' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    std::list<std::string &> x;\\n\"\n                   \"public:\\n\"\n                   \"    std::list<std::string &> get() { return x; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    std::list<const std::string &> x;\\n\"\n                   \"public:\\n\"\n                   \"    std::list<const std::string &> get() { return x; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:36]: (style, inconclusive) Technically the member function 'Fred::get' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const21() {\n        // ticket #1683\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"private:\\n\"\n                   \"    const char * l1[10];\\n\"\n                   \"public:\\n\"\n                   \"    A()\\n\"\n                   \"    {\\n\"\n                   \"        for (int i = 0 ; i < 10; l1[i] = NULL, i++);\\n\"\n                   \"    }\\n\"\n                   \"    void f1() { l1[0] = \\\"Hello\\\"; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const22() {\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"private:\\n\"\n                   \"    B::C * v1;\\n\"\n                   \"public:\\n\"\n                   \"    void f1() { v1 = 0; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"private:\\n\"\n                   \"    B::C * v1[0];\\n\"\n                   \"public:\\n\"\n                   \"    void f1() { v1[0] = 0; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const23() {\n        checkConst(\"class Class {\\n\"\n                   \"public:\\n\"\n                   \"    typedef Template<double> Type;\\n\"\n                   \"    typedef Template2<Type> Type2;\\n\"\n                   \"    void set_member(Type2 m) { _m = m; }\\n\"\n                   \"private:\\n\"\n                   \"    Type2 _m;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const24() {\n        checkConst(\"class Class {\\n\"\n                   \"public:\\n\"\n                   \"void Settings::SetSetting(QString strSetting, QString strNewVal)\\n\"\n                   \"{\\n\"\n                   \"    (*m_pSettings)[strSetting] = strNewVal;\\n\"\n                   \"}\\n\"\n                   \"private:\\n\"\n                   \"    std::map<QString, QString> *m_pSettings;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void const25() { // ticket #1724\n        checkConst(\"class A{\\n\"\n                   \"public:\\n\"\n                   \"A(){m_strVal=\\\"\\\";}\\n\"\n                   \"std::string strGetString() const\\n\"\n                   \"{return m_strVal.c_str();}\\n\"\n                   \"const std::string strGetString1() const\\n\"\n                   \"{return m_strVal.c_str();}\\n\"\n                   \"private:\\n\"\n                   \"std::string m_strVal;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A{\\n\"\n                   \"public:\\n\"\n                   \"A(){m_strVal=\\\"\\\";}\\n\"\n                   \"std::string strGetString()\\n\"\n                   \"{return m_strVal.c_str();}\\n\"\n                   \"private:\\n\"\n                   \"std::string m_strVal;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style, inconclusive) Technically the member function 'A::strGetString' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A{\\n\"\n                   \"public:\\n\"\n                   \"A(){m_strVal=\\\"\\\";}\\n\"\n                   \"const std::string strGetString1()\\n\"\n                   \"{return m_strVal.c_str();}\\n\"\n                   \"private:\\n\"\n                   \"std::string m_strVal;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:19]: (style, inconclusive) Technically the member function 'A::strGetString1' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A{\\n\"\n                   \"public:\\n\"\n                   \"A(){m_strVec.push_back(\\\"\\\");}\\n\"\n                   \"size_t strGetSize()\\n\"\n                   \"{return m_strVec.size();}\\n\"\n                   \"private:\\n\"\n                   \"std::vector<std::string> m_strVec;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (style, inconclusive) Technically the member function 'A::strGetSize' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A{\\n\"\n                   \"public:\\n\"\n                   \"A(){m_strVec.push_back(\\\"\\\");}\\n\"\n                   \"bool strGetEmpty()\\n\"\n                   \"{return m_strVec.empty();}\\n\"\n                   \"private:\\n\"\n                   \"std::vector<std::string> m_strVec;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (style, inconclusive) Technically the member function 'A::strGetEmpty' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const26() { // ticket #1847\n        checkConst(\"class DelayBase {\\n\"\n                   \"public:\\n\"\n                   \"void swapSpecificDelays(int index1, int index2) {\\n\"\n                   \"    std::swap<float>(delays_[index1], delays_[index2]);\\n\"\n                   \"}\\n\"\n                   \"float delays_[4];\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct DelayBase {\\n\"\n                   \"    float swapSpecificDelays(int index1) {\\n\"\n                   \"        return delays_[index1];\\n\"\n                   \"    }\\n\"\n                   \"    float delays_[4];\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style, inconclusive) Technically the member function 'DelayBase::swapSpecificDelays' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const27() { // ticket #1882\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A(){m_d=1.0; m_iRealVal=2.0;}\\n\"\n                   \"    double dGetValue();\\n\"\n                   \"private:\\n\"\n                   \"    double m_d;\\n\"\n                   \"    double m_iRealVal;\\n\"\n                   \"};\\n\"\n                   \"double  A::dGetValue() {\\n\"\n                   \"    double dRet = m_iRealVal;\\n\"\n                   \"    if( m_d != 0 )\\n\"\n                   \"        return m_iRealVal / m_d;\\n\"\n                   \"    return dRet;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:12] -> [test.cpp:9:12]: (style, inconclusive) Technically the member function 'A::dGetValue' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const28() { // ticket #1883\n        checkConst(\"class P {\\n\"\n                   \"public:\\n\"\n                   \"    P() { x=0.0; y=0.0; }\\n\"\n                   \"    double x,y;\\n\"\n                   \"};\\n\"\n                   \"class A : public P {\\n\"\n                   \"public:\\n\"\n                   \"    A():P(){}\\n\"\n                   \"    void SetPos(double xPos, double yPos) {\\n\"\n                   \"        x=xPos;\\n\"\n                   \"        y=yPos;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class AA : public P {\\n\"\n                   \"public:\\n\"\n                   \"    AA():P(){}\\n\"\n                   \"    inline void vSetXPos(int x_)\\n\"\n                   \"    {\\n\"\n                   \"        UnknownScope::x = x_;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class AA {\\n\"\n                   \"public:\\n\"\n                   \"    AA():P(){}\\n\"\n                   \"    inline void vSetXPos(int x_)\\n\"\n                   \"    {\\n\"\n                   \"        UnknownScope::x = x_;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:17]: (performance, inconclusive) Technically the member function 'AA::vSetXPos' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n    }\n\n    void const29() { // ticket #1922\n        checkConst(\"class test {\\n\"\n                   \"  public:\\n\"\n                   \"    test();\\n\"\n                   \"    const char* get() const;\\n\"\n                   \"    char* get();\\n\"\n                   \"  private:\\n\"\n                   \"    char* value_;\\n\"\n                   \"};\\n\"\n                   \"test::test()\\n\"\n                   \"{\\n\"\n                   \"  value_ = 0;\\n\"\n                   \"}\\n\"\n                   \"const char* test::get() const\\n\"\n                   \"{\\n\"\n                   \"  return value_;\\n\"\n                   \"}\\n\"\n                   \"char* test::get()\\n\"\n                   \"{\\n\"\n                   \"  return value_;\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const30() {\n        // check for false negatives\n        checkConst(\"class Base {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Derived : public Base {\\n\"\n                   \"public:\\n\"\n                   \"    int get() {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (style, inconclusive) Technically the member function 'Derived::get' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Base1 {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Base2 {\\n\"\n                   \"public:\\n\"\n                   \"    int b;\\n\"\n                   \"};\\n\"\n                   \"class Derived : public Base1, public Base2 {\\n\"\n                   \"public:\\n\"\n                   \"    int getA() {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"    int getB() {\\n\"\n                   \"        return b;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:11:9]: (style, inconclusive) Technically the member function 'Derived::getA' can be const. [functionConst]\\n\"\n                      \"[test.cpp:14:9]: (style, inconclusive) Technically the member function 'Derived::getB' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Base {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Derived1 : public Base { };\\n\"\n                   \"class Derived2 : public Derived1 {\\n\"\n                   \"public:\\n\"\n                   \"    int get() {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:8:9]: (style, inconclusive) Technically the member function 'Derived2::get' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Base {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Derived1 : public Base { };\\n\"\n                   \"class Derived2 : public Derived1 { };\\n\"\n                   \"class Derived3 : public Derived2 { };\\n\"\n                   \"class Derived4 : public Derived3 {\\n\"\n                   \"public:\\n\"\n                   \"    int get() {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:10:9]: (style, inconclusive) Technically the member function 'Derived4::get' can be const. [functionConst]\\n\", errout_str());\n\n        // check for false positives\n        checkConst(\"class Base {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Derived : public Base {\\n\"\n                   \"public:\\n\"\n                   \"    int get() const {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Base1 {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Base2 {\\n\"\n                   \"public:\\n\"\n                   \"    int b;\\n\"\n                   \"};\\n\"\n                   \"class Derived : public Base1, public Base2 {\\n\"\n                   \"public:\\n\"\n                   \"    int getA() const {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"    int getB() const {\\n\"\n                   \"        return b;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Base {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Derived1 : public Base { };\\n\"\n                   \"class Derived2 : public Derived1 {\\n\"\n                   \"public:\\n\"\n                   \"    int get() const {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Base {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"};\\n\"\n                   \"class Derived1 : public Base { };\\n\"\n                   \"class Derived2 : public Derived1 { };\\n\"\n                   \"class Derived3 : public Derived2 { };\\n\"\n                   \"class Derived4 : public Derived3 {\\n\"\n                   \"public:\\n\"\n                   \"    int get() const {\\n\"\n                   \"        return a;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const31() {\n        checkConst(\"namespace std { }\\n\"\n                   \"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    int a;\\n\"\n                   \"    int get() { return a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style, inconclusive) Technically the member function 'Fred::get' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const32() {\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    std::string a[10];\\n\"\n                   \"    void seta() { a[0] = \\\"\\\"; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const33() {\n        checkConst(\"class derived : public base {\\n\"\n                   \"public:\\n\"\n                   \"    void f(){}\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Either there is a missing 'override', or the member function 'derived::f' can be static. [functionStatic]\\n\", errout_str());\n    }\n\n    void const34() { // ticket #1964\n        checkConst(\"class Bar {\\n\"\n                   \"    void init(Foo * foo) {\\n\"\n                   \"        foo.bar = this;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const35() { // ticket #2001\n        checkConst(\"namespace N\\n\"\n                   \"{\\n\"\n                   \"        class Base\\n\"\n                   \"        {\\n\"\n                   \"        };\\n\"\n                   \"}\\n\"\n                   \"namespace N\\n\"\n                   \"{\\n\"\n                   \"        class Derived : public Base\\n\"\n                   \"        {\\n\"\n                   \"        public:\\n\"\n                   \"                int getResourceName() { return var; }\\n\"\n                   \"                int var;\\n\"\n                   \"        };\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"[test.cpp:12:21]: (style, inconclusive) Technically the member function 'N::Derived::getResourceName' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"namespace N\\n\"\n                   \"{\\n\"\n                   \"        class Base\\n\"\n                   \"        {\\n\"\n                   \"        public:\\n\"\n                   \"                int getResourceName();\\n\"\n                   \"                int var;\\n\"\n                   \"        };\\n\"\n                   \"}\\n\"\n                   \"int N::Base::getResourceName() { return var; }\");\n        ASSERT_EQUALS(\"[test.cpp:6:21] -> [test.cpp:10:14]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"namespace N\\n\"\n                   \"{\\n\"\n                   \"        class Base\\n\"\n                   \"        {\\n\"\n                   \"        public:\\n\"\n                   \"                int getResourceName();\\n\"\n                   \"                int var;\\n\"\n                   \"        };\\n\"\n                   \"}\\n\"\n                   \"namespace N\\n\"\n                   \"{\\n\"\n                   \"        int Base::getResourceName() { return var; }\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:21] -> [test.cpp:12:19]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"namespace N\\n\"\n                   \"{\\n\"\n                   \"        class Base\\n\"\n                   \"        {\\n\"\n                   \"        public:\\n\"\n                   \"                int getResourceName();\\n\"\n                   \"                int var;\\n\"\n                   \"        };\\n\"\n                   \"}\\n\"\n                   \"using namespace N;\\n\"\n                   \"int Base::getResourceName() { return var; }\");\n        ASSERT_EQUALS(\"[test.cpp:6:21] -> [test.cpp:11:11]: (style, inconclusive) Technically the member function 'N::Base::getResourceName' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const36() { // ticket #2003\n        checkConst(\"class Foo {\\n\"\n                   \"public:\\n\"\n                   \"    Blue::Utility::Size m_MaxQueueSize;\\n\"\n                   \"    void SetMaxQueueSize(Blue::Utility::Size a_MaxQueueSize)\\n\"\n                   \"    {\\n\"\n                   \"        m_MaxQueueSize = a_MaxQueueSize;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const37() { // ticket #2081 and #2085\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    A(){};\\n\"\n                   \"    std::string operator+(const char *c)\\n\"\n                   \"    {\\n\"\n                   \"        return m_str+std::string(c);\\n\"\n                   \"    }\\n\"\n                   \"private:\\n\"\n                   \"    std::string m_str;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (style, inconclusive) Technically the member function 'A::operator+' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"private:\\n\"\n                   \"    long x;\\n\"\n                   \"public:\\n\"\n                   \"    Fred() {\\n\"\n                   \"        x = 0;\\n\"\n                   \"    }\\n\"\n                   \"    bool isValid() {\\n\"\n                   \"        return (x == 0x11224488);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:9:10]: (style, inconclusive) Technically the member function 'Fred::isValid' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const38() { // ticket #2135\n        checkConst(\"class Foo {\\n\"\n                   \"public:\\n\"\n                   \"    ~Foo() { delete oArq; }\\n\"\n                   \"    Foo(): oArq(new std::ofstream(\\\"...\\\")) {}\\n\"\n                   \"    void MyMethod();\\n\"\n                   \"private:\\n\"\n                   \"    std::ofstream *oArq;\\n\"\n                   \"};\\n\"\n                   \"void Foo::MyMethod()\\n\"\n                   \"{\\n\"\n                   \"    (*oArq) << \\\"</table>\\\";\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const39() {\n        checkConst(\"class Foo\\n\"\n                   \"{\\n\"\n                   \"    int * p;\\n\"\n                   \"public:\\n\"\n                   \"    Foo () : p(0) { }\\n\"\n                   \"    int * f();\\n\"\n                   \"    const int * f() const;\\n\"\n                   \"};\\n\"\n                   \"const int * Foo::f() const\\n\"\n                   \"{\\n\"\n                   \"    return p;\\n\"\n                   \"}\\n\"\n                   \"int * Foo::f()\\n\"\n                   \"{\\n\"\n                   \"    return p;\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const40() { // ticket #2228\n        checkConst(\"class SharedPtrHolder\\n\"\n                   \"{\\n\"\n                   \"  private:\\n\"\n                   \"   std::tr1::shared_ptr<int> pView;\\n\"\n                   \"  public:\\n\"\n                   \"   SharedPtrHolder()\\n\"\n                   \"   { }\\n\"\n                   \"   void SetView(const std::shared_ptr<int> & aView)\\n\"\n                   \"   {\\n\"\n                   \"      pView = aView;\\n\"\n                   \"   }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const41() { // ticket #2255\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"   ::std::string m_name;\\n\"\n                   \"public:\\n\"\n                   \"   void SetName(const ::std::string & name)\\n\"\n                   \"   {\\n\"\n                   \"      m_name = name;\\n\"\n                   \"   }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class SharedPtrHolder\\n\"\n                   \"{\\n\"\n                   \"   ::std::tr1::shared_ptr<int> pNum;\\n\"\n                   \"  public :\\n\"\n                   \"   void SetNum(const ::std::tr1::shared_ptr<int> & apNum)\\n\"\n                   \"   {\\n\"\n                   \"      pNum = apNum;\\n\"\n                   \"   }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class SharedPtrHolder2\\n\"\n                   \"{\\n\"\n                   \"  public:\\n\"\n                   \"   typedef ::std::tr1::shared_ptr<int> IntSharedPtr;\\n\"\n                   \"  private:\\n\"\n                   \"   IntSharedPtr pNum;\\n\"\n                   \"  public :\\n\"\n                   \"   void SetNum(const IntSharedPtr & apNum)\\n\"\n                   \"   {\\n\"\n                   \"      pNum = apNum;\\n\"\n                   \"   }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct IntPtrTypes\\n\"\n                   \"{\\n\"\n                   \"   typedef ::std::tr1::shared_ptr<int> Shared;\\n\"\n                   \"};\\n\"\n                   \"class SharedPtrHolder3\\n\"\n                   \"{\\n\"\n                   \"  private:\\n\"\n                   \"   IntPtrTypes::Shared pNum;\\n\"\n                   \"  public :\\n\"\n                   \"   void SetNum(const IntPtrTypes::Shared & apNum)\\n\"\n                   \"   {\\n\"\n                   \"      pNum = apNum;\\n\"\n                   \"   }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"template <typename T>\\n\"\n                   \"struct PtrTypes\\n\"\n                   \"{\\n\"\n                   \"   typedef ::std::tr1::shared_ptr<T> Shared;\\n\"\n                   \"};\\n\"\n                   \"class SharedPtrHolder4\\n\"\n                   \"{\\n\"\n                   \"  private:\\n\"\n                   \"   PtrTypes<int>::Shared pNum;\\n\"\n                   \"  public :\\n\"\n                   \"   void SetNum(const PtrTypes<int>::Shared & apNum)\\n\"\n                   \"   {\\n\"\n                   \"      pNum = apNum;\\n\"\n                   \"   }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const42() { // ticket #2282\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    struct AB { };\\n\"\n                   \"    bool f(AB * ab);\\n\"\n                   \"};\\n\"\n                   \"bool Fred::f(Fred::AB * ab)\\n\"\n                   \"{\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:5:10] -> [test.cpp:7:12]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"class Fred\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    struct AB {\\n\"\n                   \"        struct CD { };\\n\"\n                   \"    };\\n\"\n                   \"    bool f(AB::CD * cd);\\n\"\n                   \"};\\n\"\n                   \"bool Fred::f(Fred::AB::CD * cd)\\n\"\n                   \"{\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:7:10] -> [test.cpp:9:12]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"namespace NS {\\n\"\n                   \"    class Fred\\n\"\n                   \"    {\\n\"\n                   \"    public:\\n\"\n                   \"        struct AB {\\n\"\n                   \"            struct CD { };\\n\"\n                   \"        };\\n\"\n                   \"        bool f(AB::CD * cd);\\n\"\n                   \"    };\\n\"\n                   \"    bool Fred::f(Fred::AB::CD * cd)\\n\"\n                   \"    {\\n\"\n                   \"    }\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:8:14] -> [test.cpp:10:16]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"namespace NS {\\n\"\n                   \"    class Fred\\n\"\n                   \"    {\\n\"\n                   \"    public:\\n\"\n                   \"        struct AB {\\n\"\n                   \"            struct CD { };\\n\"\n                   \"        };\\n\"\n                   \"        bool f(AB::CD * cd);\\n\"\n                   \"    };\\n\"\n                   \"}\\n\"\n                   \"bool NS::Fred::f(NS::Fred::AB::CD * cd)\\n\"\n                   \"{\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:8:14] -> [test.cpp:11:16]: (performance, inconclusive) Technically the member function 'NS::Fred::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"class Foo {\\n\"\n                   \"    class Fred\\n\"\n                   \"    {\\n\"\n                   \"    public:\\n\"\n                   \"        struct AB {\\n\"\n                   \"            struct CD { };\\n\"\n                   \"        };\\n\"\n                   \"        bool f(AB::CD * cd);\\n\"\n                   \"    };\\n\"\n                   \"};\\n\"\n                   \"bool Foo::Fred::f(Foo::Fred::AB::CD * cd)\\n\"\n                   \"{\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:8:14] -> [test.cpp:11:17]: (performance, inconclusive) Technically the member function 'Foo::Fred::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const43() { // ticket 2377\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    void foo( AA::BB::CC::DD b );\\n\"\n                   \"    AA::BB::CC::DD a;\\n\"\n                   \"};\\n\"\n                   \"void A::foo( AA::BB::CC::DD b )\\n\"\n                   \"{\\n\"\n                   \"    a = b;\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"namespace AA\\n\"\n                   \"{\\n\"\n                   \"    namespace BB\\n\"\n                   \"    {\\n\"\n                   \"        namespace CC\\n\"\n                   \"        {\\n\"\n                   \"            struct DD\\n\"\n                   \"            {};\\n\"\n                   \"        }\\n\"\n                   \"    }\\n\"\n                   \"}\\n\"\n                   \"class A\\n\"\n                   \"{\\n\"\n                   \"    public:\\n\"\n                   \"\\n\"\n                   \"    AA::BB::CC::DD a;\\n\"\n                   \"    void foo(AA::BB::CC::DD b)\\n\"\n                   \"    {\\n\"\n                   \"        a = b;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"namespace ZZ\\n\"\n                   \"{\\n\"\n                   \"    namespace YY\\n\"\n                   \"    {\\n\"\n                   \"        struct XX\\n\"\n                   \"        {};\\n\"\n                   \"    }\\n\"\n                   \"}\\n\"\n                   \"class B\\n\"\n                   \"{\\n\"\n                   \"    public:\\n\"\n                   \"    ZZ::YY::XX a;\\n\"\n                   \"    void foo(ZZ::YY::XX b)\\n\"\n                   \"    {\\n\"\n                   \"        a = b;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const44() { // ticket 2595\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    bool bOn;\\n\"\n                   \"    bool foo()\\n\"\n                   \"    {\\n\"\n                   \"        return 0 != (bOn = bOn);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const45() { // ticket 2664\n        checkConst(\"namespace wraps {\\n\"\n                   \"    class BaseLayout {};\\n\"\n                   \"}\\n\"\n                   \"namespace tools {\\n\"\n                   \"    class WorkspaceControl :\\n\"\n                   \"        public wraps::BaseLayout\\n\"\n                   \"    {\\n\"\n                   \"        int toGrid(int _value)\\n\"\n                   \"        {\\n\"\n                   \"        }\\n\"\n                   \"    };\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:8:13]: (performance, inconclusive) Technically the member function 'tools::WorkspaceControl::toGrid' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const46() { // ticket 2663\n        checkConst(\"class Altren {\\n\"\n                   \"public:\\n\"\n                   \"    int fun1() {\\n\"\n                   \"        int a;\\n\"\n                   \"        a++;\\n\"\n                   \"    }\\n\"\n                   \"    int fun2() {\\n\"\n                   \"        b++;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (performance, inconclusive) Technically the member function 'Altren::fun1' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:7:9]: (performance, inconclusive) Technically the member function 'Altren::fun2' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const47() { // ticket 2670\n        checkConst(\"class Altren {\\n\"\n                   \"public:\\n\"\n                   \"  void foo() { delete this; }\\n\"\n                   \"  void foo(int i) const { }\\n\"\n                   \"  void bar() { foo(); }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"class Altren {\\n\"\n                   \"public:\\n\"\n                   \"  void foo() { delete this; }\\n\"\n                   \"  void foo(int i) const { }\\n\"\n                   \"  void bar() { foo(1); }\\n\"\n                   \"};\");\n\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (performance, inconclusive) Technically the member function 'Altren::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:5:8]: (style, inconclusive) Technically the member function 'Altren::bar' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const48() { // ticket 2672\n        checkConst(\"class S0 {\\n\"\n                   \"    class S1 {\\n\"\n                   \"        class S2 {\\n\"\n                   \"            class S3 {\\n\"\n                   \"                class S4 { };\\n\"\n                   \"            };\\n\"\n                   \"        };\\n\"\n                   \"    };\\n\"\n                   \"};\\n\"\n                   \"class TextIterator {\\n\"\n                   \"    S0::S1::S2::S3::S4 mCurrent, mSave;\\n\"\n                   \"public:\\n\"\n                   \"    bool setTagColour();\\n\"\n                   \"};\\n\"\n                   \"bool TextIterator::setTagColour() {\\n\"\n                   \"    mSave = mCurrent;\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const49() { // ticket 2795\n        checkConst(\"class A {\\n\"\n                   \"    private:\\n\"\n                   \"         std::map<unsigned int,unsigned int> _hash;\\n\"\n                   \"    public:\\n\"\n                   \"         A() : _hash() {}\\n\"\n                   \"         unsigned int fetch(unsigned int key)\\n\" // cannot be 'const'\n                   \"         {\\n\"\n                   \"             return _hash[key];\\n\"\n                   \"         }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const50() { // ticket 2943\n        checkConst(\"class Altren\\n\"\n                   \"{\\n\"\n                   \"        class SubClass : public std::vector<int>\\n\"\n                   \"        {\\n\"\n                   \"        };\\n\"\n                   \"};\\n\"\n                   \"void _setAlign()\\n\"\n                   \"{\\n\"\n                   \"        if (mTileSize.height > 0) return;\\n\"\n                   \"        if (mEmptyView) return;\\n\"\n                   \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const51() { // ticket 3040\n        checkConst(\"class PSIPTable {\\n\"\n                   \"public:\\n\"\n                   \"    PSIPTable() : _pesdata(0) { }\\n\"\n                   \"    const unsigned char* pesdata() const { return _pesdata; }\\n\"\n                   \"    unsigned char* pesdata()             { return _pesdata; }\\n\"\n                   \"    void SetSection(uint num) { pesdata()[6] = num; }\\n\"\n                   \"private:\\n\"\n                   \"    unsigned char *_pesdata;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class PESPacket {\\n\"\n                   \"public:\\n\"\n                   \"    PESPacket() : _pesdata(0) { }\\n\"\n                   \"    const unsigned char* pesdata() const { return _pesdata; }\\n\"\n                   \"    unsigned char* pesdata()             { return _pesdata; }\\n\"\n                   \"private:\\n\"\n                   \"    unsigned char *_pesdata;\\n\"\n                   \"};\\n\"\n                   \"class PSIPTable : public PESPacket\\n\"\n                   \"{\\n\"\n                   \"public:\\n\"\n                   \"    void SetSection(uint num) { pesdata()[6] = num; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const52() { // ticket 3048\n        checkConst(\"class foo {\\n\"\n                   \"    void DoSomething(int &a) const { a = 1; }\\n\"\n                   \"    void DoSomethingElse() { DoSomething(bar); }\\n\"\n                   \"private:\\n\"\n                   \"    int bar;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance, inconclusive) Technically the member function 'foo::DoSomething' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const53() { // ticket 3049\n        checkConst(\"class A {\\n\"\n                   \"  public:\\n\"\n                   \"    A() : foo(false) {};\\n\"\n                   \"    virtual bool One(bool b = false) { foo = b; return false; }\\n\"\n                   \"  private:\\n\"\n                   \"    bool foo;\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"  public:\\n\"\n                   \"    B() {};\\n\"\n                   \"    bool One(bool b = false) { return false; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const54() { // ticket 3052\n        checkConst(\"class Example {\\n\"\n                   \"  public:\\n\"\n                   \"    void Clear(void) { Example tmp; (*this) = tmp; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const55() {\n        checkConst(\"class MyObject {\\n\"\n                   \"    int tmp;\\n\"\n                   \"    MyObject() : tmp(0) {}\\n\"\n                   \"public:\\n\"\n                   \"    void set(std::stringstream &in) { in >> tmp; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const56() { // ticket #3149\n        checkConst(\"class MyObject {\\n\"\n                   \"public:\\n\"\n                   \"    void foo(int x) {\\n\"\n                   \"    switch (x) { }\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"    protected:\\n\"\n                   \"        unsigned short f (unsigned short X);\\n\"\n                   \"    public:\\n\"\n                   \"        A ();\\n\"\n                   \"};\\n\"\n                   \"\\n\"\n                   \"unsigned short A::f (unsigned short X)\\n\"\n                   \"{\\n\"\n                   \"    enum ERetValues {RET_NOK = 0, RET_OK = 1};\\n\"\n                   \"    enum ETypes     {FLOAT_TYPE = 1, INT_TYPE = 2};\\n\"\n                   \"\\n\"\n                   \"    try\\n\"\n                   \"    {\\n\"\n                   \"        switch (X)\\n\"\n                   \"        {\\n\"\n                   \"            case FLOAT_TYPE:\\n\"\n                   \"            {\\n\"\n                   \"                return RET_OK;\\n\"\n                   \"            }\\n\"\n                   \"            case INT_TYPE:\\n\"\n                   \"            {\\n\"\n                   \"                return RET_OK;\\n\"\n                   \"            }\\n\"\n                   \"            default:\\n\"\n                   \"            {\\n\"\n                   \"                return RET_NOK;\\n\"\n                   \"            }\\n\"\n                   \"        }\\n\"\n                   \"    }\\n\"\n                   \"    catch (...)\\n\"\n                   \"    {\\n\"\n                   \"        return RET_NOK;\\n\"\n                   \"    }\\n\"\n                   \"\\n\"\n                   \"    return RET_NOK;\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:24] -> [test.cpp:9:19]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"class MyObject {\\n\"\n                   \"public:\\n\"\n                   \"    void foo(int x) {\\n\"\n                   \"    for (int i = 0; i < 5; i++) { }\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const57() { // tickets #2669 and #2477\n        checkConst(\"namespace MyGUI\\n\"\n                   \"{\\n\"\n                   \"  namespace types\\n\"\n                   \"  {\\n\"\n                   \"    struct TSize {};\\n\"\n                   \"    struct TCoord {\\n\"\n                   \"      TSize size() const { }\\n\"\n                   \"    };\\n\"\n                   \"  }\\n\"\n                   \"  typedef types::TSize IntSize;\\n\"\n                   \"  typedef types::TCoord IntCoord;\\n\"\n                   \"}\\n\"\n                   \"class SelectorControl\\n\"\n                   \"{\\n\"\n                   \"  MyGUI::IntSize getSize()\\n\"\n                   \"  {\\n\"\n                   \"    return mCoordValue.size();\\n\"\n                   \"  }\\n\"\n                   \"private:\\n\"\n                   \"  MyGUI::IntCoord mCoordValue;\\n\"\n                   \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7:13]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                           \"[test.cpp:15]: (style, inconclusive) Technically the member function 'SelectorControl::getSize' can be const.\\n\",\n                           \"[test.cpp:7:13]: (performance, inconclusive) Technically the member function 'MyGUI::types::TCoord::size' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct Foo {\\n\"\n                   \"    Bar b;\\n\"\n                   \"    void foo(Foo f) {\\n\"\n                   \"        b.run();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct Bar {\\n\"\n                   \"    int i = 0;\\n\"\n                   \"    void run() { i++; }\\n\"\n                   \"};\\n\"\n                   \"struct Foo {\\n\"\n                   \"    Bar b;\\n\"\n                   \"    void foo(Foo f) {\\n\"\n                   \"        b.run();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct Bar {\\n\"\n                   \"    void run() const { }\\n\"\n                   \"};\\n\"\n                   \"struct Foo {\\n\"\n                   \"    Bar b;\\n\"\n                   \"    void foo(Foo f) {\\n\"\n                   \"        b.run();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance, inconclusive) Technically the member function 'Bar::run' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:6:10]: (style, inconclusive) Technically the member function 'Foo::foo' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const58() {\n        checkConst(\"struct MyObject {\\n\"\n                   \"    void foo(Foo f) {\\n\"\n                   \"        f.clear();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct MyObject {\\n\"\n                   \"    int foo(Foo f) {\\n\"\n                   \"        return f.length();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (performance, inconclusive) Technically the member function 'MyObject::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct MyObject {\\n\"\n                   \"    Foo f;\\n\"\n                   \"    int foo() {\\n\"\n                   \"        return f.length();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct MyObject {\\n\"\n                   \"    std::string f;\\n\"\n                   \"    int foo() {\\n\"\n                   \"        return f.length();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style, inconclusive) Technically the member function 'MyObject::foo' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const59() { // ticket #4646\n        checkConst(\"class C {\\n\"\n                   \"public:\\n\"\n                   \"    inline void operator += (const int &x ) { re += x; }\\n\"\n                   \"    friend inline void exp(C & c, const C & x) { }\\n\"\n                   \"protected:\\n\"\n                   \"    int   re;\\n\"\n                   \"    int   im;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const60() { // ticket #3322\n        checkConst(\"class MyString {\\n\"\n                   \"public:\\n\"\n                   \"    MyString() : m_ptr(0){}\\n\"\n                   \"    MyString& operator+=( const MyString& rhs ) {\\n\"\n                   \"            delete m_ptr;\\n\"\n                   \"            m_ptr = new char[42];\\n\"\n                   \"    }\\n\"\n                   \"    MyString append( const MyString& str )\\n\"\n                   \"    {       return operator+=( str ); }\\n\"\n                   \"    char *m_ptr;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n        checkConst(\"class MyString {\\n\"\n                   \"public:\\n\"\n                   \"    MyString() : m_ptr(0){}\\n\"\n                   \"    MyString& operator+=( const MyString& rhs );\\n\"\n                   \"    MyString append( const MyString& str )\\n\"\n                   \"    {       return operator+=( str ); }\\n\"\n                   \"    char *m_ptr;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const61() { // ticket #5606 - don't crash\n        // this code is invalid so a false negative is OK\n        checkConst(\"class MixerParticipant : public MixerParticipant {\\n\"\n                   \"    int GetAudioFrame();\\n\"\n                   \"};\\n\"\n                   \"int MixerParticipant::GetAudioFrame() {\\n\"\n                   \"    return 0;\\n\"\n                   \"}\");\n\n        // this code is invalid so a false negative is OK\n        checkConst(\"class MixerParticipant : public MixerParticipant {\\n\"\n                   \"    bool InitializeFileReader() {\\n\"\n                   \"       printf(\\\"music\\\");\\n\"\n                   \"    }\\n\"\n                   \"};\");\n\n        // Based on an example from SVN source code causing an endless recursion within CheckClass::isConstMemberFunc()\n        // A more complete example including a template declaration like\n        //     template<typename K> class Hash{/* ... */};\n        // didn't .\n        checkConst(\"template<>\\n\"\n                   \"class Hash<void> {\\n\"\n                   \"protected:\\n\"\n                   \"  typedef Key::key_type key_type;\\n\"\n                   \"  void set(const Key& key);\\n\"\n                   \"};\\n\"\n                   \"template<typename K, int KeySize>\\n\"\n                   \"class Hash : private Hash<void> {\\n\"\n                   \"  typedef Hash<void> inherited;\\n\"\n                   \"  void set(const Key& key) {\\n\"\n                   \"      inherited::set(inherited::Key(key));\\n\"\n                   \"  }\\n\"\n                   \"};\\n\", dinit(CheckConstOptions, $.inconclusive = false));\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:23]: (performance, inconclusive) Either there is a missing 'override', or the member function 'MixerParticipant::GetAudioFrame' can be static. [functionStatic]\\n\",\n                      errout_str());\n    }\n\n    void const62() {\n        checkConst(\"class A {\\n\"\n                   \"    private:\\n\"\n                   \"         std::unordered_map<unsigned int,unsigned int> _hash;\\n\"\n                   \"    public:\\n\"\n                   \"         A() : _hash() {}\\n\"\n                   \"         unsigned int fetch(unsigned int key)\\n\" // cannot be 'const'\n                   \"         {\\n\"\n                   \"             return _hash[key];\\n\"\n                   \"         }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const63() {\n        checkConst(\"struct A {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void clear() {\\n\"\n                   \"         std::string* p = &s;\\n\"\n                   \"         p->clear();\\n\"\n                   \"     }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void clear() {\\n\"\n                   \"         std::string& r = s;\\n\"\n                   \"         r.clear();\\n\"\n                   \"     }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void clear() {\\n\"\n                   \"         std::string& r = sth; r = s;\\n\"\n                   \"         r.clear();\\n\"\n                   \"     }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'A::clear' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void clear() {\\n\"\n                   \"         const std::string* p = &s;\\n\"\n                   \"         p->somefunction();\\n\"\n                   \"     }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'A::clear' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    std::string s;\\n\"\n                   \"    void clear() {\\n\"\n                   \"         const std::string& r = s;\\n\"\n                   \"         r.somefunction();\\n\"\n                   \"     }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'A::clear' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const64() {\n        checkConst(\"namespace B {\\n\"\n                   \"    namespace D {\\n\"\n                   \"        typedef int DKIPtr;\\n\"\n                   \"    }\\n\"\n                   \"    class ZClass  {\\n\"\n                   \"        void set(const ::B::D::DKIPtr& p) {\\n\"\n                   \"            membervariable = p;\\n\"\n                   \"        }\\n\"\n                   \"        ::B::D::DKIPtr membervariable;\\n\"\n                   \"    };\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const65() {\n        checkConst(\"template <typename T>\\n\"\n                   \"class TemplateClass {\\n\"\n                   \"public:\\n\"\n                   \"   TemplateClass() { }\\n\"\n                   \"};\\n\"\n                   \"template <>\\n\"\n                   \"class TemplateClass<float> {\\n\"\n                   \"public:\\n\"\n                   \"   TemplateClass() { }\\n\"\n                   \"};\\n\"\n                   \"int main() {\\n\"\n                   \"    TemplateClass<int> a;\\n\"\n                   \"    TemplateClass<float> b;\\n\"\n                   \"    return 0;\\n\"\n                   \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const66() {\n        checkConst(\"struct C {\\n\"\n                   \"    C() : n(0) {}\\n\"\n                   \"    void f(int v) { g((char *) &v); }\\n\"\n                   \"    void g(char *) { n++; }\\n\"\n                   \"    int n;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const67() { // #9193\n        checkConst(\"template <class VALUE_T, class LIST_T = std::list<VALUE_T> >\\n\"\n                   \"class TestList {\\n\"\n                   \"public:\\n\"\n                   \"    LIST_T m_list;\\n\"\n                   \"};\\n\"\n                   \"class Test {\\n\"\n                   \"public:\\n\"\n                   \"    const std::list<std::shared_ptr<int>>& get() { return m_test.m_list; }\\n\"\n                   \"    TestList<std::shared_ptr<int>> m_test;\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:8:44]: (style, inconclusive) Technically the member function 'Test::get' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const68() { // #6471\n        checkConst(\"class MyClass {\\n\"\n                   \"    void clear() {\\n\"\n                   \"        SVecPtr v = (SVecPtr) m_data;\\n\"\n                   \"        v->clear();\\n\"\n                   \"    }\\n\"\n                   \"    void* m_data;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const69() { // #9806\n        checkConst(\"struct A {\\n\"\n                   \"    int a = 0;\\n\"\n                   \"    template <typename... Args> void call(const Args &... args) { a = 1; }\\n\"\n                   \"    template <typename T, typename... Args> auto call(const Args &... args) -> T {\\n\"\n                   \"        a = 2;\\n\"\n                   \"        return T{};\\n\"\n                   \"    }\\n\"\n                   \"};\\n\"\n                   \"\\n\"\n                   \"struct B : public A {\\n\"\n                   \"    void test() {\\n\"\n                   \"        call();\\n\"\n                   \"        call<int>(1, 2, 3);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const70() {\n        checkConst(\"struct A {\\n\"\n                   \"    template <typename... Args> void call(Args ... args) {\\n\"\n                   \"        func(this);\\n\"\n                   \"    }\\n\"\n                   \"\\n\"\n                   \"    void test() {\\n\"\n                   \"        call(1, 2);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const71() { // #10146\n        checkConst(\"struct Bar {\\n\"\n                   \"    int j = 5;\\n\"\n                   \"    void f(int& i) const { i += j; }\\n\"\n                   \"};\\n\"\n                   \"struct Foo {\\n\"\n                   \"    Bar bar;\\n\"\n                   \"    int k{};\\n\"\n                   \"    void g() { bar.f(k); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    A a;\\n\"\n                   \"    void f(int j, int*& p) {\\n\"\n                   \"        p = &(((a[j])));\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const72() { // #10520\n        checkConst(\"struct S {\\n\"\n                   \"    explicit S(int* p) : mp(p) {}\\n\"\n                   \"    int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return S{ &i }; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    explicit S(int* p) : mp(p) {}\\n\"\n                   \"    int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return S(&i); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return S{ &i }; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return { &i }; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    explicit S(const int* p) : mp(p) {}\\n\"\n                   \"    const int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return S{ &i }; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:7]: (style, inconclusive) Technically the member function 'C::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    explicit S(const int* p) : mp(p) {}\\n\"\n                   \"    const int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return S(&i); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:7]: (style, inconclusive) Technically the member function 'C::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    const int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return S{ &i }; }\\n\"\n                   \"};\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7:7]: (style, inconclusive) Technically the member function 'C::f' can be const. [functionConst]\\n\", \"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    const int* mp{};\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    int i{};\\n\"\n                   \"    S f() { return { &i }; }\\n\"\n                   \"};\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7:7]: (style, inconclusive) Technically the member function 'C::f' can be const. [functionConst]\\n\", \"\", errout_str());\n    }\n\n    void const73() {\n        checkConst(\"struct A {\\n\"\n                   \"    int* operator[](int i);\\n\"\n                   \"    const int* operator[](int i) const;\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    A a;\\n\"\n                   \"    void f(int j) {\\n\"\n                   \"        int* p = a[j];\\n\"\n                   \"        *p = 0;\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\" // #10758\n                   \"    T* h;\\n\"\n                   \"    void f(); \\n\"\n                   \"};\\n\"\n                   \"void S::f() {\\n\"\n                   \"    char* c = h->x[y];\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:5:9]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const74() { // #10671\n        checkConst(\"class A {\\n\"\n                   \"    std::vector<std::string> m_str;\\n\"\n                   \"public:\\n\"\n                   \"    A() {}\\n\"\n                   \"    void bar(void) {\\n\"\n                   \"        for(std::vector<std::string>::const_iterator it = m_str.begin(); it != m_str.end(); ++it) {;}\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (style, inconclusive) Technically the member function 'A::bar' can be const. [functionConst]\\n\", errout_str());\n\n        // Don't crash\n        checkConst(\"struct S {\\n\"\n                   \"    std::vector<T*> v;\\n\"\n                   \"    void f() const;\\n\"\n                   \"};\\n\"\n                   \"void S::f() const {\\n\"\n                   \"    for (std::vector<T*>::const_iterator it = v.begin(), end = v.end(); it != end; ++it) {}\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const75() { // #10065\n        checkConst(\"namespace N { int i = 0; }\\n\"\n                   \"struct S {\\n\"\n                   \"    int i;\\n\"\n                   \"    void f() {\\n\"\n                   \"        if (N::i) {}\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int i = 0;\\n\"\n                   \"struct S {\\n\"\n                   \"    int i;\\n\"\n                   \"    void f() {\\n\"\n                   \"        if (::i) {}\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"namespace N {\\n\"\n                   \"    struct S {\\n\"\n                   \"        int i;\\n\"\n                   \"        void f() {\\n\"\n                   \"            if (N::S::i) {}\\n\"\n                   \"        }\\n\"\n                   \"    };\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (style, inconclusive) Technically the member function 'N::S::f' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const76() { // #10825\n        checkConst(\"struct S {\\n\"\n                   \"    enum E {};\\n\"\n                   \"    void f(const T* t);\\n\"\n                   \"    E e;\\n\"\n                   \"};\\n\"\n                   \"struct T { void e(); };\\n\"\n                   \"void S::f(const T* t) {\\n\"\n                   \"    const_cast<T*>(t)->e();\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:7:9]: (performance, inconclusive) Technically the member function 'S::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\",\n                      errout_str());\n    }\n\n    void const77() {\n        checkConst(\"template <typename T>\\n\" // #10307\n                   \"struct S {\\n\"\n                   \"    std::vector<T> const* f() const { return p; }\\n\"\n                   \"    std::vector<T> const* p;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\" // #10311\n                   \"    std::vector<const int*> v;\\n\"\n                   \"    std::vector<const int*>& f() { return v; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const78() { // #10315\n        checkConst(\"struct S {\\n\"\n                   \"    typedef void(S::* F)();\\n\"\n                   \"    void g(F f);\\n\"\n                   \"};\\n\"\n                   \"void S::g(F f) {\\n\"\n                   \"    (this->*f)();\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    using F = void(S::*)();\\n\"\n                   \"    void g(F f);\\n\"\n                   \"};\\n\"\n                   \"void S::g(F f) {\\n\"\n                   \"    (this->*f)();\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const79() { // #9861\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    char* f() {\\n\"\n                   \"        return nullptr;\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (performance, inconclusive) Technically the member function 'A::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\",\n                      errout_str());\n    }\n\n    void const80() { // #11328\n        checkConst(\"struct B { static void b(); };\\n\"\n                   \"struct S : B {\\n\"\n                   \"    static void f() {}\\n\"\n                   \"    void g() const;\\n\"\n                   \"    void h();\\n\"\n                   \"    void k();\\n\"\n                   \"    void m();\\n\"\n                   \"    void n();\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void S::g() const {\\n\"\n                   \"    this->f();\\n\"\n                   \"}\\n\"\n                   \"void S::h() {\\n\"\n                   \"    this->f();\\n\"\n                   \"}\\n\"\n                   \"void S::k() {\\n\"\n                   \"    if (i)\\n\"\n                   \"        this->f();\\n\"\n                   \"}\\n\"\n                   \"void S::m() {\\n\"\n                   \"        this->B::b();\\n\"\n                   \"}\\n\"\n                   \"void S::n() {\\n\"\n                   \"        this->h();\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10] -> [test.cpp:11:9]: (performance, inconclusive) Technically the member function 'S::g' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:5:10] -> [test.cpp:14:9]: (performance, inconclusive) Technically the member function 'S::h' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:6:10] -> [test.cpp:17:9]: (style, inconclusive) Technically the member function 'S::k' can be const. [functionConst]\\n\"\n                      \"[test.cpp:7:10] -> [test.cpp:21:9]: (performance, inconclusive) Technically the member function 'S::m' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\",\n                      errout_str());\n    }\n\n    void const81() {\n        checkConst(\"struct A {\\n\" // #11330\n                   \"    bool f() const;\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    std::shared_ptr<A> a;\\n\"\n                   \"    void g() {\\n\"\n                   \"        if (a->f()) {}\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\",\n                      errout_str());\n\n        checkConst(\"struct A {\\n\" // #11499\n                   \"    void f() const;\\n\"\n                   \"};\\n\"\n                   \"template<class T>\\n\"\n                   \"struct P {\\n\"\n                   \"    T* operator->();\\n\"\n                   \"    const T* operator->() const;\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    P<A> p;\\n\"\n                   \"    void g() { p->f(); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:11:10]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\",\n                      errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    void f(int) const;\\n\"\n                   \"};\\n\"\n                   \"template<class T>\\n\"\n                   \"struct P {\\n\"\n                   \"  T* operator->();\\n\"\n                   \"  const T* operator->() const;\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"  P<A> p;\\n\"\n                   \"  void g() { p->f(1); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:11:8]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    void f(void*) const;\\n\"\n                   \"};\\n\"\n                   \"template<class T>\\n\"\n                   \"struct P {\\n\"\n                   \"    T* operator->();\\n\"\n                   \"    const T* operator->() const;\\n\"\n                   \"    P<T>& operator=(P) {\\n\"\n                   \"        return *this;\\n\"\n                   \"    }\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    P<A> p;\\n\"\n                   \"    std::vector<S> g() { p->f(nullptr); return {}; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:14:20]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    void f();\\n\"\n                   \"};\\n\"\n                   \"template<class T>\\n\"\n                   \"struct P {\\n\"\n                   \"    T* operator->();\\n\"\n                   \"    const T* operator->() const;\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    P<A> p;\\n\"\n                   \"    void g() { p->f(); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    void f() const;\\n\"\n                   \"};\\n\"\n                   \"template<class T>\\n\"\n                   \"struct P {\\n\"\n                   \"    T* operator->();\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    P<A> p;\\n\"\n                   \"    void g() { p->f(); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A {\\n\"\n                   \"    void f(int&) const;\\n\"\n                   \"};\\n\"\n                   \"template<class T>\\n\"\n                   \"struct P {\\n\"\n                   \"    T* operator->();\\n\"\n                   \"    const T* operator->() const;\\n\"\n                   \"};\\n\"\n                   \"struct S {\\n\"\n                   \"    P<A> p;\\n\"\n                   \"    int i;\\n\"\n                   \"    void g() { p->f(i); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A {\\n\" // #11501\n                   \"    enum E { E1 };\\n\"\n                   \"    virtual void f(E) const = 0;\\n\"\n                   \"};\\n\"\n                   \"struct F {\\n\"\n                   \"    A* a;\\n\"\n                   \"    void g() { a->f(A::E1); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (style, inconclusive) Technically the member function 'F::g' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const82() { // #11513\n        checkConst(\"struct S {\\n\"\n                   \"    int i;\\n\"\n                   \"    void h(bool) const;\\n\"\n                   \"    void g() { h(i == 1); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\",\n                      errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    int i;\\n\"\n                   \"    void h(int, int*) const;\\n\"\n                   \"    void g() { int a; h(i, &a); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\",\n                      errout_str());\n    }\n\n    void const83() {\n        checkConst(\"struct S {\\n\"\n                   \"    int i1, i2;\\n\"\n                   \"    void f(bool b);\\n\"\n                   \"    void g(bool b, int j);\\n\"\n                   \"};\\n\"\n                   \"void S::f(bool b) {\\n\"\n                   \"    int& r = b ? i1 : i2;\\n\"\n                   \"    r = 5;\\n\"\n                   \"}\\n\"\n                   \"void S::g(bool b, int j) {\\n\"\n                   \"    int& r = b ? j : i2;\\n\"\n                   \"    r = 5;\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const84() {\n        checkConst(\"class S {};\\n\" // #11616\n                   \"struct T {\\n\"\n                   \"    T(const S*);\\n\"\n                   \"    T(const S&);\\n\"\n                   \"};\\n\"\n                   \"struct C {\\n\"\n                   \"    const S s;\\n\"\n                   \"    void f1() {\\n\"\n                   \"        T t(&s);\\n\"\n                   \"    }\\n\"\n                   \"    void f2() {\\n\"\n                   \"        T t(s);\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:10]: (style, inconclusive) Technically the member function 'C::f1' can be const. [functionConst]\\n\"\n                      \"[test.cpp:11:10]: (style, inconclusive) Technically the member function 'C::f2' can be const. [functionConst]\\n\",\n                      errout_str());\n    }\n\n    void const85() { // #11618\n        checkConst(\"struct S {\\n\"\n                   \"    int a[2], b[2];\\n\"\n                   \"    void f() { f(a, b); }\\n\"\n                   \"    static void f(const int p[2], int q[2]);\\n\"\n                   \"};\\n\"\n                   \"void S::f(const int p[2], int q[2]) {\\n\"\n                   \"    q[0] = p[0];\\n\"\n                   \"    q[1] = p[1];\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const86() { // #11621\n        checkConst(\"struct S { int* p; };\\n\"\n                   \"struct T { int m; int* p; };\\n\"\n                   \"struct U {\\n\"\n                   \"    int i;\\n\"\n                   \"    void f() { S s = { &i }; }\\n\"\n                   \"    void g() { int* a[] = { &i }; }\\n\"\n                   \"    void h() { T t = { 1, &i }; }\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const87() {\n        checkConst(\"struct Tokenizer {\\n\" // #11720\n                   \"        bool isCPP() const {\\n\"\n                   \"        return cpp;\\n\"\n                   \"    }\\n\"\n                   \"    bool cpp;\\n\"\n                   \"};\\n\"\n                   \"struct Check {\\n\"\n                   \"    const Tokenizer* const mTokenizer;\\n\"\n                   \"    const int* const mSettings;\\n\"\n                   \"};\\n\"\n                   \"struct CheckA : Check {\\n\"\n                   \"    static bool test(const std::string& funcname, const int* settings, bool cpp);\\n\"\n                   \"};\\n\"\n                   \"struct CheckB : Check {\\n\"\n                   \"    bool f(const std::string& s);\\n\"\n                   \"};\\n\"\n                   \"bool CheckA::test(const std::string& funcname, const int* settings, bool cpp) {\\n\"\n                   \"    return !funcname.empty() && settings && cpp;\\n\"\n                   \"}\\n\"\n                   \"bool CheckB::f(const std::string& s) {\\n\"\n                   \"    return CheckA::test(s, mSettings, mTokenizer->isCPP());\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:15:10] -> [test.cpp:20:14]: (style, inconclusive) Technically the member function 'CheckB::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"void g(int&);\\n\"\n                   \"struct S {\\n\"\n                   \"    struct { int i; } a[1];\\n\"\n                   \"    void f() { g(a[0].i); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    const int& g() const { return i; }\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void h(int, const int&);\\n\"\n                   \"struct T {\\n\"\n                   \"    S s;\\n\"\n                   \"    int j;\\n\"\n                   \"    void f() { h(j, s.g()); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:10]: (style, inconclusive) Technically the member function 'T::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    int& g() { return i; }\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void h(int, int&);\\n\"\n                   \"struct T {\\n\"\n                   \"    S s;\\n\"\n                   \"    int j;\\n\"\n                   \"    void f() { h(j, s.g()); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    const int& g() const { return i; }\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void h(int, const int*);\\n\"\n                   \"struct T {\\n\"\n                   \"    S s;\\n\"\n                   \"    int j;\\n\"\n                   \"    void f() { h(j, &s.g()); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:10]: (style, inconclusive) Technically the member function 'T::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    int& g() { return i; }\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void h(int, int*);\\n\"\n                   \"struct T {\\n\"\n                   \"    S s;\\n\"\n                   \"    int j;\\n\"\n                   \"    void f() { h(j, &s.g()); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"void j(int** x);\\n\"\n                   \"void k(int* const* y);\\n\"\n                   \"struct S {\\n\"\n                   \"    int* p;\\n\"\n                   \"    int** q;\\n\"\n                   \"    int* const* r;\\n\"\n                   \"    void f1() { j(&p); }\\n\"\n                   \"    void f2() { j(q); }\\n\"\n                   \"    void g1() { k(&p); }\\n\"\n                   \"    void g2() { k(q); }\\n\"\n                   \"    void g3() { k(r); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"void m(int*& r);\\n\"\n                   \"void n(int* const& s);\\n\"\n                   \"struct T {\\n\"\n                   \"    int i;\\n\"\n                   \"    int* p;\\n\"\n                   \"    void f1() { m(p); }\\n\"\n                   \"    void f2() { n(&i); }\\n\"\n                   \"    void f3() { n(p); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const88() { // #11626\n        checkConst(\"struct S {\\n\"\n                   \"    bool f() { return static_cast<bool>(p); }\\n\"\n                   \"    const int* g() { return const_cast<const int*>(p); }\\n\"\n                   \"    const int* h() { return (const int*)p; }\\n\"\n                   \"    char* j() { return reinterpret_cast<char*>(p); }\\n\"\n                   \"    char* k() { return (char*)p; }\\n\"\n                   \"    int* p;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\"\n                      \"[test.cpp:3:16]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\"\n                      \"[test.cpp:4:16]: (style, inconclusive) Technically the member function 'S::h' can be const. [functionConst]\\n\",\n                      errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    bool f() { return p != nullptr; }\\n\"\n                   \"    std::shared_ptr<int> p;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\",\n                      errout_str());\n    }\n\n    void const89() {\n        checkConst(\"struct S {\\n\" // #11654\n                   \"    void f(bool b);\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void S::f(bool b) {\\n\"\n                   \"    if (i && b)\\n\"\n                   \"        f(false);\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:5:9]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct S {\\n\"\n                   \"    void f(int& r);\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\"\n                   \"void S::f(int& r) {\\n\"\n                   \"    r = 0;\\n\"\n                   \"    if (i)\\n\"\n                   \"        f(i);\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\" // #11744\n                   \"    S* p;\\n\"\n                   \"    int f() {\\n\"\n                   \"        if (p)\\n\"\n                   \"            return 1 + p->f();\\n\"\n                   \"        return 1;\\n\"\n                   \"    }\\n\"\n                   \"    int g(int i) {\\n\"\n                   \"        if (i > 0)\\n\"\n                   \"            return i + g(i - 1);\\n\"\n                   \"        return 0;\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\"\n                      \"[test.cpp:8:9]: (performance, inconclusive) Technically the member function 'S::g' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\",\n                      errout_str());\n\n        checkConst(\"class C {\\n\" // #11653\n                   \"public:\\n\"\n                   \"    void f(bool b) const;\\n\"\n                   \"};\\n\"\n                   \"void C::f(bool b) const {\\n\"\n                   \"    if (b)\\n\"\n                   \"        f(false);\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:5:9]: (performance, inconclusive) Technically the member function 'C::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\",\n                      errout_str());\n    }\n\n    void const90() { // #11637\n        checkConst(\"class S {};\\n\"\n                   \"struct C {\\n\"\n                   \"    C(const S*);\\n\"\n                   \"    C(const S&);\\n\"\n                   \"};\\n\"\n                   \"class T {\\n\"\n                   \"    S s;\\n\"\n                   \"    void f1() { C c = C{ &s }; }\\n\"\n                   \"    void f2() { C c = C{ s }; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:10]: (style, inconclusive) Technically the member function 'T::f1' can be const. [functionConst]\\n\"\n                      \"[test.cpp:9:10]: (style, inconclusive) Technically the member function 'T::f2' can be const. [functionConst]\\n\",\n                      errout_str());\n    }\n\n    void const91() { // #11790\n        checkConst(\"struct S {\\n\"\n                   \"    char* p;\\n\"\n                   \"    template <typename T>\\n\"\n                   \"    T* get() {\\n\"\n                   \"        return reinterpret_cast<T*>(p);\\n\"\n                   \"    }\\n\"\n                   \"};\\n\"\n                   \"const int* f(S& s) {\\n\"\n                   \"    return s.get<const int>();\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const92() { // #11886\n        checkConst(\"void g(int);\\n\"\n                   \"template<int n>\\n\"\n                   \"struct S : public S<n - 1> {\\n\"\n                   \"    void f() {\\n\"\n                   \"        g(n - 1);\\n\"\n                   \"    }\\n\"\n                   \"};\\n\"\n                   \"template<>\\n\"\n                   \"struct S<0> {};\\n\"\n                   \"struct D : S<150> {};\\n\");\n        // don't hang\n    }\n\n    void const93() { // #12162\n        checkConst(\"struct S {\\n\"\n                   \"    bool f() {\\n\"\n                   \"        return m.cbegin()->first == 0;\\n\"\n                   \"    }\\n\"\n                   \"    bool g() {\\n\"\n                   \"        return m.count(0);\\n\"\n                   \"    }\\n\"\n                   \"    std::map<int, int> m;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\"\n                      \"[test.cpp:5:10]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\",\n                      errout_str());\n    }\n\n    void const94() { // #7459\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    A() : tickFunction(&A::nop) {}\\n\"\n                   \"    void tick() { (this->*tickFunction)(); }\\n\"\n                   \"private:\\n\"\n                   \"    typedef void (A::* Fn)();\\n\"\n                   \"    Fn tickFunction;\\n\"\n                   \"    void nop() {}\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const95() { // #13320\n        checkConst(\"class C {\\n\"\n                   \"    std::string x;\\n\"\n                   \"    std::string get() && { return x; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const96() {\n        checkConst(\"struct S : B {\\n\" // #13282\n                   \"    bool f() { return b; }\\n\"\n                   \"    bool g() override { return b; }\\n\"\n                   \"    bool b;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style, inconclusive) Either there is a missing 'override', or the member function 'S::f' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"struct B;\\n\" // #13382\n                   \"struct S : B {\\n\"\n                   \"    void f();\\n\"\n                   \"};\\n\"\n                   \"void S::f() {\\n\"\n                   \"    B::g(0);\\n\"\n                   \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const97() { // #13301\n        checkConst(\"struct S {\\n\"\n                   \"    std::vector<int> v;\\n\"\n                   \"    int f() {\\n\"\n                   \"        const int& r = v.front();\\n\"\n                   \"        return r;\\n\"\n                   \"    }\\n\"\n                   \"    int g() {\\n\"\n                   \"        const int& r = v.at(0);\\n\"\n                   \"        return r;\\n\"\n                   \"    }\\n\"\n                   \"    void h() {\\n\"\n                   \"        if (v.front() == 0) {}\\n\"\n                   \"        if (1 == v.front()) {}\\n\"\n                   \"    }\\n\"\n                   \"    void i() {\\n\"\n                   \"        v.at(0) = 0;\\n\"\n                   \"    }\\n\"\n                   \"    void j() {\\n\"\n                   \"        dostuff(1, v.at(0));\\n\"\n                   \"    }\\n\"\n                   \"    void k() {\\n\"\n                   \"        int& r = v.front();\\n\"\n                   \"        r = 0;\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\"\n                      \"[test.cpp:7:9]: (style, inconclusive) Technically the member function 'S::g' can be const. [functionConst]\\n\"\n                      \"[test.cpp:11:10]: (style, inconclusive) Technically the member function 'S::h' can be const. [functionConst]\\n\",\n                      errout_str());\n\n        checkConst(\"struct B { std::string s; };\\n\"\n                   \"struct D : B {\\n\"\n                   \"    bool f(std::string::iterator it) { return it == B::s.begin(); }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'D::f' can be const. [functionConst]\\n\",\n                      errout_str());\n    }\n\n    void const98() { // #13642\n        checkConst(\"enum E {\\n\"\n                   \"    E0,\\n\"\n                   \"    E1\\n\"\n                   \"};\\n\"\n                   \"void set(int* p) {\\n\"\n                   \"    *p = 1;\\n\"\n                   \"}\\n\"\n                   \"struct S {\\n\"\n                   \"    E e;\\n\"\n                   \"    void f() {\\n\"\n                   \"        set(reinterpret_cast<int*>(&e));\\n\"\n                   \"    }\\n\"\n                   \"    void g() {\\n\"\n                   \"        set(reinterpret_cast<int*>(reinterpret_cast<void*>(&e)));\\n\"\n                   \"    }\\n\"\n                   \"    void h() {\\n\"\n                   \"        set((int*)(&e));\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"enum E {\\n\"\n                   \"    E0,\\n\"\n                   \"    E1\\n\"\n                   \"};\\n\"\n                   \"void set1(int i, int* p) {\\n\"\n                   \"    *p = i;\\n\"\n                   \"}\\n\"\n                   \"void set2(int* p, int i) {\\n\"\n                   \"    *p = i;\\n\"\n                   \"}\\n\"\n                   \"struct S {\\n\"\n                   \"    E e;\\n\"\n                   \"    void f1() {\\n\"\n                   \"        set1(1, reinterpret_cast<int*>(&e));\\n\"\n                   \"    }\\n\"\n                   \"    void f2() {\\n\"\n                   \"        set2(reinterpret_cast<int*>(&e), 1);\\n\"\n                   \"    }\\n\"\n                   \"    void g1() {\\n\"\n                   \"        set1(1, reinterpret_cast<int*>(reinterpret_cast<void*>(&e)));\\n\"\n                   \"    }\\n\"\n                   \"    void g2() {\\n\"\n                   \"        set2(reinterpret_cast<int*>(reinterpret_cast<void*>(&e)), 1);\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const99() {\n        checkConst(\"typedef void (*InitFunc)(void**);\\n\" // #13953\n                   \"struct S {\\n\"\n                   \"    int *m;\\n\"\n                   \"    void f(InitFunc func) {\\n\"\n                   \"        func(reinterpret_cast<void**>(&m));\\n\"\n                   \"    }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void const100() {\n        checkConst(\"struct S {\\n\" // #14023\n                   \"    void f() { ++i; }\\n\"\n                   \"    void f() const {}\\n\"\n                   \"    int i;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct S {\\n\" // #14033\n                   \"    void f();\\n\"\n                   \"    void f() const {}\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n    }\n\n    void const_handleDefaultParameters() {\n        checkConst(\"struct Foo {\\n\"\n                   \"    void foo1(int i, int j = 0) {\\n\"\n                   \"        return func(this);\\n\"\n                   \"    }\\n\"\n                   \"    int bar1() {\\n\"\n                   \"        return foo1(1);\\n\"\n                   \"    }\\n\"\n                   \"    int bar2() {\\n\"\n                   \"        return foo1(1, 2);\\n\"\n                   \"    }\\n\"\n                   \"    int bar3() {\\n\"\n                   \"        return foo1(1, 2, 3);\\n\"\n                   \"    }\\n\"\n                   \"    int bar4() {\\n\"\n                   \"        return foo1();\\n\"\n                   \"    }\\n\"\n                   \"    void foo2(int i = 0) {\\n\"\n                   \"        return func(this);\\n\"\n                   \"    }\\n\"\n                   \"    int bar5() {\\n\"\n                   \"        return foo2();\\n\"\n                   \"    }\\n\"\n                   \"    void foo3() {\\n\"\n                   \"        return func(this);\\n\"\n                   \"    }\\n\"\n                   \"    int bar6() {\\n\"\n                   \"        return foo3();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:11:9]: (performance, inconclusive) Technically the member function 'Foo::bar3' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:14:9]: (performance, inconclusive) Technically the member function 'Foo::bar4' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void const_passThisToMemberOfOtherClass() {\n        checkConst(\"struct Foo {\\n\"\n                   \"    void foo() {\\n\"\n                   \"        Bar b;\\n\"\n                   \"        b.takeFoo(this);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct Foo {\\n\"\n                   \"    void foo() {\\n\"\n                   \"        Foo f;\\n\"\n                   \"        f.foo();\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance, inconclusive) Technically the member function 'Foo::foo' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct A;\\n\" // #5839 - operator()\n                   \"struct B {\\n\"\n                   \"    void operator()(A *a);\\n\"\n                   \"};\\n\"\n                   \"struct A {\\n\"\n                   \"    void dostuff() {\\n\"\n                   \"        B()(this);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assigningPointerToPointerIsNotAConstOperation() {\n        checkConst(\"struct s\\n\"\n                   \"{\\n\"\n                   \"    int** v;\\n\"\n                   \"    void f()\\n\"\n                   \"    {\\n\"\n                   \"        v = 0;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assigningArrayElementIsNotAConstOperation() {\n        checkConst(\"struct s\\n\"\n                   \"{\\n\"\n                   \"    ::std::string v[3];\\n\"\n                   \"    void f()\\n\"\n                   \"    {\\n\"\n                   \"        v[0] = \\\"Happy new year!\\\";\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // increment/decrement => not const\n    void constincdec() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return ++a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return --a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a++; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a--; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return ++a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return --a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a++; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a--; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct S {\\n\" // #10077\n                   \"    int i{};\\n\"\n                   \"    S& operator ++() { ++i; return *this; }\\n\"\n                   \"    S operator ++(int) { S s = *this; ++(*this); return s; }\\n\"\n                   \"    void f() { (*this)--; }\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constassign1() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    void nextA() { return a/=-2; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a/=-2; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void constassign2() {\n        checkConst(\"class Fred {\\n\"\n                   \"    struct A { int a; } s;\\n\"\n                   \"    void nextA() { return s.a=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    struct A { int a; } s;\\n\"\n                   \"    void nextA() { return s.a-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    struct A { int a; } s;\\n\"\n                   \"    void nextA() { return s.a+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    struct A { int a; } s;\\n\"\n                   \"    void nextA() { return s.a*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A { int a; } s;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return s.a=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct A { int a; } s;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return s.a-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct A { int a; } s;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return s.a+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct A { int a; } s;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return s.a*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct A { int a; } s;\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return s.a/=-2; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"struct A { int a; };\\n\"\n                   \"class Fred {\\n\"\n                   \"    A s;\\n\"\n                   \"    void nextA() { return s.a=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A { int a; };\\n\"\n                   \"class Fred {\\n\"\n                   \"    A s;\\n\"\n                   \"    void nextA() { return s.a-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A { int a; };\\n\"\n                   \"class Fred {\\n\"\n                   \"    A s;\\n\"\n                   \"    void nextA() { return s.a+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A { int a; };\\n\"\n                   \"class Fred {\\n\"\n                   \"    A s;\\n\"\n                   \"    void nextA() { return s.a*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"struct A { int a; };\\n\"\n                   \"class Fred {\\n\"\n                   \"    A s;\\n\"\n                   \"    void nextA() { return s.a/=-2; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // increment/decrement array element => not const\n    void constincdecarray() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return ++a[0]; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return --a[0]; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]++; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]--; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return ++a[0]; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return --a[0]; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]++; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]--; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    void constassignarray() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class Fred {\\n\"\n                   \"    int a[2];\\n\"\n                   \"    void nextA() { return a[0]/=-2; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]-=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]+=1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]*=-1; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(\"int a[2];\\n\"\n                   \"class Fred {\\n\"\n                   \"    void nextA() { return a[0]/=-2; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'Fred::nextA' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n    }\n\n    // return pointer/reference => not const\n    void constReturnReference() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int a;\\n\"\n                   \"    int &getR() { return a; }\\n\"\n                   \"    int *getP() { return &a; }\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // delete member variable => not const (but technically it can, it compiles without errors)\n    void constDelete() {\n        checkConst(\"class Fred {\\n\"\n                   \"    int *a;\\n\"\n                   \"    void clean() { delete a; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // A function that returns unknown types can't be const (#1579)\n    void constLPVOID() {\n        checkConst(\"class Fred {\\n\"\n                   \"    UNKNOWN a() { return 0; };\\n\"\n                   \"};\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2]: (performance, inconclusive) Technically the member function 'Fred::a' can be static.\\n\", \"\", errout_str());\n\n        // #1579 - HDC\n        checkConst(\"class Fred {\\n\"\n                   \"    foo bar;\\n\"\n                   \"    UNKNOWN a() { return b; };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // a function that calls const functions can be const\n    void constFunc() {\n        checkConst(\"class Fred {\\n\"\n                   \"    void f() const { };\\n\"\n                   \"    void a() { f(); };\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance, inconclusive) Technically the member function 'Fred::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\"\n                      \"[test.cpp:3:10]: (style, inconclusive) Technically the member function 'Fred::a' can be const. [functionConst]\\n\", errout_str());\n\n        // ticket #1593\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"   std::vector<int> m_v;\\n\"\n                   \"public:\\n\"\n                   \"   A(){}\\n\"\n                   \"   unsigned int GetVecSize()  {return m_v.size();}\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:17]: (style, inconclusive) Technically the member function 'A::GetVecSize' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A\\n\"\n                   \"{\\n\"\n                   \"   std::vector<int> m_v;\\n\"\n                   \"public:\\n\"\n                   \"   A(){}\\n\"\n                   \"   bool GetVecEmpty()  {return m_v.empty();}\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (style, inconclusive) Technically the member function 'A::GetVecEmpty' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constVirtualFunc() {\n        // base class has no virtual function\n        checkConst(\"class A { };\\n\"\n                   \"class B : public A {\\n\"\n                   \"   int b;\\n\"\n                   \"public:\\n\"\n                   \"   B() : b(0) { }\\n\"\n                   \"   int func() { return b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:8]: (style, inconclusive) Technically the member function 'B::func' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A { };\\n\"\n                   \"class B : public A {\\n\"\n                   \"   int b;\\n\"\n                   \"public:\\n\"\n                   \"   B() : b(0) { }\\n\"\n                   \"   int func();\\n\"\n                   \"};\\n\"\n                   \"int B::func() { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:6:8] -> [test.cpp:8:8]: (style, inconclusive) Technically the member function 'B::func' can be const. [functionConst]\\n\", errout_str());\n\n        // base class has no virtual function\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func() { return b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:9:9]: (style, inconclusive) Technically the member function 'B::func' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int B::func() { return b; }\");\n        ASSERT_EQUALS(\"[test.cpp:9:9] -> [test.cpp:11:8]: (style, inconclusive) Technically the member function 'B::func' can be const. [functionConst]\\n\", errout_str());\n\n        // base class has virtual function\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    virtual int func();\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func() { return b; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    virtual int func();\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int B::func() { return b; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"    virtual int func() = 0;\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int B::func() { return b; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // base class has no virtual function\n        checkConst(\"class A {\\n\"\n                   \"    int a;\\n\"\n                   \"public:\\n\"\n                   \"    A() : a(0) { }\\n\"\n                   \"    int func() { return a; }\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func() { return b; }\\n\"\n                   \"};\\n\"\n                   \"class C : public B {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    C() : c(0) { }\\n\"\n                   \"    int func() { return c; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style, inconclusive) Technically the member function 'A::func' can be const. [functionConst]\\n\"\n                      \"[test.cpp:11:9]: (style, inconclusive) Technically the member function 'B::func' can be const. [functionConst]\\n\"\n                      \"[test.cpp:17:9]: (style, inconclusive) Technically the member function 'C::func' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"    int a;\\n\"\n                   \"public:\\n\"\n                   \"    A() : a(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int A::func() { return a; }\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int B::func() { return b; }\\n\"\n                   \"class C : public B {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    C() : c(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int C::func() { return c; }\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:7:8]: (style, inconclusive) Technically the member function 'A::func' can be const. [functionConst]\\n\"\n                      \"[test.cpp:12:9] -> [test.cpp:14:8]: (style, inconclusive) Technically the member function 'B::func' can be const. [functionConst]\\n\"\n                      \"[test.cpp:19:9] -> [test.cpp:21:8]: (style, inconclusive) Technically the member function 'C::func' can be const. [functionConst]\\n\", errout_str());\n\n        // base class has virtual function\n        checkConst(\"class A {\\n\"\n                   \"    int a;\\n\"\n                   \"public:\\n\"\n                   \"    A() : a(0) { }\\n\"\n                   \"    virtual int func() { return a; }\\n\"\n                   \"};\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func() { return b; }\\n\"\n                   \"};\\n\"\n                   \"class C : public B {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    C() : c(0) { }\\n\"\n                   \"    int func() { return c; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkConst(\"class A {\\n\"\n                   \"    int a;\\n\"\n                   \"public:\\n\"\n                   \"    A() : a(0) { }\\n\"\n                   \"    virtual int func();\\n\"\n                   \"};\\n\"\n                   \"int A::func() { return a; }\\n\"\n                   \"class B : public A {\\n\"\n                   \"    int b;\\n\"\n                   \"public:\\n\"\n                   \"    B() : b(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int B::func() { return b; }\\n\"\n                   \"class C : public B {\\n\"\n                   \"    int c;\\n\"\n                   \"public:\\n\"\n                   \"    C() : c(0) { }\\n\"\n                   \"    int func();\\n\"\n                   \"};\\n\"\n                   \"int C::func() { return c; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #1311\n        checkConst(\"class X {\\n\"\n                   \"    int x;\\n\"\n                   \"public:\\n\"\n                   \"    X(int x) : x(x) { }\\n\"\n                   \"    int getX() { return x; }\\n\"\n                   \"};\\n\"\n                   \"class Y : public X {\\n\"\n                   \"    int y;\\n\"\n                   \"public:\\n\"\n                   \"    Y(int x, int y) : X(x), y(y) { }\\n\"\n                   \"    int getY() { return y; }\\n\"\n                   \"};\\n\"\n                   \"class Z : public Y {\\n\"\n                   \"    int z;\\n\"\n                   \"public:\\n\"\n                   \"    Z(int x, int y, int z) : Y(x, y), z(z) { }\\n\"\n                   \"    int getZ() { return z; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style, inconclusive) Technically the member function 'X::getX' can be const. [functionConst]\\n\"\n                      \"[test.cpp:11:9]: (style, inconclusive) Technically the member function 'Y::getY' can be const. [functionConst]\\n\"\n                      \"[test.cpp:17:9]: (style, inconclusive) Technically the member function 'Z::getZ' can be const. [functionConst]\\n\", errout_str());\n\n        checkConst(\"class X {\\n\"\n                   \"    int x;\\n\"\n                   \"public:\\n\"\n                   \"    X(int x) : x(x) { }\\n\"\n                   \"    int getX();\\n\"\n                   \"};\\n\"\n                   \"int X::getX() { return x; }\\n\"\n                   \"class Y : public X {\\n\"\n                   \"    int y;\\n\"\n                   \"public:\\n\"\n                   \"    Y(int x, int y) : X(x), y(y) { }\\n\"\n                   \"    int getY();\\n\"\n                   \"};\\n\"\n                   \"int Y::getY() { return y; }\\n\"\n                   \"class Z : public Y {\\n\"\n                   \"    int z;\\n\"\n                   \"public:\\n\"\n                   \"    Z(int x, int y, int z) : Y(x, y), z(z) { }\\n\"\n                   \"    int getZ();\\n\"\n                   \"};\\n\"\n                   \"int Z::getZ() { return z; }\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:7:8]: (style, inconclusive) Technically the member function 'X::getX' can be const. [functionConst]\\n\"\n                      \"[test.cpp:12:9] -> [test.cpp:14:8]: (style, inconclusive) Technically the member function 'Y::getY' can be const. [functionConst]\\n\"\n                      \"[test.cpp:19:9] -> [test.cpp:21:8]: (style, inconclusive) Technically the member function 'Z::getZ' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constIfCfg() {\n        const char code[] = \"struct foo {\\n\"\n                            \"    int i;\\n\"\n                            \"    void f() {\\n\"\n                            //\"#ifdef ABC\\n\"\n                            //\"        i = 4;\\n\"\n                            //\"endif\\n\"\n                            \"    }\\n\"\n                            \"};\";\n\n        checkConst(code, dinit(CheckConstOptions, $.s = &settings0, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance, inconclusive) Technically the member function 'foo::f' can be static (but you may consider moving to unnamed namespace). [functionStatic]\\n\", errout_str());\n\n        checkConst(code, dinit(CheckConstOptions, $.s = &settings0, $.inconclusive = false)); // TODO: Set inconclusive to true (preprocess it)\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constFriend() { // ticket #1921\n        const char code[] = \"class foo {\\n\"\n                            \"    friend void f() { }\\n\"\n                            \"};\";\n        checkConst(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constUnion() { // ticket #2111\n        checkConst(\"class foo {\\n\"\n                   \"public:\\n\"\n                   \"    union {\\n\"\n                   \"        int i;\\n\"\n                   \"        float f;\\n\"\n                   \"    } d;\\n\"\n                   \"    void setf(float x) {\\n\"\n                   \"        d.f = x;\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constArrayOperator() {\n        checkConst(\"struct foo {\\n\"\n                   \"    int x;\\n\"\n                   \"    int y[5][724];\\n\"\n                   \"    T a() {\\n\"\n                   \"        return y[x++][6];\\n\"\n                   \"    }\\n\"\n                   \"    T b() {\\n\"\n                   \"        return y[1][++x];\\n\"\n                   \"    }\\n\"\n                   \"    T c() {\\n\"\n                   \"        return y[1][6];\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:10:7]: (style, inconclusive) Technically the member function 'foo::c' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constRangeBasedFor() { // #5514\n        checkConst(\"class Fred {\\n\"\n                   \"    int array[256];\\n\"\n                   \"public:\\n\"\n                   \"    void f1() {\\n\"\n                   \"        for (auto & e : array)\\n\"\n                   \"            foo(e);\\n\"\n                   \"    }\\n\"\n                   \"    void f2() {\\n\"\n                   \"        for (const auto & e : array)\\n\"\n                   \"            foo(e);\\n\"\n                   \"    }\\n\"\n                   \"    void f3() {\\n\"\n                   \"        for (decltype(auto) e : array)\\n\"\n                   \"            foo(e);\\n\"\n                   \"    }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"[test.cpp:8:10]: (style, inconclusive) Technically the member function 'Fred::f2' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void const_shared_ptr() { // #8674\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    std::shared_ptr<Data> getData();\\n\"\n                   \"private:\\n\"\n                   \"     std::shared_ptr<Data> data;\\n\"\n                   \"};\\n\"\n                   \"\\n\"\n                   \"std::shared_ptr<Data> Fred::getData() { return data; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constPtrToConstPtr() {\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    const char *const *data;\\n\"\n                   \"    const char *const *getData() { return data; }\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:4:24]: (style, inconclusive) Technically the member function 'Fred::getData' can be const. [functionConst]\\n\", errout_str());\n    }\n\n    void constTrailingReturnType() { // #9814\n        checkConst(\"struct A {\\n\"\n                   \"    int x = 1;\\n\"\n                   \"    auto get() -> int & { return x; }\\n\"\n                   \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constRefQualified() { // #12920\n        checkConst(\"class Fred {\\n\"\n                   \"public:\\n\"\n                   \"    const Data& get() & { return data; }\\n\"\n                   \"private:\\n\"\n                   \"    Data data;\\n\"\n                   \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void staticArrayPtrOverload() {\n        checkConst(\"struct S {\\n\"\n                   \"    template<size_t N>\\n\"\n                   \"    void f(const std::array<std::string_view, N>& sv);\\n\"\n                   \"    template<long N>\\n\"\n                   \"    void f(const char* const (&StrArr)[N]);\\n\"\n                   \"};\\n\"\n                   \"template<size_t N>\\n\"\n                   \"void S::f(const std::array<std::string_view, N>& sv) {\\n\"\n                   \"    const char* ptrs[N]{};\\n\"\n                   \"    return f(ptrs);\\n\"\n                   \"}\\n\"\n                   \"template void S::f(const std::array<std::string_view, 3>& sv);\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void qualifiedNameMember() { // #10872\n        const Settings s = settingsBuilder().severity(Severity::style).debugwarnings().library(\"std.cfg\").build();\n        checkConst(\"struct data {};\\n\"\n                   \"    struct S {\\n\"\n                   \"    std::vector<data> std;\\n\"\n                   \"    void f();\\n\"\n                   \"};\\n\"\n                   \"void S::f() {\\n\"\n                   \"    std::vector<data>::const_iterator end = std.end();\\n\"\n                   \"}\\n\", dinit(CheckConstOptions, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:4:10] -> [test.cpp:6:9]: (style, inconclusive) Technically the member function 'S::f' can be const. [functionConst]\\n\", errout_str());\n    }\n\n#define checkInitializerListOrder(...) checkInitializerListOrder_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkInitializerListOrder_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings2, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CheckClass checkClass(&tokenizer, &settings2, this);\n        checkClass.initializerListOrder();\n    }\n\n    void initializerListOrder() {\n        checkInitializerListOrder(\"class Fred {\\n\"\n                                  \"    int a, b, c;\\n\"\n                                  \"public:\\n\"\n                                  \"    Fred() : c(0), b(0), a(0) { }\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:20] -> [test.cpp:2:12]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list. [initializerList]\\n\"\n                      \"[test.cpp:4:26] -> [test.cpp:2:9]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list. [initializerList]\\n\", errout_str());\n\n        checkInitializerListOrder(\"class Fred {\\n\"\n                                  \"    int a, b, c;\\n\"\n                                  \"public:\\n\"\n                                  \"    Fred() : c{0}, b{0}, a{0} { }\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:20] -> [test.cpp:2:12]: (style, inconclusive) Member variable 'Fred::b' is in the wrong place in the initializer list. [initializerList]\\n\"\n                      \"[test.cpp:4:26] -> [test.cpp:2:9]: (style, inconclusive) Member variable 'Fred::a' is in the wrong place in the initializer list. [initializerList]\\n\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S() : b(a = 1) {}\\n\"\n                                  \"    int a, b;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    int nCols() const;\\n\"\n                                  \"    int nRows() const;\\n\"\n                                  \"};\\n\"\n                                  \"struct B {\\n\"\n                                  \"    const char* m_name;\\n\"\n                                  \"    int nCols;\\n\"\n                                  \"    int nRows;\\n\"\n                                  \"    B(const char* p_name, int nR, int nC)\\n\"\n                                  \"        : m_name(p_name)\\n\"\n                                  \"        , nCols(nC)\\n\"\n                                  \"        , nRows(nR)\\n\"\n                                  \"    {}\\n\"\n                                  \"};\\n\"\n                                  \"struct D : public B {\\n\"\n                                  \"    const int  m_i;\\n\"\n                                  \"    D(const S& s, int _i)\\n\"\n                                  \"        : B(\\\"abc\\\", s.nRows(), s.nCols())\\n\"\n                                  \"        , m_i(_i)\\n\"\n                                  \"    {}\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void initializerListArgument() {\n        checkInitializerListOrder(\"struct A { A(); };\\n\" // #12322\n                                  \"struct B { explicit B(const A* a); };\\n\"\n                                  \"struct C {\\n\"\n                                  \"    C() : b(&a) {}\\n\"\n                                  \"    B b;\\n\"\n                                  \"    const A a;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:11] -> [test.cpp:5:7]: (style, inconclusive) Member variable 'C::b' uses an uninitialized argument 'a' due to the order of declarations. [initializerList]\\n\",\n                      errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S(const std::string& f, std::string i, int b, int c) : a(0), b(b), c(c) {}\\n\"\n                                  \"    int a, b, c;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S() : p(a) {}\\n\"\n                                  \"    int* p;\\n\"\n                                  \"    int a[1];\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S() : p(&i) {}\\n\"\n                                  \"    int* p;\\n\"\n                                  \"    int i;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S() : a(b = 1) {}\\n\"\n                                  \"    int a, b;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S() : r(i) {}\\n\"\n                                  \"    int& r;\\n\"\n                                  \"    int i{};\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct B {\\n\"\n                                  \"    int a{}, b{};\\n\"\n                                  \"};\\n\"\n                                  \"struct D : B {\\n\"\n                                  \"    D() : B(), j(b) {}\\n\"\n                                  \"    int j;\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S() : a(i) {}\\n\"\n                                  \"    int a;\\n\"\n                                  \"    static int i;\\n\"\n                                  \"};\\n\"\n                                  \"int S::i = 0;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S {\\n\"\n                                  \"    S(int b) : a(b) {}\\n\"\n                                  \"    int a, b{};\\n\"\n                                  \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"class Foo {\\n\" // #3524\n                                  \"public:\\n\"\n                                  \"    Foo(int arg) : a(b), b(arg) {}\\n\"\n                                  \"    int a;\\n\"\n                                  \"    int b;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:20] -> [test.cpp:4:9]: (style, inconclusive) Member variable 'Foo::a' uses an uninitialized argument 'b' due to the order of declarations. [initializerList]\\n\",\n                      errout_str());\n\n        checkInitializerListOrder(\"struct S { double d = 0; };\\n\" // #12730\n                                  \"struct T {\\n\"\n                                  \"    T() : s(), a(s.d), d(0) {}\\n\"\n                                  \"    S s;\\n\"\n                                  \"    double a, d;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializerListOrder(\"struct S { static const int d = 1; };\\n\"\n                                  \"struct T {\\n\"\n                                  \"    T() : s(), a(S::d), d(0) {}\\n\"\n                                  \"    S s;\\n\"\n                                  \"    int a, d;\\n\"\n                                  \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkInitializationListUsage(...) checkInitializationListUsage_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkInitializationListUsage_(const char* file, int line, const char (&code)[size]) {\n        // Check..\n        const Settings settings = settingsBuilder().severity(Severity::performance).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CheckClass checkClass(&tokenizer, &settings, this);\n        checkClass.initializationListUsage();\n    }\n\n    void initializerListUsage() {\n        checkInitializationListUsage(\"enum Enum { C = 0 };\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    int a;\\n\"  // No message for builtin types: No performance gain\n                                     \"    int* b;\\n\" // No message for pointers: No performance gain\n                                     \"    Enum c;\\n\" // No message for enums: No performance gain\n                                     \"    Fred() { a = 0; b = 0; c = C; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::string s;\\n\"\n                                     \"    Fred() { a = 0; s = \\\"foo\\\"; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:21]: (performance) Variable 's' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::string& s;\\n\" // Message is invalid for references, since their initialization in initializer list is required anyway and behaves different from assignment (#5004)\n                                     \"    Fred(const std::string& s_) : s(s_) { s = \\\"foo\\\"; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::vector<int> v;\\n\"\n                                     \"    Fred() { v = unknown; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (performance) Variable 'v' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class C { std::string s; };\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C c;\\n\"\n                                     \"    Fred() { c = unknown; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C c;\\n\"\n                                     \"    Fred() { c = unknown; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C c;\\n\"\n                                     \"    Fred(Fred const & other) { c = other.c; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:32]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C c;\\n\"\n                                     \"    Fred(Fred && other) { c = other.c; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:27]: (performance) Variable 'c' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C a;\\n\"\n                                     \"    Fred() { initB(); a = b; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C a;\\n\"\n                                     \"    Fred() : a(0) { if(b) a = 0; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C a[5];\\n\"\n                                     \"    Fred() { for(int i = 0; i < 5; i++) a[i] = 0; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C a; int b;\\n\"\n                                     \"    Fred() : b(5) { a = b; }\\n\" // Don't issue a message here: You actually could move it to the initialization list, but it would cause problems if you change the order of the variable declarations.\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class C;\\n\"\n                                     \"class Fred {\\n\"\n                                     \"    C a;\\n\"\n                                     \"    Fred() { try { a = new int; } catch(...) {} }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::string s;\\n\"\n                                     \"    Fred() { s = toString((size_t)this); }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::string a;\\n\"\n                                     \"    std::string foo();\\n\"\n                                     \"    Fred() { a = foo(); }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::string a;\\n\"\n                                     \"    Fred() { a = foo(); }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (performance) Variable 'a' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]\\n\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\" // #4332\n                                     \"    static std::string s;\\n\"\n                                     \"    Fred() { s = \\\"foo\\\"; }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\" // #5640\n                                     \"    std::string s;\\n\"\n                                     \"    Fred() {\\n\"\n                                     \"        char str[2];\\n\"\n                                     \"        str[0] = c;\\n\"\n                                     \"        str[1] = 0;\\n\"\n                                     \"        s = str;\\n\"\n                                     \"    }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class B {\\n\" // #5640\n                                     \"    std::shared_ptr<A> _d;\\n\"\n                                     \"    B(const B& other) : _d(std::make_shared<A>()) {\\n\"\n                                     \"        *_d = *other._d;\\n\"\n                                     \"    }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Bar {\\n\" // #8466\n                                     \"public:\\n\"\n                                     \"    explicit Bar(const Bar &bar) : Bar{bar.s} {}\\n\"\n                                     \"    explicit Bar(const char s) : s{s} {}\\n\"\n                                     \"private:\\n\"\n                                     \"    char s;\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"unsigned bar(std::string);\\n\" // #8291\n                                     \"class Foo {\\n\"\n                                     \"public:\\n\"\n                                     \"    int a_, b_;\\n\"\n                                     \"    Foo(int a, int b) : a_(a), b_(b) {}\\n\"\n                                     \"    Foo(int a, const std::string& b) : Foo(a, bar(b)) {}\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class Fred {\\n\" // #8111\n                                     \"    std::string a;\\n\"\n                                     \"    Fred() {\\n\"\n                                     \"        std::ostringstream ostr;\\n\"\n                                     \"        ostr << x;\\n\"\n                                     \"        a = ostr.str();\\n\"\n                                     \"    }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // bailout: multi line lambda in rhs => do not warn\n        checkInitializationListUsage(\"class Fred {\\n\"\n                                     \"    std::function f;\\n\"\n                                     \"    Fred() {\\n\"\n                                     \"        f = [](){\\n\"\n                                     \"            return 1;\\n\"\n                                     \"        };\\n\"\n                                     \"    }\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // don't warn if some other instance's members are assigned to\n        checkInitializationListUsage(\"class C {\\n\"\n                                     \"public:\\n\"\n                                     \"    C(C& c) : m_i(c.m_i) { c.m_i = (Foo)-1; }\\n\"\n                                     \"private:\\n\"\n                                     \"    Foo m_i;\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInitializationListUsage(\"class A {\\n\" // #9821 - delegate constructor\n                                     \"public:\\n\"\n                                     \"    A() : st{} {}\\n\"\n                                     \"\\n\"\n                                     \"    explicit A(const std::string &input): A() {\\n\"\n                                     \"        st = input;\\n\"\n                                     \"    }\\n\"\n                                     \"\\n\"\n                                     \"private:\\n\"\n                                     \"    std::string st;\\n\"\n                                     \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n#define checkSelfInitialization(...) checkSelfInitialization_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkSelfInitialization_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings0, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CheckClass checkClass(&tokenizer, &settings0, this);\n        (checkClass.checkSelfInitialization)();\n    }\n\n    void selfInitialization() {\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    int i;\\n\"\n                                \"    Fred() : i(i) {\\n\"\n                                \"    }\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Member variable 'i' is initialized by itself. [selfInitialization]\\n\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    int i;\\n\"\n                                \"    Fred() : i{i} {\\n\"\n                                \"    }\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Member variable 'i' is initialized by itself. [selfInitialization]\\n\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    int i;\\n\"\n                                \"    Fred();\\n\"\n                                \"};\\n\"\n                                \"Fred::Fred() : i(i) {\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:14]: (error) Member variable 'i' is initialized by itself. [selfInitialization]\\n\", errout_str());\n\n        checkSelfInitialization(\"class A {\\n\" // #10427\n                                \"public:\\n\"\n                                \"    explicit A(int x) : _x(static_cast<int>(_x)) {}\\n\"\n                                \"private:\\n\"\n                                \"    int _x;\\n\"\n                                \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Member variable '_x' is initialized by itself. [selfInitialization]\\n\", errout_str());\n\n        checkSelfInitialization(\"class A {\\n\"\n                                \"public:\\n\"\n                                \"    explicit A(int x) : _x((int)(_x)) {}\\n\"\n                                \"private:\\n\"\n                                \"    int _x;\\n\"\n                                \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Member variable '_x' is initialized by itself. [selfInitialization]\\n\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    std::string s;\\n\"\n                                \"    Fred() : s(s) {\\n\"\n                                \"    }\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Member variable 's' is initialized by itself. [selfInitialization]\\n\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    int x;\\n\"\n                                \"    Fred(int x);\\n\"\n                                \"};\\n\"\n                                \"Fred::Fred(int x) : x(x) { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    int x;\\n\"\n                                \"    Fred(int x);\\n\"\n                                \"};\\n\"\n                                \"Fred::Fred(int x) : x{x} { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    std::string s;\\n\"\n                                \"    Fred(const std::string& s) : s(s) {\\n\"\n                                \"    }\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkSelfInitialization(\"class Fred {\\n\"\n                                \"    std::string s;\\n\"\n                                \"    Fred(const std::string& s) : s{s} {\\n\"\n                                \"    }\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkSelfInitialization(\"struct Foo : Bar {\\n\"\n                                \"    int i;\\n\"\n                                \"    Foo(int i)\\n\"\n                                \"        : Bar(\\\"\\\"), i(i) {}\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkSelfInitialization(\"struct Foo : std::Bar {\\n\" // #6073\n                                \"    int i;\\n\"\n                                \"    Foo(int i)\\n\"\n                                \"        : std::Bar(\\\"\\\"), i(i) {}\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkSelfInitialization(\"struct Foo : std::Bar {\\n\" // #6073\n                                \"    int i;\\n\"\n                                \"    Foo(int i)\\n\"\n                                \"        : std::Bar(\\\"\\\"), i{i} {}\\n\"\n                                \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkVirtualFunctionCall(...) checkVirtualFunctionCall_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkVirtualFunctionCall_(const char* file, int line, const char (&code)[size]) {\n        // Check..\n        const Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::style).certainty(Certainty::inconclusive).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CheckClass checkClass(&tokenizer, &settings, this);\n        checkClass.checkVirtualFunctionCallInConstructor();\n    }\n\n    void virtualFunctionCallInConstructor() {\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual int f() { return 1; }\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{f();}\");\n        ASSERT_EQUALS(\"[test.cpp:7:2] -> [test.cpp:3:17]: (style) Virtual function 'f' is called from constructor 'A()' at line 7. Dynamic binding is not used. [virtualCallInConstructor]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A {\\n\"\n                                 \"    virtual int f();\\n\"\n                                 \"    A() {f();}\\n\"\n                                 \"};\\n\"\n                                 \"int A::f() { return 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:2:17]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used. [virtualCallInConstructor]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A : B {\\n\"\n                                 \"    int f() override;\\n\"\n                                 \"    A() {f();}\\n\"\n                                 \"};\\n\"\n                                 \"int A::f() { return 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:2:9]: (style) Virtual function 'f' is called from constructor 'A()' at line 3. Dynamic binding is not used. [virtualCallInConstructor]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class B {\\n\"\n                                 \"    virtual int f() = 0;\\n\"\n                                 \"};\\n\"\n                                 \"class A : B {\\n\"\n                                 \"    int f();\\n\" // <- not explicitly virtual\n                                 \"    A() {f();}\\n\"\n                                 \"};\\n\"\n                                 \"int A::f() { return 1; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    A() { A::f(); }\\n\"\n                                 \"    virtual void f() {}\\n\"\n                                 \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A : B {\\n\"\n                                 \"    int f() final { return 1; }\\n\"\n                                 \"    A() { f(); }\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class B {\\n\"\n                                 \"public:\"\n                                 \"    virtual void f() {}\\n\"\n                                 \"};\\n\"\n                                 \"class A : B {\\n\"\n                                 \"public:\"\n                                 \"    void f() override final {}\\n\"\n                                 \"    A() { f(); }\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class Base {\\n\"\n                                 \"public:\\n\"\n                                 \"    virtual void Copy(const Base& Src) = 0;\\n\"\n                                 \"};\\n\"\n                                 \"class Derived : public Base {\\n\"\n                                 \"public:\\n\"\n                                 \"    Derived() : i(0) {}\\n\"\n                                 \"    Derived(const Derived& Src);\\n\"\n                                 \"    void Copy(const Base& Src) override;\\n\"\n                                 \"    int i;\\n\"\n                                 \"};\\n\"\n                                 \"Derived::Derived(const Derived& Src) {\\n\"\n                                 \"    Copy(Src);\\n\"\n                                 \"}\\n\"\n                                 \"void Derived::Copy(const Base& Src) {\\n\"\n                                 \"    auto d = dynamic_cast<const Derived&>(Src);\\n\"\n                                 \"    i = d.i;\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:13:5] -> [test.cpp:9:10]: (style) Virtual function 'Copy' is called from copy constructor 'Derived(const Derived&Src)' at line 13. Dynamic binding is not used. [virtualCallInConstructor]\\n\",\n                      errout_str());\n\n        checkVirtualFunctionCall(\"struct B {\\n\"\n                                 \"    B() { auto pf = &f; }\\n\"\n                                 \"    virtual void f() {}\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"struct B {\\n\"\n                                 \"    B() { auto pf = &B::f; }\\n\"\n                                 \"    virtual void f() {}\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"struct B {\\n\"\n                                 \"    B() { (f)(); }\\n\"\n                                 \"    virtual void f() {}\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:3:18]: (style) Virtual function 'f' is called from constructor 'B()' at line 2. Dynamic binding is not used. [virtualCallInConstructor]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class S {\\n\" // don't crash\n                                 \"    ~S();\\n\"\n                                 \"public:\\n\"\n                                 \"    S();\\n\"\n                                 \"};\\n\"\n                                 \"S::S() {\\n\"\n                                 \"    typeid(S);\\n\"\n                                 \"}\\n\"\n                                 \"S::~S() = default;\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"struct Base: { virtual void wibble() = 0; virtual ~Base() {} };\\n\" // #11167\n                                 \"struct D final : public Base {\\n\"\n                                 \"    void wibble() override;\\n\"\n                                 \"    D() {}\\n\"\n                                 \"    virtual ~D() { wibble(); }\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pureVirtualFunctionCall() {\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{pure();}\");\n        ASSERT_EQUALS(\"[test.cpp:7:2] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in constructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual int pure()=0;\\n\"\n                                 \"    A();\\n\"\n                                 \"    int m;\\n\"\n                                 \"};\\n\"\n                                 \"A::A():m(A::pure())\\n\"\n                                 \"{}\");\n        ASSERT_EQUALS(\"[test.cpp:7:13] -> [test.cpp:3:17]: (warning) Call of pure virtual function 'pure' in constructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"namespace N {\\n\"\n                                 \"  class A\\n\"\n                                 \"  {\\n\"\n                                 \"      virtual int pure() = 0;\\n\"\n                                 \"      A();\\n\"\n                                 \"      int m;\\n\"\n                                 \"  };\\n\"\n                                 \"}\\n\"\n                                 \"N::A::A() : m(N::A::pure()) {}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:21] -> [test.cpp:4:19]: (warning) Call of pure virtual function 'pure' in constructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    virtual ~A();\\n\"\n                                 \"    int m;\\n\"\n                                 \"};\\n\"\n                                 \"A::~A()\\n\"\n                                 \"{pure();}\");\n        ASSERT_EQUALS(\"[test.cpp:8:2] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in destructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    void nonpure()\\n\"\n                                 \"    {pure();}\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{nonpure();}\");\n        ASSERT_EQUALS(\"[test.cpp:9:2] -> [test.cpp:5:6] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in constructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual int pure()=0;\\n\"\n                                 \"    int nonpure()\\n\"\n                                 \"    {return pure();}\\n\"\n                                 \"    A();\\n\"\n                                 \"    int m;\\n\"\n                                 \"};\\n\"\n                                 \"A::A():m(nonpure())\\n\"\n                                 \"{}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:9:2] -> [test.cpp:5:6] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in constructor. [pureVirtualCall]\\n\", \"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    void nonpure()\\n\"\n                                 \"    {pure();}\\n\"\n                                 \"    virtual ~A();\\n\"\n                                 \"    int m;\\n\"\n                                 \"};\\n\"\n                                 \"A::~A()\\n\"\n                                 \"{nonpure();}\");\n        ASSERT_EQUALS(\"[test.cpp:10:2] -> [test.cpp:5:6] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in destructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    A(bool b);\\n\"\n                                 \"};\\n\"\n                                 \"A::A(bool b)\\n\"\n                                 \"{if (b) pure();}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in constructor. [pureVirtualCall]\\n\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    virtual ~A();\\n\"\n                                 \"    int m;\\n\"\n                                 \"};\\n\"\n                                 \"A::~A()\\n\"\n                                 \"{if (b) pure();}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9] -> [test.cpp:3:18]: (warning) Call of pure virtual function 'pure' in destructor. [pureVirtualCall]\\n\", errout_str());\n\n        // #5831\n        checkVirtualFunctionCall(\"class abc {\\n\"\n                                 \"public:\\n\"\n                                 \"  virtual ~abc() throw() {}\\n\"\n                                 \"  virtual void def(void* g) throw () = 0;\\n\"\n                                 \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4992\n        checkVirtualFunctionCall(\"class CMyClass {\\n\"\n                                 \"    std::function< void(void) > m_callback;\\n\"\n                                 \"public:\\n\"\n                                 \"    CMyClass() {\\n\"\n                                 \"        m_callback = [this]() { return VirtualMethod(); };\\n\"\n                                 \"    }\\n\"\n                                 \"    virtual void VirtualMethod() = 0;\\n\"\n                                 \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10559\n        checkVirtualFunctionCall(\"struct S {\\n\"\n                                 \"    S(const int x) : m(std::bind(&S::f, this, x, 42)) {}\\n\"\n                                 \"    virtual int f(const int x, const int y) = 0;\\n\"\n                                 \"    std::function<int()> m;\\n\"\n                                 \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pureVirtualFunctionCallOtherClass() {\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    A(const A & a);\\n\"\n                                 \"};\\n\"\n                                 \"A::A(const A & a)\\n\"\n                                 \"{a.pure();}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"class B\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{B b; b.pure();}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pureVirtualFunctionCallWithBody() {\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \"{\\n\"\n                                 \"    virtual void pureWithBody()=0;\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{pureWithBody();}\\n\"\n                                 \"void A::pureWithBody()\\n\"\n                                 \"{}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pureWithBody()=0;\\n\"\n                                 \"    void nonpure()\\n\"\n                                 \"    {pureWithBody();}\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{nonpure();}\\n\"\n                                 \"void A::pureWithBody()\\n\"\n                                 \"{}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void pureVirtualFunctionCallPrevented() {\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    void nonpure(bool bCallPure)\\n\"\n                                 \"    { if (bCallPure) pure();}\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{nonpure(false);}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    void nonpure(bool bCallPure)\\n\"\n                                 \"    { if (!bCallPure) ; else pure();}\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{nonpure(false);}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkVirtualFunctionCall(\"class A\\n\"\n                                 \" {\\n\"\n                                 \"    virtual void pure()=0;\\n\"\n                                 \"    void nonpure(bool bCallPure)\\n\"\n                                 \"    {\\n\"\n                                 \"        switch (bCallPure) {\\n\"\n                                 \"        case true: pure(); break;\\n\"\n                                 \"        }\\n\"\n                                 \"    }\\n\"\n                                 \"    A();\\n\"\n                                 \"};\\n\"\n                                 \"A::A()\\n\"\n                                 \"{nonpure(false);}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n#define checkOverride(...) checkOverride_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkOverride_(const char* file, int line, const char (&code)[size]) {\n        const Settings settings = settingsBuilder().severity(Severity::style).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings, this);\n        (checkClass.checkOverride)();\n    }\n\n    void override1() {\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { virtual void f(); };\");\n        ASSERT_EQUALS(\"[test.cpp:1:27] -> [test.cpp:2:37]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { virtual void f() override; };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { virtual void f() final; };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"class Base {\\n\"\n                      \"public:\\n\"\n                      \"    virtual auto foo( ) const -> size_t { return 1; }\\n\"\n                      \"    virtual auto bar( ) const -> size_t { return 1; }\\n\"\n                      \"};\\n\"\n                      \"class Derived : public Base {\\n\"\n                      \"public :\\n\"\n                      \"    auto foo( ) const -> size_t { return 0; }\\n\"\n                      \"    auto bar( ) const -> size_t override { return 0; }\\n\"\n                      \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:18] -> [test.cpp:8:10]: (style) The function 'foo' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"namespace Test {\\n\"\n                      \"    class C {\\n\"\n                      \"    public:\\n\"\n                      \"        virtual ~C();\\n\"\n                      \"    };\\n\"\n                      \"}\\n\"\n                      \"class C : Test::C {\\n\"\n                      \"public:\\n\"\n                      \"    ~C();\\n\"\n                      \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:18] -> [test.cpp:9:6]: (style) The destructor '~C' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"struct Base {\\n\"\n                      \"    virtual void foo();\\n\"\n                      \"};\\n\"\n                      \"\\n\"\n                      \"struct Derived: public Base {\\n\"\n                      \"   void foo() override;\\n\"\n                      \"   void foo(int);\\n\"\n                      \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct B {\\n\" // #9092\n                      \"    virtual int f(int i) const = 0;\\n\"\n                      \"};\\n\"\n                      \"namespace N {\\n\"\n                      \"    struct D : B {\\n\"\n                      \"        virtual int f(int i) const;\\n\"\n                      \"    };\\n\"\n                      \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:17] -> [test.cpp:6:21]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(int);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(double);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(int);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(int);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:18] -> [test.cpp:5:8]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char, int);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char, int);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:18] -> [test.cpp:5:8]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char, int);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char, double);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char, int);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char c = '\\\\0', double);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char, int);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char c = '\\\\0', int);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:18] -> [test.cpp:5:8]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char c, std::vector<int>);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char c, std::vector<double>);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char c, std::vector<int>);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char c, std::set<int>);\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct A {\\n\"\n                      \"    virtual void f(char c, std::vector<int> v);\\n\"\n                      \"};\\n\"\n                      \"struct D : A {\\n\"\n                      \"  void f(char c, std::vector<int> w = {});\\n\"\n                      \"};\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2:18] -> [test.cpp:5:8]: (style) The function 'f' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", \"\", errout_str());\n\n        checkOverride(\"struct T {};\\n\" // #10920\n                      \"struct B {\\n\"\n                      \"    virtual T f() = 0;\\n\"\n                      \"};\\n\"\n                      \"struct D : B {\\n\"\n                      \"    friend T f();\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"struct S {};\\n\" // #11827\n                      \"struct SPtr {\\n\"\n                      \"    virtual S* operator->() const { return p; }\\n\"\n                      \"    S* p = nullptr;\\n\"\n                      \"};\\n\"\n                      \"struct T : public S {};\\n\"\n                      \"struct TPtr : public SPtr {\\n\"\n                      \"    T* operator->() const { return (T*)p; }\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:16] -> [test.cpp:8:8]: (style) The function 'operator->' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\",\n                      errout_str());\n\n        checkOverride(\"class Base {\\n\" // #12131\n                      \"    virtual int Calculate(int arg) = 0;\\n\"\n                      \"};\\n\"\n                      \"class Derived : public Base {\\n\"\n                      \"    int Calculate(int arg = 0) {\\n\"\n                      \"        return arg * 2;\\n\"\n                      \"    }\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:17] -> [test.cpp:5:9]: (style) The function 'Calculate' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\", errout_str());\n\n        checkOverride(\"struct S {\\n\" // #12439\n                      \"    virtual ~S() = default;\\n\"\n                      \"};\\n\"\n                      \"struct D : S {\\n\"\n                      \"    ~D() {}\\n\"\n                      \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:14] -> [test.cpp:5:6]: (style) The destructor '~D' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]\\n\",\n                      errout_str());\n    }\n\n    void overrideCVRefQualifiers() {\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { void f() const; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { void f() volatile; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { void f() &; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOverride(\"class Base { virtual void f(); };\\n\"\n                      \"class Derived : Base { void f() &&; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    #define checkUselessOverride(...) checkUselessOverride_(__FILE__, __LINE__, __VA_ARGS__)\n    void checkUselessOverride_(const char* file, int line, const char code[]) {\n        const Settings settings = settingsBuilder().severity(Severity::style).build();\n\n        SimpleTokenizer2 tokenizer(settings, *this, code, \"test.cpp\");\n\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings, this);\n        (checkClass.checkUselessOverride)();\n    }\n\n    void uselessOverride() {\n        checkUselessOverride(\"struct B { virtual int f() { return 5; } };\\n\" // #11757\n                             \"struct D : B {\\n\"\n                             \"    int f() override { return B::f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:1:24] -> [test.cpp:3:9]: (style) The function 'f' overrides a function in a base class but just delegates back to the base class. [uselessOverride]\\n\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual void f(); };\\n\"\n                             \"struct D : B {\\n\"\n                             \"    void f() override { B::f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:1:25] -> [test.cpp:3:10]: (style) The function 'f' overrides a function in a base class but just delegates back to the base class. [uselessOverride]\\n\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual int f() = 0; };\\n\"\n                             \"int B::f() { return 5; }\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f() override { return B::f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual int f(int i); };\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f(int i) override { return B::f(i); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:1:24] -> [test.cpp:3:9]: (style) The function 'f' overrides a function in a base class but just delegates back to the base class. [uselessOverride]\\n\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual int f(int i); };\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f(int i) override { return B::f(i + 1); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual int f(int i, int j); };\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f(int i, int j) override { return B::f(j, i); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual int f(); };\\n\"\n                             \"struct I { virtual int f() = 0; };\\n\"\n                             \"struct D : B, I {\\n\"\n                             \"    int f() override { return B::f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct S { virtual void f(); };\\n\"\n                             \"struct D : S {\\n\"\n                             \"    void f() final { S::f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct S {\\n\"\n                             \"protected:\\n\"\n                             \"    virtual void f();\\n\"\n                             \"};\\n\"\n                             \"struct D : S {\\n\"\n                             \"public:\\n\"\n                             \"    void f() override { S::f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual void f(int, int, int) const; };\\n\" // #11799\n                             \"struct D : B {\\n\"\n                             \"    int m = 42;\\n\"\n                             \"    void f(int a, int b, int c) const override;\\n\"\n                             \"};\\n\"\n                             \"void D::f(int a, int b, int c) const {\\n\"\n                             \"    B::f(a, b, m);\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B {\\n\" // #11803\n                             \"    virtual void f();\\n\"\n                             \"    virtual void f(int i);\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    void f() override { B::f(); }\\n\"\n                             \"    void f(int i) override;\\n\"\n                             \"    void g() { f(); }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B { virtual void f(); };\\n\" // #11808\n                             \"struct D : B { void f() override {} };\\n\"\n                             \"struct D2 : D {\\n\"\n                             \"    void f() override {\\n\"\n                             \"        B::f();\\n\"\n                             \"    }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B {\\n\"\n                             \"    virtual int f() { return 1; }\\n\"\n                             \"    virtual int g() { return 7; }\\n\"\n                             \"    virtual int h(int i, int j) { return i + j; }\\n\"\n                             \"    virtual int j(int i, int j) { return i + j; }\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f() override { return 2; }\\n\"\n                             \"    int g() override { return 7; }\\n\"\n                             \"    int h(int j, int i) override { return i + j; }\\n\"\n                             \"    int j(int i, int j) override { return i + j; }\\n\"\n                             \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:17] -> [test.cpp:9:9]: (style) The function 'g' overrides a function in a base class but is identical to the overridden function [uselessOverride]\\n\"\n                      \"[test.cpp:5:17] -> [test.cpp:11:9]: (style) The function 'j' overrides a function in a base class but is identical to the overridden function [uselessOverride]\\n\",\n                      errout_str());\n\n        checkUselessOverride(\"struct B : std::exception {\\n\"\n                             \"    virtual void f() { throw *this; }\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    void f() override { throw *this; }\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"#define MACRO virtual void f() {}\\n\"\n                             \"struct B {\\n\"\n                             \"    MACRO\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    MACRO\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B {\\n\"\n                             \"    B() = default;\\n\"\n                             \"    explicit B(int i) : m(i) {}\\n\"\n                             \"    int m{};\\n\"\n                             \"    virtual int f() const { return m; }\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    explicit D(int i) : m(i) {}\\n\"\n                             \"    int m{};\\n\"\n                             \"    int f() const override { return m; }\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B {\\n\"\n                             \"    int g() const;\\n\"\n                             \"    virtual int f() const { return g(); }\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int g() const;\\n\"\n                             \"    int f() const override { return g(); }\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"#define MACRO 1\\n\"\n                             \"struct B { virtual int f() { return 1; } };\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f() override { return MACRO; }\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B {\\n\" // #12706\n                             \"    virtual void f() { g(); }\\n\"\n                             \"    void g() { std::cout << \\\"Base\\\\n\\\"; }\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    void f() override { g(); }\\n\"\n                             \"    virtual void g() { std::cout << \\\"Derived\\\\n\\\"; }\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUselessOverride(\"struct B {\\n\" // #12946\n                             \"    virtual int f() { return i; }\\n\"\n                             \"    int i;\\n\"\n                             \"};\\n\"\n                             \"struct D : B {\\n\"\n                             \"    int f() override { return b.f(); }\\n\"\n                             \"    B b;\\n\"\n                             \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkUnsafeClassRefMember(...) checkUnsafeClassRefMember_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkUnsafeClassRefMember_(const char* file, int line, const char (&code)[size]) {\n        /*const*/ Settings settings = settingsBuilder().severity(Severity::warning).build();\n        settings.safeChecks.classes = true;\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings, this);\n        (checkClass.checkUnsafeClassRefMember)();\n    }\n\n    void unsafeClassRefMember() {\n        checkUnsafeClassRefMember(\"class C { C(const std::string &s) : s(s) {} const std::string &s; };\");\n        ASSERT_EQUALS(\"[test.cpp:1:37]: (warning) Unsafe class: The const reference member 'C::s' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. [unsafeClassRefMember]\\n\", errout_str());\n    }\n\n\n#define checkThisUseAfterFree(...) checkThisUseAfterFree_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkThisUseAfterFree_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings1, this);\n        (checkClass.checkThisUseAfterFree)();\n    }\n\n    void thisUseAfterFree() {\n        setMultiline();\n\n        // Calling method..\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void dostuff() { delete mInstance; hello(); }\\n\"\n                              \"private:\\n\"\n                              \"  static C *mInstance;\\n\"\n                              \"  void hello() {}\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:38]: warning: Calling method 'hello()' when 'this' might be invalid [thisUseAfterFree]\\n\"\n                      \"[test.cpp:5:13]: note: Assuming 'mInstance' is used as 'this'\\n\"\n                      \"[test.cpp:3:20]: note: Delete 'mInstance', invalidating 'this'\\n\"\n                      \"[test.cpp:3:38]: note: Call method when 'this' is invalid\\n\",\n                      errout_str());\n\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void dostuff() { mInstance.reset(); hello(); }\\n\"\n                              \"private:\\n\"\n                              \"  static std::shared_ptr<C> mInstance;\\n\"\n                              \"  void hello() {}\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:39]: warning: Calling method 'hello()' when 'this' might be invalid [thisUseAfterFree]\\n\"\n                      \"[test.cpp:5:29]: note: Assuming 'mInstance' is used as 'this'\\n\"\n                      \"[test.cpp:3:20]: note: Delete 'mInstance', invalidating 'this'\\n\"\n                      \"[test.cpp:3:39]: note: Call method when 'this' is invalid\\n\",\n                      errout_str());\n\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void dostuff() { reset(); hello(); }\\n\"\n                              \"private:\\n\"\n                              \"  static std::shared_ptr<C> mInstance;\\n\"\n                              \"  void hello();\\n\"\n                              \"  void reset() { mInstance.reset(); }\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:29]: warning: Calling method 'hello()' when 'this' might be invalid [thisUseAfterFree]\\n\"\n                      \"[test.cpp:5:29]: note: Assuming 'mInstance' is used as 'this'\\n\"\n                      \"[test.cpp:7:18]: note: Delete 'mInstance', invalidating 'this'\\n\"\n                      \"[test.cpp:3:29]: note: Call method when 'this' is invalid\\n\",\n                      errout_str());\n\n        // Use member..\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void dostuff() { delete self; x = 123; }\\n\"\n                              \"private:\\n\"\n                              \"  static C *self;\\n\"\n                              \"  int x;\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:33]: warning: Using member 'x' when 'this' might be invalid [thisUseAfterFree]\\n\"\n                      \"[test.cpp:5:13]: note: Assuming 'self' is used as 'this'\\n\"\n                      \"[test.cpp:3:20]: note: Delete 'self', invalidating 'this'\\n\"\n                      \"[test.cpp:3:33]: note: Call method when 'this' is invalid\\n\",\n                      errout_str());\n\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void dostuff() { delete self; x[1] = 123; }\\n\"\n                              \"private:\\n\"\n                              \"  static C *self;\\n\"\n                              \"  std::map<int,int> x;\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:33]: warning: Using member 'x' when 'this' might be invalid [thisUseAfterFree]\\n\"\n                      \"[test.cpp:5:13]: note: Assuming 'self' is used as 'this'\\n\"\n                      \"[test.cpp:3:20]: note: Delete 'self', invalidating 'this'\\n\"\n                      \"[test.cpp:3:33]: note: Call method when 'this' is invalid\\n\",\n                      errout_str());\n\n        // Assign 'shared_from_this()' to non-static smart pointer\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void hold() { mInstance = shared_from_this(); }\\n\"\n                              \"  void dostuff() { mInstance.reset(); hello(); }\\n\"\n                              \"private:\\n\"\n                              \"  std::shared_ptr<C> mInstance;\\n\"\n                              \"  void hello() {}\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:39]: warning: Calling method 'hello()' when 'this' might be invalid [thisUseAfterFree]\\n\"\n                      \"[test.cpp:6:22]: note: Assuming 'mInstance' is used as 'this'\\n\"\n                      \"[test.cpp:4:20]: note: Delete 'mInstance', invalidating 'this'\\n\"\n                      \"[test.cpp:4:39]: note: Call method when 'this' is invalid\\n\",\n                      errout_str());\n\n        // Avoid FP..\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void dostuff() { delete self; x = 123; }\\n\"\n                              \"private:\\n\"\n                              \"  C *self;\\n\"\n                              \"  int x;\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"  void hold() { mInstance = shared_from_this(); }\\n\"\n                              \"  void dostuff() { if (x) { mInstance.reset(); return; } hello(); }\\n\"\n                              \"private:\\n\"\n                              \"  std::shared_ptr<C> mInstance;\\n\"\n                              \"  void hello() {}\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkThisUseAfterFree(\"class C\\n\"\n                              \"{\\n\"\n                              \"public:\\n\"\n                              \"    explicit C(const QString& path) : mPath( path ) {}\\n\"\n                              \"\\n\"\n                              \"    static void initialize(const QString& path) {\\n\" // <- avoid fp in static method\n                              \"        if (instanceSingleton)\\n\"\n                              \"            delete instanceSingleton;\\n\"\n                              \"        instanceSingleton = new C(path);\\n\"\n                              \"    }\\n\"\n                              \"private:\\n\"\n                              \"    static C* instanceSingleton;\\n\"\n                              \"};\\n\"\n                              \"\\n\"\n                              \"C* C::instanceSingleton;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Avoid false positive when pointer is deleted in lambda\n        checkThisUseAfterFree(\"class C {\\n\"\n                              \"public:\\n\"\n                              \"    void foo();\\n\"\n                              \"    void set() { p = this; }\\n\"\n                              \"    void dostuff() {}\\n\"\n                              \"    C* p;\\n\"\n                              \"};\\n\"\n                              \"\\n\"\n                              \"void C::foo() {\\n\"\n                              \"    auto done = [this] () { delete p; };\\n\"\n                              \"    dostuff();\\n\"\n                              \"    done();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkThisUseAfterFree(\"class C {\\n\" // #13311\n                              \"public:\\n\"\n                              \"    static void init();\\n\"\n                              \"private:\\n\"\n                              \"    C();\\n\"\n                              \"    static C* self;\\n\"\n                              \"    bool use;\\n\"\n                              \"};\\n\"\n                              \"C::C() { use = true; }\\n\"\n                              \"void C::init() {\\n\"\n                              \"    if (self)\\n\"\n                              \"        delete self;\\n\"\n                              \"    self = new C();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void ctu(const std::vector<std::string> &code) {\n        Check &check = getCheck<CheckClass>();\n\n        // getFileInfo\n        std::list<Check::FileInfo*> fileInfo;\n        for (const std::string& c: code) {\n            const std::string filename = std::to_string(fileInfo.size()) + \".cpp\";\n            SimpleTokenizer tokenizer{settingsDefault, *this, filename};\n            ASSERT(tokenizer.tokenize(c));\n            fileInfo.push_back(check.getFileInfo(tokenizer, settingsDefault, \"\"));\n        }\n\n        // Check code..\n        const CTU::FileInfo ctu;\n        check.analyseWholeProgram(ctu, fileInfo, settingsDefault, *this); // TODO: check result\n\n        while (!fileInfo.empty()) {\n            delete fileInfo.back();\n            fileInfo.pop_back();\n        }\n    }\n\n    void ctuOneDefinitionRule() {\n        ctu({\"class C { C() { std::cout << 0; } };\", \"class C { C() { std::cout << 1; } };\"});\n        ASSERT_EQUALS(\"[1.cpp:1:1] -> [0.cpp:1:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C' [ctuOneDefinitionRuleViolation]\\n\", errout_str());\n\n        ctu({\"class C { C(); }; C::C() { std::cout << 0; }\", \"class C { C(); }; C::C() { std::cout << 1; }\"});\n        ASSERT_EQUALS(\"[1.cpp:1:1] -> [0.cpp:1:1]: (error) The one definition rule is violated, different classes/structs have the same name 'C' [ctuOneDefinitionRuleViolation]\\n\", errout_str());\n\n        ctu({\"class C { C() {} };\\n\", \"class C { C() {} };\\n\"});\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu({\"class C { C(); }; C::C(){}\", \"class C { C(); }; C::C(){}\"});\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu({\"class A::C { C() { std::cout << 0; } };\", \"class B::C { C() { std::cout << 1; } };\"});\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // 11435 - template specialisations\n        const std::string header = \"template<typename T1, typename T2> struct Test {};\\n\";\n        ctu({header + \"template<typename T1> struct Test<T1, int> {};\\n\",\n             header + \"template<typename T1> struct Test<T1, double> {};\\n\"});\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n#define getFileInfo(...) getFileInfo_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void getFileInfo_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        const Check& c = getCheck<CheckClass>();\n        Check::FileInfo * fileInfo = (c.getFileInfo)(tokenizer, settings1, \"\");\n\n        delete fileInfo;\n    }\n\n    void testGetFileInfo() {\n        getFileInfo(\"void foo() { union { struct { }; }; }\"); // don't crash\n        getFileInfo(\"struct sometype { sometype(); }; sometype::sometype() = delete;\"); // don't crash\n    }\n\n#define checkReturnByReference(...) checkReturnByReference_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkReturnByReference_(const char* file, int line, const char (&code)[size]) {\n        const Settings settings = settingsBuilder().severity(Severity::performance).library(\"std.cfg\").build();\n\n        SimpleTokenizer2 tokenizer(settings, *this, code, \"test.cpp\");\n\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check..\n        CheckClass checkClass(&tokenizer, &settings, this);\n        (checkClass.checkReturnByReference)();\n    }\n\n    void returnByReference() {\n        checkReturnByReference(\"struct T { int a[10]; };\\n\" // #12546\n                               \"struct S {\\n\"\n                               \"    T t;\\n\"\n                               \"    int i;\\n\"\n                               \"    std::string s;\\n\"\n                               \"    T getT() const { return t; }\\n\"\n                               \"    int getI() const { return i; }\\n\"\n                               \"    std::string getS() const { return s; }\\n\"\n                               \"    unknown_t f() { return; }\\n\"\n                               \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:7]: (performance) Function 'getT()' should return member 't' by const reference. [returnByReference]\\n\"\n                      \"[test.cpp:8:17]: (performance) Function 'getS()' should return member 's' by const reference. [returnByReference]\\n\",\n                      errout_str());\n\n        checkReturnByReference(\"struct B {\\n\" // #12608\n                               \"    virtual std::string f() { return \\\"abc\\\"; }\\n\"\n                               \"};\\n\"\n                               \"struct D : B {\\n\"\n                               \"    std::string f() override { return s; }\\n\"\n                               \"    std::string s;\\n\"\n                               \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkReturnByReference(\"struct S {\\n\"\n                               \"    std::string f(std::string s) { return s; }\\n\"\n                               \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkReturnByReference(\"struct S { S(); };\\n\" // #12620\n                               \"S::S() = delete;\\n\");\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n\n        checkReturnByReference(\"struct S {\\n\" // #12626\n                               \"    std::string s;\\n\"\n                               \"    operator std::string_view() const { return s; }\\n\"\n                               \"    std::string_view get() const { return s; }\\n\"\n                               \"};\\n\"\n                               \"template<typename T>\\n\"\n                               \"struct U {\\n\"\n                               \"    T t;\\n\"\n                               \"    operator const T& () const { return t; }\\n\"\n                               \"};\\n\"\n                               \"U<std::string> u;\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkReturnByReference(\"struct S {\\n\" // #13011\n                               \"    std::string s;\\n\"\n                               \"    const std::string& foo() const & { return s; }\\n\"\n                               \"    std::string foo() && { return s; }\\n\" // <- used for temporary objects\n                               \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkReturnByReference(\"struct S1 {\\n\" // #13056\n                               \"    std::string str;\\n\"\n                               \"    struct T { std::string strT; } mT;\\n\"\n                               \"};\\n\"\n                               \"struct S2 {\\n\"\n                               \"    std::string get1() const {\\n\"\n                               \"        return mS1->str;\\n\"\n                               \"    }\\n\"\n                               \"    std::string get2() const {\\n\"\n                               \"        return mS1->mT.strT;\\n\"\n                               \"    }\\n\"\n                               \"    S1* mS1;\\n\"\n                               \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:17]: (performance) Function 'get1()' should return member 'str' by const reference. [returnByReference]\\n\"\n                      \"[test.cpp:9:17]: (performance) Function 'get2()' should return member 'strT' by const reference. [returnByReference]\\n\",\n                      errout_str());\n\n        checkReturnByReference(\"struct S { std::string str; };\\n\" // #13059\n                               \"struct T {\\n\"\n                               \"    S temp() const;\\n\"\n                               \"    S s[1];\\n\"\n                               \"};\\n\"\n                               \"struct U {\\n\"\n                               \"    std::string get1() const {\\n\"\n                               \"        return t.temp().str;\\n\"\n                               \"    }\\n\"\n                               \"    std::string get2() const {\\n\"\n                               \"        return t.s[0].str;\\n\"\n                               \"    }\\n\"\n                               \"    T t;\\n\"\n                               \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:10:17]: (performance) Function 'get2()' should return member 'str' by const reference. [returnByReference]\\n\",\n                      errout_str());\n\n        checkReturnByReference(\"struct S {\\n\" // #13845\n                               \"    std::string m;\\n\"\n                               \"    std::string get() { return m; }\\n\"\n                               \"};\\n\"\n                               \"std::string f(std::optional<S> o) {\\n\"\n                               \"    return o.transform(&S::get).value_or(\\\"\\\");\\n\"\n                               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestClass)\n"
    }
  ]
}