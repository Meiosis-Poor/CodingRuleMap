{
  "name": "check",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 34,
  "branches": 11,
  "apis": 27,
  "test": [
    {
      "description": null,
      "expected-problems": 4,
      "expected-linenumbers": [
        153,
        173,
        547,
        624
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkunusedfunctions.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"platform.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestUnusedFunctions : public TestFixture {\npublic:\n    TestUnusedFunctions() : TestFixture(\"TestUnusedFunctions\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().severity(Severity::style).build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(incondition);\n        TEST_CASE(return1);\n        TEST_CASE(return2);\n        TEST_CASE(return3);\n        TEST_CASE(callback1);\n        TEST_CASE(callback2);\n        TEST_CASE(else1);\n        TEST_CASE(functionpointer);\n        TEST_CASE(template1);\n        TEST_CASE(template2);\n        TEST_CASE(template3);\n        TEST_CASE(template4); // #9805\n        TEST_CASE(template5);\n        TEST_CASE(template6); // #10475 crash\n        TEST_CASE(template7); // #9766 crash\n        TEST_CASE(template8);\n        TEST_CASE(template9);\n        TEST_CASE(template10);\n        TEST_CASE(throwIsNotAFunction);\n        TEST_CASE(unusedError);\n        TEST_CASE(unusedMain);\n        TEST_CASE(initializationIsNotAFunction);\n        TEST_CASE(operator1);   // #3195\n        TEST_CASE(operator2);   // #7974\n        TEST_CASE(returnRef);\n        TEST_CASE(attribute); // #3471 - FP __attribute__(constructor)\n        TEST_CASE(initializer_list);\n        TEST_CASE(member_function_ternary);\n        TEST_CASE(boost);\n        TEST_CASE(enumValues);\n        TEST_CASE(recursive);\n\n        TEST_CASE(multipleFiles);   // same function name in multiple files\n\n        TEST_CASE(lineNumber); // Ticket 3059\n\n        TEST_CASE(ignore_declaration); // ignore declaration\n\n        TEST_CASE(operatorOverload);\n\n        TEST_CASE(entrypointsWin);\n        TEST_CASE(entrypointsWinU);\n        TEST_CASE(entrypointsUnix);\n\n        TEST_CASE(includes);\n        TEST_CASE(virtualFunc);\n        TEST_CASE(parensInit);\n        TEST_CASE(typeInCast);\n        TEST_CASE(attributeCleanup);\n        TEST_CASE(attributeUnused);\n        TEST_CASE(attributeMaybeUnused);\n        TEST_CASE(staticFunction);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        Platform::Type platform = Platform::Type::Native;\n        const Settings* s = nullptr;\n        bool cpp = true;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.s ? *options.s : settings).platform(options.platform).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this, options.cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for unused functions..\n        CheckUnusedFunctions checkUnusedFunctions;\n        checkUnusedFunctions.parseTokens(tokenizer, settings1);\n        (checkUnusedFunctions.check)(settings1, *this); // TODO: check result\n    }\n\n    // TODO: get rid of this\n    void check_(const char* file, int line, const std::string& code ) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for unused functions..\n        CheckUnusedFunctions checkUnusedFunctions;\n        checkUnusedFunctions.parseTokens(tokenizer, settings);\n        (checkUnusedFunctions.check)(settings, *this); // TODO: check result\n    }\n\n    void incondition() {\n        check(\"int f1()\\n\"\n              \"{\\n\"\n              \"    if (f1())\\n\"\n              \"    { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function 'f1' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void return1() {\n        check(\"int f1()\\n\"\n              \"{\\n\"\n              \"    return f1();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function 'f1' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void return2() {\n        check(\"char * foo()\\n\"\n              \"{\\n\"\n              \"    return foo();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:8]: (style) The function 'foo' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void return3() {\n        check(\"typedef void (*VoidFunc)();\\n\" // #9602\n              \"void sayHello() {\\n\"\n              \"  printf(\\\"Hello World\\\\n\\\");\\n\"\n              \"}\\n\"\n              \"VoidFunc getEventHandler() {\\n\"\n              \"  return sayHello;\\n\"\n              \"}\\n\"\n              \"void indirectHello() {\\n\"\n              \"  VoidFunc handler = getEventHandler();\\n\"\n              \"  handler();\\n\"\n              \"}\\n\"\n              \"int main() {\\n\"\n              \"  indirectHello();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void callback1() {\n        check(\"void f1()\\n\"\n              \"{\\n\"\n              \"    void (*f)() = cond ? f1 : NULL;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'f1' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void callback2() { // #8677\n        check(\"class C {\\n\"\n              \"public:\\n\"\n              \"    void callback();\\n\"\n              \"    void start();\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void C::callback() {}\\n\" // <- not unused\n              \"\\n\"\n              \"void C::start() { ev.set<C, &C::callback>(this); }\");\n        ASSERT_EQUALS(\"[test.cpp:9:9]: (style) The function 'start' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void else1() {\n        check(\"void f1()\\n\"\n              \"{\\n\"\n              \"    if (cond) ;\\n\"\n              \"    else f1();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'f1' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void functionpointer() {\n        check(\"void foo() { }\\n\"\n              \"int main() {\\n\"\n              \"    f(&foo);\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() { }\\n\"\n              \"int main() {\\n\"\n              \"    f(&::foo);\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace abc {\\n\"\n              \"    void foo() { }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    f(&abc::foo);\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace abc {\\n\"\n              \"    void foo() { }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    f = &abc::foo;\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace abc {\\n\"\n              \"    void foo() { }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    f = &::abc::foo;\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace abc {\\n\"  // #3875\n              \"    void foo() { }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    f(abc::foo);\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <class T> T f()\\n\" // #13117\n              \"{\\n\"\n              \"    return T(1);\\n\"\n              \"}\\n\"\n              \"int main(void)\\n\"\n              \"{\\n\"\n              \"    auto *ptr = &f<int>;\\n\"\n              \"    return ptr();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void template1() {\n        check(\"template<class T> void foo() { }\\n\"\n              \"\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    foo<int>();\\n\"\n              \"    return 0\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void template2() {\n        check(\"void f() { }\\n\"\n              \"\\n\"\n              \"template<class T> void g()\\n\"\n              \"{\\n\"\n              \"    f();\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void h() { g<int>(); h(); }\");\n        ASSERT_EQUALS(\"[test.cpp:8:6]: (style) The function 'h' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void template3() { // #4701\n        check(\"class X {\\n\"\n              \"public:\\n\"\n              \"    void bar() { foo<int>(0); }\\n\"\n              \"private:\\n\"\n              \"    template<typename T> void foo( T t ) const;\\n\"\n              \"};\\n\"\n              \"template<typename T> void X::foo( T t ) const { }\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style) The function 'bar' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void template4() { // #9805\n        check(\"struct A {\\n\"\n              \"    int a = 0;\\n\"\n              \"    void f() { a = 1; }\\n\"\n              \"    template <typename T, typename... Args> auto call(const Args &... args) -> T {\\n\"\n              \"        a = 2;\\n\"\n              \"        return T{};\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"struct B : public A {\\n\"\n              \"    void test() {\\n\"\n              \"        f();\\n\"\n              \"        call<int>(1, 2, 3);\\n\"\n              \"        test();\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:11:10]: (style) The function 'test' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void template5() { // #9220\n        check(\"void f(){}\\n\"\n              \"\\n\"\n              \"typedef void(*Filter)();\\n\"\n              \"\\n\"\n              \"template <Filter fun>\\n\"\n              \"void g() { fun(); }\\n\"\n              \"\\n\"\n              \"int main() { g<f>(); return 0;}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void template6() { // #10475\n        check(\"template<template<typename...> class Ref, typename... Args>\\n\"\n              \"struct Foo<Ref<Args...>, Ref> : std::true_type {};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void template7()\n    { // #9766\n        check(\"void f() {\\n\"\n              \"    std::array<std::array<double,3>,3> array;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'f' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void template8() { // #11485\n        check(\"struct S {\\n\"\n              \"    template<typename T>\\n\"\n              \"    void tf(const T&) { }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style) The function 'tf' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"struct C {\\n\"\n              \"    template<typename T>\\n\"\n              \"    void tf(const T&) { }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    C c;\\n\"\n              \"    c.tf(1.5);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct C {\\n\"\n              \"    template<typename T>\\n\"\n              \"    void tf(const T&) { }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    C c;\\n\"\n              \"    c.tf<int>(1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void template9() {\n        check(\"template<class T>\\n\" // #7739\n              \"void f(T const& t) {}\\n\"\n              \"template<class T>\\n\"\n              \"void g(T const& t) {\\n\"\n              \"    f(t);\\n\"\n              \"}\\n\"\n              \"template<>\\n\"\n              \"void f<double>(double const& d) {}\\n\"\n              \"int main() {\\n\"\n              \"    g(2);\\n\"\n              \"    g(3.14);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <typename T> T f(T);\\n\" // #9222\n              \"template <typename T> T f(T i) { return i; }\\n\"\n              \"template int f<int>(int);\\n\"\n              \"int main() { return f(int(2)); }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void template10() {\n        check(\"template<typename T>\\n\" // #12013, don't crash\n              \"struct S {\\n\"\n              \"    static const int digits = std::numeric_limits<T>::digits;\\n\"\n              \"    using type = std::conditional<digits < 32, std::int32_t, std::int64_t>::type;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void throwIsNotAFunction() {\n        check(\"struct A {void f() const throw () {}}; int main() {A a; a.f();}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void unusedError() {\n        check(\"void foo() {}\\n\"\n              \"int main()\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'foo' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"void foo() const {}\\n\"\n              \"int main()\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'foo' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"void foo() const throw() {}\\n\"\n              \"int main()\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'foo' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"void foo() throw() {}\\n\"\n              \"int main()\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'foo' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void unusedMain() {\n        check(\"int main() { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void initializationIsNotAFunction() {\n        check(\"struct B: N::A {\\n\"\n              \"  B(): N::A() {};\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operator1() {\n        check(\"struct Foo { void operator()(int a) {} };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo { operator std::string(int a) {} };\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operator2() { // #7974\n        check(\"bool operator==(const data_t& a, const data_t& b) {\\n\"\n              \"    return (a.fd == b.fd);\\n\"\n              \"}\\n\"\n              \"bool operator==(const event& a, const event& b) {\\n\"\n              \"    return ((a.events == b.events) && (a.data == b.data));\\n\"\n              \"}\\n\"\n              \"int main(event a, event b) {\\n\"\n              \"    return a == b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void returnRef() {\n        check(\"int& foo() {return x;}\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'foo' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void attribute() { // #3471 - FP __attribute__((constructor))\n        check(\"void __attribute__((constructor)) f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void __attribute__((constructor(1000))) f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void __attribute__((destructor)) f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void __attribute__((destructor(1000))) f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // alternate syntax\n        check(\"__attribute__((constructor)) void f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"__attribute__((constructor(1000))) void f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"__attribute__((destructor)) void f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"__attribute__((destructor(1000))) void f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // alternate syntax\n        check(\"void f() __attribute__((constructor));\\n\"\n              \"void f() { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() __attribute__((constructor(1000)));\\n\"\n              \"void f() { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() __attribute__((destructor));\\n\"\n              \"void f() { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() __attribute__((destructor(1000)));\\n\"\n              \"void f() { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Don't crash on wrong syntax\n        check(\"int x __attribute__((constructor));\\n\"\n              \"int y __attribute__((destructor));\");\n\n        // #10661\n        check(\"extern \\\"C\\\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataSize) { return 0; }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"[[maybe_unused]] void f() {}\\n\" // #13268\n              \"__attribute__((unused)) void g() {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void initializer_list() {\n        check(\"int foo() { return 0; }\\n\"\n              \"struct A {\\n\"\n              \"    A() : m_i(foo())\\n\"\n              \"    {}\\n\"\n              \"int m_i;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8580\n        check(\"int foo() { return 12345; }\\n\"\n              \"int bar(std::function<int()> func) { return func(); }\\n\"\n              \"\\n\"\n              \"class A {\\n\"\n              \"public:\\n\"\n              \"  A() : a(bar([] { return foo(); })) {}\\n\"\n              \"  const int a;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void member_function_ternary() {\n        check(\"struct Foo {\\n\"\n              \"    void F1() {}\\n\"\n              \"    void F2() {}\\n\"\n              \"};\\n\"\n              \"int main(int argc, char *argv[]) {\\n\"\n              \"    Foo foo;\\n\"\n              \"    void (Foo::*ptr)();\\n\"\n              \"    ptr = (argc > 1 && !strcmp(argv[1], \\\"F2\\\")) ? &Foo::F2 : &Foo::F1;\\n\"\n              \"    (foo.*ptr)();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void boost() {\n        check(\"static void _xy(const char *b, const char *e) {}\\n\"\n              \"void f() {\\n\"\n              \"    parse(line, blanks_p >> ident[&_xy] >> blanks_p >> eol_p).full;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (style) The function 'f' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void enumValues() { // #11486\n        check(\"enum E1 { Break1 };\\n\"\n              \"struct S {\\n\"\n              \"    enum class E { Break };\\n\"\n              \"    void Break() {}\\n\"\n              \"    void Break1() {}\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style) The function 'Break' is never used. [unusedFunction]\\n\"\n                      \"[test.cpp:5:10]: (style) The function 'Break1' is never used. [unusedFunction]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\" // #12899\n              \"    void f() {}\\n\"\n              \"};\\n\"\n              \"enum E { f };\\n\"\n              \"int main() {\\n\"\n              \"    E e{ f };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) The function 'f' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void recursive() {\n        check(\"void f() {\\n\" // #8159\n              \"    f();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (style) The function 'f' is never used. [unusedFunction]\\n\",\n                      errout_str());\n    }\n\n    void multipleFiles() {\n        CheckUnusedFunctions c;\n\n        const char code[] = \"static void f() { }\";\n\n        for (int i = 1; i <= 2; ++i) {\n            const std::string fname = \"test\" + std::to_string(i) + \".cpp\";\n\n            SimpleTokenizer tokenizer{settings, *this, fname};\n            ASSERT(tokenizer.tokenize(code));\n\n            c.parseTokens(tokenizer, settings);\n        }\n\n        // Check for unused functions..\n        (c.check)(settings, *this); // TODO: check result\n\n        ASSERT_EQUALS(\"[test1.cpp:1:13]: (style) The function 'f' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void lineNumber() {\n        check(\"void foo();\\n\"\n              \"void bar() {}\\n\"\n              \"int main() {}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (style) The function 'bar' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void ignore_declaration() {\n        check(\"void f();\\n\"\n              \"void f() {}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (style) The function 'f' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"void f(void) {}\\n\"\n              \"void (*list[])(void) = {f};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void operatorOverload() {\n        check(\"class A {\\n\"\n              \"private:\\n\"\n              \"    friend std::ostream & operator<<(std::ostream &, const A&);\\n\"\n              \"};\\n\"\n              \"std::ostream & operator<<(std::ostream &os, const A&) {\\n\"\n              \"    os << \\\"This is class A\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A{};\\n\"\n              \"A operator + (const A &, const A &){ return A(); }\\n\"\n              \"A operator - (const A &, const A &){ return A(); }\\n\"\n              \"A operator * (const A &, const A &){ return A(); }\\n\"\n              \"A operator / (const A &, const A &){ return A(); }\\n\"\n              \"A operator % (const A &, const A &){ return A(); }\\n\"\n              \"A operator & (const A &, const A &){ return A(); }\\n\"\n              \"A operator | (const A &, const A &){ return A(); }\\n\"\n              \"A operator ~ (const A &){ return A(); }\\n\"\n              \"A operator ! (const A &){ return A(); }\\n\"\n              \"bool operator < (const A &, const A &){ return true; }\\n\"\n              \"bool operator > (const A &, const A &){ return true; }\\n\"\n              \"A operator += (const A &, const A &){ return A(); }\\n\"\n              \"A operator -= (const A &, const A &){ return A(); }\\n\"\n              \"A operator *= (const A &, const A &){ return A(); }\\n\"\n              \"A operator /= (const A &, const A &){ return A(); }\\n\"\n              \"A operator %= (const A &, const A &){ return A(); }\\n\"\n              \"A operator &= (const A &, const A &){ return A(); }\\n\"\n              \"A operator ^= (const A &, const A &){ return A(); }\\n\"\n              \"A operator |= (const A &, const A &){ return A(); }\\n\"\n              \"A operator << (const A &, const int){ return A(); }\\n\"\n              \"A operator >> (const A &, const int){ return A(); }\\n\"\n              \"A operator <<= (const A &, const int){ return A(); }\\n\"\n              \"A operator >>= (const A &, const int){ return A(); }\\n\"\n              \"bool operator == (const A &, const A &){ return true; }\\n\"\n              \"bool operator != (const A &, const A &){ return true; }\\n\"\n              \"bool operator <= (const A &, const A &){ return true; }\\n\"\n              \"bool operator >= (const A &, const A &){ return true; }\\n\"\n              \"A operator && (const A &, const int){ return A(); }\\n\"\n              \"A operator || (const A &, const int){ return A(); }\\n\"\n              \"A operator ++ (const A &, const int){ return A(); }\\n\"\n              \"A operator ++ (const A &){ return A(); }\\n\"\n              \"A operator -- (const A &, const int){ return A(); }\\n\"\n              \"A operator -- (const A &){ return A(); }\\n\"\n              \"A operator , (const A &, const A &){ return A(); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"class A {\\n\"\n              \"public:\\n\"\n              \"    static void * operator new(std::size_t);\\n\"\n              \"    static void * operator new[](std::size_t);\\n\"\n              \"};\\n\"\n              \"void * A::operator new(std::size_t s) {\\n\"\n              \"    return malloc(s);\\n\"\n              \"}\\n\"\n              \"void * A::operator new[](std::size_t s) {\\n\"\n              \"    return malloc(s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void entrypointsWin() {\n        check(\"int WinMain() { }\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function 'WinMain' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"int _tmain() { }\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function '_tmain' is never used. [unusedFunction]\\n\", errout_str());\n\n        const Settings s = settingsBuilder(settings).library(\"windows.cfg\").build();\n\n        check(\"int WinMain() { }\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int _tmain() { }\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void entrypointsWinU() {\n        check(\"int wWinMain() { }\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function 'wWinMain' is never used. [unusedFunction]\\n\", errout_str());\n\n        check(\"int _tmain() { }\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function '_tmain' is never used. [unusedFunction]\\n\", errout_str());\n\n        const Settings s = settingsBuilder(settings).library(\"windows.cfg\").build();\n\n        check(\"int wWinMain() { }\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int _tmain() { }\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void entrypointsUnix() {\n        check(\"int _init() { }\\n\"\n              \"int _fini() { }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (style) The function '_init' is never used. [unusedFunction]\\n\"\n                      \"[test.cpp:2:5]: (style) The function '_fini' is never used. [unusedFunction]\\n\", errout_str());\n\n        const Settings s = settingsBuilder(settings).library(\"gnu.cfg\").build();\n\n        check(\"int _init() { }\\n\"\n              \"int _fini() { }\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // TODO: fails because the location information is not be preserved by PreprocessorHelper::getcode()\n    void includes()\n    {\n        // #11483\n        const char inc[] = \"class A {\\n\"\n                           \"public:\\n\"\n                           \"    void f() {}\\n\"\n                           \"};\";\n        const char code[] = R\"(#include \"test.h\")\";\n        ScopedFile header(\"test.h\", inc);\n        const std::string processed = PreprocessorHelper::getcode(settings, *this, code, \"\", \"test.cpp\");\n        check(processed);\n        TODO_ASSERT_EQUALS(\"[test.h:3:6]: (style) The function 'f' is never used. [unusedFunction]\\n\", \"[test.cpp:3:6]: (style) The function 'f' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void virtualFunc()\n    {\n        check(\"struct D : public B {\\n\" // #10660\n              \"    virtual void f() {}\\n\"\n              \"    void g() override {}\\n\"\n              \"    void h() final {}\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct B {\\n\"\n              \"    virtual void f() = 0;\\n\"\n              \"    void g();\\n\"\n              \"};\\n\"\n              \"struct D : B {\\n\"\n              \"    void f() override {}\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    D d;\\n\"\n              \"    d.g();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void parensInit()\n    {\n        check(\"struct S {\\n\" // #12898\n              \"    void url() {}\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    const int url(0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) The function 'url' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void typeInCast()\n    {\n        check(\"struct S {\\n\" // #12901\n              \"    void Type() {}\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    struct Type {} t;\\n\"\n              \"    Type t2{ (Type)t };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) The function 'Type' is never used. [unusedFunction]\\n\", errout_str());\n    }\n\n    void attributeCleanup()\n    {\n        check(\"void clean(void *ptr) {}\\n\"\n              \"int main() {\\n\"\n              \"    void * __attribute__((cleanup(clean))) p;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void attributeUnused()\n    {\n        check(\"[[unused]] void f() {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"[[gnu::unused]] void f() {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"__attribute__((unused)) void f() {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void attributeMaybeUnused()\n    {\n        check(\"[[__maybe_unused__]] void f() {}\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"[[maybe_unused]] void f() {}\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"[[maybe_unused]] void f() {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void staticFunction()\n    {\n        check(\"void f(void) {}\\n\"\n              \"int main() {\\n\"\n              \"    f();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void) {}\\n\"\n              \"int main() {\\n\"\n              \"    f();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:1:6]: (style) The function 'f' should have static linkage since it is not used outside of its translation unit. [staticFunction]\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestUnusedFunctions)\n"
    }
  ]
}