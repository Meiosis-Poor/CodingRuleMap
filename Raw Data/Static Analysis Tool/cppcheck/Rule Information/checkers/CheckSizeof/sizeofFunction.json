{
  "name": "sizeofFunction",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 28,
  "branches": 10,
  "apis": 32,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        150
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checksizeof.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestSizeof : public TestFixture {\npublic:\n    TestSizeof() : TestFixture(\"TestSizeof\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::portability).certainty(Certainty::inconclusive).library(\"std.cfg\").build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(sizeofsizeof);\n        TEST_CASE(sizeofCalculation);\n        TEST_CASE(sizeofFunction);\n        TEST_CASE(checkPointerSizeof);\n        TEST_CASE(checkPointerSizeofStruct);\n        TEST_CASE(sizeofDivisionMemset);\n        TEST_CASE(sizeofForArrayParameter);\n        TEST_CASE(sizeofForNumericParameter);\n        TEST_CASE(suspiciousSizeofCalculation);\n        TEST_CASE(sizeofVoid);\n        TEST_CASE(customStrncat);\n    }\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check...\n        runChecks<CheckSizeof>(tokenizer, this);\n    }\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkP_(const char* file, int line, const char (&code)[size]) {\n        SimpleTokenizer2 tokenizer(settings, *this, code, \"test.cpp\");\n\n        // Tokenize..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check...\n        runChecks<CheckSizeof>(tokenizer, this);\n    }\n\n    void sizeofsizeof() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int i = sizeof sizeof char;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (warning) Calling 'sizeof' on 'sizeof'. [sizeofsizeof]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int i = sizeof (sizeof long);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (warning) Calling 'sizeof' on 'sizeof'. [sizeofsizeof]\\n\", errout_str());\n\n        check(\"void foo(long *p)\\n\"\n              \"{\\n\"\n              \"    int i = sizeof (sizeof (p));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (warning) Calling 'sizeof' on 'sizeof'. [sizeofsizeof]\\n\", errout_str());\n    }\n\n    void sizeofCalculation() {\n        check(\"int a, b; int a,sizeof(a+b)\");\n        ASSERT_EQUALS(\"[test.cpp:1:25]: (warning) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n\n        check(\"int a, b; sizeof(a*b)\");\n        ASSERT_EQUALS(\"[test.cpp:1:19]: (warning) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n\n        check(\"int a, b; sizeof(-a)\");\n        ASSERT_EQUALS(\"[test.cpp:1:18]: (warning) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n\n        check(\"int a, b; sizeof(*a)\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"sizeof(void * const)\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"sizeof(int*[2])\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"sizeof(Fred**)\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"sizeof(foo++)\");\n        ASSERT_EQUALS(\"[test.cpp:1:11]: (warning) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n\n        check(\"sizeof(--foo)\");\n        ASSERT_EQUALS(\"[test.cpp:1:8]: (warning) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n\n        // #6888\n        checkP(\"#define SIZEOF1   sizeof(i != 2)\\n\"\n               \"#define SIZEOF2   ((sizeof(i != 2)))\\n\"\n               \"#define VOIDCAST1 (void)\\n\"\n               \"#define VOIDCAST2(SZ) static_cast<void>(SZ)\\n\"\n               \"int f(int i) {\\n\"\n               \"  VOIDCAST1 SIZEOF1;\\n\"\n               \"  VOIDCAST1 SIZEOF2;\\n\"\n               \"  VOIDCAST2(SIZEOF1);\\n\"\n               \"  VOIDCAST2(SIZEOF2);\\n\"\n               \"  return i + foo(1);\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define SIZEOF1   sizeof(i != 2)\\n\"\n               \"#define SIZEOF2   ((sizeof(i != 2)))\\n\"\n               \"int f(int i) {\\n\"\n               \"  SIZEOF1;\\n\"\n               \"  SIZEOF2;\\n\"\n               \"  return i + foo(1);\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:3]: (warning, inconclusive) Found calculation inside sizeof(). [sizeofCalculation]\\n\"\n                      \"[test.cpp:5:3]: (warning, inconclusive) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n\n        checkP(\"#define MACRO(data)  f(data, sizeof(data))\\n\"\n               \"x = MACRO((unsigned int *)data + 4);\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning, inconclusive) Found calculation inside sizeof(). [sizeofCalculation]\\n\", errout_str());\n    }\n\n    void sizeofFunction() {\n        check(\"class Foo\\n\"\n              \"{\\n\"\n              \"    int bar() { return 1; };\\n\"\n              \"}\\n\"\n              \"Foo f;int a=sizeof(f.bar());\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (warning) Found function call inside sizeof(). [sizeofFunctionCall]\\n\", errout_str());\n\n        check(\"class Foo\\n\"\n              \"{\\n\"\n              \"    int bar() { return 1; };\\n\"\n              \"    int bar() const { return 1; };\\n\"\n              \"}\\n\"\n              \"Foo f;int a=sizeof(f.bar());\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class Foo\\n\"\n              \"{\\n\"\n              \"    int bar() { return 1; };\\n\"\n              \"}\\n\"\n              \"Foo * fp;int a=sizeof(fp->bar());\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (warning) Found function call inside sizeof(). [sizeofFunctionCall]\\n\", errout_str());\n\n        check(\"int a=sizeof(foo());\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() { return 1; }; int a=sizeof(foo());\");\n        ASSERT_EQUALS(\"[test.cpp:1:32]: (warning) Found function call inside sizeof(). [sizeofFunctionCall]\\n\", errout_str());\n\n        check(\"int foo() { return 1; }; sizeof(decltype(foo()));\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int) { return 1; }; int a=sizeof(foo(0))\");\n        ASSERT_EQUALS(\"[test.cpp:1:35]: (warning) Found function call inside sizeof(). [sizeofFunctionCall]\\n\", errout_str());\n\n        check(\"char * buf; int a=sizeof(*buf);\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int a=sizeof(foo())\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int) { return 1; }; char buf[1024]; int a=sizeof(buf), foo(0)\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template<class T>\\n\"\n              \"struct A\\n\"\n              \"{\\n\"\n              \"    static B f(const B &);\\n\"\n              \"    static A f(const A &);\\n\"\n              \"    static A &g();\\n\"\n              \"    static T &h();\\n\"\n              \"\\n\"\n              \"    enum {\\n\"\n              \"        X = sizeof(f(g() >> h())) == sizeof(A),\\n\"\n              \"        Y = sizeof(f(g() << h())) == sizeof(A),\\n\"\n              \"        Z = X & Y\\n\"\n              \"    };\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g();\\n\"\n              \"size_t f1() { return sizeof(x[0]); }\\n\"\n              \"size_t f2() { return sizeof(g()); }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (warning) Found function call inside sizeof(). [sizeofFunctionCall]\\n\", errout_str());\n    }\n\n    void sizeofForArrayParameter() {\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    unsigned int a = 2;\\n\"\n              \"    unsigned int b = 2;\\n\"\n              \"    int c[(a+b)];\\n\"\n              \"    std::cout << sizeof(c) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    unsigned int a = { 2 };\\n\"\n              \"    unsigned int b[] = { 0 };\\n\"\n              \"    int c[a[b[0]]];\\n\"\n              \"    std::cout << sizeof(c) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"void f() {\\n\"\n              \"    unsigned int a[] = { 1 };\\n\"\n              \"    unsigned int b = 2;\\n\"\n              \"    int c[(a[0]+b)];\\n\"\n              \"    std::cout << sizeof(c) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a[] = { 1, 2, 3 };\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a[3] = { 1, 2, 3 };\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f( int a[]) {\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Using 'sizeof' on array given as \"\n                      \"function argument returns size of a pointer. [sizeofwithsilentarraypointer]\\n\", errout_str());\n\n        check(\"void f( int a[]) {\\n\"\n              \"    std::cout << sizeof a / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Using 'sizeof' on array given as \"\n                      \"function argument returns size of a pointer. [sizeofwithsilentarraypointer]\\n\", errout_str());\n\n        check(\"void f( int a[3] ) {\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Using 'sizeof' on array given as \"\n                      \"function argument returns size of a pointer. [sizeofwithsilentarraypointer]\\n\", errout_str());\n\n        check(\"typedef char Fixname[1000];\\n\"\n              \"int f2(Fixname& f2v) {\\n\"\n              \"  int i = sizeof(f2v);\\n\"\n              \"  printf(\\\"sizeof f2v %d\\\", i);\\n\"\n              \"   }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p) {\\n\"\n              \"    p[0] = 0;\\n\"\n              \"    int unused = sizeof(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char p[] = \\\"test\\\";\\n\"\n              \"    int unused = sizeof(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #2495\n        check(\"void f() {\\n\"\n              \"    static float col[][3]={\\n\"\n              \"      {1,0,0},\\n\"\n              \"      {0,0,1},\\n\"\n              \"      {0,1,0},\\n\"\n              \"      {1,0,1},\\n\"\n              \"      {1,0,1},\\n\"\n              \"      {1,0,1},\\n\"\n              \"    };\\n\"\n              \"    const int COL_MAX=sizeof(col)/sizeof(col[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #155\n        check(\"void f() {\\n\"\n              \"    char buff1[1024*64],buff2[sizeof(buff1)*2];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #2510\n        check(\"void f( int a[], int b) {\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Using 'sizeof' on array given as \"\n                      \"function argument returns size of a pointer. [sizeofwithsilentarraypointer]\\n\", errout_str());\n\n        // ticket #2510\n        check(\"void f( int a[3] , int b[2] ) {\\n\"\n              \"    std::cout << sizeof(a) / sizeof(int) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Using 'sizeof' on array given as \"\n                      \"function argument returns size of a pointer. [sizeofwithsilentarraypointer]\\n\", errout_str());\n\n        // ticket #2510\n        check(\"void f() {\\n\"\n              \"    char buff1[1024*64],buff2[sizeof(buff1)*(2+1)];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void sizeofForNumericParameter() {\n        check(\"void f() {\\n\"\n              \"    std::cout << sizeof(10) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::cout << sizeof(-10) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::cout << sizeof 10  << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::cout << sizeof -10  << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]\\n\", errout_str());\n    }\n\n    void suspiciousSizeofCalculation() {\n        check(\"void f() {\\n\"\n              \"  int* p;\\n\"\n              \"  return sizeof(p)/5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning, inconclusive) Division of result of sizeof() on pointer type. [divideSizeof]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  unknown p;\\n\"\n              \"  return sizeof(p)/5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  return sizeof(unknown)/5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int p;\\n\"\n              \"  return sizeof(p)/5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int* p[5];\\n\"\n              \"  return sizeof(p)/5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"void f() {\\n\"\n              \"  return sizeof(foo)*sizeof(bar);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning, inconclusive) Multiplying sizeof() with sizeof() indicates a logic error. [multiplySizeof]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  return (foo)*sizeof(bar);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  return sizeof(foo)*bar;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  return (end - source) / sizeof(encode_block_type) * sizeof(encode_block_type);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { T* t; };\\n\" // #10179\n              \"int f(S* s) {\\n\"\n              \"    return g(sizeof(*s->t) / 4);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const char* a[N];\\n\"\n              \"    for (int i = 0; i < (int)(sizeof(a) / sizeof(char*)); i++) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int** p) {\\n\"\n              \"    return sizeof(p[0]) / 4;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning, inconclusive) Division of result of sizeof() on pointer type. [divideSizeof]\\n\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    unsigned char* s;\\n\"\n              \"};\\n\"\n              \"struct T {\\n\"\n              \"    S s[38];\\n\"\n              \"};\\n\"\n              \"void f(T* t) {\\n\"\n              \"    for (size_t i = 0; i < sizeof(t->s) / sizeof(t->s[0]); i++) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    struct T {\\n\"\n              \"        char* c[3];\\n\"\n              \"    } t[1];\\n\"\n              \"};\\n\"\n              \"void f(S* s) {\\n\"\n              \"    for (int i = 0; i != sizeof(s->t[0].c) / sizeof(char*); i++) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int32_t* buf, size_t len) {\\n\"\n              \"    for (int i = 0; i < len / sizeof(buf[0]); i++) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int32_t*** buf, size_t len) {\\n\"\n              \"    for (int i = 0; i < len / sizeof(**buf[0]); i++) {}\\n\"\n              \"    for (int i = 0; i < len / sizeof(*buf[0][0]); i++) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkPointerSizeof() {\n        check(\"void f() {\\n\"\n              \"    char *x = malloc(10);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(*x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = (int*)malloc(sizeof(x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = static_cast<int*>(malloc(sizeof(x)));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(&x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int*));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    free(x);\\n\"\n              \"    int **y = malloc(sizeof(int*));\\n\"\n              \"    free(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(100 * sizeof(x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(x) * 100);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof *x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(100 * sizeof x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = calloc(1, sizeof(*x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = calloc(1, sizeof *x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = calloc(1, sizeof(x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = calloc(1, sizeof x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = calloc(1, sizeof(int));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char x[10];\\n\"\n              \"    memset(x, 0, sizeof(x));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char* x[10];\\n\"\n              \"    memset(x, 0, sizeof(x));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char x[10];\\n\"\n              \"    memset(x, 0, sizeof x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    memset(x, 0, sizeof(int));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    memset(x, 0, sizeof(*x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    memset(x, 0, sizeof *x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    memset(x, 0, sizeof x);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int));\\n\"\n              \"    memset(x, 0, sizeof(x));\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int) * 10);\\n\"\n              \"    memset(x, 0, sizeof(x) * 10);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int) * 10);\\n\"\n              \"    memset(x, 0, sizeof x * 10);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (warning) Size of pointer 'x' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int) * 10);\\n\"\n              \"    memset(x, 0, sizeof(*x) * 10);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int) * 10);\\n\"\n              \"    memset(x, 0, sizeof *x * 10);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *x = malloc(sizeof(int) * 10);\\n\"\n              \"    memset(x, 0, sizeof(int) * 10);\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"int fun(const char *buf1)\\n\"\n            \"{\\n\"\n            \"  const char *buf1_ex = \\\"foobarbaz\\\";\\n\"\n            \"  return strncmp(buf1, buf1_ex, sizeof(buf1_ex)) == 0;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:24]: (warning) Size of pointer 'buf1_ex' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\n            \"int fun(const char *buf1) {\\n\"\n            \"  return strncmp(buf1, foo(buf2), sizeof(buf1)) == 0;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Size of pointer 'buf1' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        check(\"int fun(const char *buf2) {\\n\"\n              \"  return strncmp(buf1, buf2, sizeof(char*)) == 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:24]: (warning) Size of pointer 'buf2' used instead of size of its data. [pointerSize]\\n\", errout_str());\n\n        // #ticket 3874\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \" int * pIntArray[10];\\n\"\n              \" memset(pIntArray, 0, sizeof(pIntArray));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void FreeFileName(const char *s) {\\n\"\n              \"  CxString tbuf;\\n\"\n              \"  const char *p;\\n\"\n              \"  memcpy(s, siezof(s));\\n\" // non-standard memcpy\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"  module_config_t *tab = module;\\n\"\n              \"  memset(tab + confsize, 0, sizeof(tab[confsize]));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(char* aug) {\\n\"\n              \"  memmove(aug + extra_string, aug, buf - (bfd_byte *)aug);\\n\" // #7100\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7518\n        check(\"bool create_iso_definition(cpp_reader *pfile, cpp_macro *macro) {\\n\"\n              \"  cpp_token *token;\\n\"\n              \"  cpp_hashnode **params = malloc(sizeof(cpp_hashnode *) * macro->paramc);\\n\"\n              \"  memcpy(params, macro->params, sizeof(cpp_hashnode *) * macro->paramc);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* foo() {\\n\"\n              \"  void* AtomName = malloc(sizeof(char *) * 34);\\n\"\n              \"  return AtomName;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkPointerSizeofStruct() {\n        check(\"void f() {\\n\"\n              \"    struct foo *ptr;\\n\"\n              \"    memset( ptr->bar, 0, sizeof ptr->bar );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    struct foo {\\n\"\n              \"        char bar[10];\\n\"\n              \"    }* ptr;\\n\"\n              \"    memset( ptr->bar, 0, sizeof ptr->bar );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    struct foo {\\n\"\n              \"        char *bar;\\n\"\n              \"    }* ptr;\\n\"\n              \"    memset( ptr->bar, 0, sizeof ptr->bar );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:18]: (warning) Size of pointer 'bar' used instead of size of its data. [pointerSize]\\n\", errout_str());\n    }\n\n    void sizeofDivisionMemset() {\n        check(\"void foo(memoryMapEntry_t* entry, memoryMapEntry_t* memoryMapEnd) {\\n\"\n              \"    memmove(entry, entry + 1, (memoryMapEnd - entry) / sizeof(entry));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:56]: (warning, inconclusive) Division of result of sizeof() on pointer type. [divideSizeof]\\n\"\n                      \"[test.cpp:2:54]: (warning) Division by result of sizeof(). memmove() expects a size in bytes, did you intend to multiply instead? [sizeofDivisionMemfunc]\\n\",\n                      errout_str());\n\n        check(\"Foo* allocFoo(int num) {\\n\"\n              \"    return malloc(num / sizeof(Foo));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (warning) Division by result of sizeof(). malloc() expects a size in bytes, did you intend to multiply instead? [sizeofDivisionMemfunc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char str[100];\\n\"\n              \"  strncpy(str, xyz, sizeof(str)/sizeof(str[0]));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #9648\n              \"    int a[5] = { 0 };\\n\"\n              \"    int b[5];\\n\"\n              \"    memcpy(b, a, ((sizeof(a) / sizeof(a[0])) - 1) * sizeof(a[0]));\\n\"\n              \"    memcpy(b, a, sizeof(a[0]) * ((sizeof(a) / sizeof(a[0])) - 1));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void sizeofVoid() {\n        check(\"void f() {\\n\"\n              \"  int size = sizeof(void);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (portability) Behaviour of 'sizeof(void)' is not covered by the ISO C standard. [sizeofVoid]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void* p;\\n\"\n              \"  int size = sizeof(*p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (portability) '*p' is of type 'void', the behaviour of 'sizeof(void)' is not covered by the ISO C standard. [sizeofDereferencedVoidPointer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void* p = malloc(10);\\n\"\n              \"  int* p2 = p + 4;\\n\"\n              \"  int* p3 = p - 1;\\n\"\n              \"  int* p4 = 1 + p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (portability) 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\"\n                      \"[test.cpp:4:15]: (portability) 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\"\n                      \"[test.cpp:5:15]: (portability) 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void* p1 = malloc(10);\\n\"\n              \"  void* p2 = malloc(5);\\n\"\n              \"  p1--;\\n\"\n              \"  p2++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (portability) 'p1' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\"\n                      \"[test.cpp:5:5]: (portability) 'p2' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void* p1 = malloc(10);\\n\"\n              \"  void* p2 = malloc(5);\\n\"\n              \"  p1-=4;\\n\"\n              \"  p2+=4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (portability) 'p1' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\"\n                      \"[test.cpp:5:5]: (portability) 'p2' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void* p = malloc(10);\\n\"\n              \"  int* p2 = &p + 4;\\n\"\n              \"  int* p3 = &p - 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void** p1 = malloc(10);\\n\"\n              \"  p1--;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void** p1;\\n\"\n              \"  int j = sizeof(*p1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  void* p1[5];\\n\"\n              \"  int j = sizeof(*p1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Calculations on void* with casts\n\n        check(\"void f(void *data) {\\n\"\n              \"  *((unsigned char *)data + 1) = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void *data) {\\n\"\n              \"  *((unsigned char *)(data) + 1) = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void *data) {\\n\"\n              \"  unsigned char* c = (unsigned char *)(data + 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:45]: (portability) 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"void f(void *data) {\\n\"\n              \"  unsigned char* c = (unsigned char *)data++;\\n\"\n              \"  unsigned char* c2 = (unsigned char *)++data;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:43]: (portability) 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\"\n                      \"[test.cpp:3:40]: (portability) 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"void f(void *data) {\\n\"\n              \"  void* data2 = data + 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (portability) 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        // #4908 (void pointer as a member of a struct/class)\n        check(\"struct FOO {\\n\"\n              \"  void *data;\\n\"\n              \"};\\n\"\n              \"char f(struct FOO foo) {\\n\"\n              \"  char x = *((char*)(foo.data+1));\\n\"\n              \"  foo.data++;\\n\"\n              \"  return x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:30]: (portability) 'foo.data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\"\n                      \"[test.cpp:6:11]: (portability) 'foo.data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"struct FOO {\\n\"\n              \"  void *data;\\n\"\n              \"};\\n\"\n              \"char f(struct FOO foo) {\\n\"\n              \"  char x = *((char*)foo.data+1);\\n\"\n              \"  return x;\\n\"\n              \"}\\n\"\n              \"char f2(struct FOO foo) {\\n\"\n              \"  char x = *((char*)((FOO)foo).data + 1);\\n\"\n              \"  return x;\\n\"\n              \"}\\n\"\n              \"char f3(struct FOO* foo) {\\n\"\n              \"  char x = *((char*)foo->data + 1);\\n\"\n              \"  return x;\\n\"\n              \"}\\n\"\n              \"struct BOO {\\n\"\n              \"  FOO data;\\n\"\n              \"};\\n\"\n              \"void f4(struct BOO* boo) {\\n\"\n              \"  char c = *((char*)boo->data.data + 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct FOO {\\n\"\n              \"  void *data;\\n\"\n              \"};\\n\"\n              \"char f(struct FOO* foo) {\\n\"\n              \"  *(foo[1].data + 1) = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (portability) 'foo[1].data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        check(\"struct FOO {\\n\"\n              \"  void *data;\\n\"\n              \"};\\n\"\n              \"void f2(struct FOO* foo) {\\n\"\n              \"  (foo[0]).data++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (portability) '(foo[0]).data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]\\n\", errout_str());\n\n        // #6050 arithmetic on void**\n        check(\"void* array[10];\\n\"\n              \"void** b = array + 3;\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void customStrncat() {\n        // Ensure we don't crash on custom-defined strncat, ticket #5875\n        check(\"char strncat ();\\n\"\n              \"int main () {\\n\"\n              \"  return strncat ();\\n\"\n              \"}\");\n    }\n\n};\n\nREGISTER_TEST(TestSizeof)\n\n"
    }
  ]
}