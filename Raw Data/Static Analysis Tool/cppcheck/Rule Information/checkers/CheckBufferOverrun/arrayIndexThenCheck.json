{
  "name": "arrayIndexThenCheck",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 35,
  "branches": 11,
  "apis": 32,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        5057
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"check.h\"\n#include \"checkbufferoverrun.h\"\n#include \"ctu.h\"\n#include \"errortypes.h\"\n#include \"helpers.h\"\n#include \"platform.h\"\n#include \"settings.h\"\n#include \"fixture.h\"\n\n#include <cstddef>\n#include <list>\n#include <string>\n\nclass TestBufferOverrun : public TestFixture {\npublic:\n    TestBufferOverrun() : TestFixture(\"TestBufferOverrun\") {}\n\nprivate:\n    /*const*/ Settings settings0 = settingsBuilder().library(\"std.cfg\").severity(Severity::warning).severity(Severity::style).severity(Severity::portability).build();\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        const Settings* s = nullptr;\n        bool cpp = true;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings settings = options.s ? *options.s : settingsBuilder(settings0).certainty(Certainty::inconclusive).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this, options.cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for buffer overruns..\n        runChecks<CheckBufferOverrun>(tokenizer, this);\n    }\n\n    // TODO: get rid of this\n    void check_(const char* file, int line, const std::string& code) {\n        const Settings settings = settingsBuilder(settings0).certainty(Certainty::inconclusive).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for buffer overruns..\n        runChecks<CheckBufferOverrun>(tokenizer, this);\n    }\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    void checkP_(const char* file, int line, const char code[])\n    {\n        const Settings settings = settingsBuilder(settings0).severity(Severity::performance).certainty(Certainty::inconclusive).build();\n\n        SimpleTokenizer2 tokenizer(settings, *this, code, \"test.cpp\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check for buffer overruns..\n        runChecks<CheckBufferOverrun>(tokenizer, this);\n    }\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(noerr1);\n        TEST_CASE(noerr2);\n        TEST_CASE(noerr3);\n        TEST_CASE(noerr4);\n\n        TEST_CASE(sizeof3);\n\n        TEST_CASE(array_index_1);\n        TEST_CASE(array_index_2);\n        TEST_CASE(array_index_3);\n        TEST_CASE(array_index_4);\n        TEST_CASE(array_index_6);\n        TEST_CASE(array_index_7);\n        TEST_CASE(array_index_11);\n        TEST_CASE(array_index_12);\n        TEST_CASE(array_index_13);\n        TEST_CASE(array_index_14);\n        TEST_CASE(array_index_15);\n        TEST_CASE(array_index_16);\n        TEST_CASE(array_index_17);\n        TEST_CASE(array_index_18);\n        TEST_CASE(array_index_19);\n        TEST_CASE(array_index_20);\n        TEST_CASE(array_index_21);\n        TEST_CASE(array_index_22);\n        TEST_CASE(array_index_23);\n        TEST_CASE(array_index_24); // ticket #1492 and #1539\n        TEST_CASE(array_index_25); // ticket #1536\n        TEST_CASE(array_index_26);\n        TEST_CASE(array_index_27);\n        TEST_CASE(array_index_28); // ticket #1418\n        TEST_CASE(array_index_29); // ticket #1734\n        TEST_CASE(array_index_30); // ticket #2086 - out of bounds when type is unknown\n        TEST_CASE(array_index_31); // ticket #2120 - out of bounds in subfunction when type is unknown\n        TEST_CASE(array_index_32);\n        TEST_CASE(array_index_33); // ticket #3044\n        TEST_CASE(array_index_34); // ticket #3063\n        TEST_CASE(array_index_35); // ticket #2889\n        TEST_CASE(array_index_36); // ticket #2960\n        TEST_CASE(array_index_37);\n        TEST_CASE(array_index_38); // ticket #3273\n        TEST_CASE(array_index_39);\n        TEST_CASE(array_index_40); // loop variable calculation, taking address\n        TEST_CASE(array_index_41); // structs with the same name\n        TEST_CASE(array_index_42);\n        TEST_CASE(array_index_43); // struct with array\n        TEST_CASE(array_index_44); // #3979\n        TEST_CASE(array_index_45); // #4207 - calling function with variable number of parameters (...)\n        TEST_CASE(array_index_46); // #4840 - two-statement for loop\n        TEST_CASE(array_index_47); // #5849\n        TEST_CASE(array_index_48); // #9478\n        TEST_CASE(array_index_49); // #8653\n        TEST_CASE(array_index_50);\n        TEST_CASE(array_index_51); // #3763\n        TEST_CASE(array_index_52); // #7682\n        TEST_CASE(array_index_53); // #4750\n        TEST_CASE(array_index_54); // #10268\n        TEST_CASE(array_index_55); // #10254\n        TEST_CASE(array_index_56); // #10284\n        TEST_CASE(array_index_57); // #10023\n        TEST_CASE(array_index_58); // #7524\n        TEST_CASE(array_index_59); // #10413\n        TEST_CASE(array_index_60); // #10617, #9824\n        TEST_CASE(array_index_61); // #10621\n        TEST_CASE(array_index_62); // #7684\n        TEST_CASE(array_index_63); // #10979\n        TEST_CASE(array_index_64); // #10878\n        TEST_CASE(array_index_65); // #11066\n        TEST_CASE(array_index_66); // #10740\n        TEST_CASE(array_index_67); // #1596\n        TEST_CASE(array_index_68); // #6655\n        TEST_CASE(array_index_69); // #6370\n        TEST_CASE(array_index_70); // #11355\n        TEST_CASE(array_index_71); // #11461\n        TEST_CASE(array_index_72); // #11784\n        TEST_CASE(array_index_73); // #11530\n        TEST_CASE(array_index_74); // #11088\n        TEST_CASE(array_index_75);\n        TEST_CASE(array_index_76);\n        TEST_CASE(array_index_multidim);\n        TEST_CASE(array_index_switch_in_for);\n        TEST_CASE(array_index_for_in_for);   // FP: #2634\n        TEST_CASE(array_index_bounds);\n        TEST_CASE(array_index_calculation);\n        TEST_CASE(array_index_negative1);\n        TEST_CASE(array_index_negative2);    // ticket #3063\n        TEST_CASE(array_index_negative3);\n        TEST_CASE(array_index_negative4);\n        TEST_CASE(array_index_negative5);    // #10526\n        TEST_CASE(array_index_negative6);    // #11349\n        TEST_CASE(array_index_negative7);    // #5685\n        TEST_CASE(array_index_negative8);    // #11651\n        TEST_CASE(array_index_negative9);\n        TEST_CASE(array_index_negative10);\n        TEST_CASE(array_index_for_decr);\n        TEST_CASE(array_index_varnames);     // FP: struct member #1576, FN: #1586\n        TEST_CASE(array_index_for_continue); // for,continue\n        TEST_CASE(array_index_for);          // FN: for,if\n        TEST_CASE(array_index_for_neq);      // #2211: Using != in condition\n        TEST_CASE(array_index_for_question); // #2561: for, ?:\n        TEST_CASE(array_index_for_andand_oror);  // FN: using && or || in the for loop condition\n        TEST_CASE(array_index_for_varid0);   // #4228: No varid for counter variable\n        TEST_CASE(array_index_vla_for);      // #3221: access VLA inside for\n        TEST_CASE(array_index_extern);       // FP when using 'extern'. #1684\n        TEST_CASE(array_index_cast);         // FP after cast. #2841\n        TEST_CASE(array_index_string_literal);\n        TEST_CASE(array_index_same_struct_and_var_name); // #4751 - not handled well when struct name and var name is same\n        TEST_CASE(array_index_valueflow);\n        TEST_CASE(array_index_valueflow_pointer);\n        TEST_CASE(array_index_function_parameter);\n        TEST_CASE(array_index_enum_array); // #8439\n        TEST_CASE(array_index_container); // #9386\n        TEST_CASE(array_index_two_for_loops);\n        TEST_CASE(array_index_new); // #7690\n\n        TEST_CASE(buffer_overrun_2_struct);\n        TEST_CASE(buffer_overrun_3);\n        TEST_CASE(buffer_overrun_4);\n        TEST_CASE(buffer_overrun_5);\n        TEST_CASE(buffer_overrun_6);\n        TEST_CASE(buffer_overrun_7);\n        TEST_CASE(buffer_overrun_8);\n        TEST_CASE(buffer_overrun_9);\n        TEST_CASE(buffer_overrun_10);\n        TEST_CASE(buffer_overrun_11);\n        TEST_CASE(buffer_overrun_15); // ticket #1787\n        TEST_CASE(buffer_overrun_16);\n        TEST_CASE(buffer_overrun_18); // ticket #2576 - for, calculation with loop variable\n        TEST_CASE(buffer_overrun_19); // #2597 - class member with unknown type\n        TEST_CASE(buffer_overrun_21);\n        TEST_CASE(buffer_overrun_24); // index variable is changed in for-loop\n        TEST_CASE(buffer_overrun_26); // #4432 (segmentation fault)\n        TEST_CASE(buffer_overrun_27); // #4444 (segmentation fault)\n        TEST_CASE(buffer_overrun_29); // #7083: false positive: typedef and initialization with strings\n        TEST_CASE(buffer_overrun_30); // #6367\n        TEST_CASE(buffer_overrun_31);\n        TEST_CASE(buffer_overrun_32); //#10244\n        TEST_CASE(buffer_overrun_33); //#2019\n        TEST_CASE(buffer_overrun_34); //#11035\n        TEST_CASE(buffer_overrun_35); //#2304\n        TEST_CASE(buffer_overrun_36);\n        TEST_CASE(buffer_overrun_errorpath);\n        TEST_CASE(buffer_overrun_bailoutIfSwitch);  // ticket #2378 : bailoutIfSwitch\n        TEST_CASE(buffer_overrun_function_array_argument);\n        TEST_CASE(possible_buffer_overrun_1); // #3035\n        TEST_CASE(buffer_overrun_readSizeFromCfg);\n\n        TEST_CASE(valueflow_string); // using ValueFlow string values in checking\n\n        // It is undefined behaviour to point out of bounds of an array\n        // the address beyond the last element is in bounds\n        // char a[10];\n        // char *p1 = a + 10;  // OK\n        // char *p2 = a + 11   // UB\n        TEST_CASE(pointer_out_of_bounds_1);\n        TEST_CASE(pointer_out_of_bounds_2);\n        TEST_CASE(pointer_out_of_bounds_3);\n        TEST_CASE(pointer_out_of_bounds_4);\n        TEST_CASE(pointer_out_of_bounds_5); // #10227\n        TEST_CASE(pointer_out_of_bounds_sub);\n\n        TEST_CASE(strcat1);\n\n        TEST_CASE(varid1);\n        TEST_CASE(varid2);  // ticket #4764\n\n        TEST_CASE(assign1);\n\n        TEST_CASE(alloc_new);      // Buffer allocated with new\n        TEST_CASE(alloc_malloc);   // Buffer allocated with malloc\n        TEST_CASE(alloc_string);   // statically allocated buffer\n        TEST_CASE(alloc_alloca);   // Buffer allocated with alloca\n\n        // TODO TEST_CASE(countSprintfLength);\n        TEST_CASE(minsize_argvalue);\n        TEST_CASE(minsize_sizeof);\n        TEST_CASE(minsize_strlen);\n        TEST_CASE(minsize_mul);\n        TEST_CASE(unknownType);\n\n        TEST_CASE(terminateStrncpy1);\n        TEST_CASE(terminateStrncpy2);\n        TEST_CASE(terminateStrncpy3);\n        TEST_CASE(terminateStrncpy4);\n        TEST_CASE(terminateStrncpy5); // #9944\n        TEST_CASE(recursive_long_time);\n\n        TEST_CASE(crash1);  // Ticket #1587 - crash\n        TEST_CASE(crash2);  // Ticket #3034 - crash\n        TEST_CASE(crash3);  // Ticket #5426 - crash\n        TEST_CASE(crash4);  // Ticket #8679 - crash\n        TEST_CASE(crash5);  // Ticket #8644 - crash\n        TEST_CASE(crash6);  // Ticket #9024 - crash\n        TEST_CASE(crash7);  // Ticket #9073 - crash\n\n        TEST_CASE(insecureCmdLineArgs);\n        TEST_CASE(checkBufferAllocatedWithStrlen);\n\n        TEST_CASE(scope);   // handling different scopes\n\n        TEST_CASE(getErrorMessages);\n\n        // Access array and then check if the used index is within bounds\n        TEST_CASE(arrayIndexThenCheck);\n        TEST_CASE(arrayIndexEarlyReturn); // #6884\n\n        TEST_CASE(bufferNotZeroTerminated);\n\n        TEST_CASE(negativeMemoryAllocationSizeError); // #389\n        TEST_CASE(negativeArraySize);\n\n        TEST_CASE(pointerAddition1);\n\n        TEST_CASE(ctu_malloc);\n        TEST_CASE(ctu_array);\n        TEST_CASE(ctu_variable);\n        TEST_CASE(ctu_arithmetic);\n\n        TEST_CASE(objectIndex);\n\n        TEST_CASE(checkPipeParameterSize); // ticket #3521\n    }\n\n\n\n    void noerr1() {\n        check(\"extern int ab;\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    if (ab)\\n\"\n              \"    {\\n\"\n              \"        char str[50];\\n\"\n              \"    }\\n\"\n              \"    if (ab)\\n\"\n              \"    {\\n\"\n              \"        char str[50];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void noerr2() {\n        check(\"static char buf[2];\\n\"\n              \"void f1(char *str)\\n\"\n              \"{\\n\"\n              \"    strcpy(buf,str);\\n\"\n              \"}\\n\"\n              \"void f2(char *str)\\n\"\n              \"{\\n\"\n              \"    strcat(buf,str);\\n\"\n              \"}\\n\"\n              \"void f3(char *str)\\n\"\n              \"{\\n\"\n              \"    sprintf(buf,\\\"%s\\\",str);\\n\"\n              \"}\\n\"\n              \"void f4(const char str[])\\n\"\n              \"{\\n\"\n              \"    strcpy(buf, str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void noerr3() {\n        check(\"struct { char data[10]; } abc;\\n\"\n              \"static char f()\\n\"\n              \"{\\n\"\n              \"    char data[1];\\n\"\n              \"    return abc.data[1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void noerr4() {\n        // The memory isn't read or written and therefore there is no error.\n        check(\"static void f() {\\n\"\n              \"    char data[100];\\n\"\n              \"    const char *p = data + 100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void sizeof3() {\n        check(\"struct group { int gr_gid; };\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    char group[32];\\n\"\n              \"    snprintf(group, 32, \\\"%u\\\", 0);\\n\"\n              \"    struct group *gr;\\n\"\n              \"    snprintf(group, 32, \\\"%u\\\", gr->gr_gid);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_1() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char str[0x10] = {0};\\n\"\n              \"    str[15] = 0;\\n\"\n              \"    str[16] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (error) Array 'str[16]' accessed at index 16, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"char f()\\n\"\n              \"{\\n\"\n              \"    char str[16] = {0};\\n\"\n              \"    return str[16];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (error) Array 'str[16]' accessed at index 16, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // test stack array\n        check(\"int f()\\n\"\n              \"{\\n\"\n              \"   int x[ 3 ] = { 0, 1, 2 };\\n\"\n              \"   int y;\\n\"\n              \"   y = x[ 4 ];\\n\"\n              \"   return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (error) Array 'x[3]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"int f()\\n\"\n              \"{\\n\"\n              \"   int x[ 3 ] = { 0, 1, 2 };\\n\"\n              \"   int y;\\n\"\n              \"   y = x[ 2 ];\\n\"\n              \"   return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int x[5] = {0};\\n\"\n              \"int a = x[10];\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Array 'x[5]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"int x[5] = {0};\\n\"\n              \"int a = (x)[10];\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (error) Array 'x[5]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n\n    void array_index_2() {\n        check(\"void a(int i)\\n\" // valueflow\n              \"{\\n\"\n              \"    char *str = new char[0x10];\\n\"\n              \"    str[i] = 0;\\n\"\n              \"}\\n\"\n              \"void b() { a(16); }\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Array 'str[16]' accessed at index 16, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_4() {\n        check(\"char c = \\\"abc\\\"[4];\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (error) Array '\\\"abc\\\"[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"p = &\\\"abc\\\"[4];\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char c = \\\"\\\\0abc\\\"[2];\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char c = L\\\"abc\\\"[4];\");\n        ASSERT_EQUALS(\"[test.cpp:1:16]: (error) Array 'L\\\"abc\\\"[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_3() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int val[50];\\n\"\n              \"    int i, sum=0;\\n\"\n              \"    for (i = 0; i < 100; i++)\\n\"\n              \"        sum += val[i];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:19]: (error) Array 'val[50]' accessed at index 99, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int val[50];\\n\"\n              \"    int i, sum=0;\\n\"\n              \"    for (i = 1; i < 100; i++)\\n\"\n              \"        sum += val[i];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:19]: (error) Array 'val[50]' accessed at index 99, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(int a)\\n\"\n              \"{\\n\"\n              \"    int val[50];\\n\"\n              \"    int i, sum=0;\\n\"\n              \"    for (i = a; i < 100; i++)\\n\"\n              \"        sum += val[i];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:19]: (error) Array 'val[50]' accessed at index 99, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"typedef struct g g2[3];\\n\"\n              \"void foo(char *a)\\n\"\n              \"{\\n\"\n              \"  for (int i = 0; i < 4; i++)\\n\"\n              \"  {\\n\"\n              \"    a[i]=0;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int argc)\\n\"\n              \"{\\n\"\n              \"  char a[2];\\n\"\n              \"  for (int i = 4; i < argc; i++){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a[10]) {\\n\"\n              \"    for (int i=0;i<50;++i) {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (error) Array 'a[10]' accessed at index 49, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_6() {\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[10];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC abc;\\n\"\n              \"    abc.str[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:12]: (error) Array 'abc.str[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[10];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static char f()\\n\"\n              \"{\\n\"\n              \"    struct ABC abc;\\n\"\n              \"    return abc.str[10];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:19]: (error) Array 'abc.str[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // This is not out of bounds because it is a variable length array\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(struct ABC) + 10);\\n\"\n              \"    x->str[1] = 0;\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // This is not out of bounds because it is not a variable length array\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"    int x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(struct ABC) + 10);\\n\"\n              \"    x->str[1] = 0;\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        // This is not out of bounds because it is a variable length array\n        // and the index is within the memory allocated.\n        /** @todo this works by accident because we ignore any access to this array */\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(struct ABC) + 10);\\n\"\n              \"    x->str[10] = 0;\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // This is out of bounds because it is outside the memory allocated.\n        /** @todo this doesn't work because of a bug in sizeof(struct)  */\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(struct ABC) + 10);\\n\"\n              \"    x->str[11] = 0;\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:9]: (error) Array 'str[1]' accessed at index 11, which is out of bounds.\\n\", \"\", errout_str());\n\n        // This is out of bounds if 'sizeof(ABC)' is 1 (No padding)\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(ABC) + 10);\\n\"\n              \"    x->str[11] = 0;\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        // This is out of bounds because it is outside the memory allocated\n        /** @todo this doesn't work because of a bug in sizeof(struct) */\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(struct ABC));\\n\"\n              \"    x->str[1] = 0;\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:9]: (error) Array 'str[1]' accessed at index 1, which is out of bounds.\\n\", \"\", errout_str());\n\n        // This is out of bounds because it is outside the memory allocated\n        // But only if 'sizeof(ABC)' is 1 (No padding)\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC* x = malloc(sizeof(ABC));\\n\"\n              \"    x->str[1] = 0;\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        // This is out of bounds because it is not a variable array\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[1];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC x;\\n\"\n              \"    x.str[1] = 0;\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:10]: (error) Array 'x.str[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct foo\\n\"\n              \"{\\n\"\n              \"    char str[10];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void x()\\n\"\n              \"{\\n\"\n              \"    foo f;\\n\"\n              \"    for ( unsigned int i = 0; i < 64; ++i )\\n\"\n              \"        f.str[i] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:14]: (error) Array 'f.str[10]' accessed at index 63, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct AB { char a[NUM]; char b[NUM]; }\\n\"\n              \"void f(struct AB *ab) {\\n\"\n              \"    ab->a[0] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"union { char a[1]; int b; } ab;\\n\"\n              \"void f() {\\n\"\n              \"    ab.a[2] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Array 'ab.a[1]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n\n    void array_index_7() {\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[10];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    abc->str[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:13]: (error) Array 'abc->str[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_11() {\n        check(\"class ABC\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"    ABC();\\n\"\n              \"    char *str[10];\\n\"\n              \"    struct ABC *next();\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f(ABC *abc1)\\n\"\n              \"{\\n\"\n              \"    for ( ABC *abc = abc1; abc; abc = abc->next() )\\n\"\n              \"    {\\n\"\n              \"        abc->str[10] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:13:17]: (error) Array 'abc->str[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_12() {\n        check(\"class Fred\\n\"\n              \"{\\n\"\n              \"private:\\n\"\n              \"    char str[10];\\n\"\n              \"public:\\n\"\n              \"    Fred();\\n\"\n              \"};\\n\"\n              \"Fred::Fred()\\n\"\n              \"{\\n\"\n              \"    str[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:8]: (error) Array 'str[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"class Fred\\n\"\n              \"{\\n\"\n              \"private:\\n\"\n              \"    char str[10];\\n\"\n              \"public:\\n\"\n              \"    char c();\\n\"\n              \"};\\n\"\n              \"char Fred::c()\\n\"\n              \"{\\n\"\n              \"    return str[10];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:15]: (error) Array 'str[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_13() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char buf[10];\\n\"\n              \"    for (int i = 0; i < 100; i++)\\n\"\n              \"    {\\n\"\n              \"        if (i < 10)\\n\"\n              \"            int x = buf[i];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_14() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 10; i++)\\n\"\n              \"        a[i+10] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[10]' accessed at index 19, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_15() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 10; i++)\\n\"\n              \"        a[10+i] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[10]' accessed at index 19, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_16() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 10; i++)\\n\"\n              \"        a[i+1] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_17() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 10; i++)\\n\"\n              \"        a[i*2] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[10]' accessed at index 18, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[12];\\n\"\n              \"    for (int i = 0; i < 12; i+=6)\\n\"\n              \"        a[i+5] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[12];\\n\"\n              \"    for (int i = 0; i < 12; i+=6)\\n\"\n              \"        a[i+6] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[12]' accessed at index 12, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"  // #4398\n              \"    int a[2];\\n\"\n              \"    for (int i = 0; i < 4; i+=2)\\n\"\n              \"        a[i] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'a[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"  // #4398\n              \"    int a[2];\\n\"\n              \"    for (int i = 0; i < 4; i+=2)\\n\"\n              \"        do_stuff(a+i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_18() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[5];\\n\"\n              \"    for (int i = 0; i < 6; i++)\\n\"\n              \"    {\\n\"\n              \"        a[i] = i;\\n\"\n              \"        i+=1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[5];\\n\"\n              \"    for (int i = 0; i < 6; i++)\\n\"\n              \"    {\\n\"\n              \"        a[i] = i;\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[5];\\n\"\n              \"    for (int i = 0; i < 6; i++)\\n\"\n              \"    {\\n\"\n              \"        a[i] = i;\\n\"\n              \"        ++i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[5];\\n\"\n              \"    for (int i = 0; i < 6; i++)\\n\"\n              \"    {\\n\"\n              \"        a[i] = i;\\n\"\n              \"        i=4;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: (error) Array 'a[5]' accessed at index 5, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[6];\\n\"\n              \"    for (int i = 0; i < 7; i++)\\n\"\n              \"    {\\n\"\n              \"        a[i] = i;\\n\"\n              \"        i+=1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (error) Buffer overrun\\n\", \"\", errout_str());\n    }\n\n    void array_index_19() {\n        // \"One Past the End\" is legal, as long as pointer is not dereferenced.\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2];\\n\"\n              \"  char *end = &(a[2]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Getting more than one past the end is not legal\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2];\\n\"\n              \"  char *end = &(a[3]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Array 'a[2]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_20() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \" char a[8];\\n\"\n              \" int b[10];\\n\"\n              \" for ( int i = 0; i < 9; i++ )\\n\"\n              \"  b[i] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_21() {\n        check(\"class A {\\n\"\n              \" int indices[2];\\n\"\n              \" void foo(int indices[3]);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void A::foo(int indices[3]) {\\n\"\n              \" for(int j=0; j<3; ++j) {\\n\"\n              \"  int b = indices[j];\\n\"\n              \" }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_22() {\n        check(\"int main() {\\n\"\n              \"  size_t indices[2];\\n\"\n              \"  int b = indices[2];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (error) Array 'indices[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_23() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char c[10];\\n\"\n              \"    c[1<<23]='a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 'c[10]' accessed at index 8388608, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_24() {\n        // ticket #1492 and #1539\n        const std::string charMaxPlusOne(settings0.platform.defaultSign == 'u' ? \"256\" : \"128\");\n        check(\"void f(char n) {\\n\"\n              \"    int a[n];\\n\"     // n <= CHAR_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"    a[\" + charMaxPlusOne + \"] = 0;\\n\"   // 128/256 > CHAR_MAX\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[\" + charMaxPlusOne + \"]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'a[\" + charMaxPlusOne + \"]' accessed at index \" + charMaxPlusOne + \", which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(signed char n) {\\n\"\n              \"    int a[n];\\n\"     // n <= SCHAR_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"    a[128] = 0;\\n\"   // 128 > SCHAR_MAX\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[128]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'a[128]' accessed at index 128, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(unsigned char n) {\\n\"\n              \"    int a[n];\\n\"     // n <= UCHAR_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"    a[256] = 0;\\n\"   // 256 > UCHAR_MAX\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[256]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'a[256]' accessed at index 256, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(short n) {\\n\"\n              \"    int a[n];\\n\"     // n <= SHRT_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"    a[32768] = 0;\\n\" // 32768 > SHRT_MAX\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[32768]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'a[32768]' accessed at index 32768, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(unsigned short n) {\\n\"\n              \"    int a[n];\\n\"     // n <= USHRT_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"    a[65536] = 0;\\n\" // 65536 > USHRT_MAX\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[65536]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'a[65536]' accessed at index 65536, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(signed short n) {\\n\"\n              \"    int a[n];\\n\"     // n <= SHRT_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"    a[32768] = 0;\\n\" // 32768 > SHRT_MAX\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[32768]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'a[32768]' accessed at index 32768, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(int n) {\\n\"\n              \"    int a[n];\\n\"     // n <= INT_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[2147483648]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n\n        check(\"void f(unsigned int n) {\\n\"\n              \"    int a[n];\\n\"     // n <= UINT_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[4294967296]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n\n        check(\"void f(signed int n) {\\n\"\n              \"    int a[n];\\n\"     // n <= INT_MAX\n              \"    a[-1] = 0;\\n\"    // negative index\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'a[2147483648]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    void array_index_25() { // #1536\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   long l[SOME_SIZE];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_26() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[3];\\n\"\n              \"    for (int i = 3; 0 <= i; i--)\\n\"\n              \"        a[i] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[4];\\n\"\n              \"    for (int i = 3; 0 <= i; i--)\\n\"\n              \"        a[i] = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_27() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 10; i++)\\n\"\n              \"        a[i-1] = a[i];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[10]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    void array_index_28() {\n        // ticket #1418\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int i[2];\\n\"\n              \"    int *ip = i + 1;\\n\"\n              \"    ip[-10] = 1;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Array ip[-10] out of bounds.\\n\", \"\", errout_str());\n    }\n\n    void array_index_29() {\n        // ticket #1724\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int iBuf[10];\"\n              \"    int *i = iBuf + 9;\"\n              \"    int *ii = i + -5;\"\n              \"    ii[10] = 0;\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (error) Array ii[10] out of bounds.\\n\", \"\", errout_str());\n    }\n\n    void array_index_30() {\n        // ticket #2086 - unknown type\n        // extracttests.start: typedef unsigned char UINT8;\n        check(\"void f() {\\n\"\n              \"    UINT8 x[2];\\n\"\n              \"    x[5] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'x[2]' accessed at index 5, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_31() {\n        // ticket #2120 - sub function, unknown type\n        check(\"struct s1 {\\n\"\n              \"    unknown_type_t delay[3];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void x(unknown_type_t *delay, const int *net) {\\n\"\n              \"    delay[0] = 0;\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void y() {\\n\"\n              \"    struct s1 obj;\\n\"\n              \"    x(obj.delay, 123);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct s1 {\\n\"\n              \"    unknown_type_t delay[3];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void x(unknown_type_t *delay, const int *net) {\\n\"\n              \"    delay[4] = 0;\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void y() {\\n\"\n              \"    struct s1 obj;\\n\"\n              \"    x(obj.delay, 123);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:11] -> [test.cpp:6]: (error) Array 'obj.delay[3]' accessed at index 4, which is out of bounds.\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"struct s1 {\\n\"\n              \"    float a[0];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f() {\\n\"\n              \"    struct s1 *obj;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_32() {\n        check(\"class X\\n\"\n              \"{\\n\"\n              \"    public:\\n\"\n              \"    X()\\n\"\n              \"    {\\n\"\n              \"       m_x[0] = 0;\\n\"\n              \"       m_x[1] = 0;\\n\"\n              \"    }\\n\"\n              \"    int m_x[1];\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:7:11]: (error) Array 'm_x[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_33() {\n        check(\"void foo(char bar[][4]) {\\n\"\n              \"    baz(bar[5]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_34() { // ticket #3063\n        check(\"void foo() {\\n\"\n              \"    int y[2][2][2];\\n\"\n              \"    y[0][2][0] = 0;\\n\"\n              \"    y[0][0][2] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Array 'y[2][2][2]' accessed at index y[0][2][0], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:4:6]: (error) Array 'y[2][2][2]' accessed at index y[0][0][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct TEST\\n\"\n              \"{\\n\"\n              \"    char a[10];\\n\"\n              \"    char b[10][5];\\n\"\n              \"};\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    TEST test;\\n\"\n              \"    test.a[10] = 3;\\n\"\n              \"    test.b[10][2] = 4;\\n\"\n              \"    test.b[0][19] = 4;\\n\"\n              \"    TEST *ptest;\\n\"\n              \"    ptest = &test;\\n\"\n              \"    ptest->a[10] = 3;\\n\"\n              \"    ptest->b[10][2] = 4;\\n\"\n              \"    ptest->b[0][19] = 4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:11]: (error) Array 'test.a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:10:11]: (error) Array 'test.b[10][5]' accessed at index test.b[10][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:11:11]: (error) Array 'test.b[10][5]' accessed at index test.b[0][19], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:14:13]: (error) Array 'ptest->a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:15:13]: (error) Array 'ptest->b[10][5]' accessed at index ptest->b[10][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:16:13]: (error) Array 'ptest->b[10][5]' accessed at index ptest->b[0][19], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct TEST\\n\"\n              \"{\\n\"\n              \"    char a[10][5];\\n\"\n              \"};\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    TEST test;\\n\"\n              \"    test.a[9][5] = 4;\\n\"\n              \"    test.a[0][50] = 4;\\n\"\n              \"    TEST *ptest;\\n\"\n              \"    ptest = &test;\\n\"\n              \"    ptest->a[9][5] = 4;\\n\"\n              \"    ptest->a[0][50] = 4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:11]: (error) Array 'test.a[10][5]' accessed at index test.a[9][5], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:9:11]: (error) Array 'test.a[10][5]' accessed at index test.a[0][50], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:12:13]: (error) Array 'ptest->a[10][5]' accessed at index ptest->a[9][5], which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:13:13]: (error) Array 'ptest->a[10][5]' accessed at index ptest->a[0][50], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_35() { // ticket #2889\n        check(\"void f() {\\n\"\n              \"    struct Struct { unsigned m_Var[1]; } s;\\n\"\n              \"    s.m_Var[1] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Array 's.m_Var[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct Struct { unsigned m_Var[1]; };\\n\"\n              \"void f() {\\n\"\n              \"    struct Struct s;\\n\"\n              \"    s.m_Var[1] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Array 's.m_Var[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct Struct { unsigned m_Var[1]; };\\n\"\n              \"void f() {\\n\"\n              \"    struct Struct * s = calloc(40);\\n\"\n              \"    s->m_Var[1] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_36() { // ticket #2960\n        check(\"class Fred {\\n\"\n              \"    Fred(const Fred &);\\n\"\n              \"private:\\n\"\n              \"    bool m_b[2];\\n\"\n              \"};\\n\"\n              \"Fred::Fred(const Fred & rhs) {\\n\"\n              \"    m_b[2] = rhs.m_b[2];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:8]: (error) Array 'm_b[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:7:21]: (error) Array 'rhs.m_b[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_37() {\n        check(\"class Fred {\\n\"\n              \"    char x[X];\\n\"\n              \"    Fred() {\\n\"\n              \"        for (unsigned int i = 0; i < 15; i++)\\n\"\n              \"            i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_38() { //ticket #3273\n        check(\"void aFunction() {\\n\"\n              \"    double aDoubleArray[ 10 ];\\n\"\n              \"    unsigned int i; i = 0;\\n\"\n              \"    for( i = 0; i < 6; i++ )\\n\"\n              \"    {\\n\"\n              \"        unsigned int j; j = 0;\\n\"\n              \"        for( j = 0; j < 5; j++ )\\n\"\n              \"        {\\n\"\n              \"            unsigned int x; x = 0;\\n\"\n              \"            for( x = 0; x < 4; x++ )\\n\"\n              \"            {\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_39() { // ticket 3387\n        check(\"void aFunction()\\n\"\n              \"{\\n\"\n              \"    char a[10];\\n\"\n              \"    a[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_40() {\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    for (int i = 0; i < 10; ++i)\\n\"\n              \"        f2(&a[i + 1]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_41() {\n        // Don't generate false positives when structs have the same name\n        check(\"void a() {\\n\"\n              \"    struct Fred { char data[6]; } fred;\\n\"\n              \"    fred.data[4] = 0;\\n\"  // <- no error\n              \"}\\n\"\n              \"\\n\"\n              \"void b() {\\n\"\n              \"    struct Fred { char data[3]; } fred;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void a() {\\n\"\n              \"    struct Fred { char data[6]; } fred;\\n\"\n              \"    fred.data[4] = 0;\\n\"  // <- no error\n              \"}\\n\"\n              \"\\n\"\n              \"void b() {\\n\"\n              \"    struct Fred { char data[3]; } fred;\\n\"\n              \"    fred.data[4] = 0;\\n\"  // <- error\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (error) Array 'fred.data[3]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_42() { // ticket #3569\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char *p; p = (char *)malloc(10);\\n\"\n              \"  p[10] = 7;\\n\"\n              \"  free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'p[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  float *p; p = (float *)malloc(10 * sizeof(float));\\n\"\n              \"  p[10] = 7;\\n\"\n              \"  free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'p[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char *p; p = (char *)malloc(10);\\n\"\n              \"  p[0] = 0;\\n\"\n              \"  p[9] = 9;\\n\"\n              \"  free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char *p; p = new char[10];\\n\"\n              \"  p[0] = 0;\\n\"\n              \"  p[9] = 9;\\n\"\n              \"  delete [] p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char *p(new char[10]);\\n\"\n              \"  p[0] = 0;\\n\"\n              \"  p[9] = 9;\\n\"\n              \"  delete [] p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char *p = NULL;\"\n              \"  try{\\n\"\n              \"  p = new char[10];\\n\"\n              \"  }\\n\"\n              \"  catch(...){\\n\"\n              \"  return;\\n\"\n              \"  }\"\n              \"  p[0] = 0;\\n\"\n              \"  p[9] = 9;\\n\"\n              \"  delete [] p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_43() { // #3838\n\n        check(\"int f( )\\n\"\n              \"{\\n\"\n              \"  struct {\\n\"\n              \"    int arr[ 3 ];\\n\"\n              \"  } var[ 1 ];\\n\"\n              \"   int y;\\n\"\n              \"   var[ 0 ].arr[ 0 ] = 0;\\n\"\n              \"   var[ 0 ].arr[ 1 ] = 1;\\n\"\n              \"   var[ 0 ].arr[ 2 ] = 2;\\n\"\n              \"   y = var[ 0 ].arr[ 3 ];\\n\" // <-- array access out of bounds\n              \"   return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:20]: (error) Array 'var[0].arr[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"int f( )\\n\"\n              \"{\\n\"\n              \"  struct {\\n\"\n              \"    int arr[ 3 ];\\n\"\n              \"  } var[ 1 ];\\n\"\n              \"   int y=1;\\n\"\n              \"   var[ 0 ].arr[ 0 ] = 0;\\n\"\n              \"   var[ 0 ].arr[ 1 ] = 1;\\n\"\n              \"   var[ 0 ].arr[ 2 ] = 2;\\n\"\n              \"   y = var[ 0 ].arr[ 2 ];\\n\"\n              \"   return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"int f( ){\\n\"\n              \"struct Struct{\\n\"\n              \"    int arr[ 3 ];\\n\"\n              \"};\\n\"\n              \"int y;\\n\"\n              \"Struct var;\\n\"\n              \"var.arr[ 0 ] = 0;\\n\"\n              \"var.arr[ 1 ] = 1;\\n\"\n              \"var.arr[ 2 ] = 2;\\n\"\n              \"var.arr[ 3 ] = 3;\\n\" // <-- array access out of bounds\n              \"y=var.arr[ 3 ];\\n\"   // <-- array access out of bounds\n              \"return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:8]: (error) Array 'var.arr[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:11:10]: (error) Array 'var.arr[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n\n        check(\"void f( ) {\\n\"\n              \"struct S{\\n\"\n              \"    int var[ 3 ];\\n\"\n              \"} ;\\n\"\n              \"S var[2];\\n\"\n              \"var[0].var[ 0 ] = 0;\\n\"\n              \"var[0].var[ 1 ] = 1;\\n\"\n              \"var[0].var[ 2 ] = 2;\\n\"\n              \"var[0].var[ 4 ] = 4;\\n\" // <-- array access out of bounds\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:11]: (error) Array 'var[0].var[3]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f( ) {\\n\"\n              \"struct S{\\n\"\n              \"    int var[ 3 ];\\n\"\n              \"} ;\\n\"\n              \"S var[2];\\n\"\n              \"var[0].var[ 0 ] = 0;\\n\"\n              \"var[0].var[ 1 ] = 1;\\n\"\n              \"var[0].var[ 2 ] = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // avoid FPs (modified examples taken from #3838)\n        check(\"struct AB { int a[10]; int b[10]; };\\n\"\n              \"int main() {\\n\"\n              \"    struct AB ab;\\n\"\n              \"    int * p = &ab.a[10];\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AB { int a[10]; int b[10]; };\\n\"\n              \"int main() {\\n\"\n              \"    struct AB ab[1];\\n\"\n              \"    int * p = &ab[0].a[10];\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AB { int a[10]; int b[10]; };\\n\"\n              \"int main() {\\n\"\n              \"    struct AB ab[1];\\n\"\n              \"    int * p = &ab[10].a[0];\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Array 'ab[1]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_44() { // #3979 (false positive)\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char buf[2];\\n\"\n              \"    int i;\\n\"\n              \"    for (i = 2; --i >= 0; )\\n\"\n              \"    {\\n\"\n              \"        buf[i] = 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    double buf[2];\\n\"\n              \"    for (int i = 2; i--; )\\n\"\n              \"    {\\n\"\n              \"        buf[i] = 2.;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_45() { // #4207 - handling of function with variable number of parameters / unnamed arguments\n        // Variable number of arguments\n        check(\"void f(const char *format, ...) {\\n\"\n              \"    va_args args;\\n\"\n              \"    va_start(args, format);\\n\"\n              \"}\\n\"\n              \"void test() {\\n\"\n              \"    CHAR buffer[1024];\\n\"\n              \"    f(\\\"%s\\\", buffer);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unnamed argument\n        check(\"void f(char *) {\\n\"\n              \"    dostuff();\\n\"\n              \"}\\n\"\n              \"void test() {\\n\"\n              \"    char buffer[1024];\\n\"\n              \"    f(buffer);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Two statement for-loop\n    void array_index_46() {\n        // #4840\n        check(\"void bufferAccessOutOfBounds2() {\\n\"\n              \"    char *buffer[]={\\\"a\\\",\\\"b\\\",\\\"c\\\"};\\n\"\n              \"    for(int i=3; i--;) {\\n\"\n              \"        printf(\\\"files(%i): %s\\\", 3-i, buffer[3-i]);\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Array 'buffer[3]' accessed at index 3, which is out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int buffer[9];\\n\"\n              \"    long int i;\\n\"\n              \"    for(i=10; i--;) {\\n\"\n              \"        buffer[i] = i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (error) Array 'buffer[9]' accessed at index 9, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // Correct access limits -> i from 9 to 0\n        check(\"void f() {\\n\"\n              \"    int buffer[10];\\n\"\n              \"    for(unsigned long int i=10; i--;) {\\n\"\n              \"        buffer[i] = i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_47() {\n        // #5849\n        check(\"int s[4];\\n\"\n              \"void f() {\\n\"\n              \"    for (int i = 2; i < 0; i++)\\n\"\n              \"        s[i] = 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_48() {\n        // #9478\n        check(\"void test(void)\\n\"\n              \"{\\n\"\n              \"    int array[4] = { 1,2,3,4 };\\n\"\n              \"    for (int i = 1; i <= 4; i++) {\\n\"\n              \"        printf(\\\" %i\\\", i);\\n\"\n              \"        array[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:14]: (error) Array 'array[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void test(void)\\n\"\n              \"{\\n\"\n              \"    int array[4] = { 1,2,3,4 };\\n\"\n              \"    for (int i = 1; i <= 4; i++) {\\n\"\n              \"        scanf(\\\"%i\\\", &i);\\n\"\n              \"        array[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_49() {\n        // #8653\n        check(\"void f() {\\n\"\n              \"    int i, k;\\n\"\n              \"    int arr[34] = {};\\n\"\n              \"    i = 1;\\n\"\n              \"    for (k = 0; k < 34 && i < 34; k++) {\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"    arr[k];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_50() {\n        check(\"void f(const char * str) {\\n\"\n              \"    int len = strlen(str);\\n\"\n              \"    (void)str[len - 1];\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    f(\\\"12345678\\\");\\n\"\n              \"    f(\\\"12345\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_51() {\n        check(\"void f(void){\\n\"\n              \"    int k=0, dd, d[1U] = {1};\\n\"\n              \"    for (dd=d[k]; k<10; dd=d[++k]){;}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:29]: (error) Array 'd[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_52() {\n        check(\"char f(void)\\n\"\n              \"{\\n\"\n              \"    char buf[10];\\n\"\n              \"    for(int i = 0, j= 11; i < j; ++i)\\n\"\n              \"       buf[i] = 0;\\n\"\n              \"    return buf[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:11]: (error) Array 'buf[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_53() {\n        check(\"double M[3][1];\\n\"\n              \" \\n\"\n              \"void matrix()\\n\"\n              \"{\\n\"\n              \"    for (int i=0; i < 3; i++)\\n\"\n              \"        for (int j = 0; j < 3; j++)\\n\"\n              \"             M[i][j]=0.0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:15]: (error) Array 'M[3][1]' accessed at index M[*][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_54() {\n        check(\"void f() {\\n\"\n              \"    g(0);\\n\"\n              \"}\\n\"\n              \"void g(unsigned int x) {\\n\"\n              \"    int b[4];\\n\"\n              \"    for (unsigned int i = 0; i < 4; i += 2) {\\n\"\n              \"        b[i]   = 0;\\n\"\n              \"        b[i+1] = 0;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_55() {\n        check(\"void make(const char* s, size_t len) {\\n\"\n              \"    for (size_t i = 0; i < len; ++i)\\n\"\n              \"        s[i];\\n\"\n              \"}\\n\"\n              \"void make(const char* s) {\\n\"\n              \"    make(s, strlen(s));\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    make(\\\"my-utf8-payload\\\");\\n\"\n              \"}\\n\"\n              \"void f2() {\\n\"\n              \"    make(\\\"false\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_56() {\n        check(\"struct s {\\n\"\n              \"    int array[1];\\n\"\n              \"    int index;\\n\"\n              \"};\\n\"\n              \"void f(struct s foo) {\\n\"\n              \"    foo.array[foo.index++] = 1;\\n\"\n              \"    if (foo.index == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_57() {\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    int a[3] = { 1, 2, 3 };\\n\"\n              \"    int i = 0;\\n\"\n              \"    for (auto& x : v) {\\n\"\n              \"        int c = a[i++];\\n\"\n              \"        if (i == 3)\\n\"\n              \"            i = 0;\\n\"\n              \"        x = c;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    int a[3] = { 1, 2, 3 };\\n\"\n              \"    int i = 0;\\n\"\n              \"    for (auto& x : v) {\\n\"\n              \"        int c = a[i++];\\n\"\n              \"        if (i == 4)\\n\"\n              \"            i = 0;\\n\"\n              \"        x = c;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:15] -> [test.cpp:5:18]: (warning) Either the condition 'i==4' is redundant or the array 'a[3]' is accessed at index 3, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\",\n            errout_str());\n    }\n\n    void array_index_58()\n    {\n        check(\"int f(int x, int y) {\\n\"\n              \"    int a[3]= {0,1,2};\\n\"\n              \"    if(x<2)\\n\"\n              \"        y = a[x] + 1;\\n\"\n              \"    else\\n\"\n              \"        y = a[x];\\n\"\n              \"    return y;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:9] -> [test.cpp:6:14]: (warning) Either the condition 'x<2' is redundant or the array 'a[3]' is accessed at index 3, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\" // #2199\n              \"    char a[5];\\n\"\n              \"    for (int i = 0; i < 5; i++) {\\n\"\n              \"        i += 8;\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    char a[5];\\n\"\n              \"    for (int i = 0; i < 5; i++) {\\n\"\n              \"        a[i + 7] = 0;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:10]: (error) Array 'a[5]' accessed at index 8, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n            \"[test.cpp:11:10]: (error) Array 'a[5]' accessed at index 11, which is out of bounds. [arrayIndexOutOfBounds]\\n\",\n            errout_str());\n    }\n\n    void array_index_59() // #10413\n    {\n        check(\"long f(long b) {\\n\"\n              \"  const long a[] = { 0, 1, };\\n\"\n              \"  const long c = std::size(a);\\n\"\n              \"  if (b < 0 || b >= c)\\n\"\n              \"    return 0;\\n\"\n              \"  return a[b];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a, int b) {\\n\"\n              \"    const int S[2] = {};\\n\"\n              \"    if (a < 0) {}\\n\"\n              \"    else {\\n\"\n              \"        if (b < 0) {}\\n\"\n              \"        else if (S[b] > S[a]) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int a[2] = {};\\n\"\n              \"void f(int i) {\\n\"\n              \"    g(i < 0 ? 0 : a[i]);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_60()\n    {\n        checkP(\"#define CKR(B) if (!(B)) { return -1; }\\n\"\n               \"int f(int i) {\\n\"\n               \"  const int A[3] = {};\\n\"\n               \"  CKR(i < 3);\\n\"\n               \"  if (i > 0)\\n\"\n               \"      i = A[i];\\n\"\n               \"  return i;\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define ASSERT(expression, action) if (expression) {action;}\\n\"\n               \"int array[5];\\n\"\n               \"void func (int index) {\\n\"\n               \"    ASSERT(index > 5, return);\\n\"\n               \"    array[index]++;\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:5] -> [test.cpp:5:10]: (warning) Either the condition 'index>5' is redundant or the array 'array[5]' is accessed at index 5, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\",\n            errout_str());\n    }\n\n    void array_index_61()\n    {\n        check(\"int f(int i) {\\n\"\n              \"  const int M[] = { 0, 1, 2, 3 };\\n\"\n              \"  if (i > 4)\\n\"\n              \"      return -1;\\n\"\n              \"  if (i < 0 || i == std::size(M))\\n\"\n              \"    return 0; \\n\"\n              \"  return M[i];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { enum E { e0 }; };\\n\"\n              \"const S::E M[4] = { S::E:e0, S::E:e0, S::E:e0, S::E:e0 };\\n\"\n              \"int f(int i) {\\n\"\n              \"  if (i > std::size(M) + 1)\\n\"\n              \"\t  return -1;\\n\"\n              \"  if (i < 0 || i >= std::size(M))\\n\"\n              \"\t  return 0;\\n\"\n              \"  return M[i]; \\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_62()\n    {\n        check(\"struct X {\\n\"\n              \"    static int GetSize() {return 11;}\\n\"\n              \"};\\n\"\n              \"char f() {\\n\"\n              \"    char buf[10]= {0};\\n\"\n              \"    for(int i = 0; i < X::GetSize(); ++i) \\n\"\n              \"       buf[i] = 0;\\n\"\n              \"    return buf[0];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:11]: (error) Array 'buf[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\",\n                      errout_str());\n    }\n\n    void array_index_63()\n    {\n        check(\"int b[4];\\n\" // #10979\n              \"void f(int i) {\\n\"\n              \"    if (i >= 0 && i < sizeof(b) / sizeof(*(b)))\\n\"\n              \"        b[i] = 0;\\n\"\n              \"    if (i >= 0 && i < sizeof(b) / sizeof((b)[0]))\\n\"\n              \"        b[i] = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_64() // #10878\n    {\n        check(\"struct Array {\\n\"\n              \"    int x[10];\\n\"\n              \"    int& accessArrayRef(int a) { return x[a]; }\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    Array array = {};\\n\"\n              \"    array.accessArrayRef(10);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:42]: (error) Array 'x[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"int i = 10;\\n\"\n              \"struct Array {\\n\"\n              \"    int x[10];\\n\"\n              \"    int& accessArrayRef(int a) { return x[a]; }\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    Array array = {};\\n\"\n              \"    array.accessArrayRef(i);\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3:42]: (error) Array 'x[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", \"\", errout_str());\n    }\n\n    void array_index_65() // #11066\n    {\n        check(\"char P[] = { 2, 1 };\\n\"\n              \"char f[2];\\n\"\n              \"void e(char* c) {\\n\"\n              \"    register j;\\n\"\n              \"    for (j = 0; j < 2; j++)\\n\"\n              \"        c[j] = f[P[j] - 1];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_66()\n    {\n        check(\"void foo(int j) {\\n\"\n              \"    int offsets[256];\\n\"\n              \"    while (x) {\\n\"\n              \"        if (j >= 256) break;\\n\"\n              \"        offsets[++j] = -1;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:15] -> [test.cpp:5:16]: (warning) Either the condition 'j>=256' is redundant or the array 'offsets[256]' is accessed at index 256, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\",\n            errout_str());\n    }\n\n    void array_index_67() {\n        check(\"void func(int i) {\\n\" // #1596\n              \"    int types[3];\\n\"\n              \"    int type_cnt = 0;\\n\"\n              \"    if (i == 0) {\\n\"\n              \"        types[type_cnt] = 0;\\n\"\n              \"        type_cnt++;\\n\"\n              \"        types[type_cnt] = 0;\\n\"\n              \"        type_cnt++;\\n\"\n              \"        types[type_cnt] = 0;\\n\"\n              \"        type_cnt++;\\n\"\n              \"    } else {\\n\"\n              \"        types[type_cnt] = 1;\\n\"\n              \"        type_cnt++;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_68() { // #6655\n        check(\"int ia[10];\\n\"\n              \"void f(int len) {\\n\"\n              \"    for (int i = 0; i < len; i++)\\n\"\n              \"        ia[i] = 0;\\n\"\n              \"}\\n\"\n              \"int g() {\\n\"\n              \"    f(20);\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Array 'ia[10]' accessed at index 19, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    // #6370\n    void array_index_69()\n    {\n        check(\"void f() {\\n\"\n              \"    const int e[] = {0,10,20,30};\\n\"\n              \"    int a[4];\\n\"\n              \"    for(int i = 0; i < 4; ++i)\\n\"\n              \"      a[e[i]] = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (error) Array 'a[4]' accessed at index 30, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    // #11355\n    void array_index_70() {\n        check(\"void f() {\\n\"\n              \"    static const char a[] = ((\\\"test\\\"));\\n\"\n              \"    printf(\\\"%c\\\", a[5]);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Array 'a[5]' accessed at index 5, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    // #11461\n    void array_index_71()\n    {\n        check(\"unsigned int f(unsigned int Idx) {\\n\"\n              \"  if (Idx < 64)\\n\"\n              \"    return 0;\\n\"\n              \"  Idx -= 64;\\n\"\n              \"  int arr[64] = { 0 };\\n\"\n              \"  return arr[Idx];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #11784\n    void array_index_72()\n    {\n        check(\"char f(int i) {\\n\"\n              \"  char d[4] = {};\\n\"\n              \"  for (; i < 3; i++) {}\\n\"\n              \"  for (i++; i > 0;) {\\n\"\n              \"    d[--i] = 1;\\n\"\n              \"    break;\\n\"\n              \"  }\\n\"\n              \"  return d[3];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #11530\n    void array_index_73()\n    {\n        check(\"void f() {\\n\"\n              \"  int k = 0;\\n\"\n              \"  std::function<void(int)> a[1] = {};\\n\"\n              \"  a[k++](0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #11088\n    void array_index_74()\n    {\n        check(\"void foo(const char *keys) {\\n\"\n              \"  const char *prefix = \\\"<Shift+\\\";\\n\"\n              \"  const size_t prefix_len = strlen(prefix);\\n\"\n              \"  if (strncmp(keys, prefix, prefix_len)) { return; }\\n\"\n              \"  if (keys[prefix_len] == '>') {}\\n\"\n              \"}\\n\"\n              \"void bar() {\\n\"\n              \"  foo(\\\"q\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #1644\n    void array_index_75()\n    {\n        check(\"void f() {\\n\"\n              \"    char buf[10];\\n\"\n              \"    int i = 10;\\n\"\n              \"    while (i >= 3)\\n\"\n              \"        buf[i--] = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Array 'buf[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    // #12592\n    void array_index_76()\n    {\n        check(\"void cb0(void*, int i) {\\n\"\n              \"    const char s[] = \\\"\\\";\\n\"\n              \"    (void)s[i];\\n\"\n              \"}\\n\"\n              \"void cb1(int i, void*) {\\n\"\n              \"    const char s[] = \\\"\\\";\\n\"\n              \"    (void)s[i];\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    cb0(nullptr, 1);\\n\"\n              \"    cb1(1, nullptr);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Array 's[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:7:12]: (error) Array 's[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\",\n                      errout_str());\n    }\n\n    void array_index_multidim() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2];\\n\"\n              \"  a[1][1] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2][2];\\n\"\n              \"  a[1][1][1] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2];\\n\"\n              \"  a[2][1] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[2][2]' accessed at index a[2][1], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2];\\n\"\n              \"  a[1][2] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[2][2]' accessed at index a[1][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2][2];\\n\"\n              \"  a[2][1][1] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[2][2][2]' accessed at index a[2][1][1], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2][2];\\n\"\n              \"  a[1][2][1] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[2][2][2]' accessed at index a[1][2][1], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2][2][2];\\n\"\n              \"  a[1][2][1][1] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[2][2][2][2]' accessed at index a[1][2][1][1], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[2][2][2];\\n\"\n              \"  a[1][1][2] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[2][2][2]' accessed at index a[1][1][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  char a[10][10][10];\\n\"\n              \"  a[2*3][4*3][2] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Array 'a[10][10][10]' accessed at index a[6][12][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char a[10][10][10];\\n\"\n              \"  a[6][40][10] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4]: (error) Array 'a[10][10][10]' accessed at index a[6][40][10], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char a[1][1][1];\\n\"\n              \"  a[2][2][2] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4]: (error) Array 'a[1][1][1]' accessed at index a[2][2][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char a[6][6][6];\\n\"\n              \"  a[6][6][2] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4]: (error) Array 'a[6][6][6]' accessed at index a[6][6][2], which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int a[2][2];\\n\"\n              \"  p = &a[2][0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // unknown dim..\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  int a[2][countof(x)] = {{1,2},{3,4}};\\n\"\n              \"  a[0][0] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void draw_quad(float z)  {\\n\"\n              \"    int i;\\n\"\n              \"    float (*vertices)[2][4];\\n\"\n              \"    vertices[0][0][0] = z;\\n\"\n              \"    vertices[0][0][1] = z;\\n\"\n              \"    vertices[1][0][0] = z;\\n\"\n              \"    vertices[1][0][1] = z;\\n\"\n              \"    vertices[2][0][0] = z;\\n\"\n              \"    vertices[2][0][1] = z;\\n\"\n              \"    vertices[3][0][0] = z;\\n\"\n              \"    vertices[3][0][1] = z;\\n\"\n              \"    for (i = 0; i < 4; i++) {\\n\"\n              \"        vertices[i][0][2] = z;\\n\"\n              \"        vertices[i][0][3] = 1.0;\\n\"\n              \"        vertices[i][1][0] = 2.0;\\n\"\n              \"        vertices[i][1][1] = 3.0;\\n\"\n              \"        vertices[i][1][2] = 4.0;\\n\"\n              \"        vertices[i][1][3] = 5.0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            check(\"int foo() {\\n\"\n                  \"  const size_t A = 4;\\n\"\n                  \"  const size_t B = 2;\\n\"\n                  \"  extern int stuff[A][B];\\n\"\n                  \"  return stuff[0][1];\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // TODO: better handling of VLAs in symboldatabase. should be\n            //       possible to use ValueFlow values.\n            check(\"int foo() {\\n\"\n                  \"  const size_t A = 4;\\n\"\n                  \"  const size_t B = 2;\\n\"\n                  \"  extern int stuff[A][B];\\n\"\n                  \"  return stuff[0][1];\\n\"\n                  \"}\");\n            TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n        }\n    }\n\n    void array_index_switch_in_for() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \" int ar[10];\\n\"\n              \" for (int i = 0; i < 10; ++i)\\n\"\n              \" {\\n\"\n              \"  switch(i)\\n\"\n              \"  {\\n\"\n              \"   case 9:\\n\"\n              \"    ar[i] = 0;\\n\"\n              \"    break;\\n\"\n              \"   default:\\n\"\n              \"    ar[i] = ar[i+1];\\n\"\n              \"    break;\\n\"\n              \"  };\\n\"\n              \" }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \" int ar[10];\\n\"\n              \" for (int i = 0; i < 10; ++i)\\n\"\n              \" {\\n\"\n              \"  switch(i)\\n\"\n              \"  {\\n\"\n              \"   case 8:\\n\"\n              \"    ar[i] = 0;\\n\"\n              \"    break;\\n\"\n              \"   default:\\n\"\n              \"    ar[i] = ar[i+1];\\n\"\n              \"    break;\\n\"\n              \"  };\\n\"\n              \" }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:12]: (error) Array index out of bounds.\\n\", \"\", errout_str());\n    }\n\n    void array_index_for_in_for() {\n        check(\"void f() {\\n\"\n              \"    int a[5];\\n\"\n              \"    for (int i = 0; i < 10; ++i) {\\n\"\n              \"        for (int j = i; j < 5; ++j) {\\n\"\n              \"            a[i] = 0;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_bounds() {\n        // #10275\n        check(\"int a[10];\\n\"\n              \"void f(int i) {\\n\"\n              \"  if (i >= 0 && i < 10) {}\\n\"\n              \"  a[i] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19] -> [test.cpp:4:4]: (warning) Either the condition 'i<10' is redundant or the array 'a[10]' is accessed at index 10, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\"\n                      \"[test.cpp:3:9] -> [test.cpp:4:4]: (warning) Either the condition 'i>=0' is redundant or the array 'a[10]' is accessed at index -1, which is out of bounds. [negativeIndex]\\n\",\n                      errout_str());\n    }\n\n    void array_index_calculation() {\n        // #1193 - false negative: array out of bounds in loop when there is calculation\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char data[8];\\n\"\n              \"    for (int i = 19; i < 36; ++i) {\\n\"\n              \"        data[i/2] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Array 'data[8]' accessed at index 17, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // #2199 - false negative: array out of bounds in loop when there is calculation\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char arr[5];\\n\"\n              \"    for (int i = 0; i < 5; ++i) {\\n\"\n              \"        arr[i + 7] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Array 'arr[5]' accessed at index 11, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_negative1() {\n        // #948 - array index out of bound not detected 'a[-1] = 0'\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char data[8];\\n\"\n              \"    data[-1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Array 'data[8]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char data[8][4];\\n\"\n              \"    data[5][-1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Array 'data[8][4]' accessed at index data[*][-1], which is out of bounds. [negativeIndex]\\n\", errout_str());\n\n        // #1614 - negative index is ok for pointers\n        check(\"void foo(char *p)\\n\"\n              \"{\\n\"\n              \"    p[-1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char s[] = \\\"abc\\\";\\n\"\n              \"    char *p = s + strlen(s);\\n\"\n              \"    if (p[-1]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #1850\n        check(\"int f(const std::map<int, std::map<int,int> > &m)\\n\"\n              \"{\\n\"\n              \"    return m[0][-1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_negative2() { // ticket #3063\n        check(\"struct TEST { char a[10]; };\\n\"\n              \"void foo() {\\n\"\n              \"    TEST test;\\n\"\n              \"    test.a[-1] = 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Array 'test.a[10]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    void array_index_negative3() {\n        check(\"int f(int i) {\\n\"\n              \"    int p[2] = {0, 0};\\n\"\n              \"    if(i >= 2)\\n\"\n              \"        return 0;\\n\"\n              \"    else if(i == 0)\\n\"\n              \"        return 0;\\n\"\n              \"    return p[i - 1];\\n\"\n              \"}\\n\"\n              \"void g(int i) {\\n\"\n              \"    if( i == 0 )\\n\"\n              \"        return f(i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_negative4()\n    {\n        check(\"void f(void) {\\n\"\n              \"    int buf[64]={};\\n\"\n              \"    int i;\\n\"\n              \"    for(i=0; i <16; ++i){}\\n\"\n              \"    for(; i < 24; ++i){ buf[i] = buf[i-16];}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_negative5() // #10526\n    {\n        check(\"int i;\\n\"\n              \"std::vector<int> v;\\n\"\n              \"bool f() {\\n\"\n              \"    if (i != 0) {\\n\"\n              \"        if (v.begin() != v.end()) {\\n\"\n              \"            if (i < 0)\\n\"\n              \"                return false;\\n\"\n              \"            const int a[4] = { 0, 1, 2, 3 };\\n\"\n              \"            return a[i - 1] > 0;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #11349\n    void array_index_negative6()\n    {\n        check(\"void f(int i) {\\n\"\n              \"  int j = i;\\n\"\n              \"  const int a[5] = {};\\n\"\n              \"  const int k = j < 0 ? 0 : j;\\n\"\n              \"  (void)a[k];\\n\"\n              \"  if (i == -3) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #5685\n    void array_index_negative7()\n    {\n        check(\"void f() {\\n\"\n              \"    int i = -9;\\n\"\n              \"    int a[5];\\n\"\n              \"    for (; i < 5; i++)\\n\"\n              \"        a[i] = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[5]' accessed at index -9, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    // #11651\n    void array_index_negative8()\n    {\n        check(\"unsigned g(char*);\\n\"\n              \"void f() {\\n\"\n              \"    char buf[10];\\n\"\n              \"    unsigned u = g(buf);\\n\"\n              \"    for (int i = u, j = sizeof(i); --i >= 0;)\\n\"\n              \"        char c = buf[i];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #8075\n    void array_index_negative9()\n    {\n        check(\"int g(int i) {\\n\"\n              \"    if (i < 10)\\n\"\n              \"        return -1;\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    int a[] = { 1, 2, 3 };\\n\"\n              \"    printf(\\\"%d\\\\n\\\", a[g(4)]);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:21]: (error) Array 'a[3]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    // #11844\n    void array_index_negative10()\n    {\n        check(\"struct S { int a[4]; };\\n\"\n              \"void f(S* p, int k) {\\n\"\n              \"  int m = 3;\\n\"\n              \"  if (k)\\n\"\n              \"    m = 2;\\n\"\n              \"  for (int j = m + 1; j <= 4; j++)\\n\"\n              \"    p->a[j-1];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_for_decr() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char data[8];\\n\"\n              \"    for (int i = 10; i > 0; --i) {\\n\"\n              \"        data[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Array 'data[8]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char val[5];\\n\"\n              \"    for (unsigned int i = 3; i < 5; --i) {\\n\"\n              \"        val[i+1] = val[i];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char val[5];\\n\"\n              \"    for (int i = 3; i < 5; --i) {\\n\"\n              \"        val[i+1] = val[i];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Array 'val[5]' accessed at index -9994, which is out of bounds. [negativeIndex]\\n\"\n                      \"[test.cpp:5:23]: (error) Array 'val[5]' accessed at index -9995, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n\n    void array_index_varnames() {\n        check(\"struct A {\\n\"\n              \"    char data[4];\\n\"\n              \"    struct B { char data[3]; };\\n\"\n              \"    B b;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    A a;\\n\"\n              \"    a.data[3] = 0;\\n\"\n              \"    a.b.data[2] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #1586\n        check(\"struct A {\\n\"\n              \"    char data[4];\\n\"\n              \"    struct B { char data[3]; };\\n\"\n              \"    B b;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    A a;\\n\"\n              \"    a.data[4] = 0;\\n\"\n              \"    a.b.data[3] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:11]: (error) Array 'a.data[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\"\n                      \"[test.cpp:11:13]: (error) Array 'a.b.data[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_for_andand_oror() {  // #3907 - using && or ||\n        // extracttests.start: volatile int y;\n\n        check(\"void f() {\\n\"\n              \"    char data[2];\\n\"\n              \"    int x;\\n\"\n              \"    for (x = 0; x < 10 && y; x++) {\\n\"\n              \"        data[x] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Array 'data[2]' accessed at index 9, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char data[2];\\n\"\n              \"    int x;\\n\"\n              \"    for (x = 0; x < 10 || y; x++) {\\n\"\n              \"        data[x] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Array 'data[2]' accessed at index 9, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char data[2];\\n\"\n              \"    int x;\\n\"\n              \"    for (x = 0; x <= 10 && y; x++) {\\n\"\n              \"        data[x] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Array 'data[2]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char data[2];\\n\"\n              \"    int x;\\n\"\n              \"    for (x = 0; y && x <= 10; x++) {\\n\"\n              \"        data[x] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Array 'data[2]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"int f() {\\n\" // #9126\n              \"    int i, c;\\n\"\n              \"    char* words[100] = {0};\\n\"\n              \"    g(words);\\n\"\n              \"    for (i = c = 0; (i < N) && (c < 1); i++) {\\n\"\n              \"        if (words[i][0] == '|')\\n\"\n              \"            c++;\\n\"\n              \"     }\\n\"\n              \"    return c;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_for_continue() {\n        // #3913\n        check(\"void f() {\\n\"\n              \"    int a[2];\\n\"\n              \"    for (int i = 0; i < 2; ++i) {\\n\"\n              \"        if (i == 0) {\\n\"\n              \"            continue;\\n\"\n              \"        }\\n\"\n              \"        a[i - 1] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: int maybe();\n        check(\"void f() {\\n\"\n              \"    int a[2];\\n\"\n              \"    for (int i = 0; i < 2; ++i) {\\n\"\n              \"        if (maybe()) {\\n\"\n              \"            continue;\\n\"\n              \"        }\\n\"\n              \"        a[i - 1] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (error) Array 'a[2]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    void array_index_for() {\n        // Ticket #2370 - No false negative when there is no \"break\"\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 20; ++i) {\\n\"\n              \"        if (i==1) {\\n\"\n              \"        }\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: (error) Array 'a[10]' accessed at index 19, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // Ticket #2385 - No false positive\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i < 20; ++i) {\\n\"\n              \"        if (i<10) {\\n\"\n              \"        } else {\\n\"\n              \"            a[i-10] = 0;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #3893 - start value out of bounds\n        // extracttests.start: int maybe(); int dostuff();\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 10; maybe(); dostuff()) {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // #7686\n        check(\"char f() {\\n\"\n              \"    char buf[10];\\n\"\n              \"    const bool a = true, b = true;\\n\"\n              \"    for (int i = 0; i < (a && b ? 11 : 10); ++i)\\n\"\n              \"        buf[i] = 0;\\n\"\n              \"    return buf[0];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Array 'buf[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const int a[10] = {};\\n\"\n              \"    for (int n = 0; 1; ++n) {\\n\"\n              \"        if (a[n] < 1) {\\n\"\n              \"            switch (a[n]) {\\n\"\n              \"            case 0:\\n\"\n              \"                break;\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Array 'a[10]' accessed at index 9998, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_for_neq() {\n        // Ticket #2211 - for loop using != in the condition\n        check(\"void f() {\\n\"\n              \"    int a[5];\\n\"\n              \"    for (int i = 0; i != 10; ++i) {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'a[5]' accessed at index 9, which is out of bounds. [arrayIndexOutOfBounds]\\n\",\n                      errout_str());\n    }\n\n    void array_index_for_question() {\n        // Ticket #2561 - using ?: inside for loop\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i != 10; ++i) {\\n\"\n              \"        i == 0 ? 0 : a[i-1];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i != 10; ++i) {\\n\"\n              \"        some_condition ? 0 : a[i-1];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:31]: (error) Array 'a[10]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a[10];\\n\"\n              \"    for (int i = 0; i != 10; ++i) {\\n\"\n              \"        i==0 ? 0 : a[i-1];\\n\"\n              \"        a[i-1] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'a[10]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    void array_index_for_varid0() { // #4228: No varid for counter variable\n        check(\"void f() {\\n\"\n              \"   char a[10];\\n\"\n              \"   for (i=0; i<10; i++);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_vla_for() {\n        // #3221 - access VLA inside for\n        check(\"void f(int len) {\\n\"\n              \"    char a[len];\\n\"\n              \"    for (int i=0; i<7; ++i) {\\n\"\n              \"        a[0] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_extern() {\n        // Ticket #1684. FP when using 'extern'.\n        check(\"extern char arr[15];\\n\"\n              \"char arr[15] = \\\"abc\\\";\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_cast() {\n        // Ticket #2841. FP when using cast.\n\n        // Different types => no error\n        check(\"void f1(char *buf) {\\n\"\n              \"    buf[4] = 0;\\n\"\n              \"}\\n\"\n              \"void f2() {\\n\"\n              \"    int x[2];\\n\"\n              \"    f1(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Same type => error\n        check(\"void f1(const char buf[]) {\\n\"\n              \"    char c = buf[4];\\n\"\n              \"}\\n\"\n              \"void f2() {\\n\"\n              \"    char x[2];\\n\"\n              \"    f1(x);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6] -> [test.cpp:2]: (error) Array 'x[2]' accessed at index 4, which is out of bounds.\\n\",\n                           \"\",\n                           errout_str());\n    }\n\n    void array_index_string_literal() {\n        check(\"void f() {\\n\"\n              \"    const char *str = \\\"abc\\\";\\n\"\n              \"    bar(str[10]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Array 'str[4]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    const char *str = \\\"abc\\\";\\n\"\n              \"    bar(str[4]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Array 'str[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    const char *str = \\\"abc\\\";\\n\"\n              \"    bar(str[3]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    const char *str = \\\"a\\tc\\\";\\n\"\n              \"    bar(str[4]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Array 'str[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #6973\n              \"    const char *name = \\\"\\\";\\n\"\n              \"    if ( name[0] == 'U' ? name[1] : 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main(int argc, char **argv) {\\n\"\n              \"    char str[6] = \\\"\\\\0\\\";\\n\"\n              \"    unsigned short port = 65535;\\n\"\n              \"    snprintf(str, sizeof(str), \\\"%hu\\\", port);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings0, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int x) {\\n\" // #11020\n              \"    const char* p = (x == 0 ? \\\"12345\\\" : \\\"ABC\\\");\\n\"\n              \"    int s = 0;\\n\"\n              \"    for (int i = 0; p[i]; i++)\\n\"\n              \"        s += p[i];\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_same_struct_and_var_name() {\n        // don't throw internal error\n        check(\"struct tt {\\n\"\n              \"    char name[21];\\n\"\n              \"} ;\\n\"\n              \"void doswitch(struct tt *x)\\n\"\n              \"{\\n\"\n              \"    struct tt *tt=x;\\n\"\n              \"    tt->name;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // detect error\n        check(\"struct tt {\\n\"\n              \"    char name[21];\\n\"\n              \"} ;\\n\"\n              \"void doswitch(struct tt *x)\\n\"\n              \"{\\n\"\n              \"    struct tt *tt=x;\\n\"\n              \"    tt->name[22] = 123;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:13]: (error) Array 'tt->name[21]' accessed at index 22, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_valueflow() {\n        check(\"void f(int i) {\\n\"\n              \"    char str[3];\\n\"\n              \"    str[i] = 0;\\n\"\n              \"    if (i==10) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10] -> [test.cpp:3:8]: (warning) Either the condition 'i==10' is redundant or the array 'str[3]' is accessed at index 10, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    char str[3];\\n\"\n              \"    str[i] = 0;\\n\"\n              \"    switch (i) {\\n\"\n              \"    case 10: break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5] -> [test.cpp:3:8]: (warning) Either the switch case 'case 10' is redundant or the array 'str[3]' is accessed at index 10, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char str[3];\\n\"\n              \"    str[((unsigned char)3) - 1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"  // #5416 FP\n              \"    char *str[3];\\n\"\n              \"    do_something(&str[0][5]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class X { static const int x[100]; };\\n\" // #6070\n              \"const int X::x[100] = {0};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace { class X { static const int x[100]; };\\n\" // #6232\n              \"const int X::x[100] = {0}; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class ActorSprite { static ImageSet * targetCursorImages[2][10]; };\\n\"\n              \"ImageSet *ActorSprite::targetCursorImages[2][10];\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::size_t s) {\\n\" // #10130\n              \"    const char a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\\n\"\n              \"    return (s > sizeof(a)) ? 11 : (int)a[s];\\n\"\n              \"}\\n\"\n              \"int g() {\\n\"\n              \"    return f(16);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:15] -> [test.cpp:3:41]: (warning) Either the condition 's>sizeof(a)' is redundant or the array 'a[16]' is accessed at index 16, which is out of bounds. [arrayIndexOutOfBoundsCond]\\n\",\n                      errout_str());\n\n        check(\"void f(int fd) {\\n\" // #12318\n              \"    char buf[10];\\n\"\n              \"    int size = 0;\\n\"\n              \"    int pos = -1;\\n\"\n              \"    do {\\n\"\n              \"        pos++;\\n\"\n              \"        size = read(fd, &buf[pos], 1);\\n\"\n              \"    } while (size > 0);\\n\"\n              \"    buf[pos] = '\\\\0';\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void array_index_valueflow_pointer() {\n        check(\"void f() {\\n\"\n              \"  int a[10];\\n\"\n              \"  int *p = a;\\n\"\n              \"  p[20] = 0;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:4]: (error) Array 'a[10]' accessed at index 20, which is out of bounds.\\n\", \"\", errout_str());\n\n        {\n            // address of\n            check(\"void f() {\\n\"\n                  \"  int a[10];\\n\"\n                  \"  int *p = a;\\n\"\n                  \"  p[10] = 0;\\n\"\n                  \"}\");\n            TODO_ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:4:6]: (error) Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", \"\", errout_str());\n\n            check(\"void f() {\\n\"\n                  \"  int a[10];\\n\"\n                  \"  int *p = a;\\n\"\n                  \"  dostuff(&p[10]);\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"void f() {\\n\"\n              \"  int a[X];\\n\" // unknown size\n              \"  int *p = a;\\n\"\n              \"  p[20] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int a[2];\\n\"\n              \"  char *p = (char *)a;\\n\" // cast\n              \"  p[4] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_function_parameter() {\n        check(\"void f(char a[10]) {\\n\"\n              \"  a[20] = 0;\\n\" // <- cppcheck warn here even though it's not a definite access out of bounds\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:4]: (error) Array 'a[10]' accessed at index 20, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(char a[10]) {\\n\" // #6353 - reassign 'a'\n              \"  a += 4;\\n\"\n              \"  a[-1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char a[10]) {\\n\"\n              \"  a[0] = 0;\\n\"\n              \"  a[-1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4]: (error) Array 'a[10]' accessed at index -1, which is out of bounds. [negativeIndex]\\n\", errout_str());\n    }\n\n    void array_index_enum_array() { // #8439\n        check(\"enum E : unsigned int { e1, e2 };\\n\"\n              \"void f() {\\n\"\n              \"    E arrE[] = { e1, e2 };\\n\"\n              \"    arrE[sizeof(arrE)] = e1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Array 'arrE[2]' accessed at index 8, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void array_index_container() { // #9386\n        check(\"constexpr int blockLen = 10;\\n\"\n              \"void foo(std::array<uint8_t, blockLen * 2>& a) {\\n\"\n              \"    a[2] = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_two_for_loops() {\n        check(\"bool b();\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    int val[50];\\n\"\n              \"    int i, sum=0;\\n\"\n              \"    for (i = 1; b() && i < 50; i++)\\n\"\n              \"        sum += val[i];\\n\"\n              \"    if (i < 50)\\n\"\n              \"        sum -= val[i];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool b();\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    int val[50];\\n\"\n              \"    int i, sum=0;\\n\"\n              \"    for (i = 1; b() && i < 50; i++)\\n\"\n              \"        sum += val[i];\\n\"\n              \"    for (; i < 50;) {\\n\"\n              \"        sum -= val[i];\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool b();\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    int val[50];\\n\"\n              \"    int i, sum=0;\\n\"\n              \"    for (i = 1; b() && i < 50; i++)\\n\"\n              \"        sum += val[i];\\n\"\n              \"    for (; i < 50; i++)\\n\"\n              \"        sum -= val[i];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void array_index_new() { // #7690\n        check(\"void f() {\\n\"\n              \"    int* z = new int;\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = 0;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[1]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* z = new int(1);\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = 0;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[1]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* z = new int{};\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = 0;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[1]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* z = new int[5];\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = 0;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[5]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void g() {\\n\"\n              \"    int* z = new int[5]();\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = 1;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[5]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void h() {\\n\"\n              \"    int** z = new int* [5];\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = nullptr;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[5]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void h() {\\n\"\n              \"    int** z = new int* [5]();\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = nullptr;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[5]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void h() {\\n\"\n              \"    int** z = new int* [5]{};\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = nullptr;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[5]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void h() {\\n\"\n              \"    int** z = new int* [5]{ 0 };\\n\"\n              \"    for (int n = 0; n < 8; ++n)\\n\"\n              \"        z[n] = nullptr;\\n\"\n              \"    delete[] z;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Array 'z[5]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_2_struct() {\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[5];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    strcpy( abc->str, \\\"abcdef\\\" );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:16]: (error) Buffer is accessed out of bounds: abc->str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[5];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC abc;\\n\"\n              \"    strcpy( abc.str, \\\"abcdef\\\" );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:16]: (error) Buffer is accessed out of bounds: abc.str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"struct ABC\\n\"\n              \"{\\n\"\n              \"    char str[5];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void f(struct ABC &abc)\\n\"\n              \"{\\n\"\n              \"    strcpy( abc.str, \\\"abcdef\\\" );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:16]: (error) Buffer is accessed out of bounds: abc.str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC\\n\"\n              \"    {\\n\"\n              \"        char str[5];\\n\"\n              \"    } abc;\\n\"\n              \"    strcpy( abc.str, \\\"abcdef\\\" );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:16]: (error) Buffer is accessed out of bounds: abc.str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"static void f()\\n\"\n              \"{\\n\"\n              \"    struct ABC\\n\"\n              \"    {\\n\"\n              \"        char str[5];\\n\"\n              \"    };\\n\"\n              \"    struct ABC *abc = malloc(sizeof(struct ABC));\\n\"\n              \"    strcpy( abc->str, \\\"abcdef\\\" );\\n\"\n              \"    free(abc);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:16]: (error) Buffer is accessed out of bounds: abc->str [bufferAccessOutOfBounds]\\n\", errout_str());\n    }\n\n\n    void buffer_overrun_3() {\n        check(\"int a[10];\\n\"\n              \"\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    int i;\\n\"\n              \"    for (i = 0; i <= 10; ++i)\\n\"\n              \"        a[i] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (error) Array 'a[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct S { int b; } static e[1];\\n\" // #11052\n              \"int f() { return e[1].b; }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (error) Array 'e[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n\n    void buffer_overrun_4() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    const char *p[2];\\n\"\n              \"    for (int i = 0; i < 8; ++i)\\n\"\n              \"        p[i] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Array 'p[2]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // No false positive\n        check(\"void foo(int x, int y)\\n\"\n              \"{\\n\"\n              \"    const char *p[2];\\n\"\n              \"    const char *s = y + p[1];\\n\"\n              \"    p[1] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // There is no error here\n        check(\"void f1(char *s,int size)\\n\"\n              \"{\\n\"\n              \"  if( size > 10 ) strcpy(s,\\\"abc\\\");\\n\"\n              \"}\\n\"\n              \"void f2()\\n\"\n              \"{\\n\"\n              \"  char s[3];\\n\"\n              \"  f1(s,20);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:8] -> [test.cpp:3]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f1(char *s,int size)\\n\"\n              \"{\\n\"\n              \"  if( size > 10 ) strcpy(s,\\\"abc\\\");\\n\"\n              \"}\\n\"\n              \"void f2()\\n\"\n              \"{\\n\"\n              \"  char s[3];\\n\"\n              \"  f1(s,3);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_5() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char n[5];\\n\"\n              \"    sprintf(n, \\\"d\\\");\\n\"\n              \"    printf(\\\"hello!\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_6() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   char n[5];\\n\"\n              \"   strcat(n, \\\"abc\\\");\\n\"\n              \"   strcat(n, \\\"def\\\");\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Buffer is accessed out of bounds: n\\n\", \"\", errout_str());\n\n        check(\"void f()\\n\" // #12489\n              \"{\\n\"\n              \"   char d[3] = {};\\n\"\n              \"   strcat(d, \\\"12345678\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Buffer is accessed out of bounds: d [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   char d[3] = \\\"ab\\\"; \\n\"\n              \"   strcat(d, \\\"c\\\");\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Buffer is accessed out of bounds: d [bufferAccessOutOfBounds]\\n\", \"\", errout_str());\n    }\n\n    void buffer_overrun_7() {\n        // ticket #731\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[2];\\n\"\n              \"    strcpy(a, \\\"a\\\\0\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_8() {\n        // ticket #714\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[5];\\n\"\n              \"    for (int i = 0; i < 20; i = i + 100)\\n\"\n              \"    {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[5];\\n\"\n              \"    for (int i = 0; i < 20; i = 100 + i)\\n\"\n              \"    {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_9() {\n        // ticket #738\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[5];\\n\"\n              \"    for (int i = 0; i < 20; )\\n\"\n              \"    {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"        i += 100;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_10() {\n        // ticket #740\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[4];\\n\"\n              \"    for (int i = 0; i < 4; i++)\\n\"\n              \"    {\\n\"\n              \"        char b = a[i];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_11() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[4];\\n\"\n              \"    for (float i=0; i<10.0;i=i+0.1)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char a[4];\\n\"\n              \"    for (float i=0; i<10.0;i=0.1+i)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_15() { // ticket #1787\n        check(\"class A : public B {\\n\"\n              \"    char val[2];\\n\"\n              \"    void f(int i, int ii);\\n\"\n              \"};\\n\"\n              \"void A::f(int i, int ii)\\n\"\n              \"{\\n\"\n              \"    strcpy(val, \\\"ab\\\") ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:12]: (error) Buffer is accessed out of bounds: val [bufferAccessOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_16() {\n        // unknown types\n        check(\"void f() {\\n\"\n              \"    struct Foo foo[5];\\n\"\n              \"    memset(foo, 0, sizeof(foo));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"  // ticket #2093\n              \"    gchar x[3];\\n\"\n              \"    strcpy(x, \\\"12\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"extern char a[10];\\n\"\n              \"void f() {\\n\"\n              \"    char b[25] = {0};\\n\"\n              \"    std::memcpy(b, a, 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_18() { // ticket #2576\n        check(\"class A {\\n\"\n              \"    void foo();\\n\"\n              \"    bool b[7];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void A::foo() {\\n\"\n              \"    for (int i=0; i<6; i++) {\\n\"\n              \"        b[i] = b[i+1];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A {\\n\"\n              \"    void foo();\\n\"\n              \"    bool b[7];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void A::foo() {\\n\"\n              \"    for (int i=0; i<7; i++) {\\n\"\n              \"        b[i] = b[i+1];\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:17]: (error) Array 'b[7]' accessed at index 7, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_19() { // #2597 - class member with unknown type\n        check(\"class A {\\n\"\n              \"public:\\n\"\n              \"    u8 buf[10];\\n\"\n              \"    A();\"\n              \"};\\n\"\n              \"\\n\"\n              \"A::A() {\\n\"\n              \"    memset(buf, 0, 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_21() {\n        check(\"void foo()\\n\"\n              \"{ { {\\n\"\n              \"    char dst[4];\\n\"\n              \"    const char *src = \\\"AAAAAAAAAAAAAAAAAAAAA\\\";\\n\"\n              \"    for (size_t i = 0; i <= 4; i++)\\n\"\n              \"        dst[i] = src[i];\\n\"\n              \"} } }\");\n        ASSERT_EQUALS(\"[test.cpp:6:12]: (error) Array 'dst[4]' accessed at index 4, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_24() { // index variable is changed in for-loop\n        // ticket #4106\n        check(\"void main() {\\n\"\n              \"   int array[] = {1,2};\\n\"\n              \"   int x = 0;\\n\"\n              \"   for( int i = 0; i<6; ) {\\n\"\n              \"      x += array[i];\\n\"\n              \"       i++;  }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        // ticket #4096\n        check(\"void main() {\\n\"\n              \"   int array[] = {1,2};\\n\"\n              \"   int x = 0;\\n\"\n              \"   for( int i = 0; i<6; ) {\\n\"\n              \"      x += array[i++];\\n\"\n              \"   }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n    }\n\n    void buffer_overrun_26() { // ticket #4432 (segmentation fault)\n        check(\"extern int split();\\n\"\n              \"void regress() {\\n\"\n              \"    char inbuf[1000];\\n\"\n              \"    char *f[10];\\n\"\n              \"    split(inbuf, f, 10, \\\"\\t\\t\\\");\\n\"\n              \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_27() { // ticket #4444 (segmentation fault)\n        check(\"void abc(struct foobar[5]);\\n\"\n              \"void main() {\\n\"\n              \"struct foobar x[5];\\n\"\n              \"abc(x);\\n\"\n              \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #7083: false positive: typedef and initialization with strings\n    void buffer_overrun_29() {\n        check(\"typedef char testChar[10];\\n\"\n              \"int main(){\\n\"\n              \"  testChar tc1 = \\\"\\\";\\n\"\n              \"  tc1[5]='a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    // #6367\n    void buffer_overrun_30() {\n        check(\"struct S { int m[9]; };\\n\"\n              \"int f(S * s) {\\n\"\n              \"    return s->m[sizeof(s->m)];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Array 's->m[9]' accessed at index 36, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_31() {\n        check(\"void f(WhereInfo *pWInfo, int *aiCur) {\\n\"\n              \"  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_32() {\n        // destination size is too small\n        check(\"void f(void) {\\n\"\n              \"    const char src[3] = \\\"abc\\\";\\n\"\n              \"    char dest[1] = \\\"a\\\";\\n\"\n              \"    (void)strxfrm(dest,src,1);\\n\"\n              \"    (void)strxfrm(dest,src,2);\\n\"// <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (error) Buffer is accessed out of bounds: dest [bufferAccessOutOfBounds]\\n\", errout_str());\n        // destination size is too small\n        check(\"void f(void) {\\n\"\n              \"    const char src[3] = \\\"abc\\\";\\n\"\n              \"    char dest[2] = \\\"ab\\\";\\n\"\n              \"    (void)strxfrm(dest,src,1);\\n\"\n              \"    (void)strxfrm(dest,src,2);\\n\"\n              \"    (void)strxfrm(dest,src,3);\\n\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:19]: (error) Buffer is accessed out of bounds: dest [bufferAccessOutOfBounds]\\n\", errout_str());\n        // source size is too small\n        check(\"void f(void) {\\n\"\n              \"    const char src[2] = \\\"ab\\\";\\n\"\n              \"    char dest[3] = \\\"abc\\\";\\n\"\n              \"    (void)strxfrm(dest,src,1);\\n\"\n              \"    (void)strxfrm(dest,src,2);\\n\"\n              \"    (void)strxfrm(dest,src,3);\\n\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:24]: (error) Buffer is accessed out of bounds: src [bufferAccessOutOfBounds]\\n\", errout_str());\n        // source size is too small\n        check(\"void f(void) {\\n\"\n              \"    const char src[1] = \\\"a\\\";\\n\"\n              \"    char dest[3] = \\\"abc\\\";\\n\"\n              \"    (void)strxfrm(dest,src,1);\\n\"\n              \"    (void)strxfrm(dest,src,2);\\n\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:24]: (error) Buffer is accessed out of bounds: src [bufferAccessOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_33() { // #2019\n        check(\"int f() {\\n\"\n              \"   int z[16];\\n\"\n              \"   for (int i=0; i<20; i++)\\n\"\n              \"      for (int j=0; j<20; j++)\\n\"\n              \"          z[i] = 0;\\n\"\n              \"   return z[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Array 'z[16]' accessed at index 19, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void buffer_overrun_34() { // #11035\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    int a[15] = {};\\n\"\n              \"    int g() const { return v.size(); }\\n\"\n              \"    int f(int i) const {\\n\"\n              \"        if (i < 0 || i >= g())\\n\"\n              \"            return 0;\\n\"\n              \"        return a[i];\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_35() { // #2304\n        check(\"void f() {\\n\"\n              \"    char* q = \\\"0123456789\\\";\\n\"\n              \"    char* p = (char*)malloc(sizeof(q) + 1);\\n\"\n              \"    strcpy(p, q);\\n\"\n              \"    free(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Buffer is accessed out of bounds: p [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char* q = \\\"0123456789\\\";\\n\"\n              \"    char* p = (char*)malloc(1);\\n\"\n              \"    strcpy(p, q);\\n\"\n              \"    free(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Buffer is accessed out of bounds: p [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"typedef struct { char buf[1]; } S;\\n\"\n              \"S* f() {\\n\"\n              \"    S* s = NULL;\\n\"\n              \"    s = (S*)malloc(sizeof(S) + 10);\\n\"\n              \"    sprintf((char*)s->buf, \\\"abc\\\");\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_36() { // #11708\n        check(\"void f(double d) {\\n\"\n              \"    char a[80];\\n\"\n              \"    sprintf(a, \\\"%2.1f\\\", d);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_errorpath() {\n        setMultiline();\n        const Settings settingsOld = settings0; // TODO: get rid of this\n        settings0.templateLocation = \"{file}:{line}:note:{info}\";\n\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    memset(p, 0, 20);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: error: Buffer is accessed out of bounds: p [bufferAccessOutOfBounds]\\n\"\n                      \"[test.cpp:2:13]: note: Assign p, buffer with size 10\\n\"\n                      \"[test.cpp:3:12]: note: Buffer overrun\\n\", errout_str());\n\n        settings0 = settingsOld;\n    }\n\n    void buffer_overrun_bailoutIfSwitch() {\n        // No false positive\n        check(\"void f1(char *s) {\\n\"\n              \"    if (x) s[100] = 0;\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void f2() {\\n\"\n              \"    char a[10];\\n\"\n              \"    f1(a);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // No false positive\n        check(\"void f1(char *s) {\\n\"\n              \"    if (x) return;\\n\"\n              \"    s[100] = 0;\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void f2() {\\n\"\n              \"    char a[10];\\n\"\n              \"    f1(a);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // No false negative\n        check(\"void f1(char *s) {\\n\"\n              \"    if (x) { }\\n\"\n              \"    s[100] = 0;\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void f2() {\\n\"\n              \"    char a[10];\\n\"\n              \"    f1(a);\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:8] -> [test.cpp:3]: (error) Array 'a[10]' accessed at index 100, which is out of bounds.\\n\", \"\", errout_str());\n    }\n\n    void buffer_overrun_function_array_argument() {\n        setMultiline();\n\n        check(\"void f(char a[10]);\\n\"\n              \"void g() {\\n\"\n              \"    char a[2];\\n\"\n              \"    f(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: warning: Buffer 'a' is too small, the function 'f' expects a bigger buffer in 1st argument [argumentSize]\\n\"\n                      \"[test.cpp:4:5]: note: Function 'f' is called\\n\"\n                      \"[test.cpp:1:13]: note: Declaration of 1st function argument.\\n\"\n                      \"[test.cpp:3:10]: note: Passing buffer 'a' to function that is declared here\\n\"\n                      \"[test.cpp:4:5]: note: Buffer 'a' is too small, the function 'f' expects a bigger buffer in 1st argument\\n\", errout_str());\n\n        check(\"void f(float a[10][3]);\\n\"\n              \"void g() {\\n\"\n              \"    float a[2][3];\\n\"\n              \"    f(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: warning: Buffer 'a' is too small, the function 'f' expects a bigger buffer in 1st argument [argumentSize]\\n\"\n                      \"[test.cpp:4:5]: note: Function 'f' is called\\n\"\n                      \"[test.cpp:1:14]: note: Declaration of 1st function argument.\\n\"\n                      \"[test.cpp:3:11]: note: Passing buffer 'a' to function that is declared here\\n\"\n                      \"[test.cpp:4:5]: note: Buffer 'a' is too small, the function 'f' expects a bigger buffer in 1st argument\\n\", errout_str());\n\n        check(\"void f(int a[20]);\\n\"\n              \"void g() {\\n\"\n              \"    int a[2];\\n\"\n              \"    f(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: warning: Buffer 'a' is too small, the function 'f' expects a bigger buffer in 1st argument [argumentSize]\\n\"\n                      \"[test.cpp:4:5]: note: Function 'f' is called\\n\"\n                      \"[test.cpp:1:12]: note: Declaration of 1st function argument.\\n\"\n                      \"[test.cpp:3:9]: note: Passing buffer 'a' to function that is declared here\\n\"\n                      \"[test.cpp:4:5]: note: Buffer 'a' is too small, the function 'f' expects a bigger buffer in 1st argument\\n\", errout_str());\n\n        check(\"void f(int a[]) {\\n\"\n              \"  switch (2) {\\n\"\n              \"    case 1:\\n\"\n              \"      a[1] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"int a[1];\\n\"\n              \"f(a);\\n\"\n              \"\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void CreateLeafTex(unsigned char buf[256][2048][4]);\\n\"\n              \"void foo() {\\n\"\n              \"  unsigned char(* tree)[2048][4] = new unsigned char[256][2048][4];\\n\"\n              \"  CreateLeafTex(tree);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a[10]) {\\n\" // #10069\n              \"    int i = 0;\\n\"\n              \"    for (i = 0; i < 10; i++)\\n\"\n              \"        a[i] = i * 2;\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    int b[5];\\n\"\n              \"    f(b);\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: warning: Buffer 'b' is too small, the function 'f' expects a bigger buffer in 1st argument [argumentSize]\\n\"\n                      \"[test.cpp:8:5]: note: Function 'f' is called\\n\"\n                      \"[test.cpp:1:12]: note: Declaration of 1st function argument.\\n\"\n                      \"[test.cpp:7:9]: note: Passing buffer 'b' to function that is declared here\\n\"\n                      \"[test.cpp:8:5]: note: Buffer 'b' is too small, the function 'f' expects a bigger buffer in 1st argument\\n\",\n                      errout_str());\n    }\n\n    void possible_buffer_overrun_1() { // #3035\n        check(\"void foo() {\\n\"\n              \"    char * data = (char *)alloca(50);\\n\"\n              \"    char src[100];\\n\"\n              \"    memset(src, 'C', 99);\\n\"\n              \"    src[99] = '\\\\0';\\n\"\n              \"    strcat(data, src);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (warning) Possible buffer overflow if strlen(src) is larger than sizeof(data)-strlen(data).\\n\", \"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char * data = (char *)alloca(100);\\n\"\n              \"    char src[100];\\n\"\n              \"    memset(src, 'C', 99);\\n\"\n              \"    src[99] = '\\\\0';\\n\"\n              \"    strcat(data, src);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char src[100]) {\\n\"\n              \"    char * data = (char *)alloca(50);\\n\"\n              \"    strcat(data, src);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (warning) Possible buffer overflow if strlen(src) is larger than sizeof(data)-strlen(data).\\n\", \"\", errout_str());\n\n        check(\"void foo(char src[100]) {\\n\"\n              \"    char * data = (char *)alloca(100);\\n\"\n              \"    strcat(data, src);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char * data = (char *)alloca(50);\\n\"\n              \"    char src[100];\\n\"\n              \"    memset(src, 'C', 99);\\n\"\n              \"    src[99] = '\\\\0';\\n\"\n              \"    strcpy(data, src);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (warning) Possible buffer overflow if strlen(src) is larger than or equal to sizeof(data).\\n\", \"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char * data = (char *)alloca(100);\\n\"\n              \"    char src[100];\\n\"\n              \"    memset(src, 'C', 99);\\n\"\n              \"    src[99] = '\\\\0';\\n\"\n              \"    strcpy(data, src);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char src[100]) {\\n\"\n              \"    char * data = (char *)alloca(50);\\n\"\n              \"    strcpy(data, src);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (warning) Possible buffer overflow if strlen(src) is larger than or equal to sizeof(data).\\n\", \"\", errout_str());\n\n        check(\"void foo(char src[100]) {\\n\"\n              \"    char * data = (char *)alloca(100);\\n\"\n              \"    strcpy(data, src);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void buffer_overrun_readSizeFromCfg() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <podtype name=\\\"u8\\\" sign=\\\"u\\\" size=\\\"1\\\"/>\\n\"\n                                   \"  <function name=\\\"mystrcpy\\\">\\n\"\n                                   \"    <noreturn>false</noreturn>\\n\"\n                                   \"    <arg nr=\\\"1\\\">\\n\"\n                                   \"      <minsize type=\\\"strlen\\\" arg=\\\"2\\\"/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"    <arg nr=\\\"2\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        const Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        // Attempt to get size from Cfg files, no false positives if size is not specified\n        check(\"void f() {\\n\"\n              \"  u8 str[256];\\n\"\n              \"  mystrcpy(str, \\\"abcd\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  u8 str[2];\\n\"\n              \"  mystrcpy(str, \\\"abcd\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        // The same for structs, where the message comes from a different check\n        check(\"void f() {\\n\"\n              \"    struct { u8 str[256]; } ms;\\n\"\n              \"    mystrcpy(ms.str, \\\"abcd\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    struct { u8 str[2]; } ms;\\n\"\n              \"    mystrcpy(ms.str, \\\"abcd\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Buffer is accessed out of bounds: ms.str [bufferAccessOutOfBounds]\\n\", errout_str());\n    }\n\n    void valueflow_string() { // using ValueFlow string values in checking\n        check(\"char f() {\\n\"\n              \"  const char *x = s;\\n\"\n              \"  if (cond) x = \\\"abcde\\\";\\n\"\n              \"  return x[20];\\n\" // <- array index out of bounds when x is \"abcde\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Array 'x[6]' accessed at index 20, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void pointer_out_of_bounds_1() {\n        // extracttests.start: void dostuff(char *);\n\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    char *p = a + 100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (portability) Undefined behaviour, pointer arithmetic 'a+100' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"char *f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    return a + 100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (portability) Undefined behaviour, pointer arithmetic 'a+100' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    char x[10];\\n\"\n              \"    if (i == 123) {}\\n\"\n              \"    dostuff(x+i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:4:14]: (portability) Undefined behaviour, when 'i' is 123 the pointer arithmetic 'x+i' is out of bounds. [pointerOutOfBoundsCond]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    char x[10];\\n\"\n              \"    if (i == -1) {}\\n\"\n              \"    dostuff(x+i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:4:14]: (portability) Undefined behaviour, when 'i' is -1 the pointer arithmetic 'x+i' is out of bounds. [pointerOutOfBoundsCond]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #6350 - fp when there is cast of buffer\n              \"  wchar_t buf[64];\\n\"\n              \"  p = (unsigned char *) buf + sizeof (buf);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    const char   d[] = \\\"0123456789\\\";\\n\"\n              \"    char *cp = d + 3;\\n\"\n              \"    return cp - d;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pointer_out_of_bounds_2() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    p += 100;\\n\"\n              \"    free(p);\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (portability) Undefined behaviour, pointer arithmetic 'p+100' is out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    p += 10;\\n\"\n              \"    *p = 0;\\n\"\n              \"    free(p);\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) p is out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    p += 10;\\n\"\n              \"    p -= 10;\\n\"\n              \"    *p = 0;\\n\"\n              \"    free(p);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    p += 10;\\n\"\n              \"    p = p - 1;\\n\"\n              \"    *p = 0;\\n\"\n              \"    free(p);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pointer_out_of_bounds_3() {\n        check(\"struct S { int a[10]; };\\n\"\n              \"void f(struct S *s) {\\n\"\n              \"    int *p = s->a + 100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (portability) Undefined behaviour, pointer arithmetic 's->a+100' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"template <class T> class Vector\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"    void test() const;\\n\"\n              \"    T* data();\\n\"\n              \"};\\n\"\n              \"template <class T>\\n\"\n              \"void Vector<T>::test() const\\n\"\n              \"{\\n\"\n              \"    const T* PDat = data();\\n\"\n              \"    const T* P2 = PDat + 1;\\n\"\n              \"    const T* P1 = P2 - 1;\\n\"\n              \"}\\n\"\n              \"Vector<std::array<long, 2>> Foo;\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pointer_out_of_bounds_4() {\n        check(\"const char* f() {\\n\"\n              \"    g(\\\"Hello\\\" + 6);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const char* f() {\\n\"\n              \"    g(\\\"Hello\\\" + 7);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (portability) Undefined behaviour, pointer arithmetic '\\\"Hello\\\"+7' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"const char16_t* f() {\\n\"\n              \"    g(u\\\"Hello\\\" + 6);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const char16_t* f() {\\n\"\n              \"    g(u\\\"Hello\\\" + 7);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (portability) Undefined behaviour, pointer arithmetic 'u\\\"Hello\\\"+7' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #4647\n              \"    int val = 5;\\n\"\n              \"    std::string hi = \\\"hi\\\" + val;\\n\"\n              \"    std::cout << hi << std::endl;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:27]: (portability) Undefined behaviour, pointer arithmetic '\\\"hi\\\"+val' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(const char* s, int len) {\\n\" // #11026\n              \"    const char* end = s + len;\\n\"\n              \"    printf(\\\"%s, %d\\\\n\\\", s, *end);\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    f(\\\"a\\\", 1);\\n\"\n              \"    f(\\\"bbb\\\", 3);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i, const char* a) {\\n\" // #11140\n              \"    (void)a[i];\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    for (int i = 0; \\\"01234\\\"[i]; ++i)\\n\"\n              \"        f(i, \\\"56789\\\");\\n\"\n              \"}\\n\"\n              \"void h() {\\n\"\n              \"    for (int i = 0; \\\"012\\\"[i]; ++i)\\n\"\n              \"        f(i, \\\"345\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pointer_out_of_bounds_5() { // #10227\n        check(\"int foo(char str[6]) {\\n\"\n              \"    return !((0 && *(\\\"STRING\\\" + 14) == 0) || memcmp(str, \\\"STRING\\\", 6) == 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pointer_out_of_bounds_sub() {\n        // extracttests.start: void dostuff(char *);\n\n        check(\"char *f() {\\n\"\n              \"    char x[10];\\n\"\n              \"    return x-1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (portability) Undefined behaviour, pointer arithmetic 'x-1' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    char x[10];\\n\"\n              \"    if (i == 123) {}\\n\"\n              \"    dostuff(x-i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:4:14]: (portability) Undefined behaviour, when 'i' is 123 the pointer arithmetic 'x-i' is out of bounds. [pointerOutOfBoundsCond]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    char x[10];\\n\"\n              \"    if (i == -20) {}\\n\"\n              \"    dostuff(x-i);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (portability) Undefined behaviour, when 'i' is -20 the pointer arithmetic 'x-i' is out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f(const char *x[10]) {\\n\"\n              \"    return x-4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void strcat1() {\n        check(\"struct Foo { char a[4]; };\\n\"\n              \"void f() {\\n\"\n              \"  struct Foo x = {0};\\n\"\n              \"  strcat(x.a, \\\"aa\\\");\\n\"\n              \"  strcat(x.a, \\\"aa\\\");\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n    }\n\n    void varid1() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char str[10];\\n\"\n              \"    if (str[0])\\n\"\n              \"    {\\n\"\n              \"        char str[50];\\n\"\n              \"        str[30] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varid2() { // #4764\n        check(\"struct foo {\\n\"\n              \"  void bar() { return; }\\n\"\n              \"  type<> member[1];\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign1() {\n        check(\"char str[3] = {'a', 'b', 'c'};\\n\"\n              \"\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    str[3] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (error) Array 'str[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void alloc_new() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char *s; s = new char[10];\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 's[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // ticket #1670 - false negative when using return\n        check(\"char f()\\n\"\n              \"{\\n\"\n              \"    int *s; s = new int[10];\\n\"\n              \"    return s[10];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Array 's[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"struct Fred { char c[10]; };\\n\"\n              \"char f()\\n\"\n              \"{\\n\"\n              \"    Fred *f; f = new Fred;\\n\"\n              \"    return f->c[10];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (error) Array 'f->c[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"static const size_t MAX_SIZE = UNAVAILABLE_TO_CPPCHECK;\\n\"\n              \"struct Thing { char data[MAX_SIZE]; };\\n\"\n              \"char f4(const Thing& t) { return !t.data[0]; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  char * buf; buf = new char[8];\\n\"\n              \"  buf[7] = 0;\\n\"\n              \"  delete [] buf;\\n\"\n              \"  buf = new char[9];\\n\"\n              \"  buf[8] = 0;\\n\"\n              \"  delete [] buf;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  char * buf; buf = new char[8];\\n\"\n              \"  buf[7] = 0;\\n\"\n              \"  delete [] buf;\\n\"\n              \"  buf = new char[9];\\n\"\n              \"  buf[9] = 0;\\n\"\n              \"  delete [] buf;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:6]: (error) Array 'buf[9]' accessed at index 9, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    enum E { Size = 10 };\\n\"\n              \"    char *s; s = new char[Size];\\n\"\n              \"    s[Size] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:6]: (error) Array 's[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    enum E { ZERO };\\n\"\n              \"    E *e; e = new E[10];\\n\"\n              \"    e[10] = ZERO;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:6]: (error) Array 'e[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    // data is allocated with malloc\n    void alloc_malloc() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char *s; s = (char *)malloc(10);\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 's[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // ticket #842\n        check(\"void f() {\\n\"\n              \"    int *tab4 = (int *)malloc(20 * sizeof(int));\\n\"\n              \"    tab4[20] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Array 'tab4[20]' accessed at index 20, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // ticket #1478\n        check(\"void foo() {\\n\"\n              \"    char *p = (char *)malloc(10);\\n\"\n              \"    free(p);\\n\"\n              \"    p = (char *)malloc(10);\\n\"\n              \"    p[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:6]: (error) Array 'p[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        // ticket #1134\n        check(\"void f() {\\n\"\n              \"    int *x, i;\\n\"\n              \"    x = (int *)malloc(10 * sizeof(int));\\n\"\n              \"    x[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 'x[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int *tab4; tab4 = malloc(20 * sizeof(int));\\n\"\n              \"  tab4[19] = 0;\\n\"\n              \"  free(tab4);\\n\"\n              \"  tab4 = malloc(21 * sizeof(int));\\n\"\n              \"  tab4[20] = 0;\\n\"\n              \"  free(tab4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int *tab4 = malloc(20 * sizeof(int));\\n\"\n              \"  tab4[19] = 0;\\n\"\n              \"  tab4 = realloc(tab4,21 * sizeof(int));\\n\"\n              \"  tab4[20] = 0;\\n\"\n              \"  free(tab4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum E { Size = 20 };\\n\"\n              \"    E *tab4 = (E *)malloc(Size * 4);\\n\"\n              \"    tab4[Size] = Size;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Array 'tab4[20]' accessed at index 20, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum E { Size = 20 };\\n\"\n              \"    E *tab4 = (E *)malloc(4 * Size);\\n\"\n              \"    tab4[Size] = Size;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Array 'tab4[20]' accessed at index 20, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum E { ZERO };\\n\"\n              \"    E *tab4 = (E *)malloc(20 * sizeof(E));\\n\"\n              \"    tab4[20] = ZERO;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Array 'tab4[20]' accessed at index 20, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #8721\n              \"  unsigned char **cache = malloc(32);\\n\"\n              \"  cache[i] = malloc(65536);\\n\"\n              \"  cache[i][0xFFFF] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int **a = malloc(2 * sizeof(int*));\\n\"\n              \"  for (int i = 0; i < 3; i++)\\n\"\n              \"    a[i] = NULL;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 'a[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int **a = new int*[2];\\n\"\n              \"  for (int i = 0; i < 3; i++)\\n\"\n              \"    a[i] = NULL;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 'a[2]' accessed at index 2, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    // statically allocated buffer\n    void alloc_string() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    const char *s = \\\"123\\\";\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 's[4]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char *s; s = \\\"\\\";\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 's[1]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    const char *s = \\\"\\\";\\n\"\n              \"    s = y();\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\" // #7718\n              \"{\\n\"\n              \"    std::string s = \\\"123\\\";\\n\"\n              \"    s.resize(100);\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // data is allocated with alloca\n    void alloc_alloca() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char *s = (char *)alloca(10);\\n\"\n              \"    s[10] = 0;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Array 's[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", \"\", errout_str());\n    }\n    /*\n        void countSprintfLength() const {\n            std::list<const Token*> unknownParameter(1, nullptr);\n\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"Hello\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"s\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"i\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"%d\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"%1d\", unknownParameter));\n            ASSERT_EQUALS(3, CheckBufferOverrun::countSprintfLength(\"%2.2d\", unknownParameter));\n            ASSERT_EQUALS(1, CheckBufferOverrun::countSprintfLength(\"%s\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"f%s\", unknownParameter));\n            ASSERT_EQUALS(1, CheckBufferOverrun::countSprintfLength(\"%-s\", unknownParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%-5s\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"\\\\\\\"\", unknownParameter));\n            ASSERT_EQUALS(7, CheckBufferOverrun::countSprintfLength(\"Hello \\\\0Text\", unknownParameter));\n            ASSERT_EQUALS(1, CheckBufferOverrun::countSprintfLength(\"\\\\0\", unknownParameter));\n            ASSERT_EQUALS(2, CheckBufferOverrun::countSprintfLength(\"%%\", unknownParameter));\n            ASSERT_EQUALS(3, CheckBufferOverrun::countSprintfLength(\"%d%d\", unknownParameter));\n            ASSERT_EQUALS(3, CheckBufferOverrun::countSprintfLength(\"\\\\\\\\a%s\\\\0a\", unknownParameter));\n            ASSERT_EQUALS(10, CheckBufferOverrun::countSprintfLength(\"\\\\\\\\\\\\\\\\Hello%d \\\\0Text\\\\\\\\\\\\\\\\\", unknownParameter));\n            ASSERT_EQUALS(4, CheckBufferOverrun::countSprintfLength(\"%%%%%d\", unknownParameter));\n\n            Token strTok;\n            std::list<const Token*> stringAsParameter(1, &strTok);\n            strTok.str(\"\\\"\\\"\");\n            ASSERT_EQUALS(4, CheckBufferOverrun::countSprintfLength(\"str%s\", stringAsParameter));\n            strTok.str(\"\\\"12345\\\"\");\n            ASSERT_EQUALS(9, CheckBufferOverrun::countSprintfLength(\"str%s\", stringAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%-4s\", stringAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%-5s\", stringAsParameter));\n            ASSERT_EQUALS(7, CheckBufferOverrun::countSprintfLength(\"%-6s\", stringAsParameter));\n            ASSERT_EQUALS(5, CheckBufferOverrun::countSprintfLength(\"%.4s\", stringAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%.5s\", stringAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%.6s\", stringAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%5.6s\", stringAsParameter));\n            ASSERT_EQUALS(7, CheckBufferOverrun::countSprintfLength(\"%6.6s\", stringAsParameter));\n\n            Token numTok;\n            numTok.str(\"12345\");\n            std::list<const Token*> intAsParameter(1, &numTok);\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%02ld\", intAsParameter));\n            ASSERT_EQUALS(9, CheckBufferOverrun::countSprintfLength(\"%08ld\", intAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%.2d\", intAsParameter));\n            ASSERT_EQUALS(9, CheckBufferOverrun::countSprintfLength(\"%08.2d\", intAsParameter));\n            TODO_ASSERT_EQUALS(5, 2, CheckBufferOverrun::countSprintfLength(\"%x\", intAsParameter));\n            ASSERT_EQUALS(5, CheckBufferOverrun::countSprintfLength(\"%4x\", intAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%5x\", intAsParameter));\n            ASSERT_EQUALS(5, CheckBufferOverrun::countSprintfLength(\"%.4x\", intAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%.5x\", intAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%1.5x\", intAsParameter));\n            ASSERT_EQUALS(6, CheckBufferOverrun::countSprintfLength(\"%5.1x\", intAsParameter));\n\n            Token floatTok;\n            floatTok.str(\"1.12345f\");\n            std::list<const Token*> floatAsParameter(1, &floatTok);\n            TODO_ASSERT_EQUALS(5, 3, CheckBufferOverrun::countSprintfLength(\"%.2f\", floatAsParameter));\n            ASSERT_EQUALS(9, CheckBufferOverrun::countSprintfLength(\"%8.2f\", floatAsParameter));\n            TODO_ASSERT_EQUALS(5, 3, CheckBufferOverrun::countSprintfLength(\"%2.2f\", floatAsParameter));\n\n            Token floatTok2;\n            floatTok2.str(\"100.12345f\");\n            std::list<const Token*> floatAsParameter2(1, &floatTok2);\n            TODO_ASSERT_EQUALS(7, 3, CheckBufferOverrun::countSprintfLength(\"%2.2f\", floatAsParameter2));\n            TODO_ASSERT_EQUALS(7, 3, CheckBufferOverrun::countSprintfLength(\"%.2f\", floatAsParameter));\n            TODO_ASSERT_EQUALS(7, 5, CheckBufferOverrun::countSprintfLength(\"%4.2f\", floatAsParameter));\n\n            std::list<const Token*> multipleParams = { &strTok, nullptr, &numTok };\n            ASSERT_EQUALS(15, CheckBufferOverrun::countSprintfLength(\"str%s%d%d\", multipleParams));\n            ASSERT_EQUALS(26, CheckBufferOverrun::countSprintfLength(\"str%-6s%08ld%08ld\", multipleParams));\n        }\n     */\n\n    // extracttests.disable\n\n    void minsize_argvalue() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <function name=\\\"mymemset\\\">\\n\"\n                                   \"    <noreturn>false</noreturn>\\n\"\n                                   \"    <arg nr=\\\"1\\\">\\n\"\n                                   \"      <minsize type=\\\"argvalue\\\" arg=\\\"3\\\"/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"    <arg nr=\\\"2\\\"/>\\n\"\n                                   \"    <arg nr=\\\"3\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        /*const*/ Settings settings = settingsBuilder().libraryxml(xmldata).severity(Severity::warning).build();\n        settings.platform.sizeof_wchar_t = 4;\n\n        check(\"void f() {\\n\"\n              \"    char c[10];\\n\"\n              \"    mymemset(c, 0, 10);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[10];\\n\"\n              \"    mymemset(c, 0, 11);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: c [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    char a[5];\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    S s;\\n\"\n              \"    mymemset(s.a, 0, 10);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:6:15]: (error) Buffer is accessed out of bounds: s.a [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char s[10];\\n\"\n              \"    mymemset(s, 0, '*');\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (warning) The size argument is given as a char constant.\\n\"\n                           \"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: s [bufferAccessOutOfBounds]\\n\", \"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: s [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        // ticket #836\n        check(\"void f(void) {\\n\"\n              \"  char a[10];\\n\"\n              \"  mymemset(a+5, 0, 10);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Buffer is accessed out of bounds: a [bufferAccessOutOfBounds]\\n\", \"\", errout_str());\n\n        // Ticket #909\n        check(\"void f(void) {\\n\"\n              \"    char str[] = \\\"abcd\\\";\\n\"\n              \"    mymemset(str, 0, 6);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"    char str[] = \\\"abcd\\\";\\n\"\n              \"    mymemset(str, 0, 5);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"    wchar_t str[] = L\\\"abcd\\\";\\n\"\n              \"    mymemset(str, 0, 21);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"    wchar_t str[] = L\\\"abcd\\\";\\n\"\n              \"    mymemset(str, 0, 20);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #1659 - overflowing variable when using memcpy\n        check(\"void f(void) {\\n\"\n              \"  char c;\\n\"\n              \"  mymemset(&c, 0, 4);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: c [bufferAccessOutOfBounds]\\n\", \"\", errout_str());\n\n        // ticket #2121 - buffer access out of bounds when using uint32_t\n        check(\"void f(void) {\\n\"\n              \"    unknown_type_t buf[4];\\n\"\n              \"    mymemset(buf, 0, 100);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3124 - multidimensional array\n        check(\"int main() {\\n\"\n              \"    char b[5][6];\\n\"\n              \"    mymemset(b, 0, 5 * 6);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"    char b[5][6];\\n\"\n              \"    mymemset(b, 0, 6 * 6);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: b [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"    char b[5][6];\\n\"\n              \"    mymemset(b, 0, 31);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Buffer is accessed out of bounds: b [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        // #4968 - not standard function\n        check(\"void f() {\\n\"\n              \"    char str[3];\\n\"\n              \"    foo.mymemset(str, 0, 100);\\n\"\n              \"    foo::mymemset(str, 0, 100);\\n\"\n              \"    std::mymemset(str, 0, 100);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:5:15]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", \"\", errout_str());\n\n        // #5257 - check strings\n        check(\"void f() {\\n\"\n              \"  mymemset(\\\"abc\\\", 0, 20);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:2]: (error) Buffer is accessed out of bounds.\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"void f() {\\n\"\n              \"  mymemset(temp, \\\"abc\\\", 4);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #6816 - fp when array has known string value\n              \"    char c[10] = \\\"c\\\";\\n\"\n              \"    mymemset(c, 0, 10);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void minsize_sizeof() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <function name=\\\"mystrncpy\\\">\\n\"\n                                   \"    <noreturn>false</noreturn>\\n\"\n                                   \"    <arg nr=\\\"1\\\">\\n\"\n                                   \"      <minsize type=\\\"strlen\\\" arg=\\\"2\\\"/>\\n\"\n                                   \"      <minsize type=\\\"argvalue\\\" arg=\\\"3\\\"/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"    <arg nr=\\\"2\\\"/>\\n\"\n                                   \"    <arg nr=\\\"3\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        const Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        check(\"void f() {\\n\"\n              \"    char c[7];\\n\"\n              \"    mystrncpy(c, \\\"hello\\\", 7);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \" char c[6];\\n\"\n              \" mystrncpy(c,\\\"hello\\\",6);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \" char c[5];\\n\"\n              \" mystrncpy(c,\\\"hello\\\",6);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Buffer is accessed out of bounds: c [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[6];\\n\"\n              \"    mystrncpy(c,\\\"hello!\\\",7);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Buffer is accessed out of bounds: c [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(unsigned int addr) {\\n\"\n              \"    memset((void *)addr, 0, 1000);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings0));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AB { char a[10]; };\\n\"\n              \"void foo(AB *ab) {\\n\"\n              \"    mystrncpy(x, ab->a, 100);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void a(char *p) { mystrncpy(p,\\\"hello world!\\\",10); }\\n\" // #3168\n              \"void b() {\\n\"\n              \"    char buf[5];\\n\"\n              \"    a(buf);\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:4] -> [test.cpp:1]: (error) Buffer is accessed out of bounds: buf\\n\",\n                           \"\",\n                           errout_str());\n    }\n\n    void minsize_strlen() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <function name=\\\"mysprintf\\\">\\n\"\n                                   \"    <noreturn>false</noreturn>\\n\"\n                                   \"    <formatstr/>\\n\"\n                                   \"    <arg nr=\\\"1\\\">\\n\"\n                                   \"      <minsize type=\\\"strlen\\\" arg=\\\"2\\\"/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"    <arg nr=\\\"2\\\">\\n\"\n                                   \"      <formatstr/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        const Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        // formatstr..\n        check(\"void f() {\\n\"\n              \"    char str[3];\\n\"\n              \"    mysprintf(str, \\\"test\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char str[5];\\n\"\n              \"    mysprintf(str, \\\"%s\\\", \\\"abcde\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"int getnumber();\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    char str[5];\\n\"\n              \"    mysprintf(str, \\\"%d: %s\\\", getnumber(), \\\"abcde\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char str[5];\\n\"\n              \"    mysprintf(str, \\\"test%s\\\", \\\"\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *str = new char[5];\\n\"\n              \"    mysprintf(str, \\\"abcde\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Buffer is accessed out of bounds: str [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(int condition) {\\n\"\n              \"    char str[5];\\n\"\n              \"    mysprintf(str, \\\"test%s\\\", condition ? \\\"12\\\" : \\\"34\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int condition) {\\n\"\n              \"    char str[5];\\n\"\n              \"    mysprintf(str, \\\"test%s\\\", condition ? \\\"12\\\" : \\\"345\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        check(\"struct Foo { char a[1]; };\\n\"\n              \"void f() {\\n\"\n              \"  struct Foo x;\\n\"\n              \"  mysprintf(x.a, \\\"aa\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Buffer is accessed out of bounds: x.a [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        // ticket #900\n        check(\"void f() {\\n\"\n              \"  char *a = new char(30);\\n\"\n              \"  mysprintf(a, \\\"a\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Buffer is accessed out of bounds: a [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(char value) {\\n\"\n              \"  char *a = new char(value);\\n\"\n              \"  mysprintf(a, \\\"a\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Buffer is accessed out of bounds: a [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        // This is out of bounds if 'sizeof(ABC)' is 1 (No padding)\n        check(\"struct Foo { char a[1]; };\\n\"\n              \"void f() {\\n\"\n              \"  struct Foo *x = malloc(sizeof(Foo));\\n\"\n              \"  mysprintf(x->a, \\\"aa\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error, inconclusive) Buffer is accessed out of bounds: x.a\\n\", \"\", errout_str());\n\n        check(\"struct Foo { char a[1]; };\\n\"\n              \"void f() {\\n\"\n              \"  struct Foo *x = malloc(sizeof(Foo) + 10);\\n\"\n              \"  mysprintf(x->a, \\\"aa\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo { char a[1]; };\\n\"\n              \"void f() {\\n\"\n              \"  struct Foo x;\\n\"\n              \"  mysprintf(x.a, \\\"aa\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Buffer is accessed out of bounds: x.a [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"struct Foo {\\n\" // #6668 - unknown size\n              \"  char a[LEN];\\n\"\n              \"  void f();\\n\"\n              \"};\"\n              \"void Foo::f() {\\n\"\n              \"  mysprintf(a, \\\"abcd\\\");\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void minsize_mul() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <function name=\\\"myfread\\\">\\n\"\n                                   \"    <arg nr=\\\"1\\\">\\n\"\n                                   \"      <minsize type=\\\"mul\\\" arg=\\\"2\\\" arg2=\\\"3\\\"/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"    <arg nr=\\\"2\\\"/>\\n\"\n                                   \"    <arg nr=\\\"3\\\"/>\\n\"\n                                   \"    <arg nr=\\\"4\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        const Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        check(\"void f() {\\n\"\n              \"    char c[5];\\n\"\n              \"    myfread(c, 1, 5, stdin);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[5];\\n\"\n              \"    myfread(c, 1, 6, stdin);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Buffer is accessed out of bounds: c [bufferAccessOutOfBounds]\\n\", errout_str());\n    }\n\n    // extracttests.enable\n\n    void unknownType() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \" UnknownType *a = malloc(4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n    // extracttests.disable\n    void terminateStrncpy1() {\n        check(\"void foo ( char *bar ) {\\n\"\n              \"    char baz[100];\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    baz[99] = 0;\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    baz[99] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo ( char *bar ) {\\n\"\n              \"    char baz[100];\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    baz[99] = '\\\\0';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo ( char *bar ) {\\n\"\n              \"    char baz[100];\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    baz[x+1] = '\\\\0';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test with invalid code that there is no segfault\n        check(\"char baz[100];\\n\"\n              \"strncpy(baz, \\\"var\\\", 100)\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test that there are no duplicate error messages\n        check(\"void foo ( char *bar ) {\\n\"\n              \"    char baz[100];\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    foo(baz);\\n\"\n              \"    foo(baz);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) The buffer 'baz' may not be null-terminated after the call to strncpy(). [terminateStrncpy]\\n\", errout_str());\n    }\n\n    void terminateStrncpy2() {\n        check(\"char *foo ( char *bar ) {\\n\"\n              \"    char baz[100];\\n\"\n              \"    strncpy(baz, bar, 100);\\n\"\n              \"    bar[99] = 0;\\n\"\n              \"    return strdup(baz);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) The buffer 'baz' may not be null-terminated after the call to strncpy(). [terminateStrncpy]\\n\", errout_str());\n    }\n\n    void terminateStrncpy3() {\n        // Ticket #2170 - false positive\n        // The function bar is risky. But it might work that way intentionally.\n        check(\"char str[100];\\n\"\n              \"\\n\"\n              \"void foo(char *a) {\\n\"\n              \"    strncpy(str, a, 100);\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void bar(char *p) {\\n\"\n              \"    strncpy(p, str, 100);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (warning, inconclusive) The buffer 'str' may not be null-terminated after the call to strncpy(). [terminateStrncpy]\\n\", errout_str());\n    }\n\n    void terminateStrncpy4() {\n        check(\"void bar() {\\n\"\n              \"    char buf[4];\\n\"\n              \"    strncpy(buf, \\\"ab\\\", 4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void bar() {\\n\"\n              \"    char buf[4];\\n\"\n              \"    strncpy(buf, \\\"abcde\\\", 4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) The buffer 'buf' may not be null-terminated after the call to strncpy(). [terminateStrncpy]\\n\", errout_str());\n    }\n\n    void terminateStrncpy5() { // #9944\n        check(\"void f(const std::string& buf) {\\n\"\n              \"    char v[255];\\n\"\n              \"    if (buf.size() >= sizeof(v))\\n\"\n              \"        return;\\n\"\n              \"    strncpy(v, buf.c_str(), sizeof(v));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::string& buf) {\\n\"\n              \"    char v[255];\\n\"\n              \"    if (buf.size() >= sizeof(v))\\n\"\n              \"        strncpy(v, buf.c_str(), sizeof(v));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (warning, inconclusive) The buffer 'v' may not be null-terminated after the call to strncpy(). [terminateStrncpy]\\n\", errout_str());\n    }\n    // extracttests.enable\n\n    void recursive_long_time() {\n        // Just test that recursive check doesn't take long time\n        check(\"char *f2 ( char *b )\\n\"\n              \"{\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"    f2( b );\\n\"\n              \"}\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    char a[10];\\n\"\n              \"    f2(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    // Ticket #1587 - crash\n    void crash1() {\n        check(\"struct struct A\\n\"\n              \"{\\n\"\n              \"    int alloclen;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    struct A *str;\\n\"\n              \"    str = malloc(4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void crash2() {\n        check(\"void a(char *p) {\\n\"\n              \"    f( { if(finally_arg); } );\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void b() {\\n\"\n              \"    char arr[64];\\n\"\n              \"    a(arr);\\n\"\n              \"}\");\n    }\n\n    void crash3() {\n        check(\"struct b { unknown v[0]; };\\n\"\n              \"void d() { struct b *f; f = malloc(108); }\");\n    }\n\n    void crash4() { // #8679\n        check(\"__thread void *thread_local_var; \"\n              \"int main() { \"\n              \"  thread_local_var = malloc(1337); \"\n              \"  return 0; \"\n              \"}\");\n\n        check(\"thread_local void *thread_local_var; \"\n              \"int main() { \"\n              \"  thread_local_var = malloc(1337); \"\n              \"  return 0; \"\n              \"}\");\n    }\n\n    void crash5() { // 8644 - token has varId() but variable() is null\n        check(\"int a() {\\n\"\n              \"    void b(char **dst) {\\n\"\n              \"        *dst = malloc(50);\\n\"\n              \"    }\\n\"\n              \"}\");\n    }\n\n    void crash6() {\n        check(\"void start(char* name) {\\n\"\n              \"char snapname[64] = { 0 };\\n\"\n              \"strncpy(snapname, \\\"snapshot\\\", arrayLength(snapname));\\n\"\n              \"}\");\n    }\n\n    void crash7() { // 9073 - [ has no astParent\n        check(\"char x[10];\\n\"\n              \"void f() { x[10]; }\");\n    }\n\n    void insecureCmdLineArgs() {\n        check(\"int main(int argc, char *argv[])\\n\"\n              \"{\\n\"\n              \"    if(argc>1)\\n\"\n              \"    {\\n\"\n              \"        char buf[2];\\n\"\n              \"        char *p = strdup(argv[1]);\\n\"\n              \"        strcpy(buf,p);\\n\"\n              \"        free(p);\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char *argv[])\\n\"\n              \"{\\n\"\n              \"    if(argc>1)\\n\"\n              \"    {\\n\"\n              \"        char buf[2] = {'\\\\0','\\\\0'};\\n\"\n              \"        char *p = strdup(argv[1]);\\n\"\n              \"        strcat(buf,p);\\n\"\n              \"        free(p);\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:7]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(const int argc, char* argv[])\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, const char* argv[])\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(const int argc, const char* argv[])\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char* argv[])\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    strcat(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, const char *const *const argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(const int argc, const char *const *const argv, const char *const *const envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    strcat(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(const int argc, const char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    strcat(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, const char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    strcat(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(const int argc, char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    strcat(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **options)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, options[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **options)\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    strcat(prog, options[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **options)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, *options);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **options)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog+3, *options);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        check(\"int main(int argc, char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    if (strlen(argv[0]) < 10)\\n\"\n              \"        strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main(int argc, char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10] = {'\\\\0'};\\n\"\n              \"    if (10 > strlen(argv[0]))\\n\"\n              \"        strcat(prog, argv[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main(int argc, char **argv, char **envp)\\n\"\n              \"{\\n\"\n              \"    char prog[10];\\n\"\n              \"    argv[0][0] = '\\\\0';\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5835\n        check(\"int main(int argc, char* argv[]) {\\n\"\n              \"    char prog[10];\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"    strcpy(prog, argv[0]);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Buffer overrun possible for long command line arguments.\\n\"\n                           \"[test.cpp:4]: (error) Buffer overrun possible for long command line arguments.\\n\", \"\", errout_str());\n\n        // #7964\n        check(\"int main(int argc, char *argv[]) {\\n\"\n              \"  char *strcpy();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"int main(int argc, char *argv[]) {\\n\"\n              \"  char *strcat();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkBufferAllocatedWithStrlen() {\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = new char[strlen(a)];\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = new char[strlen(a) + 1];\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = new char[strlen(a)];\\n\"\n              \"  a[0] = '\\\\0';\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = (char *)malloc(strlen(a));\\n\"\n              \"  b = realloc(b, 10000);\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = (char *)malloc(strlen(a));\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = (char *)malloc(strlen(a));\\n\"\n              \"  {\\n\"\n              \"    strcpy(b, a);\\n\"\n              \"  }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = (char *)malloc(strlen(a) + 1);\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *a, char *c) {\\n\"\n              \"  char *b = (char *)realloc(c, strlen(a));\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n\n        check(\"void f(char *a, char *c) {\\n\"\n              \"  char *b = (char *)realloc(c, strlen(a) + 1);\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *a) {\\n\"\n              \"  char *b = (char *)malloc(strlen(a));\\n\"\n              \"  strcpy(b, a);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Buffer is accessed out of bounds.\\n\", \"\", errout_str());\n    }\n\n    void scope() {\n        check(\"class A {\\n\"\n              \"private:\\n\"\n              \"    struct X { char buf[10]; };\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    X x;\\n\"\n              \"    x.buf[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A {\\n\"\n              \"public:\\n\"\n              \"    struct X { char buf[10]; };\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    A::X x;\\n\"\n              \"    x.buf[10] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:10]: (error) Array 'x.buf[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]\\n\", errout_str());\n    }\n\n    void getErrorMessages() {\n        // Ticket #2292: segmentation fault when using --errorlist\n        const Check& c = getCheck<CheckBufferOverrun>();\n        c.getErrorMessages(this, nullptr);\n        // we are not interested in the output - just consume it\n        ignore_errout();\n    }\n\n    void arrayIndexThenCheck() {\n        // extracttests.start: volatile int y;\n\n        check(\"void f(const char s[]) {\\n\"\n              \"    if (s[i] == 'x' && i < y) {\\n\"\n              \"    }\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // No message because i is unknown and thus gets no varid. Avoid an internalError here.\n\n        check(\"void f(const char s[], int i) {\\n\"\n              \"    if (s[i] == 'x' && i < y) {\\n\"\n              \"    }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Array index 'i' is used before limits check. [arrayIndexThenCheck]\\n\", errout_str());\n\n        check(\"void f(const char s[]) {\\n\"\n              \"    for (int i = 0; s[i] == 'x' && i < y; ++i) {\\n\"\n              \"    }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (style) Array index 'i' is used before limits check. [arrayIndexThenCheck]\\n\", errout_str());\n\n        check(\"void f(const int a[], unsigned i) {\\n\"\n              \"    if((a[i] < 2) && (i <= 42)) {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Array index 'i' is used before limits check. [arrayIndexThenCheck]\\n\", errout_str());\n\n        check(\"void f(const int a[], unsigned i) {\\n\"\n              \"    if((a[i] < 2) && (42 >= i)) {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Array index 'i' is used before limits check. [arrayIndexThenCheck]\\n\", errout_str());\n\n        // extracttests.start: int elen;\n        check(\"void f(char* e, int y) {\\n\"\n              \"    if (e[y] == '/' && elen > y + 1 && e[y + 1] == '?') {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: int foo(int); int func(int);\n        check(\"void f(const int a[], unsigned i) {\\n\"\n              \"    if(a[i] < func(i) && i <= 42) {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Array index 'i' is used before limits check. [arrayIndexThenCheck]\\n\", errout_str());\n\n        check(\"void f(const int a[], unsigned i) {\\n\"\n              \"    if (i <= 42 && a[i] < func(i)) {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int a[], unsigned i) {\\n\"\n              \"    if (foo(a[i] + 3) < func(i) && i <= 42) {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Array index 'i' is used before limits check. [arrayIndexThenCheck]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\" // sizeof\n              \"  sizeof(a)/sizeof(a[i]) && i < 10;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: extern int buf[];\n        check(\"void f(int i) {\\n\" // ?:\n              \"  if ((i < 10 ? buf[i] : 1) && (i < 5 ? buf[i] : 5)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void arrayIndexEarlyReturn() { // #6884\n        check(\"extern const char *Names[2];\\n\"\n              \"const char* getName(int value) {\\n\"\n              \"  if ((value < 0) || (value > 1))\\n\"\n              \"    return \\\"???\\\";\\n\"\n              \"  const char* name = Names[value]; \\n\"\n              \"  switch (value) {\\n\"\n              \"  case 2:\\n\"\n              \"    break; \\n\"\n              \"  }\\n\"\n              \"  return name;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void bufferNotZeroTerminated() {\n        check(\"void f() {\\n\"\n              \"    char c[6];\\n\"\n              \"    strncpy(c,\\\"hello!\\\",6);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) The buffer 'c' may not be null-terminated after the call to strncpy(). [terminateStrncpy]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[6];\\n\"\n              \"    memcpy(c,\\\"hello!\\\",6);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (warning, inconclusive) The buffer 'c' may not be null-terminated after the call to memcpy().\\n\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[6];\\n\"\n              \"    memmove(c,\\\"hello!\\\",6);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (warning, inconclusive) The buffer 'c' may not be null-terminated after the call to memmove().\\n\", \"\", errout_str());\n    }\n\n    void negativeMemoryAllocationSizeError() { // #389\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   int *a;\\n\"\n              \"   a = new int[-1];\\n\"\n              \"   delete [] a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Memory allocation size is negative. [negativeMemoryAllocationSize]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   int *a;\\n\"\n              \"   a = (int *)malloc( -10 );\\n\"\n              \"   free(a);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Memory allocation size is negative. [negativeMemoryAllocationSize]\\n\", \"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   int *a;\\n\"\n              \"   a = (int *)malloc( -10);\\n\"\n              \"   free(a);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Memory allocation size is negative. [negativeMemoryAllocationSize]\\n\", \"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   int *a;\\n\"\n              \"   a = (int *)alloca( -10 );\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Memory allocation size is negative. [negativeMemoryAllocationSize]\\n\", \"\", errout_str());\n\n        check(\"int* f(int n) {\\n\" // #11145\n              \"    int d = -1;\\n\"\n              \"    for (int i = 0; i < n; ++i)\\n\"\n              \"        d = std::max(i, d);\\n\"\n              \"    int* p = new int[d];\\n\"\n              \"    return p;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:14]: (warning, inconclusive) Memory allocation size is negative. [negativeMemoryAllocationSize]\\n\", errout_str());\n    }\n\n    void negativeArraySize() {\n        check(\"void f(int sz) {\\n\" // #1760 - VLA\n              \"   int a[sz];\\n\"\n              \"}\\n\"\n              \"void x() { f(-100); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:8]: (error) Declaration of array 'a' with negative size is undefined behaviour [negativeArraySize]\\n\", errout_str());\n\n        // don't warn for constant sizes -> this is a compiler error so this is used for static assertions for instance\n        check(\"int x, y;\\n\"\n              \"int a[-1];\\n\"\n              \"int b[x?1:-1];\\n\"\n              \"int c[x?y:-1];\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pointerAddition1() {\n        check(\"void f() {\\n\"\n              \"    char arr[10];\\n\"\n              \"    char *p = arr + 20;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (portability) Undefined behaviour, pointer arithmetic 'arr+20' is out of bounds. [pointerOutOfBounds]\\n\", errout_str());\n\n        check(\"char(*g())[1];\\n\" // #7950\n              \"void f() {\\n\"\n              \"    int a[2];\\n\"\n              \"    int* b = a + sizeof(*g());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define ctu(code) ctu_(code, __FILE__, __LINE__)\n    template<size_t size>\n    void ctu_(const char (&code)[size], const char* file, int line) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings0, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CTU::FileInfo *ctu = CTU::getFileInfo(tokenizer);\n\n        // Check code..\n        std::list<Check::FileInfo*> fileInfo;\n        Check& c = getCheck<CheckBufferOverrun>();\n        fileInfo.push_back(c.getFileInfo(tokenizer, settings0, \"\"));\n        c.analyseWholeProgram(*ctu, fileInfo, settings0, *this); // TODO: check result\n        while (!fileInfo.empty()) {\n            delete fileInfo.back();\n            fileInfo.pop_back();\n        }\n        delete ctu;\n    }\n\n    void ctu_malloc() {\n        ctu(\"void dostuff(char *p) {\\n\"\n            \"  p[-3] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"int main() {\\n\"\n            \"  char *s = malloc(4);\\n\"\n            \"  dostuff(s);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:11] -> [test.cpp:7:10] -> [test.cpp:2:3]: (error) Array index out of bounds; buffer 'p' is accessed at offset -3. [ctuArrayIndex]\\n\", errout_str());\n\n        ctu(\"void dostuff(char *p) {\\n\"\n            \"  p[4] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"int main() {\\n\"\n            \"  char *s = malloc(4);\\n\"\n            \"  dostuff(s);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:11] -> [test.cpp:7:10] -> [test.cpp:2:3]: (error) Array index out of bounds; 'p' buffer size is 4 and it is accessed at offset 4. [ctuArrayIndex]\\n\", errout_str());\n\n        ctu(\"void f(int* p) {\\n\" // #10415\n            \"    int b[1];\\n\"\n            \"    b[0] = p[5];\\n\"\n            \"    std::cout << b[0];\\n\"\n            \"}\\n\"\n            \"void g() {\\n\"\n            \"    int* a = new int[1];\\n\"\n            \"    a[0] = 5;\\n\"\n            \"    f(a);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:12] -> [test.cpp:9:6] -> [test.cpp:3:12]: (error) Array index out of bounds; 'p' buffer size is 4 and it is accessed at offset 20. [ctuArrayIndex]\\n\", errout_str());\n    }\n\n    void ctu_array() {\n        ctu(\"void dostuff(char *p) {\\n\"\n            \"    p[10] = 0;\\n\"\n            \"}\\n\"\n            \"int main() {\\n\"\n            \"  char str[4];\\n\"\n            \"  dostuff(str);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:10] -> [test.cpp:2:5]: (error) Array index out of bounds; 'p' buffer size is 4 and it is accessed at offset 10. [ctuArrayIndex]\\n\", errout_str());\n\n        ctu(\"static void memclr( char *data )\\n\"\n            \"{\\n\"\n            \"    data[10] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"static void f()\\n\"\n            \"{\\n\"\n            \"    char str[5];\\n\"\n            \"    memclr( str );\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:11] -> [test.cpp:3:5]: (error) Array index out of bounds; 'data' buffer size is 5 and it is accessed at offset 10. [ctuArrayIndex]\\n\", errout_str());\n\n        ctu(\"static void memclr( int i, char *data )\\n\"\n            \"{\\n\"\n            \"    data[10] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"static void f()\\n\"\n            \"{\\n\"\n            \"    char str[5];\\n\"\n            \"    memclr( 0, str );\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:11] -> [test.cpp:3:5]: (error) Array index out of bounds; 'data' buffer size is 5 and it is accessed at offset 10. [ctuArrayIndex]\\n\", errout_str());\n\n        ctu(\"static void memclr( int i, char *data )\\n\"\n            \"{\\n\"\n            \"    data[i] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"static void f()\\n\"\n            \"{\\n\"\n            \"    char str[5];\\n\"\n            \"    memclr( 10, str );\\n\"\n            \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:9] -> [test.cpp:3]: (possible error) Array index out of bounds.\\n\",\n                           \"\", errout_str());\n\n        // This is not an error\n        ctu(\"static void memclr( char *data, int size )\\n\"\n            \"{\\n\"\n            \"    if( size > 10 )\"\n            \"      data[10] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"static void f()\\n\"\n            \"{\\n\"\n            \"    char str[5];\\n\"\n            \"    memclr( str, 5 );\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2097\n        ctu(\"void foo(int *p)\\n\"\n            \"{\\n\"\n            \"    --p;\\n\"\n            \"    p[2] = 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void bar()\\n\"\n            \"{\\n\"\n            \"    int p[3];\\n\"\n            \"    foo(p+1);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9112\n        ctu(\"static void get_mac_address(const u8 *strbuf)\\n\"\n            \"{\\n\"\n            \"    (strbuf[2]);\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"static void program_mac_address(u32 mem_base)\\n\"\n            \"{\\n\"\n            \"    u8 macstrbuf[17] = { 0 };\\n\"\n            \"    get_mac_address(macstrbuf);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9788\n        ctu(\"void f1(char *s) { s[2] = 'B'; }\\n\"\n            \"void f2(char s[]) { s[2] = 'B'; }\\n\"\n            \"void g() {\\n\"\n            \"    char str[2];\\n\"\n            \"    f1(str);\\n\"\n            \"    f2(str);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:7] -> [test.cpp:1:20]: (error) Array index out of bounds; 's' buffer size is 2 and it is accessed at offset 2. [ctuArrayIndex]\\n\"\n                      \"[test.cpp:6:7] -> [test.cpp:2:21]: (error) Array index out of bounds; 's' buffer size is 2 and it is accessed at offset 2. [ctuArrayIndex]\\n\",\n                      errout_str());\n\n        // #5140\n        ctu(\"void g(const char* argv[]) { std::cout << \\\"argv: \\\" << argv[4] << std::endl; }\\n\"\n            \"void f() {\\n\"\n            \"    const char* argv[] = { \\\"test\\\" };\\n\"\n            \"    g(argv);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6] -> [test.cpp:1:55]: (error) Array index out of bounds; 'argv' buffer size is 1 and it is accessed at offset 4. [ctuArrayIndex]\\n\",\n                      errout_str());\n\n        ctu(\"void g(const char* argv[]) { std::cout << \\\"argv: \\\" << argv[5] << std::endl; }\\n\"\n            \"void f() {\\n\"\n            \"    const char* argv[1] = { \\\"test\\\" };\\n\"\n            \"    g(argv);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6] -> [test.cpp:1:55]: (error) Array index out of bounds; 'argv' buffer size is 1 and it is accessed at offset 5. [ctuArrayIndex]\\n\",\n                      errout_str());\n\n        ctu(\"void g(int *b) { b[0] = 0; }\\n\"\n            \"void f() {\\n\"\n            \"    GLint a[1];\\n\"\n            \"    g(a);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"const int a[1] = { 1 };\\n\" // #11042\n            \"void g(const int* d) {\\n\"\n            \"    (void)d[2];\\n\"\n            \"}\\n\"\n            \"void f() {\\n\"\n            \"    g(a);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:6] -> [test.cpp:3:11]: (error) Array index out of bounds; 'd' buffer size is 4 and it is accessed at offset 8. [ctuArrayIndex]\\n\",\n                      errout_str());\n    }\n\n    void ctu_variable() {\n        ctu(\"void dostuff(int *p) {\\n\"\n            \"    p[10] = 0;\\n\"\n            \"}\\n\"\n            \"int main() {\\n\"\n            \"  int x = 4;\\n\"\n            \"  dostuff(&x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:10] -> [test.cpp:2:5]: (error) Array index out of bounds; 'p' buffer size is 4 and it is accessed at offset 40. [ctuArrayIndex]\\n\", errout_str());\n    }\n\n    void ctu_arithmetic() {\n        ctu(\"void dostuff(int *p) { x = p + 10; }\\n\"\n            \"int main() {\\n\"\n            \"  int x[3];\\n\"\n            \"  dostuff(x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10] -> [test.cpp:1:28]: (error) Pointer arithmetic overflow; 'p' buffer size is 12 [ctuPointerArith]\\n\", errout_str());\n\n        ctu(\"void f(const char *p) {\\n\" // #11361\n            \"    const char* c = p + 1;\\n\"\n            \"}\\n\"\n            \"void g() {\\n\"\n            \"    const char s[N] = \\\"ab\\\";\\n\"\n            \"    f(s);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void objectIndex() {\n        check(\"int f() {\\n\"\n              \"    int i;\\n\"\n              \"    return (&i)[1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:13] -> [test.cpp:3:16]: (error) The address of variable 'i' is accessed at non-zero index. [objectIndex]\\n\",\n            errout_str());\n\n        check(\"int f(int j) {\\n\"\n              \"    int i;\\n\"\n              \"    return (&i)[j];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:13] -> [test.cpp:3:16]: (warning) The address of variable 'i' might be accessed at non-zero index. [objectIndex]\\n\",\n            errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int i;\\n\"\n              \"    return (&i)[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int * i) {\\n\"\n              \"    return i[1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::vector<int> i) {\\n\"\n              \"    return i[1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::vector<int> i) {\\n\"\n              \"    return i.data()[1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int* f(std::vector<int>& i) {\\n\"\n              \"    return &(i[1]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int i; int j; };\\n\"\n              \"int f() {\\n\"\n              \"    A x;\\n\"\n              \"    return (&x.i)[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int i; int j; };\\n\"\n              \"int f() {\\n\"\n              \"    A x;\\n\"\n              \"    int * i = &x.i;\\n\"\n              \"    return i[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int x = 0;\\n\"\n              \"  std::map<int, int*> m;\\n\"\n              \"  m[0] = &x;\\n\"\n              \"  m[1] = &x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"  int x = 0;\\n\"\n              \"  std::map<int, int*> m;\\n\"\n              \"  m[0] = &x;\\n\"\n              \"  return m[0][1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:10] -> [test.cpp:5:14]: (error) The address of variable 'x' is accessed at non-zero index. [objectIndex]\\n\",\n            errout_str());\n\n        check(\"int x = 0;\\n\"\n              \"int f() {\\n\"\n              \"  std::map<int, int*> m;\\n\"\n              \"  m[0] = &x;\\n\"\n              \"  return m[0][1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:10] -> [test.cpp:5:14]: (error) The address of variable 'x' is accessed at non-zero index. [objectIndex]\\n\",\n            errout_str());\n\n        check(\"int f(int * y) {\\n\"\n              \"  int x = 0;\\n\"\n              \"  std::map<int, int*> m;\\n\"\n              \"  m[0] = &x;\\n\"\n              \"  m[1] = y;\\n\"\n              \"  return m[1][1];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void print(char** test);\\n\"\n              \"int main(){\\n\"\n              \"    char* test = \\\"abcdef\\\";\\n\"\n              \"    print(&test);\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\"\n              \"void print(char** test){\\n\"\n              \"    for(int i=0;i<strlen(*test);i++)\\n\"\n              \"        printf(\\\"%c\\\",*test[i]);\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:4] -> [test.cpp:4] -> [test.cpp:9]: (warning) The address of local variable 'test' might be accessed at non-zero index.\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void Bar(uint8_t data);\\n\"\n              \"void Foo(const uint8_t * const data, const uint8_t length) {\\n\"\n              \"        for(uint8_t index = 0U; index < length ; ++index)\\n\"\n              \"            Bar(data[index]);\\n\"\n              \"}\\n\"\n              \"void test() {\\n\"\n              \"    const uint8_t data = 0U;\\n\"\n              \"    Foo(&data,1U);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int n, int* p) {\\n\"\n              \"    int res = 0;\\n\"\n              \"    for(int i = 0; i < n; i++ )\\n\"\n              \"        res += p[i];\\n\"\n              \"    return res;\\n\"\n              \"}\\n\"\n              \"int bar() {\\n\"\n              \"    int single_value = 0;\\n\"\n              \"    return foo(1, &single_value);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const char* app, size_t applen) {\\n\" // #10137\n              \"    char* tmp_de = NULL;\\n\"\n              \"    char** str = &tmp_de;\\n\"\n              \"    char* tmp = (char*)realloc(*str, applen + 1);\\n\"\n              \"    if (tmp) {\\n\"\n              \"        *str = tmp;\\n\"\n              \"        memcpy(*str, app, applen);\\n\"\n              \"        (*str)[applen] = '\\\\0';\\n\"\n              \"    }\\n\"\n              \"    free(*str);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <typename T, unsigned N>\\n\"\n              \"using vector = Eigen::Matrix<T, N, 1>;\\n\"\n              \"template <typename V>\\n\"\n              \"void scharr(image2d<vector<V, 2>>& out) {\\n\"\n              \"    vector<V, 2>* out_row = &out(r, 0);\\n\"\n              \"    out_row[c] = vector<V, 2>(1,2);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const uint8_t* d, const uint8_t L) {\\n\" // #10092\n              \"    for (uint8_t i = 0U; i < L; ++i)\\n\"\n              \"        g(d[i]);\\n\"\n              \"}\\n\"\n              \"void h() {\\n\"\n              \"    const uint8_t u = 4;\\n\"\n              \"    f(&u, N);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"uint32_t f(uint32_t u) {\\n\" // #10154\n              \"    return ((uint8_t*)&u)[3];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"uint32_t f(uint32_t u) {\\n\"\n              \"    return ((uint8_t*)&u)[4];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:23] -> [test.cpp:2:26]: (error) The address of variable 'u' is accessed at non-zero index. [objectIndex]\\n\", errout_str());\n\n        check(\"uint32_t f(uint32_t u) {\\n\"\n              \"    return reinterpret_cast<unsigned char*>(&u)[3];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"uint32_t f(uint32_t u) {\\n\"\n              \"    return reinterpret_cast<unsigned char*>(&u)[4];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:45] -> [test.cpp:2:48]: (error) The address of variable 'u' is accessed at non-zero index. [objectIndex]\\n\", errout_str());\n\n        check(\"uint32_t f(uint32_t u) {\\n\"\n              \"    uint8_t* p = (uint8_t*)&u;\\n\"\n              \"    return p[3];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"uint32_t f(uint32_t u) {\\n\"\n              \"    uint8_t* p = (uint8_t*)&u;\\n\"\n              \"    return p[4];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:28] -> [test.cpp:3:13]: (error) The address of variable 'u' is accessed at non-zero index. [objectIndex]\\n\", errout_str());\n\n        check(\"uint32_t f(uint32_t* pu) {\\n\"\n              \"    uint8_t* p = (uint8_t*)pu;\\n\"\n              \"    return p[4];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { uint8_t padding[500]; };\\n\" // #10133\n              \"S s = { 0 };\\n\"\n              \"uint8_t f() {\\n\"\n              \"    uint8_t* p = (uint8_t*)&s;\\n\"\n              \"    return p[10];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X {\\n\" // #2654\n              \"    int  a;\\n\"\n              \"    char b;\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    const X s;\\n\"\n              \"    const int* y = &s.a;\\n\"\n              \"    (void)y[0];\\n\"\n              \"    (void)y[1];\\n\"\n              \"    (void)y[2];\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n    }\n\n    void checkPipeParameterSize() { // #3521\n\n        const Settings settings = settingsBuilder().library(\"posix.cfg\").build();\n\n        check(\"void f(){\\n\"\n              \"int pipefd[1];\\n\" // <--  array of two integers is needed\n              \"if (pipe(pipefd) == -1) {\\n\"\n              \"    return;\\n\"\n              \"  }\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (error) Buffer is accessed out of bounds: pipefd [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(){\\n\"\n              \"int pipefd[2];\\n\"\n              \"if (pipe(pipefd) == -1) {\\n\"\n              \"    return;\\n\"\n              \"  }\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(){\\n\"\n              \"char pipefd[2];\\n\"\n              \"if (pipe((int*)pipefd) == -1) {\\n\"\n              \"    return;\\n\"\n              \"  }\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (error) Buffer is accessed out of bounds: (int*)pipefd [bufferAccessOutOfBounds]\\n\", errout_str());\n\n        check(\"void f(){\\n\"\n              \"char pipefd[20];\\n\" // Strange, but large enough\n              \"if (pipe((int*)pipefd) == -1) {\\n\"\n              \"    return;\\n\"\n              \"  }\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestBufferOverrun)\n"
    }
  ]
}