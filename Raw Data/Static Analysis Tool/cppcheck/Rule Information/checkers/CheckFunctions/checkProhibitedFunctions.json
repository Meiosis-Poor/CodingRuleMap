{
  "name": "checkProhibitedFunctions",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 39,
  "branches": 13,
  "apis": 33,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        136
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkfunctions.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"platform.h\"\n#include \"settings.h\"\n#include \"standards.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestFunctions : public TestFixture {\npublic:\n    TestFunctions() : TestFixture(\"TestFunctions\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().severity(Severity::style).severity(Severity::warning).severity(Severity::performance).severity(Severity::portability).\n                              certainty(Certainty::inconclusive).c(Standards::C11).cpp(Standards::CPP11).library(\"std.cfg\").library(\"posix.cfg\").build();\n\n    void run() override {\n        mNewTemplate = true;\n        // Prohibited functions\n        TEST_CASE(prohibitedFunctions_posix);\n        TEST_CASE(prohibitedFunctions_index);\n        TEST_CASE(prohibitedFunctions_qt_index); // FP when using the Qt function 'index'?\n        TEST_CASE(prohibitedFunctions_rindex);\n        TEST_CASE(prohibitedFunctions_var); // no false positives for variables\n        TEST_CASE(prohibitedFunctions_gets); // dangerous function\n        TEST_CASE(prohibitedFunctions_alloca);\n        TEST_CASE(prohibitedFunctions_declaredFunction); // declared function ticket #3121\n        TEST_CASE(prohibitedFunctions_std_gets); // test std::gets\n        TEST_CASE(prohibitedFunctions_multiple); // multiple use of obsolete functions\n        TEST_CASE(prohibitedFunctions_c_declaration); // c declared function\n        TEST_CASE(prohibitedFunctions_functionWithBody); // function with body\n        TEST_CASE(prohibitedFunctions_crypt); // Non-reentrant function\n        TEST_CASE(prohibitedFunctions_namespaceHandling);\n\n        // Invalid function usage\n        TEST_CASE(invalidFunctionUsage1);\n        TEST_CASE(invalidFunctionUsageStrings);\n\n        // Invalid function argument\n        TEST_CASE(invalidFunctionArg1);\n\n        // Math function usage\n        TEST_CASE(mathfunctionCall_fmod);\n        TEST_CASE(mathfunctionCall_sqrt);\n        TEST_CASE(mathfunctionCall_log);\n        TEST_CASE(mathfunctionCall_acos);\n        TEST_CASE(mathfunctionCall_asin);\n        TEST_CASE(mathfunctionCall_pow);\n        TEST_CASE(mathfunctionCall_atan2);\n        TEST_CASE(mathfunctionCall_precision);\n\n        // Ignored return value\n        TEST_CASE(checkIgnoredReturnValue);\n        TEST_CASE(checkIgnoredErrorCode);\n\n        // memset..\n        TEST_CASE(memsetZeroBytes);\n        TEST_CASE(memsetInvalid2ndParam);\n\n        // missing \"return\"\n        TEST_CASE(checkMissingReturn1);\n        TEST_CASE(checkMissingReturn2); // #11798\n        TEST_CASE(checkMissingReturn3);\n        TEST_CASE(checkMissingReturn4);\n        TEST_CASE(checkMissingReturn5);\n        TEST_CASE(checkMissingReturn6); // #13180\n\n        // std::move for locar variable\n        TEST_CASE(returnLocalStdMove1);\n        TEST_CASE(returnLocalStdMove2);\n        TEST_CASE(returnLocalStdMove3);\n        TEST_CASE(returnLocalStdMove4);\n\n        TEST_CASE(returnLocalStdMove5);\n\n        TEST_CASE(negativeMemoryAllocationSizeError); // #389\n\n        TEST_CASE(checkLibraryMatchFunctions);\n\n        TEST_CASE(checkUseStandardLibrary1);\n        TEST_CASE(checkUseStandardLibrary2);\n        TEST_CASE(checkUseStandardLibrary3);\n        TEST_CASE(checkUseStandardLibrary4);\n        TEST_CASE(checkUseStandardLibrary5);\n        TEST_CASE(checkUseStandardLibrary6);\n        TEST_CASE(checkUseStandardLibrary7);\n        TEST_CASE(checkUseStandardLibrary8);\n        TEST_CASE(checkUseStandardLibrary9);\n        TEST_CASE(checkUseStandardLibrary10);\n        TEST_CASE(checkUseStandardLibrary11);\n        TEST_CASE(checkUseStandardLibrary12);\n        TEST_CASE(checkUseStandardLibrary13);\n        TEST_CASE(checkUseStandardLibrary14);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        bool cpp = true;\n        const Settings* s = nullptr;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings& s = options.s ? *options.s : settings;\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(s, *this, options.cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        runChecks<CheckFunctions>(tokenizer, this);\n    }\n\n    void prohibitedFunctions_posix() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    bsd_signal(SIGABRT, SIG_IGN);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Obsolescent function 'bsd_signal' called. It is recommended to use 'sigaction' instead. [bsd_signalCalled]\\n\", errout_str());\n\n        check(\"int f()\\n\"\n              \"{\\n\"\n              \"    int bsd_signal(0);\\n\"\n              \"    return bsd_signal;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    struct hostent *hp;\\n\"\n              \"    if(!hp = gethostbyname(\\\"127.0.0.1\\\")) {\\n\"\n              \"        exit(1);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (style) Obsolescent function 'gethostbyname' called. It is recommended to use 'getaddrinfo' instead. [gethostbynameCalled]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    long addr;\\n\"\n              \"    addr = inet_addr(\\\"127.0.0.1\\\");\\n\"\n              \"    if(!hp = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET)) {\\n\"\n              \"        exit(1);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:14]: (style) Obsolescent function 'gethostbyaddr' called. It is recommended to use 'getnameinfo' instead. [gethostbyaddrCalled]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    usleep( 1000 );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Obsolescent function 'usleep' called. It is recommended to use 'nanosleep' or 'setitimer' instead. [usleepCalled]\\n\", errout_str());\n    }\n\n    void prohibitedFunctions_index() {\n        check(\"namespace n1 {\\n\"\n              \"    int index(){ return 1; };\\n\"\n              \"}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    n1::index();\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::size_t f()\\n\"\n              \"{\\n\"\n              \"    std::size_t index(0);\\n\"\n              \"    index++;\\n\"\n              \"    return index;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f()\\n\"\n              \"{\\n\"\n              \"    return this->index();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int index( 0 );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const char f()\\n\"\n              \"{\\n\"\n              \"    const char var[6] = \\\"index\\\";\\n\"\n              \"    const char i = index(var, 0);\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: (style) Obsolescent function 'index' called. It is recommended to use 'strchr' instead. [indexCalled]\\n\",\n                      errout_str());\n    }\n\n    void prohibitedFunctions_qt_index() {\n        check(\"void TDataModel::forceRowRefresh(int row) {\\n\"\n              \"    emit dataChanged(index(row, 0), index(row, columnCount() - 1));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:22]: (style) Obsolescent function 'index' called. It is recommended to use 'strchr' instead. [indexCalled]\\n\"\n            \"[test.cpp:2:37]: (style) Obsolescent function 'index' called. It is recommended to use 'strchr' instead. [indexCalled]\\n\",   // duplicate\n            errout_str());\n    }\n\n    void prohibitedFunctions_rindex() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int rindex( 0 );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    const char var[7] = \\\"rindex\\\";\\n\"\n              \"    print(rindex(var, 0));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Obsolescent function 'rindex' called. It is recommended to use 'strrchr' instead. [rindexCalled]\\n\", errout_str());\n    }\n\n\n    void prohibitedFunctions_var() {\n        check(\"class Fred {\\n\"\n              \"public:\\n\"\n              \"    Fred() : index(0) { }\\n\"\n              \"    int index;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void prohibitedFunctions_gets() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *x = gets(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (warning) Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    foo(x, gets(a));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (warning) Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]\\n\", errout_str());\n    }\n\n    void prohibitedFunctions_alloca() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *x = alloca(10);\\n\"\n              \"}\");  // #4382 - there are no VLAs in C++\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (warning) Obsolete function 'alloca' called. [allocaCalled]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *x = alloca(10);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:15]: (warning) Obsolete function 'alloca' called. In C99 and later it is recommended to use a variable length array instead. [allocaCalled]\\n\", errout_str());\n\n        const Settings s = settingsBuilder(settings).c(Standards::C89).cpp(Standards::CPP03).build();\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *x = alloca(10);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &s));  // #4382 - there are no VLAs in C++\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *x = alloca(10);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false, $.s = &s)); // #7558 - no alternative to alloca in C89\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *x = alloca(10);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // ticket #3121\n    void prohibitedFunctions_declaredFunction() {\n        check(\"int ftime ( int a )\\n\"\n              \"{\\n\"\n              \"    return a;\\n\"\n              \"}\\n\"\n              \"int main ()\\n\"\n              \"{\\n\"\n              \"    int b ; b = ftime ( 1 ) ;\\n\"\n              \"    return 0 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // test std::gets\n    void prohibitedFunctions_std_gets() {\n        check(\"void f(char * str)\\n\"\n              \"{\\n\"\n              \"    char *x = std::gets(str);\\n\"\n              \"    char *y = gets(str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (warning) Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]\\n\"\n                      \"[test.cpp:4:15]: (warning) Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]\\n\", errout_str());\n    }\n\n    // multiple use\n    void prohibitedFunctions_multiple() {\n        check(\"void f(char * str)\\n\"\n              \"{\\n\"\n              \"    char *x = std::gets(str);\\n\"\n              \"    usleep( 1000 );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (warning) Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]\\n\"\n                      \"[test.cpp:4:5]: (style) Obsolescent function 'usleep' called. It is recommended to use 'nanosleep' or 'setitimer' instead. [usleepCalled]\\n\", errout_str());\n    }\n\n    void prohibitedFunctions_c_declaration() {\n        check(\"char * gets ( char * c ) ;\\n\"\n              \"int main ()\\n\"\n              \"{\\n\"\n              \"    char s [ 10 ] ;\\n\"\n              \"    gets ( s ) ;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (warning) Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]\\n\", errout_str());\n\n        check(\"int getcontext(ucontext_t *ucp);\\n\"\n              \"void f (ucontext_t *ucp)\\n\"\n              \"{\\n\"\n              \"    getcontext ( ucp ) ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (portability) Obsolescent function 'getcontext' called. Applications are recommended to be rewritten to use POSIX threads. [getcontextCalled]\\n\", errout_str());\n    }\n\n    void prohibitedFunctions_functionWithBody() {\n        check(\"char * gets ( char * c ) { return c; }\\n\"\n              \"int main ()\\n\"\n              \"{\\n\"\n              \"    char s [ 10 ] ;\\n\"\n              \"    gets ( s ) ;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void prohibitedFunctions_crypt() {\n        check(\"void f(char *pwd)\\n\"\n              \"{\\n\"\n              \"    char *cpwd;\"\n              \"    crypt(pwd, cpwd);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (warning) Return value of function crypt() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:3:20]: (portability) Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'. [cryptCalled]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *pwd = getpass(\\\"Password:\\\");\"\n              \"    char *cpwd;\"\n              \"    crypt(pwd, cpwd);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:57]: (warning) Return value of function crypt() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:3:57]: (portability) Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'. [cryptCalled]\\n\", errout_str());\n\n        check(\"int f()\\n\"\n              \"{\\n\"\n              \"    int crypt = 0;\"\n              \"    return crypt;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void prohibitedFunctions_namespaceHandling() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    time_t t = 0;\"\n              \"    auto lt = std::localtime(&t);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:37]: (portability) Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'. [localtimeCalled]\\n\", errout_str());\n\n        // Passed as function argument\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    printf(\\\"Magic guess: %d\\\", getpwent());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:31]: (portability) Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'. [getpwentCalled]\\n\", errout_str());\n\n        // Pass return value\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    time_t t = 0;\"\n              \"    struct tm *foo = localtime(&t);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:39]: (portability) Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'. [localtimeCalled]\\n\", errout_str());\n\n        // Access via global namespace\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    ::getpwent();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Return value of function ::getpwent() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:3:7]: (portability) Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'. [getpwentCalled]\\n\", errout_str());\n\n        // Be quiet on function definitions\n        check(\"int getpwent()\\n\"\n              \"{\\n\"\n              \"    return 123;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Be quiet on other namespaces\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    foobar::getpwent();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Be quiet on class member functions\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    foobar.getpwent();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void invalidFunctionUsage1() {\n        check(\"void f() { memset(a,b,sizeof(a)!=12); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:32]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n\n        check(\"void f() { memset(a,b,sizeof(a)!=0); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:32]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n\n        check(\"void f() { memset(a,b,!c); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n\n        // Ticket #6990\n        check(\"void f(bool c) { memset(a,b,c); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:29]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n        check(\"void f() { memset(a,b,true); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n\n        // Ticket #6588 (c mode)\n        check(\"void record(char* buf, int n) {\\n\"\n              \"  memset(buf, 0, n < 255);\\n\"           /* KO */\n              \"  memset(buf, 0, n < 255 ? n : 255);\\n\" /* OK */\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:2:20]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n\n        // Ticket #6588 (c++ mode)\n        check(\"void record(char* buf, int n) {\\n\"\n              \"  memset(buf, 0, n < 255);\\n\"           /* KO */\n              \"  memset(buf, 0, n < 255 ? n : 255);\\n\" /* OK */\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (error) Invalid memset() argument nr 3. A non-boolean value is required. [invalidFunctionArgBool]\\n\", errout_str());\n\n        check(\"int boolArgZeroIsInvalidButOneIsValid(int a, int param) {\\n\"\n              \"  return div(a, param > 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (error) Invalid div() argument nr 2. The value is 0 or 1 (boolean) but the valid values are ':-1,1:'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void boolArgZeroIsValidButOneIsInvalid(int param) {\\n\"\n              \"  strtol(a, b, param > 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (error) Invalid strtol() argument nr 3. The value is 0 or 1 (boolean) but the valid values are '0,2:36'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void f() { strtol(a,b,1); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (error) Invalid strtol() argument nr 3. The value is 1 but the valid values are '0,2:36'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void f() { strtol(a,b,10); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\" //  #10754\n              \"    int N = -1;\\n\"\n              \"    for (long i = 0; i < g(); i++)\\n\"\n              \"        N = h(N);\\n\"\n              \"    v.resize(N);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:14]: (warning) Invalid v.resize() argument nr 1. The value is -1 but the valid values are '0:'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void f(std::vector<int>& v, int N) {\\n\"\n              \"    if (N < -1)\\n\"\n              \"        return;\\n\"\n              \"    v.resize(N);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:4:14]: (warning) Either the condition 'N<-1' is redundant or v.resize() argument nr 1 can have invalid value. The value is -1 but the valid values are '0:'. [invalidFunctionArg]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v, int N) {\\n\"\n              \"    if (N == -1) {}\\n\"\n              \"    v.resize(N);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:14]: (warning) Either the condition 'N==-1' is redundant or v.resize() argument nr 1 can have invalid value. The value is -1 but the valid values are '0:'. [invalidFunctionArg]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v, int N, bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        N = -1;\\n\"\n              \"    v.resize(N);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (warning) Invalid v.resize() argument nr 1. The value is -1 but the valid values are '0:'. [invalidFunctionArg]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    int N = -1;\\n\"\n              \"    v.resize(N);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Invalid v.resize() argument nr 1. The value is -1 but the valid values are '0:'. [invalidFunctionArg]\\n\",\n                      errout_str());\n    }\n\n    void invalidFunctionUsageStrings() {\n        check(\"size_t f() { char x = 'x'; return strlen(&x); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:42]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"size_t f() { return strlen(&x); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f(char x) { return strlen(&x); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:34]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"size_t f() { char x = '\\\\0'; return strlen(&x); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f() {\\n\"\n              \"  char x;\\n\"\n              \"  if (y)\\n\"\n              \"    x = '\\\\0';\\n\"\n              \"  else\\n\"\n              \"    x = 'a';\\n\"\n              \"  return strlen(&x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:17]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"int f() { char x = '\\\\0'; return strcmp(\\\"Hello world\\\", &x); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() { char x = 'x'; return strcmp(\\\"Hello world\\\", &x); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:54]: (error) Invalid strcmp() argument nr 2. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"size_t f(char x) { char * y = &x; return strlen(y); }\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:1:42]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", \"\", errout_str());\n\n        check(\"size_t f(char x) { char * y = &x; char *z = y; return strlen(z); }\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:1:42]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", \"\", errout_str());\n\n        check(\"size_t f() { char x = 'x'; char * y = &x; char *z = y; return strlen(z); }\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:1:42]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", \"\", errout_str());\n\n        check(\"size_t f() { char x = '\\\\0'; char * y = &x; char *z = y; return strlen(z); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f() { char x[] = \\\"Hello world\\\"; return strlen(x); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f(char x[]) { return strlen(x); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(char x, char y) { return strcmp(&x, &y); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:39]: (error) Invalid strcmp() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\"\n                      \"[test.cpp:1:43]: (error) Invalid strcmp() argument nr 2. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"size_t f() { char x[] = \\\"Hello world\\\"; return strlen(&x[0]); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f() { char* x = \\\"Hello world\\\"; return strlen(&x[0]); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"  char x;\\n\"\n              \"};\\n\"\n              \"size_t f() {\\n\"\n              \"  S s1 = {0};\\n\"\n              \"  S s2;\\n;\"\n              \"  s2.x = 'x';\\n\"\n              \"  size_t l1 = strlen(&s1.x);\\n\"\n              \"  size_t l2 = strlen(&s2.x);\\n\"\n              \"  return l1 + l2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:22]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\"\n                      \"[test.cpp:9:22]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"const char x = 'x'; size_t f() { return strlen(&x); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:48]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"struct someStruct {\\n\"\n              \"    union {\\n\"\n              \"        struct {\\n\"\n              \"            uint16_t nr;\\n\"\n              \"            uint8_t d[40];\\n\"\n              \"        } data;\\n\"\n              \"        char buf[42];\\n\"\n              \"    } x;\\n\"\n              \"};\\n\"\n              \"int f(struct someStruct * const tp, const int k)\\n\"\n              \"{\\n\"\n              \"    return strcmp(&tp->x.buf[k], \\\"needle\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct someStruct {\\n\"\n              \"    char buf[42];\\n\"\n              \"};\\n\"\n              \"int f(struct someStruct * const tp, const int k)\\n\"\n              \"{\\n\"\n              \"    return strcmp(&tp->buf[k], \\\"needle\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const char x = 'x'; size_t f() { char y = x; return strlen(&y); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:60]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"const char x = '\\\\0'; size_t f() { return strlen(&x); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const char x = '\\\\0'; size_t f() { char y = x; return strlen(&y); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f() {\\n\"\n              \"  char * a = \\\"Hello world\\\";\\n\"\n              \"  char ** b = &a;\\n\"\n              \"  return strlen(&b[0][0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f() {\\n\"\n              \"  char ca[] = \\\"asdf\\\";\\n\"\n              \"  return strlen((char*) &ca);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5225\n        check(\"int main(void)\\n\"\n              \"{\\n\"\n              \"  char str[80] = \\\"hello worl\\\";\\n\"\n              \"  char d = 'd';\\n\"\n              \"  strcat(str, &d);\\n\"\n              \"  puts(str);\\n\"\n              \"  return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (error) Invalid strcat() argument nr 2. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[1] = { \\'x\\' };\\n\"\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Invalid fopen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[2] = { \\'x\\', \\'y\\' };\\n\"\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Invalid fopen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[3] = { \\'x\\', \\'y\\' ,\\'\\\\0\\' };\\n\"\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[3] = { \\'x\\', \\'\\\\0\\' ,\\'y\\' };\\n\"\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[3] = { \\'x\\', \\'y\\' };\\n\" // implicit '\\0' added at the end\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[] = { \\'\\\\0\\' };\\n\"\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[] = { \\'0\\' + 42 };\\n\" // no size is explicitly defined, no implicit '\\0' is added\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Invalid fopen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[] = { \\'0\\' + 42, \\'x\\' };\\n\" // no size is explicitly defined, no implicit '\\0' is added\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Invalid fopen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[2] = { \\'0\\' + 42 };\\n\" // implicitly '\\0' added at the end because size is set to 2\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"FILE* f(void) {\\n\"\n              \"  const char fileName[] = { };\\n\"\n              \"  return fopen(fileName, \\\"r\\\"); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void scanMetaTypes()\\n\" // don't crash\n              \"{\\n\"\n              \"    QVector<int> metaTypes;\\n\"\n              \"    for (int mtId = 0; mtId <= QMetaType::User; ++mtId) {\\n\"\n              \"        const auto name = QMetaType::typeName(mtId);\\n\"\n              \"        if (strstr(name, \\\"GammaRay::\\\") != name)\\n\"\n              \"            metaTypes.push_back(mtId);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    const char c[3] = \\\"abc\\\";\\n\"\n              \"    return strlen(c);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Invalid strlen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    const wchar_t c[3] = L\\\"abc\\\";\\n\"\n              \"    return wcslen(c);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Invalid wcslen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"void f(char* dest) {\\n\"\n              \"    char if_name[(IF_NAMESIZE > 21 ? IF_NAMESIZE : 21) + 1] = \\\"%\\\";\\n\"\n              \"    strcat(dest, if_name);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    const char c[3] = \\\"ab\\\\0\\\";\\n\"\n              \"    return strlen(c);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int n) {\\n\" // #11179\n              \"    char s[8] = \\\"        \\\";\\n\"\n              \"    n = (n + 1) % 100;\\n\"\n              \"    sprintf(s, \\\"lwip%02d\\\", n);\\n\"\n              \"    s[strlen(s)] = ' ';\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t f() { wchar_t x = L'x'; return wcslen(&x); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:46]: (error) Invalid wcslen() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n\n        check(\"void f() { char a[10] = \\\"1234567890\\\"; puts(a); }\", dinit(CheckOptions, $.cpp = false)); // #1770\n        ASSERT_EQUALS(\"[test.c:1:44]: (error) Invalid puts() argument nr 1. A nul-terminated string is required. [invalidFunctionArgStr]\\n\", errout_str());\n    }\n\n    void invalidFunctionArg1() {\n        const Settings settingsUnix32 = settingsBuilder(settings).platform(Platform::Unix32).build();\n        check(\"int main() {\\n\"\n              \"    char tgt[7];\\n\"\n              \"    char src[7+1] = \\\"7777777\\\";\\n\"\n              \"    if (sizeof tgt <= sizeof src) {\\n\"\n              \"        memmove(&tgt, &src, sizeof tgt);\\n\"\n              \"    } else {\\n\"\n              \"        memmove(&tgt, &src, sizeof src);\\n\"\n              \"        memset(&tgt + sizeof src, ' ', sizeof tgt - sizeof src);\\n\"\n              \"    }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = false, $.s = &settingsUnix32));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mathfunctionCall_sqrt() {\n        // sqrt, sqrtf, sqrtl\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  sqrt(-1) << std::endl;\\n\"\n              \"    std::cout <<  sqrtf(-1) << std::endl;\\n\"\n              \"    std::cout <<  sqrtl(-1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (error) Invalid sqrt() argument nr 1. The value is -1 but the valid values are '0.0:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:26]: (error) Invalid sqrtf() argument nr 1. The value is -1 but the valid values are '0.0:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:26]: (error) Invalid sqrtl() argument nr 1. The value is -1 but the valid values are '0.0:'. [invalidFunctionArg]\\n\", errout_str());\n\n        // implementation-defined behaviour for \"finite values of x<0\" only:\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  sqrt(-0.) << std::endl;\\n\"\n              \"    std::cout <<  sqrtf(-0.) << std::endl;\\n\"\n              \"    std::cout <<  sqrtl(-0.) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  sqrt(1) << std::endl;\\n\"\n              \"    std::cout <<  sqrtf(1) << std::endl;\\n\"\n              \"    std::cout <<  sqrtl(1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mathfunctionCall_log() {\n        // log,log10,logf,logl,log10f,log10l,log2,log2f,log2l,log1p,log1pf,log1pl\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  log(-2) << std::endl;\\n\"\n              \"    std::cout <<  logf(-2) << std::endl;\\n\"\n              \"    std::cout <<  logl(-2) << std::endl;\\n\"\n              \"    std::cout <<  log10(-2) << std::endl;\\n\"\n              \"    std::cout <<  log10f(-2) << std::endl;\\n\"\n              \"    std::cout <<  log10l(-2) << std::endl;\\n\"\n              \"    std::cout <<  log2(-2) << std::endl;\\n\"\n              \"    std::cout <<  log2f(-2) << std::endl;\\n\"\n              \"    std::cout <<  log2l(-2) << std::endl;\\n\"\n              \"    std::cout <<  log1p(-3) << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-3) << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-3) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:24]: (error) Invalid log() argument nr 1. The value is -2 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:25]: (error) Invalid logf() argument nr 1. The value is -2 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:25]: (error) Invalid logl() argument nr 1. The value is -2 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:6:26]: (error) Invalid log10() argument nr 1. The value is -2 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:7:27]: (error) Invalid log10f() argument nr 1. The value is -2 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:8:27]: (error) Invalid log10l() argument nr 1. The value is -2 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:9:25]: (error) Invalid log2() argument nr 1. The value is -2 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:10:26]: (error) Invalid log2f() argument nr 1. The value is -2 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:11:26]: (error) Invalid log2l() argument nr 1. The value is -2 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:3:19]: (warning) Passing value -2 to log() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing value -2 to logf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing value -2 to logl() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:6:19]: (warning) Passing value -2 to log10() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:7:19]: (warning) Passing value -2 to log10f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:8:19]: (warning) Passing value -2 to log10l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:9:19]: (warning) Passing value -2 to log2() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:10:19]: (warning) Passing value -2 to log2f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:11:19]: (warning) Passing value -2 to log2l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:12:19]: (warning) Passing value -3 to log1p() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:13:19]: (warning) Passing value -3 to log1pf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:14:19]: (warning) Passing value -3 to log1pl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  log(-1) << std::endl;\\n\"\n              \"    std::cout <<  logf(-1) << std::endl;\\n\"\n              \"    std::cout <<  logl(-1) << std::endl;\\n\"\n              \"    std::cout <<  log10(-1) << std::endl;\\n\"\n              \"    std::cout <<  log10f(-1) << std::endl;\\n\"\n              \"    std::cout <<  log10l(-1) << std::endl;\\n\"\n              \"    std::cout <<  log2(-1) << std::endl;\\n\"\n              \"    std::cout <<  log2f(-1) << std::endl;\\n\"\n              \"    std::cout <<  log2l(-1) << std::endl;\\n\"\n              \"    std::cout <<  log1p(-2) << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-2) << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-2) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:24]: (error) Invalid log() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:25]: (error) Invalid logf() argument nr 1. The value is -1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:25]: (error) Invalid logl() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:6:26]: (error) Invalid log10() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:7:27]: (error) Invalid log10f() argument nr 1. The value is -1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:8:27]: (error) Invalid log10l() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:9:25]: (error) Invalid log2() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:10:26]: (error) Invalid log2f() argument nr 1. The value is -1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:11:26]: (error) Invalid log2l() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:3:19]: (warning) Passing value -1 to log() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing value -1 to logf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing value -1 to logl() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:6:19]: (warning) Passing value -1 to log10() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:7:19]: (warning) Passing value -1 to log10f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:8:19]: (warning) Passing value -1 to log10l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:9:19]: (warning) Passing value -1 to log2() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:10:19]: (warning) Passing value -1 to log2f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:11:19]: (warning) Passing value -1 to log2l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:12:19]: (warning) Passing value -2 to log1p() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:13:19]: (warning) Passing value -2 to log1pf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:14:19]: (warning) Passing value -2 to log1pl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  log(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  logf(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  logl(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log10(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log10f(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log10l(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log2(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log2f(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log2l(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log1p(-2.0) << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-2.0) << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-2.0) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (error) Invalid log() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:26]: (error) Invalid logf() argument nr 1. The value is -1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:26]: (error) Invalid logl() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:6:27]: (error) Invalid log10() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:7:28]: (error) Invalid log10f() argument nr 1. The value is -1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:8:28]: (error) Invalid log10l() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:9:26]: (error) Invalid log2() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:10:27]: (error) Invalid log2f() argument nr 1. The value is -1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:11:27]: (error) Invalid log2l() argument nr 1. The value is -1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:3:19]: (warning) Passing value -1.0 to log() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing value -1.0 to logf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing value -1.0 to logl() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:6:19]: (warning) Passing value -1.0 to log10() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:7:19]: (warning) Passing value -1.0 to log10f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:8:19]: (warning) Passing value -1.0 to log10l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:9:19]: (warning) Passing value -1.0 to log2() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:10:19]: (warning) Passing value -1.0 to log2f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:11:19]: (warning) Passing value -1.0 to log2l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:12:19]: (warning) Passing value -2.0 to log1p() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:13:19]: (warning) Passing value -2.0 to log1pf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:14:19]: (warning) Passing value -2.0 to log1pl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  log(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  logf(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  logl(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log10(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log10f(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log10l(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log2(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log2f(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log2l(-0.1) << std::endl;\\n\"\n              \"    std::cout <<  log1p(-1.1) << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-1.1) << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-1.1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (error) Invalid log() argument nr 1. The value is -0.1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:26]: (error) Invalid logf() argument nr 1. The value is -0.1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:26]: (error) Invalid logl() argument nr 1. The value is -0.1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:6:27]: (error) Invalid log10() argument nr 1. The value is -0.1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:7:28]: (error) Invalid log10f() argument nr 1. The value is -0.1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:8:28]: (error) Invalid log10l() argument nr 1. The value is -0.1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:9:26]: (error) Invalid log2() argument nr 1. The value is -0.1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:10:27]: (error) Invalid log2f() argument nr 1. The value is -0.1 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:11:27]: (error) Invalid log2l() argument nr 1. The value is -0.1 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:3:19]: (warning) Passing value -0.1 to log() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing value -0.1 to logf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing value -0.1 to logl() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:6:19]: (warning) Passing value -0.1 to log10() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:7:19]: (warning) Passing value -0.1 to log10f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:8:19]: (warning) Passing value -0.1 to log10l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:9:19]: (warning) Passing value -0.1 to log2() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:10:19]: (warning) Passing value -0.1 to log2f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:11:19]: (warning) Passing value -0.1 to log2l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:12:19]: (warning) Passing value -1.1 to log1p() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:13:19]: (warning) Passing value -1.1 to log1pf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:14:19]: (warning) Passing value -1.1 to log1pl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  log(0) << std::endl;\\n\"\n              \"    std::cout <<  logf(0.) << std::endl;\\n\"\n              \"    std::cout <<  logl(0.0) << std::endl;\\n\"\n              \"    std::cout <<  log10(0.0) << std::endl;\\n\"\n              \"    std::cout <<  log10f(0) << std::endl;\\n\"\n              \"    std::cout <<  log10l(0.) << std::endl;\\n\"\n              \"    std::cout <<  log2(0.) << std::endl;\\n\"\n              \"    std::cout <<  log2f(0.0) << std::endl;\\n\"\n              \"    std::cout <<  log2l(0) << std::endl;\\n\"\n              \"    std::cout <<  log1p(-1.) << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-1.0) << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Invalid log() argument nr 1. The value is 0 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:25]: (error) Invalid logf() argument nr 1. The value is 0 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:25]: (error) Invalid logl() argument nr 1. The value is 0 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:6:26]: (error) Invalid log10() argument nr 1. The value is 0 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:7:26]: (error) Invalid log10f() argument nr 1. The value is 0 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:8:27]: (error) Invalid log10l() argument nr 1. The value is 0 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:9:25]: (error) Invalid log2() argument nr 1. The value is 0 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:10:26]: (error) Invalid log2f() argument nr 1. The value is 0 but the valid values are '1.4013e-45:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:11:25]: (error) Invalid log2l() argument nr 1. The value is 0 but the valid values are '4.94066e-324:'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:3:19]: (warning) Passing value 0 to log() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing value 0. to logf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing value 0.0 to logl() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:6:19]: (warning) Passing value 0.0 to log10() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:7:19]: (warning) Passing value 0 to log10f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:8:19]: (warning) Passing value 0. to log10l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:9:19]: (warning) Passing value 0. to log2() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:10:19]: (warning) Passing value 0.0 to log2f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:11:19]: (warning) Passing value 0 to log2l() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:12:19]: (warning) Passing value -1. to log1p() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:13:19]: (warning) Passing value -1.0 to log1pf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:14:19]: (warning) Passing value -1 to log1pl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  log(1E-3)         << std::endl;\\n\"\n              \"    std::cout <<  logf(1E-3)        << std::endl;\\n\"\n              \"    std::cout <<  logl(1E-3)        << std::endl;\\n\"\n              \"    std::cout <<  log10(1E-3)       << std::endl;\\n\"\n              \"    std::cout <<  log10f(1E-3)      << std::endl;\\n\"\n              \"    std::cout <<  log10l(1E-3)      << std::endl;\\n\"\n              \"    std::cout <<  log2(1E-3)        << std::endl;\\n\"\n              \"    std::cout <<  log2f(1E-3)       << std::endl;\\n\"\n              \"    std::cout <<  log2l(1E-3)       << std::endl;\\n\"\n              \"    std::cout <<  log1p(-1+1E-3)    << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-1+1E-3)   << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-1+1E-3)   << std::endl;\\n\"\n              \"    std::cout <<  log(1.0E-3)       << std::endl;\\n\"\n              \"    std::cout <<  logf(1.0E-3)      << std::endl;\\n\"\n              \"    std::cout <<  logl(1.0E-3)      << std::endl;\\n\"\n              \"    std::cout <<  log10(1.0E-3)     << std::endl;\\n\"\n              \"    std::cout <<  log10f(1.0E-3)    << std::endl;\\n\"\n              \"    std::cout <<  log10l(1.0E-3)    << std::endl;\\n\"\n              \"    std::cout <<  log2(1.0E-3)      << std::endl;\\n\"\n              \"    std::cout <<  log2f(1.0E-3)     << std::endl;\\n\"\n              \"    std::cout <<  log2l(1.0E-3)     << std::endl;\\n\"\n              \"    std::cout <<  log1p(-1+1.0E-3)  << std::endl;\\n\"\n              \"    std::cout <<  log1pf(-1+1.0E-3) << std::endl;\\n\"\n              \"    std::cout <<  log1pl(-1+1.0E-3) << std::endl;\\n\"\n              \"    std::cout <<  log(1.0E+3)       << std::endl;\\n\"\n              \"    std::cout <<  logf(1.0E+3)      << std::endl;\\n\"\n              \"    std::cout <<  logl(1.0E+3)      << std::endl;\\n\"\n              \"    std::cout <<  log10(1.0E+3)     << std::endl;\\n\"\n              \"    std::cout <<  log10f(1.0E+3)    << std::endl;\\n\"\n              \"    std::cout <<  log10l(1.0E+3)    << std::endl;\\n\"\n              \"    std::cout <<  log2(1.0E+3)      << std::endl;\\n\"\n              \"    std::cout <<  log2f(1.0E+3)     << std::endl;\\n\"\n              \"    std::cout <<  log2l(1.0E+3)     << std::endl;\\n\"\n              \"    std::cout <<  log1p(1.0E+3)     << std::endl;\\n\"\n              \"    std::cout <<  log1pf(1.0E+3)    << std::endl;\\n\"\n              \"    std::cout <<  log1pl(1.0E+3)    << std::endl;\\n\"\n              \"    std::cout <<  log(2.0)          << std::endl;\\n\"\n              \"    std::cout <<  logf(2.0)         << std::endl;\\n\"\n              \"    std::cout <<  logf(2.0f)        << std::endl;\\n\"\n              \"    std::cout <<  log10(2.0)        << std::endl;\\n\"\n              \"    std::cout <<  log10f(2.0)       << std::endl;\\n\"\n              \"    std::cout <<  log10f(2.0f)      << std::endl;\\n\"\n              \"    std::cout <<  log2(2.0)         << std::endl;\\n\"\n              \"    std::cout <<  log2f(2.0)        << std::endl;\\n\"\n              \"    std::cout <<  log2f(2.0f)       << std::endl;\\n\"\n              \"    std::cout <<  log1p(2.0)        << std::endl;\\n\"\n              \"    std::cout <<  log1pf(2.0)       << std::endl;\\n\"\n              \"    std::cout <<  log1pf(2.0f)      << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::string *log(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3473 - no warning if \"log\" is a variable\n        check(\"Fred::Fred() : log(0) { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5748\n        check(\"void f() { foo.log(0); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mathfunctionCall_acos() {\n        // acos, acosf, acosl\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \" return acos(-1)     \\n\"\n              \"    + acos(0.1)      \\n\"\n              \"    + acos(0.0001)   \\n\"\n              \"    + acos(0.01)     \\n\"\n              \"    + acos(1.0E-1)   \\n\"\n              \"    + acos(-1.0E-1)  \\n\"\n              \"    + acos(+1.0E-1)  \\n\"\n              \"    + acos(0.1E-1)   \\n\"\n              \"    + acos(+0.1E-1)  \\n\"\n              \"    + acos(-0.1E-1)  \\n\"\n              \"    + acosf(-1)      \\n\"\n              \"    + acosf(0.1)     \\n\"\n              \"    + acosf(0.0001)  \\n\"\n              \"    + acosf(0.01)    \\n\"\n              \"    + acosf(1.0E-1)  \\n\"\n              \"    + acosf(-1.0E-1) \\n\"\n              \"    + acosf(+1.0E-1) \\n\"\n              \"    + acosf(0.1E-1)  \\n\"\n              \"    + acosf(+0.1E-1) \\n\"\n              \"    + acosf(-0.1E-1) \\n\"\n              \"    + acosl(-1)      \\n\"\n              \"    + acosl(0.1)     \\n\"\n              \"    + acosl(0.0001)  \\n\"\n              \"    + acosl(0.01)    \\n\"\n              \"    + acosl(1.0E-1)  \\n\"\n              \"    + acosl(-1.0E-1) \\n\"\n              \"    + acosl(+1.0E-1) \\n\"\n              \"    + acosl(0.1E-1)  \\n\"\n              \"    + acosl(+0.1E-1) \\n\"\n              \"    + acosl(-0.1E-1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  acos(1.1) << std::endl;\\n\"\n              \"    std::cout <<  acosf(1.1) << std::endl;\\n\"\n              \"    std::cout <<  acosl(1.1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (error) Invalid acos() argument nr 1. The value is 1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:26]: (error) Invalid acosf() argument nr 1. The value is 1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:26]: (error) Invalid acosl() argument nr 1. The value is 1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  acos(-1.1) << std::endl;\\n\"\n              \"    std::cout <<  acosf(-1.1) << std::endl;\\n\"\n              \"    std::cout <<  acosl(-1.1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:26]: (error) Invalid acos() argument nr 1. The value is -1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:27]: (error) Invalid acosf() argument nr 1. The value is -1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:27]: (error) Invalid acosl() argument nr 1. The value is -1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\", errout_str());\n    }\n\n    void mathfunctionCall_asin() {\n        // asin, asinf, asinl\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \" return asin(1)      \\n\"\n              \"    + asin(-1)       \\n\"\n              \"    + asin(0.1)      \\n\"\n              \"    + asin(0.0001)   \\n\"\n              \"    + asin(0.01)     \\n\"\n              \"    + asin(1.0E-1)   \\n\"\n              \"    + asin(-1.0E-1)  \\n\"\n              \"    + asin(+1.0E-1)  \\n\"\n              \"    + asin(0.1E-1)   \\n\"\n              \"    + asin(+0.1E-1)  \\n\"\n              \"    + asin(-0.1E-1)  \\n\"\n              \"    + asinf(1)       \\n\"\n              \"    + asinf(-1)      \\n\"\n              \"    + asinf(0.1)     \\n\"\n              \"    + asinf(0.0001)  \\n\"\n              \"    + asinf(0.01)    \\n\"\n              \"    + asinf(1.0E-1)  \\n\"\n              \"    + asinf(-1.0E-1) \\n\"\n              \"    + asinf(+1.0E-1) \\n\"\n              \"    + asinf(0.1E-1)  \\n\"\n              \"    + asinf(+0.1E-1) \\n\"\n              \"    + asinf(-0.1E-1) \\n\"\n              \"    + asinl(1)       \\n\"\n              \"    + asinl(-1)      \\n\"\n              \"    + asinl(0.1)     \\n\"\n              \"    + asinl(0.0001)  \\n\"\n              \"    + asinl(0.01)    \\n\"\n              \"    + asinl(1.0E-1)  \\n\"\n              \"    + asinl(-1.0E-1) \\n\"\n              \"    + asinl(+1.0E-1) \\n\"\n              \"    + asinl(0.1E-1)  \\n\"\n              \"    + asinl(+0.1E-1) \\n\"\n              \"    + asinl(-0.1E-1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  asin(1.1) << std::endl;\\n\"\n              \"    std::cout <<  asinf(1.1) << std::endl;\\n\"\n              \"    std::cout <<  asinl(1.1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (error) Invalid asin() argument nr 1. The value is 1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:26]: (error) Invalid asinf() argument nr 1. The value is 1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:26]: (error) Invalid asinl() argument nr 1. The value is 1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  asin(-1.1) << std::endl;\\n\"\n              \"    std::cout <<  asinf(-1.1) << std::endl;\\n\"\n              \"    std::cout <<  asinl(-1.1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:26]: (error) Invalid asin() argument nr 1. The value is -1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:27]: (error) Invalid asinf() argument nr 1. The value is -1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:27]: (error) Invalid asinl() argument nr 1. The value is -1.1 but the valid values are '-1.0:1.0'. [invalidFunctionArg]\\n\", errout_str());\n    }\n\n    void mathfunctionCall_pow() {\n        // pow, powf, powl\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  pow(0,-10) << std::endl;\\n\"\n              \"    std::cout <<  powf(0,-10) << std::endl;\\n\"\n              \"    std::cout <<  powl(0,-10) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (warning) Passing values 0 and -10 to pow() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing values 0 and -10 to powf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing values 0 and -10 to powl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  pow(0,10) << std::endl;\\n\"\n              \"    std::cout <<  powf(0,10) << std::endl;\\n\"\n              \"    std::cout <<  powl(0,10) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mathfunctionCall_atan2() {\n        // atan2\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  atan2(1,1)         ;\\n\"\n              \"    std::cout <<  atan2(-1,-1)       ;\\n\"\n              \"    std::cout <<  atan2(0.1,1)       ;\\n\"\n              \"    std::cout <<  atan2(0.0001,100)  ;\\n\"\n              \"    std::cout <<  atan2(0.0,1e-1)    ;\\n\"\n              \"    std::cout <<  atan2(1.0E-1,-3)   ;\\n\"\n              \"    std::cout <<  atan2(-1.0E-1,+2)  ;\\n\"\n              \"    std::cout <<  atan2(+1.0E-1,0)   ;\\n\"\n              \"    std::cout <<  atan2(0.1E-1,3)    ;\\n\"\n              \"    std::cout <<  atan2(+0.1E-1,1)   ;\\n\"\n              \"    std::cout <<  atan2(-0.1E-1,8)   ;\\n\"\n              \"    std::cout <<  atan2f(1,1)        ;\\n\"\n              \"    std::cout <<  atan2f(-1,-1)      ;\\n\"\n              \"    std::cout <<  atan2f(0.1,1)      ;\\n\"\n              \"    std::cout <<  atan2f(0.0001,100) ;\\n\"\n              \"    std::cout <<  atan2f(0.0,1e-1)   ;\\n\"\n              \"    std::cout <<  atan2f(1.0E-1,-3)  ;\\n\"\n              \"    std::cout <<  atan2f(-1.0E-1,+2) ;\\n\"\n              \"    std::cout <<  atan2f(+1.0E-1,0)  ;\\n\"\n              \"    std::cout <<  atan2f(0.1E-1,3)   ;\\n\"\n              \"    std::cout <<  atan2f(+0.1E-1,1)  ;\\n\"\n              \"    std::cout <<  atan2f(-0.1E-1,8)  ;\\n\"\n              \"    std::cout <<  atan2l(1,1)        ;\\n\"\n              \"    std::cout <<  atan2l(-1,-1)      ;\\n\"\n              \"    std::cout <<  atan2l(0.1,1)      ;\\n\"\n              \"    std::cout <<  atan2l(0.0001,100) ;\\n\"\n              \"    std::cout <<  atan2l(0.0,1e-1)   ;\\n\"\n              \"    std::cout <<  atan2l(1.0E-1,-3)  ;\\n\"\n              \"    std::cout <<  atan2l(-1.0E-1,+2) ;\\n\"\n              \"    std::cout <<  atan2l(+1.0E-1,0)  ;\\n\"\n              \"    std::cout <<  atan2l(0.1E-1,3)   ;\\n\"\n              \"    std::cout <<  atan2l(+0.1E-1,1)  ;\\n\"\n              \"    std::cout <<  atan2l(-0.1E-1,8)  ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  atan2(0,0) << std::endl;\\n\"\n              \"    std::cout <<  atan2f(0,0) << std::endl;\\n\"\n              \"    std::cout <<  atan2l(0,0) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (warning) Passing values 0 and 0 to atan2() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing values 0 and 0 to atan2f() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing values 0 and 0 to atan2l() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n    }\n\n    void mathfunctionCall_fmod() {\n        // fmod, fmodl, fmodf\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  fmod(1.0,0) << std::endl;\\n\"\n              \"    std::cout <<  fmodf(1.0,0) << std::endl;\\n\"\n              \"    std::cout <<  fmodl(1.0,0) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:28]: (error) Invalid fmod() argument nr 2. The value is 0 but the valid values are '!0.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:4:29]: (error) Invalid fmodf() argument nr 2. The value is 0 but the valid values are '!0.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:5:29]: (error) Invalid fmodl() argument nr 2. The value is 0 but the valid values are '!0.0'. [invalidFunctionArg]\\n\"\n                      \"[test.cpp:3:19]: (warning) Passing values 1.0 and 0 to fmod() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:4:19]: (warning) Passing values 1.0 and 0 to fmodf() leads to implementation-defined result. [wrongmathcall]\\n\"\n                      \"[test.cpp:5:19]: (warning) Passing values 1.0 and 0 to fmodl() leads to implementation-defined result. [wrongmathcall]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::cout <<  fmod(1.0,1) << std::endl;\\n\"\n              \"    std::cout <<  fmodf(1.0,1) << std::endl;\\n\"\n              \"    std::cout <<  fmodl(1.0,1) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mathfunctionCall_precision() {\n        check(\"void foo() {\\n\"\n              \"    print(exp(x) - 1);\\n\"\n              \"    print(log(1 + x));\\n\"\n              \"    print(1 - erf(x));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]\\n\"\n                      \"[test.cpp:3:11]: (style) Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]\\n\"\n                      \"[test.cpp:4:11]: (style) Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of precision. [unpreciseMathCall]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    print(exp(x) - 1.0);\\n\"\n              \"    print(log(1.0 + x));\\n\"\n              \"    print(1.0 - erf(x));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]\\n\"\n                      \"[test.cpp:3:11]: (style) Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]\\n\"\n                      \"[test.cpp:4:12]: (style) Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of precision. [unpreciseMathCall]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    print(exp(3 + x*f(a)) - 1);\\n\"\n              \"    print(log(x*4 + 1));\\n\"\n              \"    print(1 - erf(34*x + f(x) - c));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Expression 'exp(x) - 1' can be replaced by 'expm1(x)' to avoid loss of precision. [unpreciseMathCall]\\n\"\n                      \"[test.cpp:3:11]: (style) Expression 'log(1 + x)' can be replaced by 'log1p(x)' to avoid loss of precision. [unpreciseMathCall]\\n\"\n                      \"[test.cpp:4:11]: (style) Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of precision. [unpreciseMathCall]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    print(2*exp(x) - 1);\\n\"\n              \"    print(1 - erf(x)/2.0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkIgnoredReturnValue() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def version=\\\"2\\\">\\n\"\n                                   \"  <function name=\\\"mystrcmp,foo::mystrcmp\\\">\\n\"\n                                   \"    <use-retval/>\\n\"\n                                   \"    <arg nr=\\\"1\\\"/>\\n\"\n                                   \"    <arg nr=\\\"2\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        const Settings settings2 = settingsBuilder().severity(Severity::warning).libraryxml(xmldata).build();\n\n        check(\"void foo() {\\n\"\n              \"  mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (warning) Return value of function mystrcmp() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  foo::mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:2:8]: (warning) Return value of function foo::mystrcmp() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  foo x;\\n\"\n              \"  x.mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning) Return value of function x.mystrcmp() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        check(\"bool mystrcmp(char* a, char* b);\\n\" // cppcheck sees a custom strcmp definition, but it returns a value. Assume it is the one specified in the library.\n              \"void foo() {\\n\"\n              \"    mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning) Return value of function mystrcmp() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        check(\"void mystrcmp(char* a, char* b);\\n\" // cppcheck sees a custom strcmp definition which returns void!\n              \"void foo() {\\n\"\n              \"    mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    class mystrcmp { mystrcmp() {} };\\n\" // strcmp is a constructor definition here\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    return mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    return foo::mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if(mystrcmp(a, b));\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    bool b = mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6194\n        check(\"void foo() {\\n\"\n              \"    MyStrCmp mystrcmp(x, y);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6197\n        check(\"void foo() {\\n\"\n              \"    abc::def.mystrcmp(a,b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6233\n        check(\"int main() {\\n\"\n              \"    auto lambda = [](double value) {\\n\"\n              \"        double rounded = floor(value + 0.5);\\n\"\n              \"        printf(\\\"Rounded value = %f\\\\n\\\", rounded);\\n\"\n              \"    };\\n\"\n              \"    lambda(13.3);\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6669\n        check(\"void foo(size_t size) {\\n\"\n              \"   void * res{malloc(size)};\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7447\n        check(\"void foo() {\\n\"\n              \"   int x{mystrcmp(a,b)};\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7905\n        check(\"void foo() {\\n\"\n              \"   int x({mystrcmp(a,b)});\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\" // don't crash\n              \"  DEBUG(123)(mystrcmp(a,b))(fd);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        check(\"struct teststruct {\\n\"\n              \"    int testfunc1() __attribute__ ((warn_unused_result)) { return 1; }\\n\"\n              \"    [[nodiscard]] int testfunc2() { return 1; }\\n\"\n              \"    void foo() { testfunc1(); testfunc2(); }\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"    teststruct TestStruct1;\\n\"\n              \"    TestStruct1.testfunc1();\\n\"\n              \"    TestStruct1.testfunc2();\\n\"\n              \"    return 0;\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (warning) Return value of function testfunc1() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:4:31]: (warning) Return value of function testfunc2() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:8:17]: (warning) Return value of function TestStruct1.testfunc1() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:9:17]: (warning) Return value of function TestStruct1.testfunc2() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        // #9006\n        check(\"template <typename... a> uint8_t b(std::tuple<uint8_t> d) {\\n\"\n              \"  std::tuple<a...> c{std::move(d)};\\n\"\n              \"  return std::get<0>(c);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int x; };\\n\"\n              \"template <class... Ts>\\n\"\n              \"A f(int x, Ts... xs) {\\n\"\n              \"    return {std::move(x), static_cast<int>(xs)...};\\n\"\n              \"}\\n\"\n              \"A g() { return f(1); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8412 - unused operator result\n        check(\"void foo() {\\n\"\n              \"  !mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:2:4]: (warning) Return value of function mystrcmp() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        check(\"void f(std::vector<int*> v) {\\n\"\n              \"    delete *v.begin();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int __attribute__((pure)) p_foo(int);\\n\" // #12697\n              \"int __attribute__((const)) c_foo(int);\\n\"\n              \"void f() {\\n\"\n              \"    p_foo(0);\\n\"\n              \"    c_foo(0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (warning) Return value of function p_foo() is not used. [ignoredReturnValue]\\n\"\n                      \"[test.cpp:5:5]: (warning) Return value of function c_foo() is not used. [ignoredReturnValue]\\n\",\n                      errout_str());\n    }\n\n    void checkIgnoredErrorCode() {\n        const char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                               \"<def version=\\\"2\\\">\\n\"\n                               \"  <function name=\\\"mystrcmp\\\">\\n\"\n                               \"    <use-retval type=\\\"error-code\\\"/>\\n\"\n                               \"    <arg nr=\\\"1\\\"/>\\n\"\n                               \"    <arg nr=\\\"2\\\"/>\\n\"\n                               \"  </function>\\n\"\n                               \"</def>\";\n        const Settings settings2 = settingsBuilder().severity(Severity::style).libraryxml(xmldata).build();\n\n        check(\"void foo() {\\n\"\n              \"  mystrcmp(a, b);\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settings2));\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (style) Error code from the return value of function mystrcmp() is not used. [ignoredReturnErrorCode]\\n\", errout_str());\n    }\n\n    void memsetZeroBytes() {\n        check(\"void f() {\\n\"\n              \"    memset(p, 10, 0x0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning) memset() called to fill 0 bytes. [memsetZeroBytes]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    memset(p, sizeof(p), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning) memset() called to fill 0 bytes. [memsetZeroBytes]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    memset(p, sizeof(p), i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6269 false positives in case of overloaded standard library functions\n        check(\"class c {\\n\"\n              \"  void memset( int i );\\n\"\n              \"  void f( void )   {\\n\"\n              \"     memset( 0 );\\n\"\n              \"  }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7285\n        check(\"void f() {\\n\"\n              \"    memset(&tm, sizeof(tm), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning) memset() called to fill 0 bytes. [memsetZeroBytes]\\n\", errout_str());\n\n    }\n\n    void memsetInvalid2ndParam() {\n        check(\"void f() {\\n\"\n              \"    int* is = new int[10];\\n\"\n              \"    memset(is, 1.0f, 40);\\n\"\n              \"    int* is2 = new int[10];\\n\"\n              \"    memset(is2, 0.1f, 40);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (portability) The 2nd memset() argument '1.0f' is a float, its representation is implementation defined. [memsetFloat]\\n\"\n                      \"[test.cpp:5:18]: (portability) The 2nd memset() argument '0.1f' is a float, its representation is implementation defined. [memsetFloat]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* is = new int[10];\\n\"\n              \"    float g = computeG();\\n\"\n              \"    memset(is, g, 40);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (portability) The 2nd memset() argument 'g' is a float, its representation is implementation defined. [memsetFloat]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* is = new int[10];\\n\"\n              \"    memset(is, 0.0f, 40);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // FP\n              \"    float x = 2.3f;\\n\"\n              \"    memset(a, (x?64:0), 40);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    short ss[] = {1, 2};\\n\"\n              \"    memset(ss, 256, 4);\\n\"\n              \"    short ss2[2];\\n\"\n              \"    memset(ss2, -129, 4);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (warning) The 2nd memset() argument '256' doesn't fit into an 'unsigned char'. [memsetValueOutOfRange]\\n\"\n                      \"[test.cpp:5:18]: (warning) The 2nd memset() argument '-129' doesn't fit into an 'unsigned char'. [memsetValueOutOfRange]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int is[10];\\n\"\n              \"    memset(is, 0xEE, 40);\\n\"\n              \"    unsigned char* cs = malloc(256);\\n\"\n              \"    memset(cs, -1, 256);\\n\"\n              \"    short* ss[30];\\n\"\n              \"    memset(ss, -128, 60);\\n\"\n              \"    char cs2[30];\\n\"\n              \"    memset(cs2, 255, 30);\\n\"\n              \"    char cs3[30];\\n\"\n              \"    memset(cs3, 0, 30);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int is[10];\\n\"\n              \"    const int i = g();\\n\"\n              \"    memset(is, 1.0f + i, 40);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:21]: (portability) The 2nd memset() argument '1.0f+i' is a float, its representation is implementation defined. [memsetFloat]\\n\", errout_str());\n    }\n\n    void checkMissingReturn1() {\n        check(\"int f() {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:10]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n\n        {\n            const char code[] = \"int main(void) {}\";\n            {\n                const Settings s = settingsBuilder().c(Standards::C89).build();\n\n                check(code, dinit(CheckOptions, $.cpp = false, $.s = &s)); // c code (c89)\n                ASSERT_EQUALS(\"[test.c:1:17]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n            }\n\n            {\n                const Settings s = settingsBuilder().c(Standards::C99).build();\n                check(code, dinit(CheckOptions, $.cpp = false, $.s = &s)); // c code (c99)\n                ASSERT_EQUALS(\"\", errout_str());\n\n                check(code, dinit(CheckOptions, $.s = &s)); // c++ code\n                ASSERT_EQUALS(\"\", errout_str());\n            }\n        }\n\n        check(\"F(A,B) { x=1; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"auto foo4() -> void {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void STDCALL foo() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void operator=(int y) { x=y; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"back:\\n\"\n              \"    return 0;\\n\"\n              \"ng:\\n\"\n              \"    x=y;\\n\"\n              \"    goto back;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // unreachable code..\n        check(\"int foo(int x) {\\n\"\n              \"  return 1;\\n\"\n              \"  (void)x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int x) {\\n\"\n              \"  if (x) goto out;\\n\"\n              \"  return 1;\\n\"\n              \"out:\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n\n        // switch\n        check(\"int f() {\\n\"\n              \"    switch (x) {\\n\"\n              \"        case 1: break;\\n\" // <- error\n              \"        case 2: return 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    switch (x) {\\n\"\n              \"        case 1: return 2; break;\\n\"\n              \"        default: return 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool test(unsigned char v1, int v2) {\\n\"\n              \"    switch (v1) {\\n\"\n              \"        case 0:\\n\"\n              \"            switch (v2) {\\n\"\n              \"            case 48000:\\n\"\n              \"                break;\\n\"\n              \"            }\\n\"\n              \"            return false;\\n\"\n              \"        default:\\n\"\n              \"            return true;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // if/else\n        check(\"int f(int x) {\\n\"\n              \"    if (x) {\\n\"\n              \"        return 1;\\n\"\n              \"    }\\n\" // <- error (missing else)\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n\n        check(\"int f(int x) {\\n\"\n              \"    if (x) {\\n\"\n              \"        ;\\n\" // <- error\n              \"    } else {\\n\"\n              \"        return 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    if (!0) {\\n\"\n              \"        return 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    if (!0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n\n        // loop\n        check(\"int f(int x) {\\n\"\n              \"    while (1) {\\n\"\n              \"        dostuff();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // return {..}\n        check(\"std::pair<int, int> typeDecl(int tok) {\\n\"\n              \"    if (!tok)\\n\"\n              \"        return {};\\n\"\n              \"    else\\n\"\n              \"        return {1, 2};\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // noreturn function\n        check(\"int f(int x) { exit(0); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int x) { assert(0); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int x) { if (x) return 1; else return bar({1}, {}); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"auto f() -> void {}\"); // #10342\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S1 {\\n\" // #7433\n              \"    S1& operator=(const S1& r) { if (this != &r) { i = r.i; } }\\n\"\n              \"    int i;\\n\"\n              \"};\\n\"\n              \"struct S2 {\\n\"\n              \"    S2& operator=(const S2& s) { if (this != &s) { j = s.j; } return *this; }\\n\"\n              \"    int j;\\n\"\n              \"};\\n\"\n              \"struct S3 {\\n\"\n              \"    S3& operator=(const S3& t) { if (this != &t) { k = t.k; return *this; } }\\n\"\n              \"    int k;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:61]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\"\n                      \"[test.cpp:10:75]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\",\n                      errout_str());\n\n        // #11171\n        check(\"std::enable_if_t<sizeof(uint64_t) == 8> f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::enable_if_t<sizeof(uint64_t) == 8, int> f() {}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:51]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\",\n            errout_str());\n\n        check(\"template<class T> std::enable_if_t<std::is_same<T, int>{}, int> f(T) {}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:71]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\",\n            errout_str());\n\n        check(\"template<class T> std::enable_if_t<std::is_same<T, int>{}> f(T) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typename std::enable_if<sizeof(uint64_t) == 8>::type f() {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typename std::enable_if<sizeof(uint64_t) == 8, int>::type f() {}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:64]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\",\n            errout_str());\n\n        check(\"template<class T> typename std::enable_if<std::is_same<T, int>{}, int>::type f(T) {}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:84]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\",\n            errout_str());\n\n        check(\"template<class T> typename std::enable_if<std::is_same<T, int>{}>::type f(T) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"     [[noreturn]] void f();\\n\"\n              \"     int g() { this->f(); }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { [[noreturn]] void f(); };\\n\"\n              \"int g(S& s) { s.f(); }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkMissingReturn2() { // #11798\n        check(\"int f(bool const a) {\\n\"\n              \"      switch (a) {\\n\"\n              \"      case true:\\n\"\n              \"            return 1;\\n\"\n              \"      case false:\\n\"\n              \"            return 2;\\n\"\n              \"      }\\n\"\n              \"}\\n\"\n              \"int main(int argc, char* argv[])\\n\"\n              \"{\\n\"\n              \"      auto const b= f(true);\\n\"\n              \"      auto const c= f(false);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkMissingReturn3() {\n        check(\"enum Enum {\\n\"\n              \"    A,\\n\"\n              \"    B,\\n\"\n              \"    C,\\n\"\n              \"};\\n\"\n              \"int f(Enum e) {\\n\"\n              \"    switch (e) {\\n\"\n              \"    case A:\\n\"\n              \"          return 1;\\n\"\n              \"    case B:\\n\"\n              \"          return 2;\\n\"\n              \"    case C:\\n\"\n              \"          return 2;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkMissingReturn4() {\n        check(\"enum Enum {\\n\"\n              \"    A,\\n\"\n              \"    B,\\n\"\n              \"    C,\\n\"\n              \"};\\n\"\n              \"int f(Enum e) {\\n\"\n              \"    switch (e) {\\n\"\n              \"    case A:\\n\"\n              \"          return 1;\\n\"\n              \"    case B:\\n\"\n              \"          return 2;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:16]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n    }\n\n    void checkMissingReturn5() {\n        check(\"enum Enum {\\n\"\n              \"    A,\\n\"\n              \"    B,\\n\"\n              \"    C,\\n\"\n              \"};\\n\"\n              \"int f(Enum e, bool b) {\\n\"\n              \"    switch (e) {\\n\"\n              \"    case A:\\n\"\n              \"          return 1;\\n\"\n              \"    case B:\\n\"\n              \"          return 2;\\n\"\n              \"    case C:\\n\"\n              \"          switch (b) {\\n\"\n              \"          case true:\\n\"\n              \"              return 3;\\n\"\n              \"          case false:\\n\"\n              \"              return 4;\\n\"\n              \"          }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkMissingReturn6() {// #13180\n        check(\"int foo(void)\\n\"\n              \"{\\n\"\n              \"    i = readData();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Found an exit path from function with non-void return type that has missing return statement [missingReturn]\\n\", errout_str());\n    }\n\n    // NRVO check\n    void returnLocalStdMove1() {\n        check(\"struct A{}; A f() { A var; return std::move(var); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:45]: (performance) Using std::move for returning object by-value from function will affect copy elision optimization.\"\n                      \" More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local [returnStdMoveLocal]\\n\", errout_str());\n    }\n\n    // RVO, C++03 ctor style\n    void returnLocalStdMove2() {\n        check(\"struct A{}; A f() { return std::move( A() ); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:40]: (performance) Using std::move for returning object by-value from function will affect copy elision optimization.\"\n                      \" More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local [returnStdMoveLocal]\\n\", errout_str());\n    }\n\n    // RVO, new ctor style\n    void returnLocalStdMove3() {\n        check(\"struct A{}; A f() { return std::move(A{}); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:39]: (performance) Using std::move for returning object by-value from function will affect copy elision optimization.\"\n                      \" More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local [returnStdMoveLocal]\\n\", errout_str());\n    }\n\n    // Function argument\n    void returnLocalStdMove4() {\n        check(\"struct A{}; A f(A a) { return std::move(A{}); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:42]: (performance) Using std::move for returning object by-value from function will affect copy elision optimization.\"\n                      \" More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local [returnStdMoveLocal]\\n\", errout_str());\n    }\n\n    void returnLocalStdMove5() {\n        check(\"struct A{} a; A f1() { return std::move(a); }\\n\"\n              \"A f2() { volatile A var; return std::move(var); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { std::string msg{ \\\"abc\\\" }; };\\n\"\n              \"std::unique_ptr<S> get(std::vector<std::unique_ptr<S>>& v) {\\n\"\n              \"    return std::move(v.front());\\n\"\n              \"}\\n\"\n              \"int main() {\\n\"\n              \"    std::vector<std::unique_ptr<S>> v;\\n\"\n              \"    v.emplace_back(std::make_unique<S>());\\n\"\n              \"    auto p = get(v);\\n\"\n              \"    std::cout << p->msg;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string&& f() {\\n\" // #11881\n              \"    std::string s;\\n\"\n              \"    return std::move(s);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void negativeMemoryAllocationSizeError() { // #389\n        check(\"void f() {\\n\"\n              \"   int *a;\\n\"\n              \"   a = malloc( -10 );\\n\"\n              \"   free(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Invalid malloc() argument nr 1. The value is -10 but the valid values are '0:'. [invalidFunctionArg]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int *a;\\n\"\n              \"   a = alloca( -10 );\\n\"\n              \"   free(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (warning) Obsolete function 'alloca' called. [allocaCalled]\\n\"\n                      \"[test.cpp:3:17]: (error) Invalid alloca() argument nr 1. The value is -10 but the valid values are '0:'. [invalidFunctionArg]\\n\", errout_str());\n    }\n\n    void checkLibraryMatchFunctions() {\n        /*const*/ Settings s = settingsBuilder(settings).checkLibrary().debugwarnings().build();\n        s.daca = true;\n\n        check(\"void f() {\\n\"\n              \"    lib_func();\"\n              \"}\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (information) --check-library: There is no matching configuration for function lib_func() [checkLibraryFunction]\\n\", errout_str());\n\n        check(\"void f(void* v) {\\n\"\n              \"    lib_func(v);\"\n              \"}\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (information) --check-library: There is no matching configuration for function lib_func() [checkLibraryFunction]\\n\", errout_str());\n\n        // #10105\n        check(\"class TestFixture {\\n\"\n              \"protected:\\n\"\n              \"        bool prepareTest(const char testname[]);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class TestMemleak : private TestFixture {\\n\"\n              \"        void run() {\\n\"\n              \"                do { prepareTest(\\\"testFunctionReturnType\\\"); } while (false);\\n\"\n              \"        }\\n\"\n              \"\\n\"\n              \"        void testFunctionReturnType() {\\n\"\n              \"        }\\n\"\n              \"};\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11183\n        check(\"#include <string>\\n\"\n              \"\\n\"\n              \"extern void cb(const std::string&);\\n\"\n              \"\\n\"\n              \"void f() {\\n\"\n              \"    cb(std::string(\\\"\\\"));\\n\"\n              \"}\", dinit(CheckOptions, $.s = &s));\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:6:5]: (information) --check-library: There is no matching configuration for function cb() [checkLibraryFunction]\\n\", errout_str());\n\n        // #7375\n        check(\"void f() {\\n\"\n              \"    struct S { int i; char c; };\\n\"\n              \"    size_t s = sizeof(S);\\n\"\n              \"    static_assert(s == 9);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char) {}\\n\"\n              \"void g() {\\n\"\n              \"    f(int8_t(1));\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::uint64_t& u) {\\n\"\n              \"    u = std::uint32_t(u) * std::uint64_t(100);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { throw(1); }\\n\", dinit(CheckOptions, $.s = &s)); // #8958\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"using namespace std;\\n\"\n              \"void f() { throw range_error(\\\"abc\\\"); }\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C {\\n\" // #9002\n              \"public:\\n\"\n              \"    static int f() { return 1; }\\n\"\n              \"};\\n\"\n              \"void g() { C::f(); }\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<std::string>& v) {\\n\" // #11223\n              \"    for (const auto& s : v)\\n\"\n              \"        s.find(\\\"\\\");\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (warning) Return value of function s.find() is not used. [ignoredReturnValue]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    auto* p = new std::vector<int>(5);\\n\"\n              \"    p->push_back(1);\\n\"\n              \"    auto* q = new std::vector<int>{ 5, 7 };\\n\"\n              \"    q->push_back(1);\\n\"\n              \"    auto* r = new std::vector<int>;\\n\"\n              \"    r->push_back(1);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    auto p = std::make_shared<std::vector<int>>();\\n\"\n              \"    p->push_back(1);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<std::vector<int>>& v) {\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    it->push_back(1);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    auto v = std::vector<int>{};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    auto w = std::vector<int>{ 1, 2, 3 };\\n\"\n              \"    w.push_back(1);\\n\"\n              \"    auto x = std::vector<int>(1);\\n\"\n              \"    x.push_back(1);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    auto p(std::make_shared<std::vector<int>>());\\n\"\n              \"    p->push_back(1);\\n\"\n              \"    auto q{ std::make_shared<std::vector<int>>{} };\\n\"\n              \"    q->push_back(1);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        TODO_ASSERT_EQUALS(\"\",\n                           \"[test.cpp:2:5]: (debug) auto token with no type. [autoNoType]\\n\"\n                           \"[test.cpp:4:5]: (debug) auto token with no type. [autoNoType]\\n\"\n                           \"[test.cpp:3:8]: (information) --check-library: There is no matching configuration for function auto::push_back() [checkLibraryFunction]\\n\"\n                           \"[test.cpp:5:8]: (information) --check-library: There is no matching configuration for function auto::push_back() [checkLibraryFunction]\\n\",\n                           errout_str());\n\n        check(\"struct F { void g(int); };\\n\"\n              \"void f(std::list<F>& l) {\\n\"\n              \"    std::list<F>::iterator it;\\n\"\n              \"    for (it = l.begin(); it != l.end(); ++it)\\n\"\n              \"        it->g(0);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", filter_valueflow(errout_str()));\n\n        check(\"auto f() {\\n\"\n              \"    return std::runtime_error(\\\"abc\\\");\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        TODO_ASSERT_EQUALS(\"\",\n                           \"[test.cpp:1:1]: (debug) auto token with no type. [autoNoType]\\n\",\n                           errout_str());\n\n        check(\"struct S {\\n\" // #11543\n              \"    S() {}\\n\"\n              \"    std::vector<std::shared_ptr<S>> v;\\n\"\n              \"    void f(int i) const;\\n\"\n              \"};\\n\"\n              \"void S::f(int i) const {\\n\"\n              \"    for (const std::shared_ptr<S>& c : v)\\n\"\n              \"        c->f(i);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace N {\\n\"\n              \"    struct S { static const std::set<std::string> s; };\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    const auto& t = N::S::s;\\n\"\n              \"    if (t.find(\\\"abc\\\") != t.end()) {}\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", filter_valueflow(errout_str()));\n\n        check(\"void f(std::vector<std::unordered_map<int, std::unordered_set<int>>>& v, int i, int j) {\\n\"\n              \"    auto& s = v[i][j];\\n\"\n              \"    s.insert(0);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<std::string>& v, int i, char c) {\\n\"\n              \"    const auto& s = v[i];\\n\"\n              \"    return s.find(c);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #11604\n              \"    int (*g)() = nullptr;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    INT (*g)() = nullptr;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T;\\n\"\n              \"std::shared_ptr<T> get();\\n\"\n              \"void f(int i) {\\n\"\n              \"    auto p = get();\\n\"\n              \"    p->h(i);\\n\"\n              \"    p.reset(nullptr);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (information) --check-library: There is no matching configuration for function T::h() [checkLibraryFunction]\\n\",\n                      errout_str());\n\n        check(\"struct S : std::vector<int> {\\n\"\n              \"    void f(int i) { push_back(i); }\\n\"\n              \"};\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    auto g = []() -> std::string { return \\\"abc\\\"; };\\n\"\n              \"    auto s = g();\\n\"\n              \"    if (s.at(0)) {}\\n\"\n              \"    auto h{ []() -> std::string { return \\\"xyz\\\"; } };\\n\"\n              \"    auto t = h();\\n\"\n              \"    if (t.at(0)) {}\\n\"\n              \"};\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", filter_valueflow(errout_str()));\n\n        check(\"::std::string f(const char* c) {\\n\" // #12365\n              \"    return ::std::string(c);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <typename T>\\n\"\n              \"struct S : public std::vector<T> {\\n\"\n              \"    void resize(size_t n) { std::vector<T>::resize(n); }\\n\"\n              \"};\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct P {\\n\" // #13105\n              \"    bool g(int i) const;\\n\"\n              \"    std::shared_ptr<std::map<int, int>> m;\\n\"\n              \"};\\n\"\n              \"bool P::g(int i) const {\\n\"\n              \"    auto it = m->find(i);\\n\"\n              \"    const bool b = it != m->end();\\n\"\n              \"    return b;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:6:5]: (debug) auto token with no type. [autoNoType]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary1() {\n        check(\"void f(void* dest, void const* src, const size_t count) {\\n\"\n              \"    size_t i;\\n\"\n              \"    for (i = 0; count > i; ++i)\\n\"\n              \"        (reinterpret_cast<uint8_t*>(dest))[i] = (reinterpret_cast<const uint8_t*>(src))[i];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consider using std::memcpy instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary2() {\n        check(\"void f(void* dest, void const* src, const size_t count) {\\n\"\n              \"    for (size_t i = 0; i < count; i++) {\\n\"\n              \"        (reinterpret_cast<uint8_t*>(dest))[i] = (reinterpret_cast<const uint8_t*>(src))[i];\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memcpy instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary3() {\n        check(\"void f(void* dst, const void* src, const size_t count) {\\n\"\n              \"    size_t i;\\n\"\n              \"    for (i = 0; count > i; i++)\\n\"\n              \"        ((char*)dst)[i] = ((const char*)src)[i];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consider using std::memcpy instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary4() {\n        check(\"void f(void* dst, void* src, const size_t size) {\\n\"\n              \"    for (size_t i = 0; i < size; i += 1) {\\n\"\n              \"        ((int8_t*)dst)[i] = ((int8_t*)src)[i];\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memcpy instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    // different indexes\n    void checkUseStandardLibrary5() {\n        check(\"void f(void* dst, void* src, const size_t size, const size_t from_idx) {\\n\"\n              \"    for (size_t i = 0; i < size; ++i) {\\n\"\n              \"        ((int8_t*)dst)[i] = ((int8_t*)src)[from_idx];\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // unknown count\n    void checkUseStandardLibrary6() {\n        check(\"void f(void* dst, void* src, const size_t size) {\\n\"\n              \"    for (size_t i = 0; ((int8_t*)src)[i] != 0; ++i) {\\n\"\n              \"        ((int8_t*)dst)[i] = ((int8_t*)src)[i];\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // increment with 2\n    void checkUseStandardLibrary7() {\n        check(\"void f(void* dst, void* src, const size_t size) {\\n\"\n              \"    for (size_t i = 0; i < size; i += 2) {\\n\"\n              \"        ((int8_t*)dst)[i] = ((int8_t*)src)[i];\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // right argument of assignment could be static_cast, functional cast, c-style and implicit cast\n    // functional cast case not covered\n    void checkUseStandardLibrary8() {\n        check(\"void f(void* dest, const size_t count) {\\n\"\n              \"    size_t i;\\n\"\n              \"    for (i = 0; i < count; ++i)\\n\"\n              \"        (reinterpret_cast<int8_t*>(dest))[i] = static_cast<const int8_t>(0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary9() {\n        check(\"void f(void* dest, const size_t count) {\\n\"\n              \"    for (size_t i = 0; i < count; i++) {\\n\"\n              \"        (reinterpret_cast<uint8_t*>(dest))[i] = (static_cast<const uint8_t>(0));\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary10() {\n        check(\"void f(void* dst, const size_t size) {\\n\"\n              \"    size_t i;\\n\"\n              \"    for (i = 0; i < size; i++)\\n\"\n              \"        ((char*)dst)[i] = (const char)0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary11() {\n        check(\"void f(void* dst, const size_t size) {\\n\"\n              \"    for (size_t i = 0; i < size; i += 1) {\\n\"\n              \"        ((int8_t*)dst)[i] = ((int8_t)0);\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary12() {\n        check(\"void f(void* dst, const size_t size) {\\n\"\n              \"    for (size_t i = 0; i < size; i += 1) {\\n\"\n              \"        ((int8_t*)dst)[i] = 42;\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary13() {\n        check(\"void f(void* dest, const size_t count) {\\n\"\n              \"    for (size_t i = 0; i < count; i++) {\\n\"\n              \"        reinterpret_cast<unsigned char*>(dest)[i] = '0';\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n\n    void checkUseStandardLibrary14() {\n        check(\"void f(void* dest) {\\n\"\n              \"    for (size_t i = 0; i < sizeof(int)*(15 + 42/2 - 7); i++) {\\n\"\n              \"        reinterpret_cast<unsigned char*>(dest)[i] = '0';\\n\"\n              \"}}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::memset instead of loop. [useStandardLibrary]\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestFunctions)\n"
    }
  ]
}