{
  "name": "checkIncorrectStringCompare",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 43,
  "branches": 16,
  "apis": 69,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        644
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"checkstring.h\"\n#include \"errortypes.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n#include \"fixture.h\"\n\n#include <string>\n\nclass TestString : public TestFixture {\npublic:\n    TestString() : TestFixture(\"TestString\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::style).build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(stringLiteralWrite);\n\n        TEST_CASE(alwaysTrueFalseStringCompare);\n        TEST_CASE(suspiciousStringCompare);\n        TEST_CASE(suspiciousStringCompare_char);\n\n        TEST_CASE(strPlusChar1);     // \"/usr\" + '/'\n        TEST_CASE(strPlusChar2);     // \"/usr\" + ch\n        TEST_CASE(strPlusChar3);     // ok: path + \"/sub\" + '/'\n        TEST_CASE(strPlusChar4);     // L\"/usr\" + L'/'\n\n        TEST_CASE(snprintf1);       // Dangerous usage of snprintf\n        TEST_CASE(sprintf1);        // Dangerous usage of sprintf\n        TEST_CASE(sprintf2);\n        TEST_CASE(sprintf3);\n        TEST_CASE(sprintf4);        // struct member\n        TEST_CASE(sprintf5);        // another struct member\n        TEST_CASE(sprintf6);        // (char*)\n        TEST_CASE(sprintf7);        // (char*)(void*)\n        TEST_CASE(wsprintf1);       // Dangerous usage of wsprintf\n\n        TEST_CASE(incorrectStringCompare);\n\n        TEST_CASE(deadStrcmp);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        bool cpp = true;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    void check_(const char* file, int line, const char code[], const CheckOptions& options = make_default_obj()) {\n        SimpleTokenizer2 tokenizer(settings, *this, code, options.cpp ? \"test.cpp\" : \"test.c\");\n\n        // Tokenize..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check char variable usage..\n        runChecks<CheckString>(tokenizer, this);\n    }\n\n    void stringLiteralWrite() {\n        check(\"void f() {\\n\"\n              \"  char *abc = \\\"abc\\\";\\n\"\n              \"  abc[0] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3] -> [test.cpp:2:15]: (error) Modifying string literal \\\"abc\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char *abc = \\\"abc\\\";\\n\"\n              \"  *abc = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4] -> [test.cpp:2:15]: (error) Modifying string literal \\\"abc\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char *abc = \\\"A very long string literal\\\";\\n\"\n              \"  abc[0] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3] -> [test.cpp:2:15]: (error) Modifying string literal \\\"A very long stri..\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  QString abc = \\\"abc\\\";\\n\"\n              \"  abc[0] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo_FP1(char *p) {\\n\"\n              \"  p[1] = 'B';\\n\"\n              \"}\\n\"\n              \"void foo_FP2(void) {\\n\"\n              \"  char* s = \\\"Y\\\";\\n\"\n              \"  foo_FP1(s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:3] -> [test.cpp:5:13]: (error) Modifying string literal \\\"Y\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\",\n            errout_str());\n\n        check(\"void foo_FP1(char *p) {\\n\"\n              \"  p[1] = 'B';\\n\"\n              \"}\\n\"\n              \"void foo_FP2(void) {\\n\"\n              \"  char s[10] = \\\"Y\\\";\\n\"\n              \"  foo_FP1(s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  wchar_t *abc = L\\\"abc\\\";\\n\"\n              \"  abc[0] = u'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3] -> [test.cpp:2:18]: (error) Modifying string literal L\\\"abc\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char16_t *abc = u\\\"abc\\\";\\n\"\n              \"  abc[0] = 'a';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3] -> [test.cpp:2:19]: (error) Modifying string literal u\\\"abc\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\", errout_str());\n\n        check(\"void foo() {\\n\" // #8332\n              \"    int i;\\n\"\n              \"    char *p  = \\\"string literal\\\";\\n\"\n              \"    for( i = 0; i < strlen(p); i++) {\\n\"\n              \"        p[i] = \\'X\\';\\n\" // <<\n              \"    }\\n\"\n              \"    printf(\\\"%s\\\\n\\\", p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:3:16]: (error) Modifying string literal \\\"string literal\\\" directly or indirectly is undefined behaviour. [stringLiteralWrite]\\n\", errout_str());\n    }\n\n    void alwaysTrueFalseStringCompare() {\n        check(\"void f() {\\n\"\n              \"  if (strcmp(\\\"A\\\",\\\"A\\\")){}\\n\"\n              \"  if (strncmp(\\\"A\\\",\\\"A\\\",1)){}\\n\"\n              \"  if (strcasecmp(\\\"A\\\",\\\"A\\\")){}\\n\"\n              \"  if (strncasecmp(\\\"A\\\",\\\"A\\\",1)){}\\n\"\n              \"  if (memcmp(\\\"A\\\",\\\"A\\\",1)){}\\n\"\n              \"  if (strverscmp(\\\"A\\\",\\\"A\\\")){}\\n\"\n              \"  if (bcmp(\\\"A\\\",\\\"A\\\",1)){}\\n\"\n              \"  if (wcsncasecmp(L\\\"A\\\",L\\\"A\\\",1)){}\\n\"\n              \"  if (wcsncmp(L\\\"A\\\",L\\\"A\\\",1)){}\\n\"\n              \"  if (wmemcmp(L\\\"A\\\",L\\\"A\\\",1)){}\\n\"\n              \"  if (wcscmp(L\\\"A\\\",L\\\"A\\\")){}\\n\"\n              \"  if (wcscasecmp(L\\\"A\\\",L\\\"A\\\")){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:3:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:4:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:5:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:6:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:7:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:8:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:9:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:10:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:11:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:12:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\"\n                      \"[test.cpp:13:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        // avoid false positives when the address is modified #6415\n        check(\"void f(void *p, int offset)  {\\n\"\n              \"     if (!memcmp(p, p + offset, 42)){}\\n\"\n              \"     if (!memcmp(p + offset, p, 42)){}\\n\"\n              \"     if (!memcmp(offset + p, p, 42)){}\\n\"\n              \"     if (!memcmp(p, offset + p, 42)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // avoid false positives when the address is modified #6415\n        check(\"void f(char *c, int offset)  {\\n\"\n              \"     if (!memcmp(c, c + offset, 42)){}\\n\"\n              \"     if (!memcmp(c + offset, c, 42)){}\\n\"\n              \"     if (!memcmp(offset + c, c, 42)){}\\n\"\n              \"     if (!memcmp(c, offset + c, 42)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // avoid false positives when the address is modified #6415\n        check(\"void f(std::string s, int offset)  {\\n\"\n              \"     if (!memcmp(s.c_str(), s.c_str() + offset, 42)){}\\n\"\n              \"     if (!memcmp(s.c_str() + offset, s.c_str(), 42)){}\\n\"\n              \"     if (!memcmp(offset + s.c_str(), s.c_str(), 42)){}\\n\"\n              \"     if (!memcmp(s.c_str(), offset + s.c_str(), 42)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(void) {\\n\" // #13527\n              \"    const wchar_t* str1 = L\\\"Hello\\\";\\n\"\n              \"    return wcsicmp(str1, str1);\\n\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (warning) Comparison of identical string variables. [stringCompare]\\n\", errout_str());\n\n        check(\"int main()\\n\"\n              \"{\\n\"\n              \"  if (strcmp(\\\"00FF00\\\", \\\"00FF00\\\") == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if (strcmp($\\\"00FF00\\\", \\\"00FF00\\\") == 0) {}\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if ($strcmp(\\\"00FF00\\\", \\\"00FF00\\\") == 0) {}\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main()\\n\"\n              \"{\\n\"\n              \"  if (stricmp(\\\"hotdog\\\",\\\"HOTdog\\\") == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        check(\"int main()\\n\"\n              \"{\\n\"\n              \"  if (QString::compare(\\\"Hamburger\\\", \\\"Hotdog\\\") == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        check(\"int main()\\n\"\n              \"{\\n\"\n              \"  if (QString::compare(argv[2], \\\"hotdog\\\") == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main()\\n\"\n              \"{\\n\"\n              \"  if (strncmp(\\\"hotdog\\\",\\\"hotdog\\\", 6) == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        check(\"int foo(const char *buf)\\n\"\n              \"{\\n\"\n              \"  if (strcmp(buf, buf) == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Comparison of identical string variables. [stringCompare]\\n\", errout_str());\n\n        check(\"int foo(const std::string& buf)\\n\"\n              \"{\\n\"\n              \"  if (stricmp(buf.c_str(), buf.c_str()) == 0)\"\n              \"  {\"\n              \"    std::cout << \\\"Equal\\\";\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Comparison of identical string variables. [stringCompare]\\n\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"  if (\\\"str\\\" == \\\"str\\\") {\\n\"\n              \"    std::cout << \\\"Equal\\\";\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"  if (\\\"str\\\" != \\\"str\\\") {\\n\"\n              \"    std::cout << \\\"Equal\\\";\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Unnecessary comparison of static strings. [staticStringCompare]\\n\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"  if (a+\\\"str\\\" != \\\"str\\\"+b) {\\n\"\n              \"    std::cout << \\\"Equal\\\";\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void suspiciousStringCompare() {\n        check(\"bool foo(char* c) {\\n\"\n              \"    return c == \\\"x\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) String literal compared with variable 'c'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(char** c) {\\n\"\n              \"    return c[3] == \\\"x\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) String literal compared with variable 'c[3]'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(wchar_t* c) {\\n\"\n              \"    return c == L\\\"x\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) String literal compared with variable 'c'. Did you intend to use wcscmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(const char* c) {\\n\"\n              \"    return \\\"x\\\" == c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) String literal compared with variable 'c'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return foo+\\\"x\\\" == c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return \\\"x\\\" == c+foo;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return \\\"x\\\" == c+foo;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:2:16]: (warning) String literal compared with variable 'c+foo'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(Foo c) {\\n\"\n              \"    return \\\"x\\\" == c.foo;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(Foo c) {\\n\"\n              \"    return \\\"x\\\" == c.foo;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:2:16]: (warning) String literal compared with variable 'c.foo'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(const std::string& c) {\\n\"\n              \"    return \\\"x\\\" == c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(const Foo* c) {\\n\"\n              \"    return \\\"x\\\" == c->bar();\\n\" // #4314\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #4257\n        check(\"bool foo() {\\n\"\n              \"MyString *str=Getter();\\n\"\n              \"return *str==\\\"bug\\\"; }\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:12]: (warning) String literal compared with variable '*str'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        // Ticket #4257\n        check(\"bool foo() {\\n\"\n              \"MyString *str=Getter();\\n\"\n              \"return *str==\\\"bug\\\"; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #4257\n        check(\"bool foo() {\\n\"\n              \"MyString **str=OtherGetter();\\n\"\n              \"return *str==\\\"bug\\\"; }\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:12]: (warning) String literal compared with variable '*str'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        // Ticket #4257\n        check(\"bool foo() {\\n\"\n              \"MyString str=OtherGetter2();\\n\"\n              \"return &str==\\\"bug\\\"; }\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:12]: (warning) String literal compared with variable '&str'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        // Ticket #5734\n        check(\"int foo(char c) {\\n\"\n              \"return c == '4';}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"int foo(char c) {\\n\"\n              \"return c == '4';}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"int foo(char c) {\\n\"\n              \"return c == \\\"42\\\"[0];}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"int foo(char c) {\\n\"\n              \"return c == \\\"42\\\"[0];}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // 5639 String literal compared with char buffer in a struct\n        check(\"struct Example {\\n\"\n              \"   char buffer[200];\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"   struct Example example;\\n\"\n              \"   if (example.buffer == \\\"test\\\") ;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:23]: (warning) String literal compared with variable 'example.buffer'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n        check(\"struct Example {\\n\"\n              \"   char buffer[200];\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"   struct Example example;\\n\"\n              \"   if (example.buffer == \\\"test\\\") ;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:6:23]: (warning) String literal compared with variable 'example.buffer'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]\\n\", errout_str());\n\n        // #9726\n        check(\"void f(std::vector<std::string> theArgs) {\\n\"\n              \"   std::string arg1(*theArgs.begin());\\n\"\n              \"   if(arg1 == \\\"aaa\\\") {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void suspiciousStringCompare_char() {\n        check(\"bool foo(char* c) {\\n\"\n              \"    return c == 'x';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) Char literal compared with pointer 'c'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(wchar_t* c) {\\n\"\n              \"    return c == L'x';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) Char literal compared with pointer 'c'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return '\\\\0' != c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) Char literal compared with pointer 'c'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(char c) {\\n\"\n              \"    return c == '\\\\0';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return c[0] == '\\\\0';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(char** c) {\\n\"\n              \"    return c[0] == '\\\\0';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) Char literal compared with pointer 'c[0]'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(char** c) {\\n\"\n              \"    return *c == '\\\\0';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Char literal compared with pointer '*c'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"bool foo(char c) {\\n\"\n              \"    return c == 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return *c == 0;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(char* c) {\\n\"\n              \"    return *c == 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(Foo* c) {\\n\"\n              \"    return 0 == c->x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char* c) {\\n\"\n              \"    if(c == '\\\\0') bar();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Char literal compared with pointer 'c'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  struct { struct { char *str; } x; } a;\\n\"\n              \"  return a.x.str == '\\\\0';\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (warning) Char literal compared with pointer 'a.x.str'. Did you intend to dereference it? [charLiteralWithCharPtrCompare]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  struct { struct { char *str; } x; } a;\\n\"\n              \"  return *a.x.str == '\\\\0';\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void snprintf1() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char buf[100];\\n\"\n              \"    snprintf(buf,100,\\\"%s\\\",buf);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:27]: (error) Undefined behavior: Variable 'buf' is used as parameter and destination in snprintf(). [sprintfOverlappingData]\\n\", errout_str());\n    }\n\n    void sprintf1() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char buf[100];\\n\"\n              \"    sprintf(buf,\\\"%s\\\",buf);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:22]: (error) Undefined behavior: Variable 'buf' is used as parameter and destination in sprintf(). [sprintfOverlappingData]\\n\", errout_str());\n    }\n\n    void sprintf2() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char buf[100];\\n\"\n              \"    sprintf(buf,\\\"%i\\\",sizeof(buf));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void sprintf3() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char buf[100];\\n\"\n              \"    sprintf(buf,\\\"%i\\\",sizeof(buf));\\n\"\n              \"    if (buf[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void sprintf4() {\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    char filename[128];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    const char* filename = \\\"hello\\\";\\n\"\n              \"    struct A a;\\n\"\n              \"    snprintf(a.filename, 128, \\\"%s\\\", filename);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void sprintf5() {\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    char filename[128];\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void foo(struct A *a)\\n\"\n              \"{\\n\"\n              \"    snprintf(a->filename, 128, \\\"%s\\\", a->filename);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:39]: (error) Undefined behavior: Variable 'a->filename' is used as parameter and destination in snprintf(). [sprintfOverlappingData]\\n\", errout_str());\n    }\n\n    void sprintf6() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char buf[100];\\n\"\n              \"    sprintf((char*)buf,\\\"%s\\\",(char*)buf);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:29]: (error) Undefined behavior: Variable 'buf' is used as parameter and destination in sprintf(). [sprintfOverlappingData]\\n\", errout_str());\n    }\n\n    void sprintf7() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char buf[100];\\n\"\n              \"    sprintf((char*)(void*)buf,\\\"%s\\\",(void*)(char*)buf);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:36]: (error) Undefined behavior: Variable 'buf' is used as parameter and destination in sprintf(). [sprintfOverlappingData]\\n\", errout_str());\n    }\n\n    void wsprintf1() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    wchar_t buf[100];\\n\"\n              \"    swprintf(buf,10, \\\"%s\\\",buf);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:27]: (error) Undefined behavior: Variable 'buf' is used as parameter and destination in swprintf(). [sprintfOverlappingData]\\n\", errout_str());\n    }\n\n    void strPlusChar1() {\n        // Strange looking pointer arithmetic..\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    const char *p = \\\"/usr\\\" + '/';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:28]: (error) Unusual pointer arithmetic. A value of type 'char' is added to a string literal. [strPlusChar]\\n\", errout_str());\n    }\n\n    void strPlusChar2() {\n        // Strange looking pointer arithmetic..\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char ch = 1;\\n\"\n              \"    const char *p = ch + \\\"/usr\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Strange looking pointer arithmetic..\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int i = 1;\\n\"\n              \"    const char* psz = \\\"Bla\\\";\\n\"\n              \"    const std::string str = i + psz;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void strPlusChar3() {\n        // Strange looking pointer arithmetic..\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::string temp = \\\"/tmp\\\";\\n\"\n              \"    std::string path = temp + '/' + \\\"sub\\\" + '/';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void strPlusChar4() {\n        // Strange looking pointer arithmetic, wide char..\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    const wchar_t *p = L\\\"/usr\\\" + L'/';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:32]: (error) Unusual pointer arithmetic. A value of type 'wchar_t' is added to a string literal. [strPlusChar]\\n\", errout_str());\n\n        check(\"void foo(wchar_t c)\\n\"\n              \"{\\n\"\n              \"    const wchar_t *p = L\\\"/usr\\\" + c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:32]: (error) Unusual pointer arithmetic. A value of type 'wchar_t' is added to a string literal. [strPlusChar]\\n\", errout_str());\n    }\n\n    void incorrectStringCompare() {\n        check(\"int f() {\\n\"\n              \"    return test.substr( 0 , 4 ) == \\\"Hello\\\" ? 0 : 1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) String literal \\\"Hello\\\" doesn't match length argument for substr(). [incorrectStringCompare]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return test.substr( 0 , 4 ) == L\\\"Hello\\\" ? 0 : 1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) String literal L\\\"Hello\\\" doesn't match length argument for substr(). [incorrectStringCompare]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return test.substr( 0 , 5 ) == \\\"Hello\\\" ? 0 : 1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return \\\"Hello\\\" == test.substr( 0 , 4 ) ? 0 : 1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:28]: (warning) String literal \\\"Hello\\\" doesn't match length argument for substr(). [incorrectStringCompare]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return \\\"Hello\\\" == foo.bar<int>().z[1].substr(i+j*4, 4) ? 0 : 1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:43]: (warning) String literal \\\"Hello\\\" doesn't match length argument for substr(). [incorrectStringCompare]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return \\\"Hello\\\" == test.substr( 0 , 5 ) ? 0 : 1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    if (\\\"Hello\\\") { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    if (\\\"Hello\\\" && test) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    if (test && \\\"Hello\\\") { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    while (\\\"Hello\\\") { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return \\\"Hello\\\" ? 1 : 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    assert (test || \\\"Hello\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:21]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    assert (test && \\\"Hello\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    assert (\\\"Hello\\\" || test);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (warning) Conversion of string literal \\\"Hello\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    assert (\\\"Hello\\\" && test);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    BOOST_ASSERT (\\\"Hello\\\" && test);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    return f2(\\\"Hello\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7750 warn about char literals in boolean expressions\n        check(\"void f() {\\n\"\n              \"  if('a'){}\\n\"\n              \"  if(L'b'){}\\n\"\n              \"  if(1 && 'c'){}\\n\"\n              \"  int x = 'd' ? 1 : 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Conversion of char literal 'a' to bool always evaluates to true. [incorrectCharBooleanError]\\n\"\n                      \"[test.cpp:3:6]: (warning) Conversion of char literal L'b' to bool always evaluates to true. [incorrectCharBooleanError]\\n\"\n                      \"[test.cpp:4:11]: (warning) Conversion of char literal 'c' to bool always evaluates to true. [incorrectCharBooleanError]\\n\"\n                      \"[test.cpp:5:11]: (warning) Conversion of char literal 'd' to bool always evaluates to true. [incorrectCharBooleanError]\\n\"\n                      , errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if('\\\\0'){}\\n\"\n              \"  if(L'\\\\0'){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Conversion of char literal '\\\\0' to bool always evaluates to false. [incorrectCharBooleanError]\\n\"\n                      \"[test.cpp:3:6]: (warning) Conversion of char literal L'\\\\0' to bool always evaluates to false. [incorrectCharBooleanError]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if('\\\\0' || cond){}\\n\"\n              \"  if(L'\\\\0' || cond){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Conversion of char literal '\\\\0' to bool always evaluates to false. [incorrectCharBooleanError]\\n\"\n                      \"[test.cpp:3:6]: (warning) Conversion of char literal L'\\\\0' to bool always evaluates to false. [incorrectCharBooleanError]\\n\", errout_str());\n\n        check(\"void f(bool b);\\n\" // #9450\n              \"void f(std::string s);\\n\"\n              \"void g() {\\n\"\n              \"    f(\\\"abc\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (warning) Conversion of string literal \\\"abc\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"void g(bool);\\n\"\n              \"    void f(std::map<std::string, std::vector<int>>&m) {\\n\"\n              \"    if (m.count(\\\"abc\\\"))\\n\"\n              \"        g(m[\\\"abc\\\"][0] ? true : false);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(bool b);\\n\"\n              \"void f() {\\n\"\n              \"    g('\\\\0');\\n\"\n              \"    g('a');\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Conversion of char literal '\\\\0' to bool always evaluates to false. [incorrectCharBooleanError]\\n\"\n                      \"[test.cpp:4:7]: (warning) Conversion of char literal 'a' to bool always evaluates to true. [incorrectCharBooleanError]\\n\",\n                      errout_str());\n\n        check(\"#define ERROR(msg) if (msg) printf(\\\"%s\\\\n\\\", msg);\\n\"\n              \"void f() {\\n\"\n              \"\t  ERROR(\\\"abc\\\")\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int, bool);\\n\"\n              \"void f() {\\n\"\n              \"    MyAssert(!\\\"abc\\\");\\n\"\n              \"    g(2, !\\\"def\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (warning) Conversion of string literal \\\"def\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"bool f(const char *p) {\\n\"\n              \"    if (*p == '\\\\0')\\n\"\n              \"        return *p == '\\\\0';\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int* p, const int* q) {\\n\"\n              \"    assert((p != NULL && q != NULL) || !\\\"abc\\\");\\n\"\n              \"    ASSERT((void*)(\\\"def\\\") == 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C {\\n\" // #6109\n              \"    void check(const char code[], bool validate = true, const char* filename = \\\"test.cpp\\\");\\n\"\n              \"    void f() {\\n\"\n              \"        check(\\\"class A<B&, C>;\\\", \\\"test.C\\\");\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:34]: (warning) Conversion of string literal \\\"test.C\\\" to bool always evaluates to true. [incorrectStringBooleanError]\\n\", errout_str());\n\n        check(\"#define MACRO(C) if(!(C)) { error(__FILE__, __LINE__, __FUNCTION__, #C); return; }\\n\" // #13067\n              \"void f() {\\n\"\n              \"    MACRO(false && \\\"abc\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"#define strequ(s1,s2) ((void *)s1 && (void *)s2 && strcmp(s1, s2) == 0)\\n\" // #13093\n              \"void f(const char* p) {\\n\"\n              \"    if (strequ(p, \\\"ALL\\\")) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deadStrcmp() {\n        check(\"void f(const char *str) {\\n\"\n              \"  if (strcmp(str, \\\"abc\\\") == 0 || strcmp(str, \\\"def\\\")) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:40]: (warning) The expression 'strcmp(str,\\\"def\\\") != 0' is suspicious. It overlaps 'strcmp(str,\\\"abc\\\") == 0'. [overlappingStrcmp]\\n\", errout_str());\n\n        check(\"void f(const wchar_t *str) {\\n\"\n              \"  if (wcscmp(str, L\\\"abc\\\") == 0 || wcscmp(str, L\\\"def\\\")) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:41]: (warning) The expression 'wcscmp(str,L\\\"def\\\") != 0' is suspicious. It overlaps 'wcscmp(str,L\\\"abc\\\") == 0'. [overlappingStrcmp]\\n\", errout_str());\n\n        check(\"struct X {\\n\"\n              \"  char *str;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f(const struct X *x) {\\n\"\n              \"  if (strcmp(x->str, \\\"abc\\\") == 0 || strcmp(x->str, \\\"def\\\")) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:43]: (warning) The expression 'strcmp(x->str,\\\"def\\\") != 0' is suspicious. It overlaps 'strcmp(x->str,\\\"abc\\\") == 0'. [overlappingStrcmp]\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestString)\n"
    }
  ]
}