{
  "name": "check",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 16,
  "branches": 3,
  "apis": 7,
  "test": [
    {
      "description": null,
      "expected-problems": 2,
      "expected-linenumbers": [
        903,
        3084
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkleakautovar.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestLeakAutoVar : public TestFixture {\npublic:\n    TestLeakAutoVar() : TestFixture(\"TestLeakAutoVar\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"std.cfg\").build();\n\n    void run() override {\n        mNewTemplate = true;\n        // Assign\n        TEST_CASE(assign1);\n        TEST_CASE(assign2);\n        TEST_CASE(assign3);\n        TEST_CASE(assign4);\n        TEST_CASE(assign5);\n        TEST_CASE(assign6);\n        TEST_CASE(assign7);\n        TEST_CASE(assign8);\n        TEST_CASE(assign9);\n        TEST_CASE(assign10);\n        TEST_CASE(assign11); // #3942: x = a(b(p));\n        TEST_CASE(assign12); // #4236: FP. bar(&x);\n        TEST_CASE(assign13); // #4237: FP. char*&ref=p; p=malloc(10); free(ref);\n        TEST_CASE(assign14);\n        TEST_CASE(assign15);\n        TEST_CASE(assign16);\n        TEST_CASE(assign17); // #9047\n        TEST_CASE(assign18);\n        TEST_CASE(assign19);\n        TEST_CASE(assign20); // #9187\n        TEST_CASE(assign21); // #10186\n        TEST_CASE(assign22); // #9139\n        TEST_CASE(assign23);\n        TEST_CASE(assign24); // #7440\n        TEST_CASE(assign25);\n        TEST_CASE(assign26);\n\n        TEST_CASE(memcpy1); // #11542\n        TEST_CASE(memcpy2);\n\n        TEST_CASE(isAutoDealloc);\n\n        TEST_CASE(realloc1);\n        TEST_CASE(realloc2);\n        TEST_CASE(realloc3);\n        TEST_CASE(realloc4);\n        TEST_CASE(realloc5); // #9292, #9990\n        TEST_CASE(freopen1);\n        TEST_CASE(freopen2);\n\n        TEST_CASE(deallocuse1);\n        TEST_CASE(deallocuse3);\n        TEST_CASE(deallocuse4);\n        TEST_CASE(deallocuse5); // #4018: FP. free(p), p = 0;\n        TEST_CASE(deallocuse6); // #4034: FP. x = p = f();\n        TEST_CASE(deallocuse7); // #6467, #6469, #6473\n        TEST_CASE(deallocuse8); // #1765\n        TEST_CASE(deallocuse9); // #9781\n        TEST_CASE(deallocuse10);\n        TEST_CASE(deallocuse11); // #8302\n        TEST_CASE(deallocuse12);\n        TEST_CASE(deallocuse13);\n        TEST_CASE(deallocuse14);\n        TEST_CASE(deallocuse15);\n        TEST_CASE(deallocuse16); // #8109: delete with comma operator\n\n        TEST_CASE(doublefree1);\n        TEST_CASE(doublefree2);\n        TEST_CASE(doublefree3); // #4914\n        TEST_CASE(doublefree4); // #5451 - FP when exit is called\n        TEST_CASE(doublefree5); // #5522\n        TEST_CASE(doublefree6); // #7685\n        TEST_CASE(doublefree7);\n        TEST_CASE(doublefree8);\n        TEST_CASE(doublefree9);\n        TEST_CASE(doublefree10); // #8706\n        TEST_CASE(doublefree11);\n        TEST_CASE(doublefree12); // #10502\n        TEST_CASE(doublefree13); // #11008\n        TEST_CASE(doublefree14); // #9708\n        TEST_CASE(doublefree15);\n        TEST_CASE(doublefree16);\n        TEST_CASE(doublefree17); // #8109: delete with comma operator\n        TEST_CASE(doublefree18);\n        TEST_CASE(doublefree19); // #13960\n\n        // exit\n        TEST_CASE(exit1);\n        TEST_CASE(exit2);\n        TEST_CASE(exit3);\n        TEST_CASE(exit4);\n\n        // handling function calls\n        TEST_CASE(functioncall1);\n\n        // goto\n        TEST_CASE(goto1);\n        TEST_CASE(goto2);\n        TEST_CASE(goto3); // #11431\n\n        // if/else\n        TEST_CASE(ifelse1);\n        TEST_CASE(ifelse2);\n        TEST_CASE(ifelse3);\n        TEST_CASE(ifelse4);\n        TEST_CASE(ifelse5);\n        TEST_CASE(ifelse6); // #3370\n        TEST_CASE(ifelse7); // #5576 - if (fd < 0)\n        TEST_CASE(ifelse8); // #5747 - if (fd == -1)\n        TEST_CASE(ifelse9); // #5273 - if (X(p==NULL, 0))\n        TEST_CASE(ifelse10); // #8794 - if (!(x!=NULL))\n        TEST_CASE(ifelse11); // #8365 - if (NULL == (p = malloc(4)))\n        TEST_CASE(ifelse12); // #8340 - if ((*p = malloc(4)) == NULL)\n        TEST_CASE(ifelse13); // #8392\n        TEST_CASE(ifelse14); // #9130 - if (x == (char*)NULL)\n        TEST_CASE(ifelse15); // #9206 - if (global_ptr = malloc(1))\n        TEST_CASE(ifelse16); // #9635 - if (p = malloc(4), p == NULL)\n        TEST_CASE(ifelse17); //  if (!!(!p))\n        TEST_CASE(ifelse18);\n        TEST_CASE(ifelse19);\n        TEST_CASE(ifelse20); // #10182\n        TEST_CASE(ifelse21);\n        TEST_CASE(ifelse22); // #10187\n        TEST_CASE(ifelse23); // #5473\n        TEST_CASE(ifelse24); // #1733\n        TEST_CASE(ifelse25); // #9966\n        TEST_CASE(ifelse26);\n        TEST_CASE(ifelse27);\n        TEST_CASE(ifelse28); // #11038\n        TEST_CASE(ifelse29);\n\n        // switch\n        TEST_CASE(switch1);\n\n        // loops\n        TEST_CASE(loop1);\n        TEST_CASE(loop2);\n\n        // mismatching allocation/deallocation\n        TEST_CASE(mismatchAllocDealloc);\n\n        TEST_CASE(smartPointerDeleter);\n        TEST_CASE(smartPointerRelease);\n\n        // Execution reaches a 'return'\n        TEST_CASE(return1);\n        TEST_CASE(return2);\n        TEST_CASE(return3);\n        TEST_CASE(return4);\n        TEST_CASE(return5);\n        TEST_CASE(return6); // #8282 return {p, p}\n        TEST_CASE(return7); // #9343 return (uint8_t*)x\n        TEST_CASE(return8);\n        TEST_CASE(return9);\n        TEST_CASE(return10);\n        TEST_CASE(return11); // #13098\n        TEST_CASE(return12); // #12238\n\n        // General tests: variable type, allocation type, etc\n        TEST_CASE(test1);\n        TEST_CASE(test2);\n        TEST_CASE(test3);  // #3954 - reference pointer\n        TEST_CASE(test4);  // #5923 - static pointer\n        TEST_CASE(test5);  // unknown type\n\n        // Execution reaches a 'throw'\n        TEST_CASE(throw1);\n        TEST_CASE(throw2);\n\n        // Possible leak => Further configuration is needed for complete analysis\n        TEST_CASE(configuration1);\n        TEST_CASE(configuration2);\n        TEST_CASE(configuration3);\n        TEST_CASE(configuration4);\n        TEST_CASE(configuration5);\n        TEST_CASE(configuration6);\n\n        TEST_CASE(ptrptr);\n\n        TEST_CASE(nestedAllocation);\n        TEST_CASE(testKeywords); // #6767\n\n        TEST_CASE(inlineFunction); // #3989\n\n        TEST_CASE(smartPtrInContainer); // #8262\n\n        TEST_CASE(functionCallCastConfig); // #9652\n        TEST_CASE(functionCallLeakIgnoreConfig); // #7923\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        bool cpp = false;\n        const Settings *s = nullptr;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.s ? *options.s : settings).checkLibrary().build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this, options.cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for leaks..\n        runChecks<CheckLeakAutoVar>(tokenizer, this);\n    }\n\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const Settings & s) {\n        const Settings settings0 = settingsBuilder(s).checkLibrary().build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings0, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for leaks..\n        runChecks<CheckLeakAutoVar>(tokenizer, this);\n    }\n\n    void assign1() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    p = NULL;\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:5]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign2() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    char *q = p;\\n\"\n              \"    free(q);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign3() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    char *q = p + 1;\\n\"\n              \"    free(q - 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign4() {\n        check(\"void f() {\\n\"\n              \"    char *a = malloc(10);\\n\"\n              \"    a += 10;\\n\"\n              \"    free(a - 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign5() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    char *p = new char[100];\\n\"\n              \"    list += p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign6() { // #2806 - FP when there is redundant assignment\n        check(\"void foo() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    p = strcpy(p,q);\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign7() {\n        check(\"void foo(struct str *d) {\\n\"\n              \"    struct str *p = malloc(10);\\n\"\n              \"    d->p = p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign8() {  // linux list\n        check(\"void foo(struct str *d) {\\n\"\n              \"    struct str *p = malloc(10);\\n\"\n              \"    d->p = &p->x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign9() {\n        check(\"void foo() {\\n\"\n              \"    char *p = x();\\n\"\n              \"    free(p);\\n\"\n              \"    p = NULL;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign10() {\n        check(\"void foo() {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x) { p = malloc(10); }\\n\"\n              \"    if (!x) { p = NULL; }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign11() { // #3942 - FP for x = a(b(p));\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    x = a(b(p));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:4:1]: (information) --check-library: Function b() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n    }\n\n    void assign12() { // #4236: FP. bar(&x)\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    free(p);\\n\"\n              \"    bar(&p);\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign13() { // #4237: FP. char *&ref=p; p=malloc(10); free(ref);\n        check(\"void f() {\\n\"\n              \"    char *p;\\n\"\n              \"    char * &ref = p;\\n\"\n              \"    p = malloc(10);\\n\"\n              \"    free(ref);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:6:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign14() {\n        check(\"void f(int x) {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x && (p = malloc(10))) { }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:35]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x && (p = new char[10])) { }\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:37]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign15() {\n        // #8120\n        check(\"void f() {\\n\"\n              \"   baz *p;\\n\"\n              \"   p = malloc(sizeof *p);\\n\"\n              \"   free(p);\\n\"\n              \"   p = malloc(sizeof *p);\\n\"\n              \"   free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign16() {\n        check(\"void f() {\\n\"\n              \"   char *p = malloc(10);\\n\"\n              \"   free(p);\\n\"\n              \"   if (p=dostuff()) *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign17() { // #9047\n        check(\"void f() {\\n\"\n              \"    char *p = (char*)malloc(10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *p = (char*)(int*)malloc(10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign18() {\n        check(\"void f(int x) {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x && (p = (char*)malloc(10))) { }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:42]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x && (p = (char*)(int*)malloc(10))) { }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:48]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign19() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    free((void*)p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign20() { // #9187\n        check(\"void f() {\\n\"\n              \"    char *p = static_cast<int>(malloc(10));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign21() {\n        check(\"void f(int **x) {\\n\" // #10186\n              \"    void *p = malloc(10);\\n\"\n              \"    *x = (int*)p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int i; };\\n\" // #10996\n              \"void f() {\\n\"\n              \"    S* s = new S();\\n\"\n              \"    (void)s;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:5:1]: (error) Memory leak: s [memleak]\\n\", errout_str());\n    }\n\n    void assign22() { // #9139\n        const Settings s = settingsBuilder().library(\"posix.cfg\").build();\n        check(\"void f(char tempFileName[256]) {\\n\"\n              \"    const int fd = socket(AF_INET, SOCK_PACKET, 0 );\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:3:1]: (error) Resource leak: fd [resourceLeak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const void * const p = malloc(10);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign23() {\n        const Settings s = settingsBuilder().library(\"posix.cfg\").build();\n        check(\"void f() {\\n\"\n              \"    int n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14;\\n\"\n              \"    *&n1 = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *&(n2) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *(&n3) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *&*&n4 = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *&*&*&(n5) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *&*&(*&n6) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *&*(&*&n7) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *(&*&n8) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *&(*&*&(*&n9)) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    (n10) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    ((n11)) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    ((*&n12)) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    *(&(*&n13)) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"    ((*&(*&n14))) = open(\\\"xx.log\\\", O_RDONLY);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:17:1]: (error) Resource leak: n1 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n2 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n3 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n4 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n5 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n6 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n7 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n8 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n9 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n10 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n11 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n12 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n13 [resourceLeak]\\n\"\n                      \"[test.cpp:17:1]: (error) Resource leak: n14 [resourceLeak]\\n\",\n                      errout_str());\n    }\n\n    void assign24() {\n        check(\"void f() {\\n\" // #7440\n              \"    char* data = new char[100];\\n\"\n              \"    char** dataPtr = &data;\\n\"\n              \"    delete[] *dataPtr;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char* data = new char[100];\\n\"\n              \"    char** dataPtr = &data;\\n\"\n              \"    printf(\\\"test\\\");\\n\"\n              \"    delete[] *dataPtr;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #9279\n              \"    int* p = new int;\\n\"\n              \"    *p = 42;\\n\"\n              \"    g();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (information) --check-library: Function g() should have <noreturn> configuration [checkLibraryNoReturn]\\n\",\n                      errout_str());\n\n        check(\"void g();\\n\"\n              \"void f() {\\n\"\n              \"    int* p = new int;\\n\"\n              \"    *p = 42;\\n\"\n              \"    g();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:6:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void g() {}\\n\"\n              \"void f() {\\n\"\n              \"    int* p = new int;\\n\"\n              \"    *p = 42;\\n\"\n              \"    g();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:6:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"[[noreturn]] void g();\\n\"\n              \"void f() {\\n\"\n              \"    int* p = new int;\\n\"\n              \"    *p = 42;\\n\"\n              \"    g();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g() { exit(1); }\\n\"\n              \"void f() {\\n\"\n              \"    int* p = new int;\\n\"\n              \"    *p = 42;\\n\"\n              \"    g();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g() {}\\n\" // #10517\n              \"void f() {\\n\"\n              \"    char* p = malloc(10);\\n\"\n              \"    g();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:5:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void assign25() {\n        check(\"void f() {\\n\" // #11796\n              \"    int* p{ new int };\\n\"\n              \"    int* q(new int);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) Memory leak: p [memleak]\\n\"\n                      \"[test.cpp:4:1]: (error) Memory leak: q [memleak]\\n\",\n                      errout_str());\n\n        check(\"struct S : B {\\n\" // #12239\n              \"    void f();\\n\"\n              \"    void g();\\n\"\n              \"};\\n\"\n              \"void S::f() {\\n\"\n              \"    FD* fd(new FD(this));\\n\"\n              \"    fd->exec();\\n\"\n              \"}\\n\"\n              \"void S::g() {\\n\"\n              \"    FD* fd{ new FD(this) };\\n\"\n              \"    fd->exec();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct C {\\n\" // #12327\n              \"    char* m_p;\\n\"\n              \"    C(char* p) : m_p(p) {}\\n\"\n              \"};\\n\"\n              \"std::list<C> gli;\\n\"\n              \"void f() {\\n\"\n              \"    std::list<C> li;\\n\"\n              \"    char* p = new char[1];\\n\"\n              \"    C c(p);\\n\"\n              \"    li.push_back(c);\\n\"\n              \"    C c2(li.front());\\n\"\n              \"    delete[] c2.m_p;\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    char* p = new char[1];\\n\"\n              \"    C c(p);\\n\"\n              \"    gli.push_back(c);\\n\"\n              \"}\\n\"\n              \"void h() {\\n\"\n              \"    std::list<C> li;\\n\"\n              \"    char* p = new char[1];\\n\"\n              \"    C c(p);\\n\"\n              \"    li.push_back(c);\\n\"\n              \"    delete[] li.front().m_p;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12890\n              \"    int** p;\\n\"\n              \"    S() {\\n\"\n              \"        p = std::malloc(sizeof(int*));\\n\"\n              \"        p[0] = new int;\\n\"\n              \"    }\\n\"\n              \"    ~S() {\\n\"\n              \"        delete p[0];\\n\"\n              \"        std::free(p);\\n\"\n              \"    }\\n\"\n              \"};\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void assign26() {\n        check(\"void f(int*& x) {\\n\" // #8235\n              \"    int* p = (int*)malloc(10);\\n\"\n              \"    x = p ? p : nullptr;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int*& x) {\\n\"\n              \"    int* p = (int*)malloc(10);\\n\"\n              \"    x = p != nullptr ? p : nullptr;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memcpy1() { // #11542\n        const Settings s = settingsBuilder().library(\"std.cfg\").build();\n        check(\"void f(char** old, char* value) {\\n\"\n              \"    char *str = strdup(value);\\n\"\n              \"    memcpy(old, &str, sizeof(char*));\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memcpy2() {\n        const Settings s = settingsBuilder().library(\"std.cfg\").build();\n        check(\"void f(char* old, char* value, size_t len) {\\n\"\n              \"    char *str = strdup(value);\\n\"\n              \"    memcpy(old, str, len);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) Memory leak: str [memleak]\\n\", errout_str());\n    }\n\n    void isAutoDealloc() {\n        check(\"void f() {\\n\"\n              \"    char *p = new char[100];\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:29]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Fred *fred = new Fred;\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::string *str = new std::string;\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:40]: (error) Memory leak: str [memleak]\\n\", errout_str());\n\n        check(\"class TestType {\\n\" // #9028\n              \"public:\\n\"\n              \"    char ca[12];\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    TestType *tt = new TestType();\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:7:1]: (error) Memory leak: tt [memleak]\\n\", errout_str());\n\n        check(\"void f(Bar& b) {\\n\" // #7622\n              \"    char* data = new char[10];\\n\"\n              \"    b = Bar(*new Foo(data));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (information) --check-library: Function Foo() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n\n        check(\"class B {};\\n\"\n              \"    class D : public B {};\\n\"\n              \"    void g() {\\n\"\n              \"        auto d = new D();\\n\"\n              \"        if (d) {}\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:6:1]: (error) Memory leak: d [memleak]\\n\", errout_str());\n\n        check(\"struct S {\\n\" // #12354\n              \"    int i{};\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void f(S* p, bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        p = new S();\\n\"\n              \"    p->f();\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:9:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void realloc1() {\n        check(\"void f() {\\n\"\n              \"    void *p = malloc(10);\\n\"\n              \"    void *q = realloc(p, 20);\\n\"\n              \"    free(q)\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void realloc2() {\n        check(\"void f() {\\n\"\n              \"    void *p = malloc(10);\\n\"\n              \"    void *q = realloc(p, 20);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:4:1]: (error) Memory leak: q [memleak]\\n\", errout_str());\n    }\n\n    void realloc3() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    char *q = (char*) realloc(p, 20);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:4:1]: (error) Memory leak: q [memleak]\\n\", errout_str());\n    }\n\n    void realloc4() {\n        check(\"void f(void *p) {\\n\"\n              \"    void * q = realloc(p, 10);\\n\"\n              \"    if (q == NULL)\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:5:1]: (error) Memory leak: q [memleak]\\n\", errout_str());\n    }\n\n    void realloc5() {\n        // #9292\n        check(\"void * f(void * ptr, size_t size) {\\n\"\n              \"    void *datap = realloc(ptr, size);\\n\"\n              \"    if (size && !datap)\\n\"\n              \"        free(ptr);\\n\"\n              \"    return datap;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9990\n        check(\"void f() {\\n\"\n              \"    void * p1 = malloc(10);\\n\"\n              \"    if (!p1)\\n\"\n              \"        return;\\n\"\n              \"    void * p2 = realloc(p1, 42);\\n\"\n              \"    if (!p2) {\\n\"\n              \"        free(p1);\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    free(p2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void freopen1() {\n        check(\"void f() {\\n\"\n              \"    void *p = fopen(name,a);\\n\"\n              \"    void *q = freopen(name, b, p);\\n\"\n              \"    fclose(q)\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void freopen2() {\n        check(\"void f() {\\n\"\n              \"    void *p = fopen(name,a);\\n\"\n              \"    void *q = freopen(name, b, p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:4:1]: (error) Resource leak: q [resourceLeak]\\n\", errout_str());\n    }\n\n    void deallocuse1() {\n        check(\"void f(char *p) {\\n\"\n              \"    free(p);\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:6]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\", errout_str());\n\n        check(\"void f(char *p) {\\n\"\n              \"    free(p);\\n\"\n              \"    char c = *p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:15]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\", errout_str());\n    }\n\n    void deallocuse3() {\n        check(\"void f(struct str *p) {\\n\"\n              \"    free(p);\\n\"\n              \"    p = p->next;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:9]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\", errout_str());\n    }\n\n    void deallocuse4() {\n        check(\"void f(char *p) {\\n\"\n              \"    free(p);\\n\"\n              \"    return p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:2:5] -> [test.c:3:5]: (error) Returning/dereferencing 'p' after it is deallocated / released [deallocret]\\n\", errout_str());\n\n        check(\"void f(char *p) {\\n\"\n              \"  if (!p) free(p);\\n\"\n              \"  return p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *p) {\\n\"\n              \"  if (!p) delete p;\\n\"\n              \"  return p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *p) {\\n\"\n              \"  if (!p) delete [] p;\\n\"\n              \"  return p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void* p) {\\n\"\n              \"   if (a) {\\n\"\n              \"      free(p);\\n\"\n              \"       return;\\n\"\n              \"   }\\n\"\n              \"   g(p);\\n\"\n              \"   return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse5() {  // #4018\n        check(\"void f(char *p) {\\n\"\n              \"    free(p), p = 0;\\n\"\n              \"    *p = 0;\\n\"  // <- Make sure pointer info is reset. It is NOT a freed pointer dereference\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse6() {  // #4034\n        check(\"void f(char *p) {\\n\"\n              \"    free(p);\\n\"\n              \"    x = p = foo();\\n\"  // <- p is not dereferenced\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse7() {  // #6467, #6469, #6473, #6648\n        check(\"struct Foo { int* ptr; };\\n\"\n              \"void f(Foo* foo) {\\n\"\n              \"    delete foo->ptr;\\n\"\n              \"    foo->ptr = new Foo;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo { int* ptr; };\\n\"\n              \"void f(Foo* foo) {\\n\"\n              \"    delete foo->ptr;\\n\"\n              \"    x = *foo->ptr;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Dereferencing 'ptr' after it is deallocated / released [deallocuse]\\n\", \"\", errout_str());\n\n        check(\"void parse() {\\n\"\n              \"    struct Buf {\\n\"\n              \"        Buf(uint32_t len) : m_buf(new uint8_t[len]) {}\\n\"\n              \"        ~Buf() { delete[]m_buf; }\\n\"\n              \"        uint8_t *m_buf;\\n\"\n              \"    };\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo {\\n\"\n              \"    Foo();\\n\"\n              \"    Foo* ptr;\\n\"\n              \"    void func();\\n\"\n              \"};\\n\"\n              \"void bar(Foo* foo) {\\n\"\n              \"    delete foo->ptr;\\n\"\n              \"    foo->ptr = new Foo;\\n\"\n              \"    foo->ptr->func();\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(void (*conv)(char**)) {\\n\"\n              \"  char * ptr=(char*)malloc(42);\\n\"\n              \"  free(ptr);\\n\"\n              \"  (*conv)(&ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse8() {  // #1765\n        check(\"void f() {\\n\"\n              \"    int *ptr = new int;\\n\"\n              \"    delete(ptr);\\n\"\n              \"    *ptr = 0;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Dereferencing 'ptr' after it is deallocated / released [deallocuse]\\n\", errout_str());\n    }\n\n    void deallocuse9() {\n        check(\"void f(Type* p) {\\n\" // #9781\n              \"  std::shared_ptr<Type> sp(p);\\n\"\n              \"  bool b = p->foo();\\n\"\n              \"  return b;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\" // #8635\n              \"    std::vector<std::unique_ptr<A>> array_;\\n\"\n              \"    A* foo() {\\n\"\n              \"        A* a = new A();\\n\"\n              \"        array_.push_back(std::unique_ptr<A>(a));\\n\"\n              \"        return a;\\n\"\n              \"    }\\n\"\n              \"};\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g(int *p) {\\n\" // #9838\n              \"    std::unique_ptr<int> temp(p);\\n\"\n              \"    return DoSomething(p);\\n\"\n              \"}\\n\"\n              \"int f() {\\n\"\n              \"    return g(new int(3));\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse10() {\n        check(\"void f(char* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    p[0] = 10;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:3:5]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\", errout_str());\n\n        check(\"int f(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    return p[1];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:2:5] -> [test.c:3:5]: (error) Returning/dereferencing 'p' after it is deallocated / released [deallocret]\\n\", errout_str());\n    }\n\n    void deallocuse11() { // #8302\n        check(\"int f() {\\n\"\n              \"  int *array = new int[42];\\n\"\n              \"  delete [] array;\\n\"\n              \"  return array[1];\" // <<\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:3] -> [test.cpp:4:3]: (error) Returning/dereferencing 'array' after it is deallocated / released [deallocret]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"  int *array = (int*)malloc(40);\\n\"\n              \"  free(array);\\n\"\n              \"  return array[1];\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:3] -> [test.c:4:3]: (error) Returning/dereferencing 'array' after it is deallocated / released [deallocret]\\n\", errout_str());\n    }\n\n    void deallocuse12() {\n        check(\"struct foo { int x; }\\n\"\n              \"void f1(struct foo *f) {\\n\"\n              \"  free(f);\\n\"\n              \"}\\n\"\n              \"void f2(struct foo *f, int *out) {\\n\"\n              \"  *out = f->x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse13() {\n        check(\"void f() {\\n\" // #9695\n              \"    auto* a = new int[2];\\n\"\n              \"    delete[] a;\\n\"\n              \"    a[1] = 0;\\n\"\n              \"    auto* b = static_cast<int*>(malloc(8));\\n\"\n              \"    free(b);\\n\"\n              \"    b[1] = 0;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Dereferencing 'a' after it is deallocated / released [deallocuse]\\n\"\n                      \"[test.cpp:7:5]: (error) Dereferencing 'b' after it is deallocated / released [deallocuse]\\n\",\n                      errout_str());\n    }\n\n    void deallocuse14() {\n        check(\"struct S { void f(); };\\n\" // #10905\n              \"void g() {\\n\"\n              \"    S* s = new S;\\n\"\n              \"    delete s;\\n\"\n              \"    s->f();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (error) Dereferencing 's' after it is deallocated / released [deallocuse]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *p = (int*)malloc(4);\\n\"\n              \"    free(p);\\n\"\n              \"    if (*p == 5) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:4:10]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\",\n                      errout_str());\n\n        check(\"int g(int);\\n\"\n              \"void f(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    g(*p);\\n\"\n              \"}\\n\"\n              \"int h(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    return g(*p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:4:8]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\"\n                      \"[test.c:7:5] -> [test.c:8:5]: (error) Returning/dereferencing 'p' after it is deallocated / released [deallocret]\\n\",\n                      errout_str());\n\n        check(\"int g(int);\\n\"\n              \"void f(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    g(1 + *p);\\n\"\n              \"}\\n\"\n              \"int h(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    return g(1 + *p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:4:12]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\"\n                      \"[test.c:7:5] -> [test.c:8:5]: (error) Returning/dereferencing 'p' after it is deallocated / released [deallocret]\\n\",\n                      errout_str());\n\n        check(\"int g(int, int);\\n\"\n              \"void f(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    g(0, 1 + *p);\\n\"\n              \"}\\n\"\n              \"int h(int* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    return g(0, 1 + *p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:4:15]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\"\n                      \"[test.c:7:5] -> [test.c:8:5]: (error) Returning/dereferencing 'p' after it is deallocated / released [deallocret]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FOREACH(callables, ());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:2:27]: (information) --check-library: Function FOREACH() should have <noreturn> configuration [checkLibraryNoReturn]\\n\", errout_str()); // don't crash\n\n        check(\"int f() {\\n\" // #12321\n              \"    std::invoke([](int i) {\\n\"\n              \"        int* p = (int*)malloc(4);\\n\"\n              \"        *p = 0;\\n\"\n              \"        if (i) {\\n\"\n              \"            free(p);\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"        free(p);\\n\"\n              \"    }, 1);\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse15() {\n        check(\"bool FileExists(const char* filename) {\\n\" // #12490\n              \"    FILE* f = fopen(filename, \\\"rb\\\");\\n\"\n              \"    if (f) fclose(f);\\n\"\n              \"    return f;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\" // #12590\n              \"    FILE* fd = fopen(\\\"/foo/bar\\\", \\\"w\\\");\\n\"\n              \"    if (fd == nullptr)\\n\"\n              \"        return false;\\n\"\n              \"    return fclose(fd) == 0;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const char* fileName) {\\n\" // #13136\n              \"    FILE* h = fopen(fileName, \\\"rb\\\");\\n\"\n              \"    if (fseek(h, 0L, SEEK_END) == -1)\\n\"\n              \"        fclose(h);\\n\"\n              \"    int i = ftell(h);\\n\"\n              \"    return i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:5:19]: (error) Dereferencing 'h' after it is deallocated / released [deallocuse]\\n\", errout_str());\n    }\n\n    void deallocuse16() {\n        check(\"void f() {\\n\"\n              \"    int *a = nullptr;\\n\"\n              \"    int *c = new int;\\n\"\n              \"    delete (a, c);\\n\"\n              \"    *c = 10;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:5:6]: (error) Dereferencing 'c' after it is deallocated / released [deallocuse]\\n\", errout_str());\n    }\n\n    void doublefree1() {  // #3895\n        check(\"void f(char *p) {\\n\"\n              \"    if (x)\\n\"\n              \"        free(p);\\n\"\n              \"    else\\n\"\n              \"        p = 0;\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:9] -> [test.c:6:5]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  free(p);\\n\"\n            \"  free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:2:3] -> [test.c:3:3]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(char *p, char *r) {\\n\"\n            \"  free(p);\\n\"\n            \"  free(r);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo() {\\n\"\n            \"  free(p);\\n\"\n            \"  free(r);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  if (x < 3) free(p);\\n\"\n            \"  else { if (x > 9) free(p); }\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  free(p);\\n\"\n            \"  getNext(&p);\\n\"\n            \"  free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  free(p);\\n\"\n            \"  bar();\\n\"\n            \"  free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:2:3] -> [test.c:4:3]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  free(p);\\n\"\n            \"  printf(\\\"Freed memory at location %x\\\", p);\\n\"\n            \"  free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:3:41]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\"\n                      \"[test.c:2:3] -> [test.c:4:3]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\",\n                      errout_str());\n\n        check(\n            \"void foo(FILE *p) {\\n\"\n            \"  fclose(p);\\n\"\n            \"  fclose(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:2:3] -> [test.c:3:3]: (error) Resource handle 'p' freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(FILE *p, FILE *r) {\\n\"\n            \"  fclose(p);\\n\"\n            \"  fclose(r);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(FILE *p) {\\n\"\n            \"  if (x < 3) fclose(p);\\n\"\n            \"  else { if (x > 9) fclose(p); }\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(FILE *p) {\\n\"\n            \"  fclose(p);\\n\"\n            \"  gethandle(&p);\\n\"\n            \"  fclose(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(FILE *p) {\\n\"\n            \"  fclose(p);\\n\"\n            \"  gethandle();\\n\"\n            \"  fclose(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:2:3] -> [test.c:4:3]: (error) Resource handle 'p' freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(Data* p) {\\n\"\n            \"  free(p->a);\\n\"\n            \"  free(p->b);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void f() {\\n\"\n            \"    char *p; p = malloc(100);\\n\"\n            \"    if (x) {\\n\"\n            \"        free(p);\\n\"\n            \"        exit();\\n\"\n            \"    }\\n\"\n            \"    free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void f() {\\n\"\n            \"    char *p; p = malloc(100);\\n\"\n            \"    if (x) {\\n\"\n            \"        free(p);\\n\"\n            \"        x = 0;\\n\"\n            \"    }\\n\"\n            \"    free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:4:9] -> [test.c:7:5]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void f() {\\n\"\n            \"    char *p; p = do_something();\\n\"\n            \"    free(p);\\n\"\n            \"    p = do_something();\\n\"\n            \"    free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  delete p;\\n\"\n            \"  delete p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:3:10]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(char *p, char *r) {\\n\"\n            \"  delete p;\\n\"\n            \"  delete r;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(P p) {\\n\"\n            \"  delete p.x;\\n\"\n            \"  delete p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char **p) {\\n\"\n            \"  delete p[0];\\n\"\n            \"  delete p[1];\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  delete p;\\n\"\n            \"  getNext(&p);\\n\"\n            \"  delete p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  delete p;\\n\"\n            \"  bar();\\n\"\n            \"  delete p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:4:10]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  delete[] p;\\n\"\n            \"  delete[] p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:3:12]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(char *p, char *r) {\\n\"\n            \"  delete[] p;\\n\"\n            \"  delete[] r;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  delete[] p;\\n\"\n            \"  getNext(&p);\\n\"\n            \"  delete[] p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(char *p) {\\n\"\n            \"  delete[] p;\\n\"\n            \"  bar();\\n\"\n            \"  delete[] p;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:4:12]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"LineMarker::~LineMarker() {\\n\"\n            \"  delete pxpm;\\n\"\n            \"}\\n\"\n            \"LineMarker &LineMarker::operator=(const LineMarker &) {\\n\"\n            \"  delete pxpm;\\n\"\n            \"  pxpm = NULL;\\n\"\n            \"  return *this;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo()\\n\"\n            \"{\\n\"\n            \"  int* ptr; ptr = NULL;\\n\"\n            \"  try\\n\"\n            \"    {\\n\"\n            \"      ptr = new int(4);\\n\"\n            \"    }\\n\"\n            \"  catch(...)\\n\"\n            \"    {\\n\"\n            \"      delete ptr;\\n\"\n            \"      throw;\\n\"\n            \"    }\\n\"\n            \"  delete ptr;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"int foo()\\n\"\n            \"{\\n\"\n            \"   int* a; a = new int;\\n\"\n            \"   bool doDelete; doDelete = true;\\n\"\n            \"   if (a != 0)\\n\"\n            \"   {\\n\"\n            \"       doDelete = false;\\n\"\n            \"       delete a;\\n\"\n            \"   }\\n\"\n            \"   if(doDelete)\\n\"\n            \"       delete a;\\n\"\n            \"   return 0;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:8:8] -> [test.cpp:11:15]: (error) Memory pointed to by 'a' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void foo(int y)\\n\"\n            \"{\\n\"\n            \"    char * x; x = NULL;\\n\"\n            \"    while(true) {\\n\"\n            \"        x = new char[100];\\n\"\n            \"        if (y++ > 100)\\n\"\n            \"            break;\\n\"\n            \"        delete[] x;\\n\"\n            \"    }\\n\"\n            \"    delete[] x;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(int y)\\n\"\n            \"{\\n\"\n            \"    char * x; x = NULL;\\n\"\n            \"    for (int i = 0; i < 10000; i++) {\\n\"\n            \"        x = new char[100];\\n\"\n            \"        delete[] x;\\n\"\n            \"    }\\n\"\n            \"    delete[] x;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:8]: (error) Memory pointed to by 'x' is freed twice.\\n\", \"\", errout_str());\n\n        check(\n            \"void foo(int y)\\n\"\n            \"{\\n\"\n            \"    char * x; x = NULL;\\n\"\n            \"    while (isRunning()) {\\n\"\n            \"        x = new char[100];\\n\"\n            \"        delete[] x;\\n\"\n            \"    }\\n\"\n            \"    delete[] x;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:8]: (error) Memory pointed to by 'x' is freed twice.\\n\", \"\", errout_str());\n\n        check(\n            \"void foo(int y)\\n\"\n            \"{\\n\"\n            \"    char * x; x = NULL;\\n\"\n            \"    while (isRunning()) {\\n\"\n            \"        x = malloc(100);\\n\"\n            \"        free(x);\\n\"\n            \"    }\\n\"\n            \"    free(x);\\n\"\n            \"}\");\n        TODO_ASSERT_EQUALS(\"[test.c:8]: (error) Memory pointed to by 'x' is freed twice.\\n\", \"\", errout_str());\n\n        check(\n            \"void foo(int y)\\n\"\n            \"{\\n\"\n            \"    char * x; x = NULL;\\n\"\n            \"    for (;;) {\\n\"\n            \"        x = new char[100];\\n\"\n            \"        if (y++ > 100)\\n\"\n            \"            break;\\n\"\n            \"        delete[] x;\\n\"\n            \"    }\\n\"\n            \"    delete[] x;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void foo(int y)\\n\"\n            \"{\\n\"\n            \"    char * x; x = NULL;\\n\"\n            \"    do {\\n\"\n            \"        x = new char[100];\\n\"\n            \"        if (y++ > 100)\\n\"\n            \"            break;\\n\"\n            \"        delete[] x;\\n\"\n            \"    } while (true);\\n\"\n            \"    delete[] x;\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void f()\\n\"\n            \"{\\n\"\n            \"    char *p; p = 0;\\n\"\n            \"    if (x < 100) {\\n\"\n            \"        p = malloc(10);\\n\"\n            \"        free(p);\\n\"\n            \"    }\\n\"\n            \"    free(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.c:6:9] -> [test.c:8:5]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\n            \"void MyFunction()\\n\"\n            \"{\\n\"\n            \"    char* data; data = new char[100];\\n\"\n            \"    try\\n\"\n            \"    {\\n\"\n            \"    }\\n\"\n            \"    catch(err)\\n\"\n            \"    {\\n\"\n            \"        delete[] data;\\n\"\n            \"        MyThrow(err);\\n\"\n            \"    }\\n\"\n            \"    delete[] data;\\n\"\n            \"}\\n\"\n\n            \"void MyThrow(err)\\n\"\n            \"{\\n\"\n            \"    throw(err);\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\n            \"void MyFunction()\\n\"\n            \"{\\n\"\n            \"    char* data; data = new char[100];\\n\"\n            \"    try\\n\"\n            \"    {\\n\"\n            \"    }\\n\"\n            \"    catch(err)\\n\"\n            \"    {\\n\"\n            \"        delete[] data;\\n\"\n            \"        MyExit(err);\\n\"\n            \"    }\\n\"\n            \"    delete[] data;\\n\"\n            \"}\\n\"\n\n            \"void MyExit(err)\\n\"\n            \"{\\n\"\n            \"    exit(err);\\n\"\n            \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check( // #6252\n            \"struct Wrapper {\\n\"\n            \"    Thing* m_thing;\\n\"\n            \"    Wrapper() : m_thing(0) {\\n\"\n            \"    }\\n\"\n            \"    ~Wrapper() {\\n\"\n            \"        delete m_thing;\\n\"\n            \"    }\\n\"\n            \"    void changeThing() {\\n\"\n            \"        delete m_thing;\\n\"\n            \"        m_thing = new Thing;\\n\"\n            \"    }\\n\"\n            \"};\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7401\n        check(\"void pCodeLabelDestruct(pCode *pc) {\\n\"\n              \"    free(PCL(pc)->label);\\n\"\n              \"    free(pc);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree2() {  // #3891\n        check(\"void *f(int a) {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    if (a == 2) { free(p); return ((void*)1); }\\n\"\n              \"    free(p);\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree3() {  // #4914\n        check(\"void foo() {\\n\"\n              \"   bool done = false;\\n\"\n              \"   do {\\n\"\n              \"       char *bar = malloc(10)\\n\"\n              \"       if(condition()) {\\n\"\n              \"           free(bar);\\n\"\n              \"           continue;\\n\"\n              \"       }\\n\"\n              \"       done = true;\\n\"\n              \"       free(bar)\\n\"\n              \"   } while(!done);\\n\"\n              \"   return;\"\n              \"}\"\n              );\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree4() {\n        check(\"void f(char *p) {\\n\" // #5451 - exit\n              \"  if (x) {\\n\"\n              \"    free(p);\\n\"\n              \"    exit(1);\\n\"\n              \"  }\\n\"\n              \"  free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void* p, int i) {\\n\" // #11391\n              \"    if (i)\\n\"\n              \"        goto cleanup;\\n\"\n              \"    free(p);\\n\"\n              \"    exit(0);\\n\"\n              \"cleanup:\\n\"\n              \"    free(p);\\n\"\n              \"    exit(1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree5() {  // #5522\n        check(\"void f(char *p) {\\n\"\n              \"  free(p);\\n\"\n              \"  x = (q == p);\\n\"\n              \"  free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:2:3] -> [test.c:4:3]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n    }\n\n    void doublefree6() { // #7685\n        check(\"void do_wordexp(FILE *f) {\\n\"\n              \"  free(getword(f));\\n\"\n              \"  fclose(f);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree7() {\n        check(\"void f(char *p, int x) {\\n\"\n              \"    free(p);\\n\"\n              \"    if (x && (p = malloc(10)))\\n\"\n              \"        free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *p, int x) {\\n\"\n              \"    delete[] p;\\n\"\n              \"    if (x && (p = new char[10]))\\n\"\n              \"        delete[] p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree8() {\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::unique_ptr<int> x(i);\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    delete i;\\n\"\n              \"    std::unique_ptr<int> x(i);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:4:28]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::unique_ptr<int> x{i};\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::shared_ptr<int> x(i);\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::shared_ptr<int> x{i};\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        // Check for use-after-free FP\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::shared_ptr<int> x{i};\\n\"\n              \"    *i = 123;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int[1];\\n\"\n              \"    std::unique_ptr<int[]> x(i);\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\"using namespace std;\\n\" // #9708\n              \"void f() {\\n\"\n              \"    int* i = new int;\\n\"\n              \"    unique_ptr<int> x(i);\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:5:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n    }\n\n    void doublefree9() {\n        check(\"struct foo {\\n\"\n              \"    int* get(int) { return new int(); }\\n\"\n              \"};\\n\"\n              \"void f(foo* b) {\\n\"\n              \"    std::unique_ptr<int> x(b->get(0));\\n\"\n              \"    std::unique_ptr<int> y(b->get(1));\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree10() {\n        check(\"void f(char* s) {\\n\"\n              \"    char *p = malloc(strlen(s));\\n\"\n              \"    if (p != NULL) {\\n\"\n              \"        strcat(p, s);\\n\"\n              \"        if (strlen(s) != 10)\\n\"\n              \"            free(p); p = NULL;\\n\"\n              \"    }\\n\"\n              \"    if (p != NULL)\\n\"\n              \"        free(p);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char* s) {\\n\"\n              \"    char *p = malloc(strlen(s));\\n\"\n              \"    if (p != NULL) {\\n\"\n              \"        strcat(p, s);\\n\"\n              \"        if (strlen(s) != 10)\\n\"\n              \"            free(p), p = NULL;\\n\"\n              \"    }\\n\"\n              \"    if (p != NULL)\\n\"\n              \"        free(p);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree11() {\n        check(\"void f() {\\n\"\n              \"    void * p = malloc(5);\\n\"\n              \"    void * q = realloc(p, 10);\\n\"\n              \"    if (q == NULL) {\\n\"\n              \"        free(p);\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    free(p);\\n\"\n              \"    if (q == NULL)\\n\"\n              \"        return;\\n\"\n              \"    free(q);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:16] -> [test.c:8:5]: (error) Memory pointed to by 'p' is freed twice. [doubleFree]\\n\", errout_str());\n    }\n\n    void doublefree12() { // #10502\n        check(\"int f(FILE *fp, const bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        return fclose(fp);\\n\"\n              \"    fclose(fp);\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree13() { // #11008\n        check(\"struct buf_t { void* ptr; };\\n\"\n              \"void f() {\\n\"\n              \"    struct buf_t buf;\\n\"\n              \"    if ((buf.ptr = malloc(10)) == NULL)\\n\"\n              \"        return;\\n\"\n              \"    free(buf.ptr);\\n\"\n              \"    if ((buf.ptr = malloc(10)) == NULL)\\n\"\n              \"        return;\\n\"\n              \"    free(buf.ptr);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree14() { // #9708\n        check(\"using namespace std;\\n\"\n              \" \\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    int *i = new int;\\n\"\n              \"    unique_ptr<int> x(i);\\n\"\n              \"    delete i;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:6:5] -> [test.cpp:7:12]: (error) Memory pointed to by 'i' is freed twice. [doubleFree]\\n\", errout_str());\n\n        check(\"using namespace std;\\n\"\n              \" \\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    int *i = new int;\\n\"\n              \"    unique_ptr<int> x(i);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree15() { // #11966\n        check(\"void f(FILE* fp) {\\n\"\n              \"    static_cast<void>(fclose(fp));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree16() { // #12236\n        check(\"void f() {\\n\"\n              \"    FILE* f = fopen(\\\"abc\\\", \\\"r\\\");\\n\"\n              \"    decltype(fclose(f)) y;\\n\"\n              \"    y = fclose(f);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE *fp = fopen(\\\"abc\\\", \\\"r\\\");\\n\"\n              \"    if (({\\n\"\n              \"        __typeof__(fclose(fp)) r;\\n\"\n              \"        r = (fclose(fp));\\n\"\n              \"        r;\\n\"\n              \"    })) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree17() {\n        check(\"void f() {\\n\"\n              \"    int *a = nullptr;\\n\"\n              \"    int *b = nullptr;\\n\"\n              \"    int *c = new int;\\n\"\n              \"    delete (a, c);\\n\"\n              \"    delete (b, c);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:5:5] -> [test.cpp:6:16]: (error) Memory pointed to by 'c' is freed twice. [doubleFree]\\n\", errout_str());\n    }\n\n    void doublefree18() {\n        check(\"typedef struct {\\n\" // #13918\n              \"    FILE * fp;\\n\"\n              \"} S;\\n\"\n              \"void f(S* s, FILE* x) {\\n\"\n              \"    if (fclose(s->fp)) {}\\n\"\n              \"    s->fp = x;\\n\"\n              \"    if (fclose(s->fp)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree19() {\n        check(\"struct S {\\n\"\n              \"  void *x;\\n\"\n              \"};\\n\"\n              \"void f(struct S *p)\\n\"\n              \"{\\n\"\n              \"  free(p->x);\\n\"\n              \"  free(p->x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:6:3] -> [test.c:7:3]: (error) Memory pointed to by 'x' is freed twice. [doubleFree]\\n\", errout_str());\n    }\n\n    void exit1() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    exit(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void exit2() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    fatal_error();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:18]: (information) --check-library: Function fatal_error() should have <noreturn> configuration [checkLibraryNoReturn]\\n\",\n                      errout_str());\n    }\n\n    void exit3() {\n        check(\"void f() {\\n\"\n              \"  char *p = malloc(100);\\n\"\n              \"  if (x) {\\n\"\n              \"    free(p);\\n\"\n              \"    ::exit(0);\\n\"\n              \"  }\"\n              \"  free(p);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char *p = malloc(100);\\n\"\n              \"  if (x) {\\n\"\n              \"    free(p);\\n\"\n              \"    std::exit(0);\\n\"\n              \"  }\"\n              \"  free(p);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void exit4() {\n        check(\"void __attribute__((__noreturn__)) (*func_notret)(void);\\n\"\n              \"int main(int argc) {\\n\"\n              \"    void* ptr = malloc(1000);\\n\"\n              \"    if (argc == 1) {\\n\"\n              \"        free(ptr);\\n\"\n              \"        func_notret();\\n\"\n              \"    }\\n\"\n              \"    free(ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void functioncall1() {\n        check(\"void f(struct S *p) {\\n\"\n              \"  p->x = malloc(10);\\n\"\n              \"  free(p->x);\\n\"\n              \"  p->x = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(s_t s) {\\n\" // #11061\n              \"    s->p = (char*)malloc(10);\\n\"\n              \"    free((void*)s->p);\\n\"\n              \"    s->p = NULL;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        const Settings s = settingsBuilder().library(\"std.cfg\").build();\n        check(\"struct S {};\\n\"\n              \"void f(int i, std::vector<std::unique_ptr<S>> &v) {\\n\"\n              \"    if (i < 1) {\\n\"\n              \"        auto s = new S;\\n\"\n              \"        v.push_back(std::unique_ptr<S>(s));\\n\"\n              \"    }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n\n        check(\"void g(size_t len) {\\n\" // #12365\n              \"    char* b = new char[len + 1]{};\\n\"\n              \"    std::string str = std::string(b);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true, $.s = &s));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) Memory leak: b [memleak]\\n\", errout_str());\n    }\n\n    void goto1() {\n        check(\"static void f() {\\n\"\n              \"    int err = -ENOMEM;\\n\"\n              \"    char *reg = malloc(100);\\n\"\n              \"    if (err) {\\n\"\n              \"        free(reg);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void goto2() { // #4231\n        check(\"static char * f() {\\n\"\n              \"x:\\n\"\n              \"    char *p = malloc(100);\\n\"\n              \"    if (err) {\\n\"\n              \"        free(p);\\n\"\n              \"        goto x;\\n\"\n              \"    }\\n\"\n              \"    return p;\\n\"  // no error since there is a goto\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void goto3() { // #11431\n        check(\"void f() {\\n\"\n              \"    int* p = (int*)malloc(2);\\n\"\n              \"    if (!p) {\\n\"\n              \"        p = (int*)malloc(1);\\n\"\n              \"        if (!p)\\n\"\n              \"            goto err;\\n\"\n              \"    }\\n\"\n              \"    free(p);\\n\"\n              \"err:\\n\"\n              \"    (void)0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse1() {\n        check(\"int f() {\\n\"\n              \"    char *p = NULL;\\n\"\n              \"    if (x) { p = malloc(10); }\\n\"\n              \"    else { return 0; }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse2() {\n        check(\"int f() {\\n\"\n              \"    char *p = NULL;\\n\"\n              \"    if (x) { p = malloc(10); }\\n\"\n              \"    else { return 0; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:5:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void ifelse3() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    if (!p) { return; }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char * f(size_t size) {\"\n              \"    void *p = malloc(1);\"\n              \"    if (!p && size != 0)\"\n              \"        return NULL;\"\n              \"    return p;\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    if (p) { } else { return; }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3866 - UNLIKELY\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    if (UNLIKELY(!p)) { return; }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse4() {\n        check(\"void f(int x) {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x) { p = malloc(10); }\\n\"\n              \"    if (x) { free(p); }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    char *p;\\n\"\n              \"    if (x) { p = malloc(10); }\\n\"\n              \"    if (!x) { return; }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse5() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    if (!p && x) { p = malloc(10); }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse6() { // #3370\n        check(\"void f(int x) {\\n\"\n              \"    int *a = malloc(20);\\n\"\n              \"    if (x)\\n\"\n              \"        free(a);\\n\"\n              \"    else\\n\"\n              \"        a = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:6:9]: (error) Memory leak: a [memleak]\\n\", errout_str());\n    }\n\n    void ifelse7() { // #5576\n        check(\"void f() {\\n\"\n              \"    int x = malloc(20);\\n\"\n              \"    if (x < 0)\\n\"  // assume negative value indicates its unallocated\n              \"        return;\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse8() { // #5747\n        check(\"int f() {\\n\"\n              \"    int fd = socket(AF_INET, SOCK_PACKET, 0 );\\n\"\n              \"    if (fd == -1)\\n\"\n              \"        return -1;\\n\"\n              \"    return fd;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int fd = socket(AF_INET, SOCK_PACKET, 0 );\\n\"\n              \"    if (fd != -1)\\n\"\n              \"        return fd;\\n\"\n              \"    return -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse9() { // #5273\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(100);\\n\"\n              \"    if (dostuff(p==NULL,0))\\n\"\n              \"        return;\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse10() { // #8794\n        check(\"void f() {\\n\"\n              \"    void *x = malloc(1U);\\n\"\n              \"    if (!(x != NULL))\\n\"\n              \"        return;\\n\"\n              \"    free(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse11() { // #8365\n        check(\"void f() {\\n\"\n              \"    void *p;\\n\"\n              \"    if (NULL == (p = malloc(4)))\\n\"\n              \"        return;\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse12() { // #8340\n        check(\"void f(char **p) {\\n\"\n              \"    if ((*p = malloc(4)) == NULL)\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse13() { // #8392\n        check(\"int f(int fd, const char *mode) {\\n\"\n              \"    char *path;\\n\"\n              \"    if (fd == -1 || (path = (char *)malloc(10)) == NULL)\\n\"\n              \"        return 1;\\n\"\n              \"    free(path);\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int fd, const char *mode) {\\n\"\n              \"    char *path;\\n\"\n              \"    if ((path = (char *)malloc(10)) == NULL || fd == -1)\\n\"\n              \"        return 1;\\n\" // <- memory leak\n              \"    free(path);\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4] memory leak\", \"\", errout_str());\n    }\n\n    void ifelse14() { // #9130\n        check(\"char* f() {\\n\"\n              \"    char* buf = malloc(10);\\n\"\n              \"    if (buf == (char*)NULL)\\n\"\n              \"        return NULL;\\n\"\n              \"    return buf;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse15() { // #9206\n        check(\"struct SSS { int a; };\\n\"\n              \"SSS* global_ptr;\\n\"\n              \"void test_alloc() {\\n\"\n              \"   if ( global_ptr = new SSS()) {}\\n\"\n              \"   return;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"FILE* hFile;\\n\"\n              \"int openFile( void ) {\\n\"\n              \"   if ((hFile = fopen(\\\"1.txt\\\", \\\"wb\\\" )) == NULL) return 0;\\n\"\n              \"   return 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse16() { // #9635\n        check(\"void f(void) {\\n\"\n              \"    char *p;\\n\"\n              \"    if(p = malloc(4), p == NULL)\\n\"\n              \"        return;\\n\"\n              \"    free(p);\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"    char *p, q;\\n\"\n              \"    if(p = malloc(4), q = 1, p == NULL)\\n\"\n              \"        return;\\n\"\n              \"    free(p);\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse17() {\n        check(\"int *f() {\\n\"\n              \"    int *p = realloc(nullptr, 10);\\n\"\n              \"    if (!p)\\n\"\n              \"        return NULL;\\n\"\n              \"    return p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int *f() {\\n\"\n              \"    int *p = realloc(nullptr, 10);\\n\"\n              \"    if (!!(!p))\\n\"\n              \"        return NULL;\\n\"\n              \"    return p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse18() {\n        check(\"void f() {\\n\"\n              \"    void * p = malloc(10);\\n\"\n              \"    void * q = realloc(p, 20);\\n\"\n              \"    if (q == 0)\\n\"\n              \"        return;\\n\"\n              \"    free(q);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:5:9]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    void * p = malloc(10);\\n\"\n              \"    void * q = realloc(p, 20);\\n\"\n              \"    if (q != 0) {\\n\"\n              \"        free(q);\\n\"\n              \"        return;\\n\"\n              \"    } else\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:8:9]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void ifelse19() {\n        check(\"void f() {\\n\"\n              \"    static char * a;\\n\"\n              \"    char * b = realloc(a, 10);\\n\"\n              \"    if (!b)\\n\"\n              \"        return;\\n\"\n              \"    a = b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse20() {\n        check(\"void f() {\\n\"\n              \"    if (x > 0)\\n\"\n              \"        void * p1 = malloc(5);\\n\"\n              \"    else\\n\"\n              \"        void * p2 = malloc(2);\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:0]: (error) Memory leak: p1 [memleak]\\n\"\n                      \"[test.c:5:0]: (error) Memory leak: p2 [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (x > 0)\\n\"\n              \"        void * p1 = malloc(5);\\n\"\n              \"    else\\n\"\n              \"        void * p2 = malloc(2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:0]: (error) Memory leak: p1 [memleak]\\n\"\n                      \"[test.c:5:0]: (error) Memory leak: p2 [memleak]\\n\", errout_str());\n    }\n\n    void ifelse21() {\n        check(\"void f() {\\n\"\n              \"    if (y) {\\n\"\n              \"        void * p;\\n\"\n              \"        if (x > 0)\\n\"\n              \"            p = malloc(5);\\n\"\n              \"    }\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:6:5]: (error) Memory leak: p [memleak]\\n\",  errout_str());\n    }\n\n    void ifelse22() { // #10187\n        check(\"int f(const char * pathname, int flags) {\\n\"\n              \"    int fd = socket(pathname, flags);\\n\"\n              \"    if (fd >= 0)\\n\"\n              \"        return fd;\\n\"\n              \"    return -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const char * pathname, int flags) {\\n\"\n              \"    int fd = socket(pathname, flags);\\n\"\n              \"    if (fd <= -1)\\n\"\n              \"        return -1;\\n\"\n              \"    return fd;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse23() { // #5473\n        check(\"void f() {\\n\"\n              \"    if (FILE* fp = fopen(\\\"x\\\", \\\"r\\\")) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:2:38]: (error) Resource leak: fp [resourceLeak]\\n\", errout_str());\n    }\n\n    void ifelse24() { // #1733\n        const Settings s = settingsBuilder().library(\"std.cfg\").library(\"posix.cfg\").build();\n\n        check(\"void f() {\\n\"\n              \"    char* temp = strdup(\\\"temp.txt\\\");\\n\"\n              \"    FILE* fp;\\n\"\n              \"    if (NULL == x || NULL == (fp = fopen(temp, \\\"rt\\\")))\\n\"\n              \"        return;\\n\"\n              \"}\\n\", s);\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (error) Memory leak: temp [memleak]\\n\"\n                      \"[test.cpp:6:1]: (error) Memory leak: temp [memleak]\\n\"\n                      \"[test.cpp:6:1]: (error) Resource leak: fp [resourceLeak]\\n\",\n                      errout_str());\n\n        check(\"FILE* f() {\\n\"\n              \"    char* temp = strdup(\\\"temp.txt\\\");\\n\"\n              \"    FILE* fp = fopen(temp, \\\"rt\\\");\\n\"\n              \"    return fp;\\n\"\n              \"}\\n\", s);\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Memory leak: temp [memleak]\\n\", errout_str());\n\n        check(\"FILE* f() {\\n\"\n              \"    char* temp = strdup(\\\"temp.txt\\\");\\n\"\n              \"    FILE* fp = NULL;\\n\"\n              \"    fopen_s(&fp, temp, \\\"rt\\\");\\n\"\n              \"    return fp;\\n\"\n              \"}\\n\", s);\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (error) Memory leak: temp [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char* temp = strdup(\\\"temp.txt\\\");\\n\"\n              \"    FILE* fp = fopen(\\\"a.txt\\\", \\\"rb\\\");\\n\"\n              \"    if (fp)\\n\"\n              \"        freopen(temp, \\\"rt\\\", fp);\\n\"\n              \"}\\n\", s);\n        ASSERT_EQUALS(\"[test.cpp:6:1]: (error) Memory leak: temp [memleak]\\n\"\n                      \"[test.cpp:6:1]: (error) Resource leak: fp [resourceLeak]\\n\",\n                      errout_str());\n\n        check(\"FILE* f() {\\n\"\n              \"    char* temp = strdup(\\\"temp.txt\\\");\\n\"\n              \"    return fopen(temp, \\\"rt\\\");\\n\"\n              \"}\\n\", s);\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Memory leak: temp\\n\", \"\", errout_str());\n    }\n\n    void ifelse25() { // #9966\n        check(\"void f() {\\n\"\n              \"    void *p, *p2;\\n\"\n              \"    if((p2 = p = malloc(10)) == NULL)\\n\"\n              \"        return;\\n\"\n              \"    (void)p;\\n\"\n              \"    free(p2);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse26() { // don't crash\n        check(\"union tidi {\\n\"\n              \"    long long ti;\\n\"\n              \"    unsigned int di[2];\\n\"\n              \"};\\n\"\n              \"void f(long long val) {\\n\"\n              \"    if (val == ({ union tidi d = {.di = {0x0, 0x80000000}}; d.ti; })) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse27() {\n        check(\"struct key { void* p; };\\n\"\n              \"int f(struct key** handle) {\\n\"\n              \"    struct key* key;\\n\"\n              \"    if (!(key = calloc(1, sizeof(*key))))\\n\"\n              \"        return 0;\\n\"\n              \"    if (!(key->p = malloc(4))) {\\n\"\n              \"        free(key);\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"    *handle = key;\\n\"\n              \"    return 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse28() { // #11038\n        check(\"char * f(void) {\\n\"\n              \"   char *buf = (char*)malloc(42*sizeof(char));\\n\"\n              \"   char *temp;\\n\"\n              \"   if ((temp = (char*)realloc(buf, 16)) != NULL)\\n\"\n              \"   {  buf = temp;  }\\n\"\n              \"   return buf;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ifelse29() { // #13296\n        check(\"struct S {\\n\"\n              \"    typedef int (S::* func_t)(int) const;\\n\"\n              \"    void f(func_t pfn);\\n\"\n              \"    int g(int) const;\\n\"\n              \"};\\n\"\n              \"void S::f(func_t pfn) {\\n\"\n              \"    if (pfn == (func_t)&S::g) {}\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n    }\n\n    void switch1() {\n        check(\"void f() {\\n\"\n              \"    char *p = 0;\\n\"\n              \"    switch (x) {\\n\"\n              \"    case 123: p = malloc(100); break;\\n\"\n              \"    default: return;\\n\"\n              \"    }\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void loop1() {\n        // test the handling of { }\n        check(\"void f() {\\n\"\n              \"    char *p;\\n\"\n              \"    for (i=0;i<5;i++) { }\\n\"\n              \"    if (x) { free(p) }\\n\"\n              \"    else { a = p; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void loop2() {\n        check(\"void f() {\\n\" // #11786\n              \"    int* p = (int*)malloc(sizeof(int));\\n\"\n              \"    if (1) {\\n\"\n              \"        while (0) {}\\n\"\n              \"        free(p);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(node **p) {\\n\"\n              \"    node* n = *p;\\n\"\n              \"    if (n->left == NULL) {\\n\"\n              \"        *p = n->right;\\n\"\n              \"        free(n);\\n\"\n              \"    }\\n\"\n              \"    else if (n->right == NULL) {\\n\"\n              \"        *p = n->left;\\n\"\n              \"        free(n);\\n\"\n              \"    }\\n\"\n              \"    else {\\n\"\n              \"        for (int i = 0; i < 4; ++i) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void mismatchAllocDealloc() {\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    free(f);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:2:12] -> [test.c:3:5]: (error) Mismatching allocation and deallocation: f [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    free((void*)f);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:2:12] -> [test.c:3:5]: (error) Mismatching allocation and deallocation: f [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *cPtr = new char[100];\\n\"\n              \"    delete[] cPtr;\\n\"\n              \"    cPtr = new char[100]('x');\\n\"\n              \"    delete[] cPtr;\\n\"\n              \"    cPtr = new char[100];\\n\"\n              \"    delete cPtr;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:6:12] -> [test.cpp:7:12]: (error) Mismatching allocation and deallocation: cPtr [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *cPtr = new char[100];\\n\"\n              \"    free(cPtr);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:18] -> [test.cpp:3:5]: (error) Mismatching allocation and deallocation: cPtr [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *cPtr = new (buf) char[100];\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int[1];\\n\"\n              \"    std::unique_ptr<int> x(i);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:15] -> [test.cpp:3:28]: (error) Mismatching allocation and deallocation: i [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::unique_ptr<int[]> x(i);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:15] -> [test.cpp:3:30]: (error) Mismatching allocation and deallocation: i [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   void* a = malloc(1);\\n\"\n              \"   void* b = freopen(f, p, a);\\n\"\n              \"   free(b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:2:14] -> [test.c:3:14]: (error) Mismatching allocation and deallocation: a [mismatchAllocDealloc]\\n\"\n                      \"[test.c:3:14] -> [test.c:4:4]: (error) Mismatching allocation and deallocation: b [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   void* a;\\n\"\n              \"   void* b = realloc(a, 10);\\n\"\n              \"   free(b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int * i = new int;\\n\"\n              \"   int * j = realloc(i, 2 * sizeof(int));\\n\"\n              \"   delete[] j;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:14] -> [test.cpp:3:14]: (error) Mismatching allocation and deallocation: i [mismatchAllocDealloc]\\n\"\n                      \"[test.cpp:3:14] -> [test.cpp:4:13]: (error) Mismatching allocation and deallocation: j [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"static void deleter(int* p) { free(p); }\\n\" // #11392\n              \"void f() {\\n\"\n              \"    if (int* p = static_cast<int*>(malloc(4))) {\\n\"\n              \"        std::unique_ptr<int, decltype(&deleter)> guard(p, &deleter);\\n\"\n              \"    }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (int* p = static_cast<int*>(malloc(4))) {\\n\"\n              \"        std::unique_ptr<int, decltype(&deleter)> guard(p, &deleter);\\n\"\n              \"    }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int* a = new int[i] {};\\n\"\n              \"    delete[] a;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void smartPointerDeleter() {\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::unique_ptr<FILE> fp{f};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:3:30]: (error) Mismatching allocation and deallocation: f [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::unique_ptr<FILE, decltype(&fclose)> fp{f, &fclose};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::shared_ptr<FILE> fp{f, &fclose};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct deleter { void operator()(FILE* f) { fclose(f); }};\\n\"\n              \"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::unique_ptr<FILE, deleter> fp{f};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int * create();\\n\"\n              \"void destroy(int * x);\\n\"\n              \"void f() {\\n\"\n              \"    int x * = create()\\n\"\n              \"    std::unique_ptr<int, decltype(&destroy)> xp{x, &destroy()};\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int * create();\\n\"\n              \"void destroy(int * x);\\n\"\n              \"void f() {\\n\"\n              \"    int x * = create()\\n\"\n              \"    std::unique_ptr<int, decltype(&destroy)> xp(x, &destroy());\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::shared_ptr<FILE> fp{f, [](FILE* x) { fclose(x); }};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::shared_ptr<FILE> fp{f, +[](FILE* x) { fclose(x); }};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::shared_ptr<FILE> fp{f, [](FILE* x) { free(f); }};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:3:30]: (error) Mismatching allocation and deallocation: f [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE*f=fopen(fname,a);\\n\"\n              \"    std::shared_ptr<FILE> fp{f, [](FILE* x) {}};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:3:30]: (error) Mismatching allocation and deallocation: f [mismatchAllocDealloc]\\n\", errout_str());\n\n        check(\"class C;\\n\"\n              \"void f() {\\n\"\n              \"  C* c = new C{};\\n\"\n              \"  std::shared_ptr<C> a{c, [](C*) {}};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C;\\n\"\n              \"void f() {\\n\"\n              \"  C* c = new C{};\\n\"\n              \"  std::shared_ptr<C> a{c, [](C* x) { delete x; }};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct DirDeleter {\\n\" // #12544\n              \"    void operator()(DIR* d) { ::closedir(d); }\\n\"\n              \"};\\n\"\n              \"void openDir(DIR* dir) {\\n\"\n              \"    std::shared_ptr<DIR> dp(dir, DirDeleter());\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:2:44]: (information) --check-library: Function closedir() should have <noreturn> configuration [checkLibraryNoReturn]\\n\", errout_str()); // don't crash\n    }\n    void smartPointerRelease() {\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::unique_ptr<int> x(i);\\n\"\n              \"    x.release();\\n\"\n              \"    delete i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * i = new int;\\n\"\n              \"    std::unique_ptr<int> x(i);\\n\"\n              \"    x.release();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:5:1]: (error) Memory leak: i [memleak]\\n\", errout_str());\n    }\n\n    void return1() {\n        check(\"int f() {\\n\"\n              \"    char *p = malloc(100);\\n\"\n              \"    return 123;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:5]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void return2() {\n        check(\"char *f() {\\n\"\n              \"    char *p = malloc(100);\\n\"\n              \"    return p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return3() {\n        check(\"struct dev * f() {\\n\"\n              \"    struct ABC *abc = malloc(100);\\n\"\n              \"    return &abc->dev;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return4() { // ticket #3862\n        // avoid false positives\n        check(\"void f(char *p, int x) {\\n\"\n              \"    if (x==12) {\\n\"\n              \"        free(p);\\n\"\n              \"        throw 1;\\n\"\n              \"    }\\n\"\n              \"    free(p);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *p, int x) {\\n\"\n              \"    if (x==12) {\\n\"\n              \"        delete p;\\n\"\n              \"        throw 1;\\n\"\n              \"    }\\n\"\n              \"    delete p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *p, int x) {\\n\"\n              \"    if (x==12) {\\n\"\n              \"        delete [] p;\\n\"\n              \"        throw 1;\\n\"\n              \"    }\\n\"\n              \"    delete [] p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return5() { // ticket #6397 - conditional allocation/deallocation and conditional return\n        // avoid false positives\n        check(\"void f(int *p, int x) {\\n\"\n              \"    if (x != 0) {\\n\"\n              \"        free(p);\\n\"\n              \"    }\\n\"\n              \"    if (x != 0) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return6() { // #8282\n        check(\"std::pair<char*, char*> f(size_t n) {\\n\"\n              \"   char* p = (char* )malloc(n);\\n\"\n              \"   return {p, p};\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return7() { // #9343\n        check(\"uint8_t *f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (uint8_t *)x;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"uint8_t f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (uint8_t)x;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Memory leak: x [memleak]\\n\", errout_str());\n\n        check(\"void** f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (void**)x;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (long long)x;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (void*)(short)x;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Memory leak: x [memleak]\\n\", errout_str());\n\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (mytype)x;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* f() {\\n\" // Do not crash\n              \"    void *x = malloc(1);\\n\"\n              \"    return (mytype)y;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Memory leak: x [memleak]\\n\", errout_str());\n    }\n\n    void return8() {\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (x);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return ((x));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return ((((x))));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char* f() {\\n\"\n              \"    void *x = malloc(1);\\n\"\n              \"    return (char*)(x);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return9() {\n        check(\"void* f() {\\n\"\n              \"    void *x = malloc (sizeof (struct alloc));\\n\"\n              \"    return x + sizeof (struct alloc);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void return10() {\n        check(\"char f() {\\n\" // #11758\n              \"    char* p = (char*)malloc(1);\\n\"\n              \"    p[0] = 'x';\\n\"\n              \"    return p[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:4:5]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"struct S { int f(); };\\n\" // #11746\n              \"int g() {\\n\"\n              \"    S* s = new S;\\n\"\n              \"    delete s;\\n\"\n              \"    return s->f();\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:5:5]: (error) Returning/dereferencing 's' after it is deallocated / released [deallocret]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int* p = new int(3);\\n\"\n              \"    delete p;\\n\"\n              \"    return *p;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:4:5]: (error) Returning/dereferencing 'p' after it is deallocated / released [deallocret]\\n\", errout_str());\n    }\n\n    void return11() { // #13098\n        check(\"char malloc_memleak(void) {\\n\"\n              \"    bool flag = false;\\n\"\n              \"    char *ptr = malloc(10);\\n\"\n              \"    if (flag) {\\n\"\n              \"        free(ptr);\\n\"\n              \"    }\\n\"\n              \"    return 'a';\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Memory leak: ptr [memleak]\\n\", errout_str());\n\n        check(\"char malloc_memleak(void) {\\n\"\n              \"    bool flag = false;\\n\"\n              \"    char *ptr = malloc(10);\\n\"\n              \"    if (flag) {\\n\"\n              \"        free(ptr);\\n\"\n              \"    }\\n\"\n              \"    return 'a';\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:7:5]: (error) Memory leak: ptr [memleak]\\n\", errout_str());\n    }\n\n    void return12() { // #12238\n        CheckOptions options;\n        options.cpp = true;\n        check(\"void f(size_t size) {\\n\"\n              \"    void* buffer = malloc(size);\\n\"\n              \"    std::vector<void*> v{ buffer };\\n\"\n              \"    x->g(v);\\n\"\n              \"}\\n\", options);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void test1() {\n        check(\"void f(double*&p) {\\n\" // 3809\n              \"    p = malloc(0x100);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int*& p) {\\n\" // #4400\n              \"    p = (int*)malloc(4);\\n\"\n              \"    p = (int*)malloc(4);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* p = (int*)malloc(4);\\n\"\n              \"    int*& r = p;\\n\"\n              \"    r = (int*)malloc(4);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (error) Memory leak: p\\n\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int* p = (int*)malloc(4);\\n\"\n              \"    int*& r = p;\\n\"\n              \"    free(r);\\n\"\n              \"    p = (int*)malloc(4);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:6:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void test2() { // 3899\n        check(\"struct Fred {\\n\"\n              \"    char *p;\\n\"\n              \"    void f1() { free(p); }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void test3() { // 3954 - reference pointer\n        check(\"void f() {\\n\"\n              \"    char *&p = x();\\n\"\n              \"    p = malloc(10);\\n\"\n              \"};\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void test4() { // 5923 - static pointer\n        check(\"void f() {\\n\"\n              \"    static char *p;\\n\"\n              \"    if (!p) p = malloc(10);\\n\"\n              \"    if (x) { free(p); p = 0; }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void test5() { // unknown type\n        check(\"void f() { Fred *p = malloc(10); }\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:1:34]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() { Fred *p = malloc(10); }\");\n        ASSERT_EQUALS(\"[test.c:1:34]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() { Fred *p = new Fred; }\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { Fred fred = malloc(10); }\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void throw1() { // 3987 - Execution reach a 'throw'\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    throw 123;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *p;\\n\"\n              \"    try {\\n\"\n              \"        p = malloc(10);\\n\"\n              \"        throw 123;\\n\"\n              \"    } catch (...) { }\\n\"\n              \"    free(p);\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void throw2() { // do not miss ::NS::Except()\n        check(\"namespace NS {\\n\"\n              \"    class Except {\\n\"\n              \"    };\\n\"\n              \"}\\n\"\n              \"void foo(int i)\\n\"\n              \"{\\n\"\n              \"    int *pi = new int;\\n\"\n              \"    if (i == 42) {\\n\"\n              \"        delete pi;\\n\"\n              \"        throw ::NS::Except();\\n\"\n              \"    }\\n\"\n              \"    delete pi;\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void configuration1() {\n        // Possible leak => configuration is required for complete analysis\n        // The user should be able to \"white list\" and \"black list\" functions.\n\n        // possible leak. If the function 'x' deallocates the pointer or\n        // takes the address, there is no leak.\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    x(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:9]: (information) --check-library: Function x() should have <noreturn> configuration [checkLibraryNoReturn]\\n\"\n                      \"[test.c:4:1]: (information) --check-library: Function x() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\",\n                      errout_str());\n\n        check(\"void cb();\\n\" // #11190, #11523\n              \"void f() {\\n\"\n              \"    cb();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void configuration2() {\n        // possible leak. If the function 'x' deallocates the pointer or\n        // takes the address, there is no leak.\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    x(&p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:10]: (information) --check-library: Function x() should have <noreturn> configuration [checkLibraryNoReturn]\\n\"\n                      \"[test.c:4:1]: (information) --check-library: Function x() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\",\n                      errout_str());\n    }\n\n    void configuration3() {\n        {\n            const char code[] = \"void f() {\\n\"\n                                \"    char *p = malloc(10);\\n\"\n                                \"    if (set_data(p)) { }\\n\"\n                                \"}\";\n            check(code);\n            ASSERT_EQUALS(\"[test.c:4:1]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n            check(code, dinit(CheckOptions, $.cpp = true));\n            ASSERT_EQUALS(\"[test.cpp:4:1]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f() {\\n\"\n                                \"    char *p = malloc(10);\\n\"\n                                \"    if (set_data(p)) { return; }\\n\"\n                                \"}\";\n            check(code);\n            ASSERT_EQUALS(\"[test.c:3:24]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\"\n                          \"[test.c:4:1]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\"\n                          , errout_str());\n            check(code, dinit(CheckOptions, $.cpp = true));\n            ASSERT_EQUALS(\"[test.cpp:3:24]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\"\n                          \"[test.cpp:4:1]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\"\n                          , errout_str());\n        }\n    }\n\n    void configuration4() {\n        check(\"void f() {\\n\"\n              \"    char *p = malloc(10);\\n\"\n              \"    int ret = set_data(p);\\n\"\n              \"    return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:4:5]: (information) --check-library: Function set_data() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n    }\n\n    void configuration5() {\n        check(\"void f() {\\n\"\n              \"    int(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static_assert(1 == sizeof(char), \\\"test\\\");\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace pal {\\n\" // #11237\n              \"    struct AutoTimer {};\\n\"\n              \"}\\n\"\n              \"int main() {\\n\"\n              \"    pal::AutoTimer();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AutoTimer {};\\n\"\n              \"int main() {\\n\"\n              \"    AutoTimer();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #8666\n              \"    asm(\\\"assembler code\\\");\\n\"\n              \"    asm volatile(\\\"assembler code\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #11239\n              \"    asm goto(\\\"assembler code\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    FILE* p = fopen(\\\"abc.txt\\\", \\\"r\\\");\\n\"\n              \"    if (fclose(p) != 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S;\\n\"\n              \"void f(int a, int b, S*& p) {\\n\"\n              \"    if (a == -1) {\\n\"\n              \"        FILE* file = fopen(\\\"abc.txt\\\", \\\"r\\\");\\n\"\n              \"    }\\n\"\n              \"    if (b) {\\n\"\n              \"        void* buf = malloc(10);\\n\"\n              \"        p = reinterpret_cast<S*>(buf);\\n\"\n              \"    }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (error) Resource leak: file [resourceLeak]\\n\", errout_str());\n    }\n\n    void configuration6() {\n        check(\"void f() {}\\n\" // #11198\n              \"void g() {\\n\"\n              \"    f();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::function<void()> cb) {\\n\" // #11189\n              \"    cb();\\n\"\n              \"}\\n\"\n              \"void g(void (*cb)()) {\\n\"\n              \"    cb();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ptrptr() {\n        check(\"void f() {\\n\"\n              \"    char **p = malloc(10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.c:3:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n    }\n\n    void nestedAllocation() {\n        check(\"void QueueDSMCCPacket(unsigned char *data, int length) {\\n\"\n              \"    unsigned char *dataCopy = malloc(length * sizeof(unsigned char));\\n\"\n              \"    m_dsmccQueue.enqueue(new DSMCCPacket(dataCopy));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (information) --check-library: Function DSMCCPacket() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n\n        check(\"void QueueDSMCCPacket(unsigned char *data, int length) {\\n\"\n              \"    unsigned char *dataCopy = malloc(length * sizeof(unsigned char));\\n\"\n              \"    m_dsmccQueue.enqueue(new DSMCCPacket(somethingunrelated));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) Memory leak: dataCopy [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char *buf = new char[1000];\\n\"\n              \"  clist.push_back(new (std::nothrow) C(buf));\\n\"\n              \"}\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (information) --check-library: Function C() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n    }\n\n    void testKeywords() {\n        check(\"int main(int argc, char **argv) {\\n\"\n              \"  double *new = malloc(1*sizeof(double));\\n\"\n              \"  free(new);\\n\"\n              \"  return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void inlineFunction() {\n        check(\"int test() {\\n\"\n              \"  char *c;\\n\"\n              \"  int ret() {\\n\"\n              \"        free(c);\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"    c = malloc(128);\\n\"\n              \"    return ret();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #8262\n    void smartPtrInContainer() {\n        check(\"std::list< std::shared_ptr<int> > mList;\\n\"\n              \"void test(){\\n\"\n              \"  int *pt = new int(1);\\n\"\n              \"  mList.push_back(std::shared_ptr<int>(pt));\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.cpp = true)\n              );\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void functionCallCastConfig() { // #9652\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def format=\\\"2\\\">\\n\"\n                                   \"  <function name=\\\"free_func\\\">\\n\"\n                                   \"    <noreturn>false</noreturn>\\n\"\n                                   \"    <arg nr=\\\"1\\\">\\n\"\n                                   \"      <not-uninit/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"    <arg nr=\\\"2\\\">\\n\"\n                                   \"      <not-uninit/>\\n\"\n                                   \"    </arg>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        const Settings settingsFunctionCall = settingsBuilder(settings).libraryxml(xmldata).build();\n\n        check(\"void test_func()\\n\"\n              \"{\\n\"\n              \"    char * buf = malloc(4);\\n\"\n              \"    free_func((void *)(1), buf);\\n\"\n              \"}\", settingsFunctionCall);\n        ASSERT_EQUALS(\"[test.cpp:5:1]: (information) --check-library: Function free_func() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n\n        check(\"void g(void*);\\n\"\n              \"void h(int, void*);\\n\"\n              \"void f1() {\\n\"\n              \"    int* p = new int;\\n\"\n              \"    g(static_cast<void*>(p));\\n\"\n              \"}\\n\"\n              \"void f2() {\\n\"\n              \"    int* p = new int;\\n\"\n              \"    h(1, static_cast<void*>(p));\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:6:1]: (information) --check-library: Function g() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\"\n                      \"[test.cpp:10:1]: (information) --check-library: Function h() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\",\n                      errout_str());\n    }\n\n    void functionCallLeakIgnoreConfig() { // #7923\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def format=\\\"2\\\">\\n\"\n                                   \"  <function name=\\\"SomeClass::someMethod\\\">\\n\"\n                                   \"    <leak-ignore/>\\n\"\n                                   \"    <noreturn>false</noreturn>\\n\"\n                                   \"    <arg nr=\\\"1\\\" direction=\\\"in\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\\n\";\n        const Settings settingsLeakIgnore = settingsBuilder().libraryxml(xmldata).build();\n        check(\"void f() {\\n\"\n              \"    double* a = new double[1024];\\n\"\n              \"    SomeClass::someMethod(a);\\n\"\n              \"}\\n\", settingsLeakIgnore);\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) Memory leak: a [memleak]\\n\", errout_str());\n\n        check(\"void bar(int* p) {\\n\"\n              \"    if (p)\\n\"\n              \"        free(p);\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    int* p = malloc(4);\\n\"\n              \"    bar(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int n) {\\n\"\n              \"    char* p = new char[n];\\n\"\n              \"    v.push_back(p);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = true));\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (information) --check-library: Function unknown::push_back() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestLeakAutoVar)\n\nclass TestLeakAutoVarRecursiveCountLimit : public TestFixture {\npublic:\n    TestLeakAutoVarRecursiveCountLimit() : TestFixture(\"TestLeakAutoVarRecursiveCountLimit\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"std.cfg\").checkLibrary().build();\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    void checkP_(const char* file, int line, const char code[], bool cpp = false) {\n        SimpleTokenizer2 tokenizer(settings, *this, code, cpp?\"test.cpp\":\"test.c\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check for leaks..\n        runChecks<CheckLeakAutoVar>(tokenizer, this);\n    }\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(recursiveCountLimit); // #5872 #6157 #9097\n    }\n\n    void recursiveCountLimit() { // #5872 #6157 #9097\n        ASSERT_THROW_INTERNAL_EQUALS(checkP(\"#define ONE     else if (0) { }\\n\"\n                                            \"#define TEN     ONE ONE ONE ONE ONE ONE ONE ONE ONE ONE\\n\"\n                                            \"#define HUN     TEN TEN TEN TEN TEN TEN TEN TEN TEN TEN\\n\"\n                                            \"#define THOU    HUN HUN HUN HUN HUN HUN HUN HUN HUN HUN\\n\"\n                                            \"void foo() {\\n\"\n                                            \"  if (0) { }\\n\"\n                                            \"  THOU THOU\\n\"\n                                            \"}\"), LIMIT, \"Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached.\");\n        ASSERT_NO_THROW(checkP(\"#define ONE     if (0) { }\\n\"\n                               \"#define TEN     ONE ONE ONE ONE ONE ONE ONE ONE ONE ONE\\n\"\n                               \"#define HUN     TEN TEN TEN TEN TEN TEN TEN TEN TEN TEN\\n\"\n                               \"#define THOU    HUN HUN HUN HUN HUN HUN HUN HUN HUN HUN\\n\"\n                               \"void foo() {\\n\"\n                               \"  if (0) { }\\n\"\n                               \"  THOU THOU\\n\"\n                               \"}\"));\n    }\n};\n\n#if !defined(__MINGW32__) && !defined(__CYGWIN__)\n// TODO: this crashes with a stack overflow for MinGW and error 2816 for Cygwinin the CI\nREGISTER_TEST(TestLeakAutoVarRecursiveCountLimit)\n#endif\n\nclass TestLeakAutoVarStrcpy : public TestFixture {\npublic:\n    TestLeakAutoVarStrcpy() : TestFixture(\"TestLeakAutoVarStrcpy\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"std.cfg\").checkLibrary().build();\n\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for leaks..\n        runChecks<CheckLeakAutoVar>(tokenizer, this);\n    }\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(returnedValue); // #9298\n        TEST_CASE(deallocuse2);\n        TEST_CASE(fclose_false_positive); // #9575\n        TEST_CASE(strcpy_false_negative);\n        TEST_CASE(doubleFree);\n        TEST_CASE(memleak_std_string);\n    }\n\n    void returnedValue() { // #9298\n        check(\"char *m;\\n\"\n              \"void strcpy_returnedvalue(const char* str)\\n\"\n              \"{\\n\"\n              \"    char* ptr = new char[strlen(str)+1];\\n\"\n              \"    m = strcpy(ptr, str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse2() {\n        check(\"void f(char *p) {\\n\"\n              \"    free(p);\\n\"\n              \"    strcpy(a, p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\", errout_str());\n\n        check(\"void f(char *p, const char *q) {\\n\" // #11665\n              \"    free(p);\\n\"\n              \"    strcpy(p, q);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Dereferencing 'p' after it is deallocated / released [deallocuse]\\n\",\n                      errout_str());\n\n        check(\"void f(char *p) {\\n\"   // #3041 - assigning pointer when it's used\n              \"    free(p);\\n\"\n              \"    strcpy(a, p=b());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void fclose_false_positive() { // #9575\n        check(\"int  f(FILE *fp) { return fclose(fp); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void strcpy_false_negative() { // #12289\n        check(\"void f() {\\n\"\n              \"    char* buf = new char[12];\\n\"\n              \"    strcpy(buf, \\\"123\\\");\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) Memory leak: buf [memleak]\\n\", errout_str());\n    }\n\n    void doubleFree() {\n        check(\"void f(char* p) {\\n\"\n              \"    free(p);\\n\"\n              \"    printf(\\\"%s\\\", p = strdup(\\\"abc\\\"));\\n\"\n              \"    free(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memleak_std_string() {\n        check(\"struct S {\\n\" // #12354\n              \"    std::string s;\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void f(S* p, bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        p = new S();\\n\"\n              \"    p->f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:1]: (error) Memory leak: p [memleak]\\n\", errout_str());\n\n        check(\"class B { std::string s; };\\n\" // #12062\n              \"class D : public B {};\\n\"\n              \"void g() {\\n\"\n              \"    auto d = new D();\\n\"\n              \"    if (d) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:1]: (error) Memory leak: d [memleak]\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestLeakAutoVarStrcpy)\n\n\nclass TestLeakAutoVarWindows : public TestFixture {\npublic:\n    TestLeakAutoVarWindows() : TestFixture(\"TestLeakAutoVarWindows\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"windows.cfg\").build();\n\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this, false);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for leaks..\n        runChecks<CheckLeakAutoVar>(tokenizer, this);\n    }\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(heapDoubleFree);\n    }\n\n    void heapDoubleFree() {\n        check(\"void f() {\\n\"\n              \"  HANDLE MyHeap = HeapCreate(0, 0, 0);\\n\"\n              \"  int *a = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  int *b = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  HeapFree(MyHeap, 0, a);\\n\"\n              \"  HeapFree(MyHeap, 0, b);\\n\"\n              \"  HeapDestroy(MyHeap);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int *a = HeapAlloc(GetProcessHeap(), 0, sizeof(int))\\n\"\n              \"  int *b = HeapAlloc(GetProcessHeap(), 0, sizeof(int));\\n\"\n              \"  HeapFree(GetProcessHeap(), 0, a);\\n\"\n              \"  HeapFree(GetProcessHeap(), 0, b);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  HANDLE MyHeap = HeapCreate(0, 0, 0);\\n\"\n              \"  int *a = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  int *b = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  HeapFree(MyHeap, 0, a);\\n\"\n              \"  HeapDestroy(MyHeap);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:7:1]: (error) Memory leak: b [memleak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  HANDLE MyHeap = HeapCreate(0, 0, 0);\\n\"\n              \"  int *a = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  int *b = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  HeapFree(MyHeap, 0, a);\\n\"\n              \"  HeapFree(MyHeap, 0, b);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:7:1]: (error) Resource leak: MyHeap [resourceLeak]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  HANDLE MyHeap = HeapCreate(0, 0, 0);\\n\"\n              \"  int *a = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  int *b = HeapAlloc(MyHeap, 0, sizeof(int));\\n\"\n              \"  HeapFree(MyHeap, 0, a);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.c:6:1]: (error) Resource leak: MyHeap [resourceLeak]\\n\"\n                      \"[test.c:6:1]: (error) Memory leak: b [memleak]\\n\",\n                      errout_str());\n    }\n};\n\nREGISTER_TEST(TestLeakAutoVarWindows)\n\nclass TestLeakAutoVarPosix : public TestFixture {\npublic:\n    TestLeakAutoVarPosix() : TestFixture(\"TestLeakAutoVarPosix\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"std.cfg\").library(\"posix.cfg\").build();\n\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for leaks..\n        runChecks<CheckLeakAutoVar>(tokenizer, this);\n    }\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(memleak_getline);\n        TEST_CASE(deallocuse_fdopen);\n        TEST_CASE(doublefree_fdopen); // #12781\n        TEST_CASE(memleak_open); // #13356\n    }\n\n    void memleak_getline() {\n        check(\"void f(std::ifstream &is) {\\n\" // #12297\n              \"    std::string str;\\n\"\n              \"    if (getline(is, str, 'x').good()) {};\\n\"\n              \"    if (!getline(is, str, 'x').good()) {};\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocuse_fdopen() {\n        check(\"struct FileCloser {\\n\" // #13126\n              \"    void operator()(std::FILE * ptr) const {\\n\"\n              \"        std::fclose(ptr);\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"void f(char* fileName) {\\n\"\n              \"    std::unique_ptr<std::FILE, FileCloser> out;\\n\"\n              \"    int fd = mkstemps(fileName, 4);\\n\"\n              \"    if (fd != -1)\\n\"\n              \"        out.reset(fdopen(fd, \\\"w\\\"));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doublefree_fdopen() { // #12781\n        check(\"void foo(void) {\\n\"\n              \"    int fd;\\n\"\n              \"    FILE *stream;\\n\"\n              \"    fd = open(\\\"/foo\\\", O_RDONLY);\\n\"\n              \"    if (fd == -1) return;\\n\"\n              \"    stream = fdopen(fd, \\\"r\\\");\\n\"\n              \"    if (!stream) {\\n\"\n              \"        close(fd);\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    fclose(stream);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void memleak_open() { // #13356\n        check(\"int f() {\\n\"\n              \"    int fd = open(\\\"abc \\\", O_RDONLY);\\n\"\n              \"    if (fd > -1) {\\n\"\n              \"        return fd;\\n\"\n              \"    }\\n\"\n              \"    return -1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestLeakAutoVarPosix)\n"
    }
  ]
}