{
  "name": "nullPointer",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 4,
  "branches": 0,
  "apis": 2,
  "test": [
    {
      "description": null,
      "expected-problems": 97,
      "expected-linenumbers": [
        344,
        377,
        1002,
        1285,
        1294,
        1303,
        1313,
        1325,
        1342,
        1351,
        1360,
        1376,
        1389,
        1396,
        1412,
        1422,
        1431,
        1440,
        1450,
        1467,
        1481,
        1493,
        1510,
        1542,
        1554,
        1564,
        1576,
        1602,
        1614,
        1633,
        1645,
        1656,
        1667,
        1685,
        1696,
        1707,
        1736,
        1769,
        1777,
        1786,
        1795,
        1813,
        1829,
        1843,
        1894,
        1906,
        1922,
        1953,
        1965,
        1980,
        1990,
        2005,
        2018,
        2051,
        2081,
        2095,
        2130,
        2150,
        2167,
        2194,
        2215,
        2255,
        2294,
        2312,
        2342,
        2370,
        2409,
        2424,
        2436,
        2463,
        2475,
        2487,
        2501,
        2518,
        2538,
        2553,
        2566,
        2587,
        2606,
        2633,
        2654,
        2691,
        2713,
        2725,
        2742,
        2773,
        2786,
        2796,
        2815,
        2829,
        2840,
        2861,
        2872,
        2884,
        2898,
        2928,
        2937
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"check.h\"\n#include \"checknullpointer.h\"\n#include \"ctu.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"library.h\"\n#include \"settings.h\"\n#include \"standards.h\"\n#include \"token.h\"\n\n#include <cstddef>\n#include <list>\n#include <string>\n\nclass TestNullPointer : public TestFixture {\npublic:\n    TestNullPointer() : TestFixture(\"TestNullPointer\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"std.cfg\").severity(Severity::warning).build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(nullpointerAfterLoop);\n        TEST_CASE(nullpointer1);\n        TEST_CASE(nullpointer2);\n        TEST_CASE(structDerefAndCheck);    // dereferencing struct and then checking if it's null\n        TEST_CASE(pointerDerefAndCheck);\n        TEST_CASE(nullpointer5);    // References should not be checked\n        TEST_CASE(nullpointerExecutionPaths);\n        TEST_CASE(nullpointerExecutionPathsLoop);\n        TEST_CASE(nullpointer7);\n        TEST_CASE(nullpointer9);\n        TEST_CASE(nullpointer10);\n        TEST_CASE(nullpointer11); // ticket #2812\n        TEST_CASE(nullpointer12); // ticket #2470\n        TEST_CASE(nullpointer15); // #3560 (fp: return p ? f(*p) : f(0))\n        TEST_CASE(nullpointer16); // #3591\n        TEST_CASE(nullpointer17); // #3567\n        TEST_CASE(nullpointer18); // #1927\n        TEST_CASE(nullpointer19); // #3811\n        TEST_CASE(nullpointer20); // #3807 (fp: return p ? (p->x() || p->y()) : z)\n        TEST_CASE(nullpointer21); // #4038 (fp: if (x) p=q; else return;)\n        TEST_CASE(nullpointer23); // #4665 (false positive)\n        TEST_CASE(nullpointer24); // #5082 fp: chained assignment\n        TEST_CASE(nullpointer25); // #5061\n        TEST_CASE(nullpointer26); // #3589\n        TEST_CASE(nullpointer27); // #6568\n        TEST_CASE(nullpointer28); // #6491\n        TEST_CASE(nullpointer30); // #6392\n        TEST_CASE(nullpointer31); // #8482\n        TEST_CASE(nullpointer32); // #8460\n        TEST_CASE(nullpointer33);\n        TEST_CASE(nullpointer34);\n        TEST_CASE(nullpointer35);\n        TEST_CASE(nullpointer36); // #9264\n        TEST_CASE(nullpointer37); // #9315\n        TEST_CASE(nullpointer38);\n        TEST_CASE(nullpointer39); // #2153\n        TEST_CASE(nullpointer40);\n        TEST_CASE(nullpointer41);\n        TEST_CASE(nullpointer42);\n        TEST_CASE(nullpointer43); // #9404\n        TEST_CASE(nullpointer44); // #9395, #9423\n        TEST_CASE(nullpointer45);\n        TEST_CASE(nullpointer46); // #9441\n        TEST_CASE(nullpointer47); // #6850\n        TEST_CASE(nullpointer48); // #9196\n        TEST_CASE(nullpointer49); // #7804\n        TEST_CASE(nullpointer50); // #6462\n        TEST_CASE(nullpointer51);\n        TEST_CASE(nullpointer52);\n        TEST_CASE(nullpointer53); // #8005\n        TEST_CASE(nullpointer54); // #9573\n        TEST_CASE(nullpointer55); // #8144\n        TEST_CASE(nullpointer56); // #9701\n        TEST_CASE(nullpointer57); // #9751\n        TEST_CASE(nullpointer58); // #9807\n        TEST_CASE(nullpointer59); // #9897\n        TEST_CASE(nullpointer60); // #9842\n        TEST_CASE(nullpointer61);\n        TEST_CASE(nullpointer62);\n        TEST_CASE(nullpointer63);\n        TEST_CASE(nullpointer64);\n        TEST_CASE(nullpointer65); // #9980\n        TEST_CASE(nullpointer66); // #10024\n        TEST_CASE(nullpointer67); // #10062\n        TEST_CASE(nullpointer68);\n        TEST_CASE(nullpointer69); // #8143\n        TEST_CASE(nullpointer70);\n        TEST_CASE(nullpointer71); // #10178\n        TEST_CASE(nullpointer72); // #10215\n        TEST_CASE(nullpointer73); // #10321\n        TEST_CASE(nullpointer74);\n        TEST_CASE(nullpointer75);\n        TEST_CASE(nullpointer76); // #10408\n        TEST_CASE(nullpointer77);\n        TEST_CASE(nullpointer78); // #7802\n        TEST_CASE(nullpointer79); // #10400\n        TEST_CASE(nullpointer80); // #10410\n        TEST_CASE(nullpointer81); // #8724\n        TEST_CASE(nullpointer82); // #10331\n        TEST_CASE(nullpointer83); // #9870\n        TEST_CASE(nullpointer84); // #9873\n        TEST_CASE(nullpointer85); // #10210\n        TEST_CASE(nullpointer86);\n        TEST_CASE(nullpointer87); // #9291\n        TEST_CASE(nullpointer88); // #9949\n        TEST_CASE(nullpointer89); // #10640\n        TEST_CASE(nullpointer90); // #6098\n        TEST_CASE(nullpointer91); // #10678\n        TEST_CASE(nullpointer92);\n        TEST_CASE(nullpointer93); // #3929\n        TEST_CASE(nullpointer94); // #11040\n        TEST_CASE(nullpointer95); // #11142\n        TEST_CASE(nullpointer96); // #11416\n        TEST_CASE(nullpointer97); // #11229\n        TEST_CASE(nullpointer98); // #11458\n        TEST_CASE(nullpointer99); // #10602\n        TEST_CASE(nullpointer100);        // #11636\n        TEST_CASE(nullpointer101);        // #11382\n        TEST_CASE(nullpointer102);\n        TEST_CASE(nullpointer103);\n        TEST_CASE(nullpointer104); // #13881\n        TEST_CASE(nullpointer105); // #13861\n        TEST_CASE(nullpointer_addressOf); // address of\n        TEST_CASE(nullpointerSwitch); // #2626\n        TEST_CASE(nullpointer_cast); // #4692\n        TEST_CASE(nullpointer_castToVoid); // #3771\n        TEST_CASE(nullpointer_subfunction);\n        TEST_CASE(pointerCheckAndDeRef);     // check if pointer is null and then dereference it\n        TEST_CASE(nullConstantDereference);  // Dereference NULL constant\n        TEST_CASE(gcc_statement_expression); // Don't crash\n        TEST_CASE(snprintf_with_zero_size);\n        TEST_CASE(snprintf_with_non_zero_size);\n        TEST_CASE(printf_with_invalid_va_argument);\n        TEST_CASE(scanf_with_invalid_va_argument);\n        TEST_CASE(nullpointer_in_return);\n        TEST_CASE(nullpointer_in_typeid);\n        TEST_CASE(nullpointer_in_alignof); // #11401\n        TEST_CASE(nullpointer_in_for_loop);\n        TEST_CASE(nullpointerDeadCode); // #11311\n        TEST_CASE(nullpointerDelete);\n        TEST_CASE(nullpointerSubFunction);\n        TEST_CASE(nullpointerExit);\n        TEST_CASE(nullpointerStdString);\n        TEST_CASE(nullpointerStdStream);\n        TEST_CASE(nullpointerSmartPointer);\n        TEST_CASE(nullpointerOutOfMemory);\n        TEST_CASE(functioncall);\n        TEST_CASE(functioncalllibrary); // use Library to parse function call\n        TEST_CASE(functioncallDefaultArguments);\n        TEST_CASE(nullpointer_internal_error); // #5080\n        TEST_CASE(ticket6505);\n        TEST_CASE(subtract);\n        TEST_CASE(addNull);\n        TEST_CASE(isPointerDeRefFunctionDecl);\n\n        TEST_CASE(ctuTest);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        bool inconclusive = false;\n        bool cpp = true;\n        Standards::cstd_t cstd = Standards::CLatest;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(settings).certainty(Certainty::inconclusive, options.inconclusive).c(options.cstd).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this, options.cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for null pointer dereferences..\n        runChecks<CheckNullPointer>(tokenizer, this);\n    }\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkP_(const char* file, int line, const char (&code)[size]) {\n        const Settings settings1 = settingsBuilder(settings).certainty(Certainty::inconclusive, false).build();\n\n        SimpleTokenizer2 tokenizer(settings1, *this, code, \"test.cpp\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check for null pointer dereferences..\n        runChecks<CheckNullPointer>(tokenizer, this);\n    }\n\n\n\n    void nullpointerAfterLoop() {\n        // extracttests.start: struct Token { const Token *next() const; std::string str() const; };\n        check(\"void foo(const Token *tok)\\n\"\n              \"{\\n\"\n              \"    while (tok);\\n\"\n              \"    tok = tok->next();\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:12] -> [test.cpp:4:11]: (warning) Either the condition 'tok' is redundant or there is possible null pointer dereference: tok. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // #2681\n        {\n            const char code[] = \"void foo(const Token *tok)\\n\"\n                                \"{\\n\"\n                                \"    while (tok && tok->str() == \\\"=\\\")\\n\"\n                                \"        tok = tok->next();\\n\"\n                                \"\\n\"\n                                \"    if (tok->str() != \\\";\\\")\\n\"\n                                \"        ;\\n\"\n                                \"}\\n\";\n\n            check(code);\n            ASSERT_EQUALS(\"[test.cpp:3:12] -> [test.cpp:6:9]: (warning) Either the condition 'tok' is redundant or there is possible null pointer dereference: tok. [nullPointerRedundantCheck]\\n\", errout_str());\n        }\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    for (const Token *tok = tokens; tok; tok = tok->next())\\n\"\n              \"    {\\n\"\n              \"        while (tok && tok->str() != \\\";\\\")\\n\"\n              \"            tok = tok->next();\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5] -> [test.cpp:3]: (warning) Either the condition 'while' is redundant or there is possible null pointer dereference: tok.\\n\", \"\", errout_str());\n\n        check(\"void foo(Token &tok)\\n\"\n              \"{\\n\"\n              \"    for (int i = 0; i < tok.size(); i++ )\\n\"\n              \"    {\\n\"\n              \"        while (!tok)\\n\"\n              \"            char c = tok.read();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    for (const Token *tok = tokens; tok; tok = tok->next())\\n\"\n              \"    {\\n\"\n              \"        while (tok && tok->str() != \\\";\\\")\\n\"\n              \"            tok = tok->next();\\n\"\n              \"        if( !tok ) break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    for (const Token *tok = tokens; tok; tok = tok ? tok->next() : NULL)\\n\"\n              \"    {\\n\"\n              \"        while (tok && tok->str() != \\\";\\\")\\n\"\n              \"            tok = tok->next();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(A*a)\\n\"\n              \"{\\n\"\n              \"  switch (a->b()) {\\n\"\n              \"    case 1:\\n\"\n              \"      while( a ){\\n\"\n              \"        a = a->next;\\n\"\n              \"      }\\n\"\n              \"    break;\\n\"\n              \"    case 2:\\n\"\n              \"      a->b();\\n\"\n              \"      break;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // dereference in outer scope..\n        check(\"void foo(int x, const Token *tok) {\\n\"\n              \"    if (x == 123) {\\n\"\n              \"        while (tok) tok = tok->next();\\n\"\n              \"    }\\n\"\n              \"    tok->str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16] -> [test.cpp:5:5]: (warning) Either the condition 'tok' is redundant or there is possible null pointer dereference: tok. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"int foo(const Token *tok)\\n\"\n              \"{\\n\"\n              \"    while (tok){;}\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(const Token *tok)\\n\"\n              \"{\\n\"\n              \"    while (tok){;}\\n\"\n              \"    char a[2] = {0,0};\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct b {\\n\"\n              \"    b * c;\\n\"\n              \"    int i;\\n\"\n              \"}\\n\"\n              \"void a(b * e) {\\n\"\n              \"  for (b *d = e;d; d = d->c)\\n\"\n              \"    while (d && d->i == 0)\\n\"\n              \"      d = d->c;\\n\"\n              \"  if (!d) throw;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct b {\\n\"\n              \"    b * c;\\n\"\n              \"    int i;\\n\"\n              \"};\\n\"\n              \"void f(b* e1, b* e2) {\\n\"\n              \"    for (const b* d = e1; d != e2; d = d->c) {\\n\"\n              \"        if (d && d->i != 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:13] -> [test.cpp:6:40]: (warning) Either the condition 'd' is redundant or there is possible null pointer dereference: d. [nullPointerRedundantCheck]\\n\", errout_str());\n    }\n\n    void nullpointer1() {\n        // ticket #1923 - no false positive when using else if\n        check(\"void f(A *a)\\n\"\n              \"{\\n\"\n              \"    if (a->x == 1)\\n\"\n              \"    {\\n\"\n              \"        a = a->next;\\n\"\n              \"    }\\n\"\n              \"    else if (a->x == 2) { }\\n\"\n              \"    if (a) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #2134 - sizeof doesn't dereference\n        check(\"void f() {\\n\"\n              \"    int c = 1;\\n\"\n              \"    int *list = NULL;\\n\"\n              \"    sizeof(*list);\\n\"\n              \"    if (!list)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #2245 - sizeof doesn't dereference\n        check(\"void f(Bar *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"        int sz = sizeof(p->x);\\n\"\n              \"    }\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void nullpointer2() {\n        // Null pointer dereference can only happen with pointers\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    Fred fred;\\n\"\n              \"    while (fred);\\n\"\n              \"    fred.hello();\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Dereferencing a struct and then checking if it is null\n    // This is checked by this function:\n    //        CheckOther::nullPointerStructByDeRefAndCheck\n    void structDerefAndCheck() {\n        // extracttests.start: struct ABC { int a; int b; int x; };\n\n        // errors..\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    int a = abc->a;\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:13]: (warning) Either the condition '!abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(struct ABC *abc) {\\n\"\n              \"    bar(abc->a);\\n\"\n              \"    bar(x, abc->a);\\n\"\n              \"    bar(x, y, abc->a);\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:2:9]: (warning) Either the condition '!abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\"\n                      \"[test.cpp:5:9] -> [test.cpp:3:12]: (warning) Either the condition '!abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\"\n                      \"[test.cpp:5:9] -> [test.cpp:4:15]: (warning) Either the condition '!abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(ABC *abc) {\\n\"\n              \"    if (abc->a == 3) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    if (abc) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:9] -> [test.cpp:2:9]: (warning) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"void f(ABC *abc) {\\n\"\n              \"    if (abc->x == 0) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    if (!abc);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:2:9]: (warning) Either the condition '!abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // TODO: False negative if member of member is dereferenced\n        check(\"void foo(ABC *abc) {\\n\"\n              \"    abc->next->a = 0;\\n\"\n              \"    if (abc->next)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:2]: (warning) Possible null pointer dereference: abc - otherwise it is redundant to check it against null.\\n\", \"\", errout_str());\n\n        check(\"void foo(ABC *abc) {\\n\"\n              \"    abc->a = 0;\\n\"\n              \"    if (abc && abc->b == 0)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:9] -> [test.cpp:2:5]: (warning) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        // ok dereferencing in a condition\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    if (abc && abc->a);\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(struct ABC *abc) {\\n\"\n              \"    int x = abc && a(abc->x);\\n\"\n              \"    if (abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok to use a linked list..\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    abc = abc->next;\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(struct ABC *abc) {\\n\"\n              \"    abc = (ABC *)(abc->_next);\\n\"\n              \"    if (abc) { }\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // reassign struct..\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    int a = abc->a;\\n\"\n              \"    abc = abc->next;\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    int a = abc->a;\\n\"\n              \"    f(&abc);\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // goto..\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    int a;\\n\"\n              \"    if (!abc)\\n\"\n              \"        goto out;\"\n              \"    a = abc->a;\\n\"\n              \"    return;\\n\"\n              \"out:\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // loops..\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    int a = abc->a;\"\n              \"    do\\n\"\n              \"    {\\n\"\n              \"        if (abc)\\n\"\n              \"            abc = abc->next;\\n\"\n              \"        --a;\\n\"\n              \"    }\\n\"\n              \"    while (a > 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    for (const Token *tok = _tokenizer->tokens(); tok; tok = tok->next())\\n\"\n              \"    {\\n\"\n              \"        while (tok && tok->str() != \\\"{\\\")\\n\"\n              \"            tok = tok->next();\\n\"\n              \"        if (!tok)\\n\"\n              \"            return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // dynamic_cast..\n        check(\"void foo(ABC *abc)\\n\"\n              \"{\\n\"\n              \"    int a = abc->a;\\n\"\n              \"    if (!dynamic_cast<DEF *>(abc))\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2641 - global pointer, function call\n        check(\"ABC *abc;\\n\"\n              \"void f() {\\n\"\n              \"    abc->a = 0;\\n\"\n              \"    do_stuff();\\n\"\n              \"    if (abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\",errout_str());\n\n        check(\"Fred *fred;\\n\"\n              \"void f() {\\n\"\n              \"    fred->foo();\\n\"\n              \"    if (fred) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\",errout_str());\n\n        // #2641 - local pointer, function call\n        check(\"void f() {\\n\"\n              \"    ABC *abc = abc1;\\n\"\n              \"    abc->a = 0;\\n\"\n              \"    do_stuff();\\n\"\n              \"    if (abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:9] -> [test.cpp:3:5]: (warning) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        // #2641 - local pointer, function call\n        check(\"void f(ABC *abc) {\\n\"\n              \"    abc->a = 0;\\n\"\n              \"    do_stuff();\\n\"\n              \"    if (abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:2:5]: (warning) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        // #2691 - switch/break\n        check(\"void f(ABC *abc) {\\n\"\n              \"    switch ( x ) {\\n\"\n              \"        case 14:\\n\"\n              \"            sprintf(buf, \\\"%d\\\", abc->a);\\n\"\n              \"            break;\\n\"\n              \"        case 15:\\n\"\n              \"            if ( abc ) {}\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3128\n        check(\"void f(ABC *abc) {\\n\"\n              \"    x(!abc || y(abc->a));\\n\"\n              \"    if (abc) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(ABC *abc) {\\n\"\n              \"  x(def || !abc || y(def, abc->a));\\n\"\n              \"  if (abc) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(ABC *abc) {\\n\"\n              \"  x(abc && y(def, abc->a));\\n\"\n              \"  if (abc) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(ABC *abc) {\\n\"\n              \"    x(def && abc && y(def, abc->a));\\n\"\n              \"    if (abc) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3228 - calling function with null object\n        {\n            const char code[] = \"void f(Fred *fred) {\\n\"\n                                \"    fred->x();\\n\"\n                                \"    if (fred) { }\\n\"\n                                \"}\";\n            check(code);\n            ASSERT_EQUALS(\n                \"[test.cpp:3:9] -> [test.cpp:2:5]: (warning) Either the condition 'fred' is redundant or there is possible null pointer dereference: fred. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n        }\n\n        // #3425 - false positives when there are macros\n        checkP(\"#define IF if\\n\"\n               \"void f(struct FRED *fred) {\\n\"\n               \"    fred->x = 0;\\n\"\n               \"    IF(!fred){}\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  BUFFER *buffer = get_buffer();\\n\"\n              \"  if (!buffer)\\n\"\n              \"    uv_fatal_error();\\n\"\n              \"  buffer->x = 11;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Dereferencing a pointer and then checking if it is null\n    void pointerDerefAndCheck() {\n        // extracttests.start: void bar(int);\n\n        // errors..\n        check(\"void foo(int *p)\\n\"\n              \"{\\n\"\n              \"    *p = 0;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:6]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(int *p)\\n\"\n              \"{\\n\"\n              \"    *p = 0;\\n\"\n              \"    if (p) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:3:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"void foo(int *p)\\n\"\n              \"{\\n\"\n              \"    *p = 0;\\n\"\n              \"    if (p || q) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:3:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"void foo(int *p)\\n\"\n              \"{\\n\"\n              \"    bar(*p);\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:10]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *p)\\n\"\n              \"{\\n\"\n              \"    strcpy(p, \\\"abc\\\");\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:12]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *p)\\n\"\n              \"{\\n\"\n              \"    if (*p == 0) { }\\n\"\n              \"    if (!p) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:10]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // no error\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int *p;\\n\"\n              \"    f(&p);\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int **p = f();\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int *p)\\n\"\n              \"{\\n\"\n              \"    if (x)\\n\"\n              \"        p = 0;\\n\"\n              \"    else\\n\"\n              \"        *p = 0;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int x)\\n\"\n              \"{\\n\"\n              \"    int a = 2 * x;\"\n              \"    if (x == 0)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int *p)\\n\"\n              \"{\\n\"\n              \"    int var1 = p ? *p : 0;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int *p, bool x)\\n\"\n              \"{\\n\"\n              \"    int var1 = x ? *p : 5;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:3:21]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        // while\n        check(\"void f(int *p) {\\n\"\n              \"    *p = 0;\\n\"\n              \"    while (p) { p = 0; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p) {\\n\"\n              \"    *p = 0;\\n\"\n              \"    while (p) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12] -> [test.cpp:2:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        // Ticket #3125\n        check(\"void foo(ABC *p)\\n\"\n              \"{\\n\"\n              \"    int var1 = p ? (p->a) : 0;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(ABC *p)\\n\"\n              \"{\\n\"\n              \"    int var1 = p ? (1 + p->a) : 0;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * a=0;\\n\"\n              \"    if (!a) {};\\n\"\n              \"    int c = a ? 0 : 1;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3686\n        check(\"void f() {\\n\"\n              \"    int * a=0;\\n\"\n              \"    if (!a) {};\\n\"\n              \"    int c = a ? b : b+1;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int * a=0;\\n\"\n              \"    if (!a) {};\\n\"\n              \"    int c = (a) ? b : b+1;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(P *p)\\n\"\n              \"{\\n\"\n              \"  while (p)\\n\"\n              \"    if (p->check())\\n\"\n              \"      break;\\n\"\n              \"    else\\n\"\n              \"      p = p->next();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(Document *doc) {\\n\"\n              \"    int x = doc && doc->x;\\n\"\n              \"    if (!doc) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3128 - false positive\n        check(\"void f(int *p) {\\n\"\n              \"    assert(!p || (*p<=6));\\n\"\n              \"    if (p) { *p = 0; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p) {\\n\"\n              \"    assert(p && (*p<=6));\\n\"\n              \"    if (p) { *p = 0; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p) {\\n\"\n              \"    *p = 12;\\n\"\n              \"    assert(p && (*p<=6));\\n\"\n              \"    if (p) { *p = 0; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12] -> [test.cpp:2:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"void foo(x *p)\\n\"\n              \"{\\n\"\n              \"    p = p->next;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(x *p)\\n\"\n              \"{\\n\"\n              \"    p = bar(p->next);\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(x *p)\\n\"\n              \"{\\n\"\n              \"    p = aa->bar(p->next);\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(x *p)\\n\"\n              \"{\\n\"\n              \"    p = *p2 = p->next;\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(struct ABC *abc)\\n\"\n              \"{\\n\"\n              \"    abc = abc ? abc->next : 0;\\n\"\n              \"    if (!abc)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(struct ABC *abc) {\\n\" // #4523\n              \"    abc = (*abc).next;\\n\"\n              \"    if (abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(struct ABC *abc) {\\n\" // #4523\n              \"    abc = (*abc->ptr);\\n\"\n              \"    if (abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(Item *item) {\\n\"\n              \"    x = item ? ab(item->x) : 0;\\n\"\n              \"    if (item) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(Item *item) {\\n\"\n              \"    item->x = 0;\\n\"\n              \"    a = b ? c : d;\\n\"\n              \"    if (item) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:2:5]: (warning) Either the condition 'item' is redundant or there is possible null pointer dereference: item. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"BOOL GotoFlyAnchor()\\n\"  // #2243\n              \"{\\n\"\n              \"    const SwFrm* pFrm = GetCurrFrm();\\n\"\n              \"    do {\\n\"\n              \"        pFrm = pFrm->GetUpper();\\n\"\n              \"    } while( pFrm && !pFrm->IsFlyFrm() );\\n\"\n              \"\\n\"\n              \"    if( !pFrm )\\n\"\n              \"        return FALSE;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #2463\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    B* W;\\n\"\n              \"\\n\"\n              \"    void f() {\\n\"\n              \"        switch (InData) {\\n\"\n              \"            case 2:\\n\"\n              \"                if (!W) return;\\n\"\n              \"                W->foo();\\n\"\n              \"                break;\\n\"\n              \"            case 3:\\n\"\n              \"                f();\\n\"\n              \"                if (!W) return;\\n\"\n              \"                break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2525 - sizeof\n        check(\"void f() {\\n\"\n              \"    int *test = NULL;\\n\"\n              \"    int c = sizeof(test[0]);\\n\"\n              \"    if (!test)\\n\"\n              \"        ;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(type* p) {\\n\" // #4983\n              \"    x(sizeof p[0]);\\n\"\n              \"    if (!p)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3023 - checked deref\n        check(\"void f(struct ABC *abc) {\\n\"\n              \"  WARN_ON(!abc || abc->x == 0);\\n\"\n              \"  if (!abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(struct ABC *abc) {\\n\"\n              \"  WARN_ON(!abc || abc->x == 7);\\n\"\n              \"  if (!abc) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3425 - false positives when there are macros\n        checkP(\"#define IF if\\n\"\n               \"void f(int *p) {\\n\"\n               \"    *p = 0;\\n\"\n               \"    IF(!p){}\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #3914 - false positive\n              \"    int *p;\\n\"\n              \"    ((p=ret()) && (x=*p));\\n\"\n              \"    if (p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { struct T { char c; } *p; };\\n\" // #6541\n              \"char f(S* s) { return s->p ? 'a' : s->p->c; }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:24] -> [test.cpp:2:37]: (warning) Either the condition 's->p' is redundant or there is possible null pointer dereference: s->p. [nullPointerRedundantCheck]\\n\",\n                      errout_str());\n    }\n\n    void nullpointer5() {\n        // errors..\n        check(\"void foo(A &a)\\n\"\n              \"{\\n\"\n              \" char c = a.c();\\n\"\n              \" if (!a)\\n\"\n              \"   return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Execution paths..\n    void nullpointerExecutionPaths() {\n        // errors..\n        check(\"static void foo()\\n\"\n              \"{\\n\"\n              \"    Foo *p = 0;\\n\"\n              \"    if (a == 1) {\\n\"\n              \"        p = new FooBar;\\n\"\n              \"    } else { if (a == 2) {\\n\"\n              \"        p = new FooCar; } }\\n\"\n              \"    p->abcd();\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:8]: (error) Possible null pointer dereference: p\\n\",\n                           \"\", errout_str());\n\n        check(\"static void foo() {\\n\"\n              \"    int &r = *(int*)0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (error) Null pointer dereference: (int*)0 [nullPointer]\\n\", errout_str());\n\n        check(\"static void foo(int x) {\\n\"\n              \"    int y = 5 + *(int*)0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (error) Null pointer dereference: (int*)0 [nullPointer]\\n\", errout_str());\n\n        {\n            const char code[] = \"static void foo() {\\n\"\n                                \"    Foo<int> *abc = 0;\\n\"\n                                \"    abc->a();\\n\"\n                                \"}\\n\";\n\n            check(code);\n            ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Null pointer dereference: abc [nullPointer]\\n\", errout_str());\n        }\n\n        check(\"static void foo() {\\n\"\n              \"    std::cout << *(int*)0;\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (error) Null pointer dereference: (int*)0 [nullPointer]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    char *c = 0;\\n\"\n              \"    {\\n\"\n              \"        delete c;\\n\"\n              \"    }\\n\"\n              \"    c[0] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Null pointer dereference: c [nullPointer]\\n\", errout_str());\n\n        check(\"static void foo() {\\n\"\n              \"    if (3 > *(int*)0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (error) Null pointer dereference: (int*)0 [nullPointer]\\n\", errout_str());\n\n        // no false positive..\n        check(\"static void foo()\\n\"\n              \"{\\n\"\n              \"    Foo *p = 0;\\n\"\n              \"    p = new Foo;\\n\"\n              \"    p->abcd();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int sz = sizeof((*(struct dummy *)0).x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void get_offset(long &offset)\\n\"\n              \"{\\n\"\n              \"    mystruct * temp; temp = 0;\\n\"\n              \"    offset = (long)(&(temp->z));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #1893 - try/catch inside else\n        check(\"int *test(int *Z)\\n\"\n              \"{\\n\"\n              \"    int *Q=NULL;\\n\"\n              \"    if (Z) {\\n\"\n              \"        Q = Z;\\n\"\n              \"    }\\n\"\n              \"    else {\\n\"\n              \"        Z = new int;\\n\"\n              \"        try {\\n\"\n              \"        } catch(...) {\\n\"\n              \"        }\\n\"\n              \"        Q = Z;\\n\"\n              \"    }\\n\"\n              \"    *Q=1;\\n\"\n              \"    return Q;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int *test(int *Z)\\n\"\n              \"{\\n\"\n              \"    int *Q=NULL;\\n\"\n              \"    if (Z) {\\n\"\n              \"        Q = Z;\\n\"\n              \"    }\\n\"\n              \"    else {\\n\"\n              \"        try {\\n\"\n              \"        } catch(...) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    *Q=1;\\n\"\n              \"    return Q;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:12:6]: (warning) Possible null pointer dereference: Q [nullPointer]\\n\", errout_str());\n\n        // Ticket #2052 (false positive for 'else continue;')\n        check(\"void f() {\\n\"\n              \"    for (int x = 0; x < 5; ++x) {\"\n              \"        int *p = 0;\\n\"\n              \"        if (a(x)) p=b(x);\\n\"\n              \"        else continue;\\n\"\n              \"        *p = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // function pointer..\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    void (*f)();\\n\"\n              \"    f = 0;\\n\"\n              \"    f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (error) Null pointer dereference: f [nullPointer]\\n\", errout_str());\n\n        check(\"int* g();\\n\" // #11007\n              \"int* f() {\\n\"\n              \"    static int* (*fun)() = 0;\\n\"\n              \"    if (!fun)\\n\"\n              \"        fun = g;\\n\"\n              \"    return fun();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // loops..\n        check(\"void f() {\\n\"\n              \"    int *p = 0;\\n\"\n              \"    for (int i = 0; i < 10; ++i) {\\n\"\n              \"        int x = *p + 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"void f(int a) {\\n\"\n              \"    const char *p = 0;\\n\"\n              \"    if (a) {\\n\"\n              \"        p = \\\"abcd\\\";\\n\"\n              \"    }\\n\"\n              \"    for (int i = 0; i < 3; i++) {\\n\"\n              \"        if (a && (p[i] == '1'));\\n\"\n              \"    }\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #2251: taking the address of member\n        check(\"void f() {\\n\"\n              \"    Fred *fred = 0;\\n\"\n              \"    int x = &fred->x;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #3220: dereferencing a null pointer is UB\n        check(\"void f() {\\n\"\n              \"    Fred *fred = NULL;\\n\"\n              \"    fred->do_something();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Null pointer dereference: fred [nullPointer]\\n\", errout_str());\n\n        // ticket #3570 - parsing of conditions\n        {\n            check(\"void f() {\\n\"\n                  \"    int *p = NULL;\\n\"\n                  \"    if (x)\\n\"\n                  \"        p = q;\\n\"\n                  \"    if (p && *p) { }\\n\"\n                  \"}\", dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\"\", errout_str());\n            check(\"void f() {\\n\"\n                  \"    int *p = NULL;\\n\"\n                  \"    if (x)\\n\"\n                  \"        p = q;\\n\"\n                  \"    if (!p || *p) { }\\n\"\n                  \"}\", dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\"\", errout_str());\n            check(\"void f() {\\n\"\n                  \"    int *p = NULL;\\n\"\n                  \"    if (x)\\n\"\n                  \"        p = q;\\n\"\n                  \"    if (p || *p) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"[test.cpp:5:15]: (warning) Possible null pointer dereference: p [nullPointer]\\n\", errout_str());\n        }\n\n        // ticket #8831 - FP triggered by if/return/else sequence\n        {\n            check(\"void f(int *p, int *q) {\\n\"\n                  \"    if (p == NULL)\\n\"\n                  \"        return;\\n\"\n                  \"    else if (q == NULL)\\n\"\n                  \"        return;\\n\"\n                  \"    *q = 0;\\n\"\n                  \"}\\n\"\n                  \"\\n\"\n                  \"void g() {\\n\"\n                  \"    f(NULL, NULL);\\n\"\n                  \"}\", dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"void f() {\\n\" // #5979\n              \"    int* const crash = 0;\\n\"\n              \"    *crash = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Null pointer dereference: crash [nullPointer]\\n\", errout_str());\n    }\n\n    // Ticket #2350\n    void nullpointerExecutionPathsLoop() {\n        // No false positive:\n        check(\"void foo() {\\n\"\n              \"    int n;\\n\"\n              \"    int *argv32 = p;\\n\"\n              \"    if (x) {\\n\"\n              \"        n = 0;\\n\"\n              \"        argv32 = 0;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    for (int i = 0; i < n; i++) {\\n\"\n              \"        argv32[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // No false negative:\n        check(\"void foo() {\\n\"\n              \"    int n;\\n\"\n              \"    int *argv32;\\n\"\n              \"    if (x) {\\n\"\n              \"        n = 10;\\n\"\n              \"        argv32 = 0;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    for (int i = 0; i < n; i++) {\\n\"\n              \"        argv32[i] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:9]: (warning) Possible null pointer dereference: argv32 [nullPointer]\\n\", errout_str());\n\n        // #2231 - error if assignment in loop is not used\n        // extracttests.start: int y[20];\n        check(\"void f() {\\n\"\n              \"    char *p = 0;\\n\"\n              \"\\n\"\n              \"    for (int x = 0; x < 3; ++x) {\\n\"\n              \"        if (y[x] == 0) {\\n\"\n              \"            p = (char *)malloc(10);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:11:6]: (warning) Possible null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer7() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"  wxLongLong x = 0;\\n\"\n              \"  int y = x.GetValue();\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer9() { //#ticket 1778\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"  std::string * x = 0;\\n\"\n              \"  *x = \\\"test\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:4]: (error) Null pointer dereference: x [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer10() {\n        // extracttests.start: struct my_type { int x; };\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"  struct my_type* p = 0;\\n\"\n              \"  p->x = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:3]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer11() { // ticket #2812\n        // extracttests.start: struct my_type { int x; };\n\n        check(\"int foo()\\n\"\n              \"{\\n\"\n              \"  struct my_type* p;\\n\"\n              \"  p = 0;\\n\"\n              \"  return p->x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer12() { // ticket #2470, #4035\n        const char code[] = \"int foo()\\n\"\n                            \"{\\n\"\n                            \"  int* i = nullptr;\\n\"\n                            \"  return *i;\\n\"\n                            \"}\\n\";\n\n        check(code); // C++ file => nullptr means NULL\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: i [nullPointer]\\n\", errout_str());\n\n        check(code, dinit(CheckOptions, $.cpp = false, $.cstd = Standards::C17)); // C17 file => nullptr does not mean NULL\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(code, dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:4:11]: (error) Null pointer dereference: i [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer15() {  // #3560\n        check(\"void f() {\\n\"\n              \"    char *p = 0;\\n\"\n              \"    if (x) p = \\\"abcd\\\";\\n\"\n              \"    return p ? f(*p) : f(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer16() {  // #3591\n        check(\"void foo() {\\n\"\n              \"    int *p = 0;\\n\"\n              \"    bar(&p);\\n\"\n              \"    *p = 0;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer17() {  // #3567\n        check(\"int foo() {\\n\"\n              \"    int *p = 0;\\n\"\n              \"    if (x) { return 0; }\\n\"\n              \"    return !p || *p;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    int *p = 0;\\n\"\n              \"    if (x) { return 0; }\\n\"\n              \"    return p && *p;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer18() {  // #1927\n        check(\"void f ()\\n\"\n              \"{\\n\"\n              \"  int i=0;\\n\"\n              \"  char *str=NULL;\\n\"\n              \"  while (str[i])\\n\"\n              \"  {\\n\"\n              \"    i++;\\n\"\n              \"  };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Null pointer dereference: str [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer19() { // #3811\n        check(\"int foo() {\\n\"\n              \"    perror(0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer20() {  // #3807\n        check(\"void f(int x) {\\n\"\n              \"    struct xy *p = 0;\\n\"\n              \"    if (x) p = q;\\n\"\n              \"    if (p ? p->x || p->y : 0) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"   // false negative\n              \"    struct xy *p = 0;\\n\"\n              \"    if (x) p = q;\\n\"\n              \"    if (y ? p->x : p->y) { }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (warning) Possible null pointer dereference: p\\n\", \"\", errout_str());\n    }\n\n    void nullpointer21() {  // #4038 - fp: if (x) p=q; else return;\n        check(\"void f(int x) {\\n\"\n              \"    int *p = 0;\\n\"\n              \"    if (x) p = q;\\n\"\n              \"    else return;\\n\"\n              \"    *p = 0;\\n\" // <- p is not NULL\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer23() {  // #4665\n        check(\"void f(){\\n\"\n              \"    char *c = NULL;\\n\"\n              \"    char cBuf[10];\\n\"\n              \"    sprintf(cBuf, \\\"%s\\\", c ? c : \\\"0\\\" );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\",errout_str());\n    }\n\n    void nullpointer24() {  // #5083 - fp: chained assignment\n        check(\"void f(){\\n\"\n              \"    char *c = NULL;\\n\"\n              \"    x = c = new char[10];\\n\"\n              \"    *c = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer25() { // #5061\n        check(\"void f(int *data, int i)\\n\"\n              \"{\\n\"\n              \"    int *array = NULL;\\n\"\n              \"    if (data == 1 && array[i] == 0)\\n\"\n              \"        std::cout << \\\"test\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:22]: (error) Null pointer dereference: array [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer26() { // #3589\n        check(\"double foo() {\\n\"\n              \"    sk *t1 = foo();\\n\"\n              \"    sk *t2 = foo();\\n\"\n              \"    if ((!t1) && (!t2))\\n\"\n              \"        return 0.0;\\n\"\n              \"    if (t1 && (!t2))\\n\"\n              \"        return t1->Inter();\\n\"\n              \"    if (t2->GetT() == t)\\n\"\n              \"        return t2->Inter();\\n\"\n              \"    if (t2 && (!t1))\\n\"\n              \"        return 0.0;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer27() { // #6568\n        check(\"template<class Type>\\n\"\n              \"class Foo {\\n\"\n              \"    Foo<Type>& operator = ( Type* );\\n\"\n              \"};\\n\"\n              \"template<class Type>\\n\"\n              \"Foo<Type>& Foo<Type>::operator = ( Type* pointer_ ) {\\n\"\n              \"    pointer_=NULL;\\n\"\n              \"    *pointer_=0;\\n\"\n              \"    return *this;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:6]: (error) Null pointer dereference: pointer_ [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer28() { // #6491\n        check(\"typedef struct { int value; } S;\\n\"\n              \"int f(const S *s) {\\n\"\n              \"  int i = s ? s->value + 1\\n\"\n              \"            : s->value - 1; // <-- null ptr dereference\\n\"\n              \"  return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11] -> [test.cpp:4:15]: (warning) Either the condition 's' is redundant or there is possible null pointer dereference: s. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer30() { // #6392\n        check(\"void f(std::vector<std::string> *values)\\n\"\n              \"{\\n\"\n              \"  values->clear();\\n\"\n              \"  if (values)\\n\"\n              \"  {\\n\"\n              \"    for (int i = 0; i < values->size(); ++i)\\n\"\n              \"    {\\n\"\n              \"      values->push_back(\\\"test\\\");\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:4:7] -> [test.cpp:3:3]: (warning) Either the condition 'values' is redundant or there is possible null pointer dereference: values. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer31() { // #8482\n        check(\"struct F\\n\"\n              \"{\\n\"\n              \"    int x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"static void foo(F* f)\\n\"\n              \"{\\n\"\n              \"    if( f ) {}\\n\"\n              \"    else { return; }\\n\"\n              \"    (void)f->x;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typedef struct\\n\"\n              \"{\\n\"\n              \"    int x;\\n\"\n              \"} F;\\n\"\n              \"\\n\"\n              \"static void foo(F* f)\\n\"\n              \"{\\n\"\n              \"    if( !f || f->x == 0 )\\n\"\n              \"    {\\n\"\n              \"        if( !f )\\n\"\n              \"            return;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    (void)f->x;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer32() { // #8460\n        check(\"int f(int * ptr) {\\n\"\n              \"  if(ptr)\\n\"\n              \"  { return 0;}\\n\"\n              \"  else{\\n\"\n              \"    int *p1 = ptr;\\n\"\n              \"    return *p1;\\n\"\n              \"  }\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:6] -> [test.cpp:6:13]: (warning) Either the condition 'ptr' is redundant or there is possible null pointer dereference: p1. [nullPointerRedundantCheck]\\n\", errout_str());\n    }\n\n    void nullpointer33() {\n        check(\"void f(int * x) {\\n\"\n              \"    if (x != nullptr)\\n\"\n              \"        *x = 2;\\n\"\n              \"    else\\n\"\n              \"        *x = 3;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:5:10]: (warning) Either the condition 'x!=nullptr' is redundant or there is possible null pointer dereference: x. [nullPointerRedundantCheck]\\n\", errout_str());\n    }\n\n    void nullpointer34() {\n        check(\"void g() {\\n\"\n              \"    throw \" \";\\n\"\n              \"}\\n\"\n              \"bool f(int * x) {\\n\"\n              \"    if (x) *x += 1;\\n\"\n              \"    if (!x) g();\\n\"\n              \"    return *x;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer35() {\n        check(\"bool f(int*);\\n\"\n              \"void g(int* x) {\\n\"\n              \"    if (f(x)) {\\n\"\n              \"        *x = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void h() {\\n\"\n              \"    g(0);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int*);\\n\"\n              \"void g(int* x) {\\n\"\n              \"    bool b = f(x);\\n\"\n              \"    if (b) {\\n\"\n              \"        *x = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void h() {\\n\"\n              \"    g(0);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer36() {\n        check(\"char* f(char* s) {\\n\"\n              \"    char* start = s;\\n\"\n              \"    if (!s)\\n\"\n              \"        return (s);\\n\"\n              \"    while (isspace(*start))\\n\"\n              \"        start++;\\n\"\n              \"    return (start);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer37() {\n        check(\"void f(int value, char *string) {\\n\"\n              \"    char *ptr1 = NULL, *ptr2 = NULL;\\n\"\n              \"    unsigned long count = 0;\\n\"\n              \"    if(!string)\\n\"\n              \"        return;\\n\"\n              \"    ptr1 = string;\\n\"\n              \"    ptr2 = strrchr(string, 'a');\\n\"\n              \"    if(ptr2 == NULL)\\n\"\n              \"        return;\\n\"\n              \"    while(ptr1 < ptr2) {\\n\"\n              \"        count++;\\n\"\n              \"        ptr1++;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer38() {\n        check(\"void f(int * x) {\\n\"\n              \"    std::vector<int*> v;\\n\"\n              \"    if (x) {\\n\"\n              \"        v.push_back(x);\\n\"\n              \"        *x;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer39() {\n        check(\"struct A { int * x; };\\n\"\n              \"void f(struct A *a) {\\n\"\n              \"    if (a->x == NULL) {}\\n\"\n              \"    *(a->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:14] -> [test.cpp:4:8]: (warning) Either the condition 'a->x==NULL' is redundant or there is possible null pointer dereference: a->x. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer40() {\n        check(\"struct A { std::unique_ptr<int> x; };\\n\"\n              \"void f(struct A *a) {\\n\"\n              \"    if (a->x == nullptr) {}\\n\"\n              \"    *(a->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:14] -> [test.cpp:4:8]: (warning) Either the condition 'a->x==nullptr' is redundant or there is possible null pointer dereference: a->x. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer41() {\n        check(\"struct A { int * g() const; };\\n\"\n              \"void f(struct A *a) {\\n\"\n              \"    if (a->g() == nullptr) {}\\n\"\n              \"    *(a->g());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:16] -> [test.cpp:4:11]: (warning) Either the condition 'a->g()==nullptr' is redundant or there is possible null pointer dereference: a->g(). [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"struct A { int * g(); };\\n\"\n              \"void f(struct A *a) {\\n\"\n              \"    if (a->g() == nullptr) {}\\n\"\n              \"    *(a->g());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer42() {\n        check(\"struct A { std::unique_ptr<int> g() const; };\\n\"\n              \"void f(struct A *a) {\\n\"\n              \"    if (a->g() == nullptr) {}\\n\"\n              \"    *(a->g());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:16] -> [test.cpp:4:11]: (warning) Either the condition 'a->g()==nullptr' is redundant or there is possible null pointer dereference: a->g(). [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer43() {\n        check(\"struct A { int* x; };\\n\"\n              \"void f(A* a) {\\n\"\n              \"    int * x = a->x;\\n\"\n              \"    if (x) {\\n\"\n              \"        (void)*a->x;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer44() {\n        // #9395\n        check(\"int foo( ) {\\n\"\n              \"    const B* b = getB();\\n\"\n              \"    const double w = ( nullptr != b) ? 42. : 0.0;\\n\"\n              \"    if ( w == 0.0 )\\n\"\n              \"        return 0;\\n\"\n              \"    return b->get();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        // #9423\n        check(\"extern F* GetF();\\n\"\n              \"extern L* GetL();\\n\"\n              \"void Foo() {\\n\"\n              \"    const F* const fPtr = GetF();\\n\"\n              \"    const bool fPtrOk = fPtr != NULL;\\n\"\n              \"    assert(fPtrOk);\\n\"\n              \"    if (!fPtrOk)\\n\"\n              \"        return;\\n\"\n              \"    L* const lPtr = fPtr->l;\\n\"\n              \"    const bool lPtrOk = lPtr != NULL;\\n\"\n              \"    assert(lPtrOk);\\n\"\n              \"    if (!lPtrOk)\\n\"\n              \"        return;\\n\"\n              \"    lPtr->Clear();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer45() {\n        check(\"struct a {\\n\"\n              \"  a *b() const;\\n\"\n              \"};\\n\"\n              \"void g() { throw 0; }\\n\"\n              \"a h(a * c) {\\n\"\n              \"  if (c && c->b()) {}\\n\"\n              \"  if (!c)\\n\"\n              \"    g();\\n\"\n              \"  if (!c->b())\\n\"\n              \"    g();\\n\"\n              \"  a d = *c->b();\\n\"\n              \"  return d;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct a {\\n\"\n              \"  a *b() const;\\n\"\n              \"};\\n\"\n              \"void e() { throw 0; }\\n\"\n              \"a f() {\\n\"\n              \"  a *c = 0;\\n\"\n              \"  if (0 && c->b()) {}\\n\"\n              \"  if (!c)\\n\"\n              \"    e();\\n\"\n              \"  if (!c->b())\\n\"\n              \"    e();\\n\"\n              \"  a d = *c->b();\\n\"\n              \"  return d;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer46() {\n        check(\"void f() {\\n\"\n              \"    char* p = new(std::nothrow) char[1];\\n\"\n              \"    if( p ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer47() {\n        check(\"void f(int *p) {\\n\"\n              \"   if(!p[0]) {}\\n\"\n              \"   const int *const a = p;\\n\"\n              \"   if(!a){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7] -> [test.cpp:2:8]: (warning) Either the condition '!a' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n    }\n\n    void nullpointer48() {\n        check(\"template<class T>\\n\"\n              \"auto f(T& x) -> decltype(x);\\n\"\n              \"int& g(int* x) {\\n\"\n              \"    return f(*x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer49() {\n        check(\"void f(int *p, int n) {\\n\"\n              \"    int *q = 0;\\n\"\n              \"    if(n > 10) q = p;\\n\"\n              \"    *p +=2;\\n\"\n              \"    if(n < 120) *q+=12;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:18]: (warning) Possible null pointer dereference: q [nullPointer]\\n\", errout_str());\n\n        check(\"void f(int *p, int n) {\\n\"\n              \"    int *q = 0;\\n\"\n              \"    if(n > 10) q = p;\\n\"\n              \"    *p +=2;\\n\"\n              \"    if(n > 10) *q+=12;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer50() {\n        check(\"void f(int *p, int a) {\\n\"\n              \"    if(!p) {\\n\"\n              \"        if(a > 0) {\\n\"\n              \"            if(a > 10){}\\n\"\n              \"            else {\\n\"\n              \"                *p = 0;\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:8] -> [test.cpp:6:18]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer51() {\n        check(\"struct a {\\n\"\n              \"  a *b();\\n\"\n              \"};\\n\"\n              \"bool c(a *, const char *);\\n\"\n              \"a *d(a *e) {\\n\"\n              \"  if (e) {}\\n\"\n              \"  if (c(e, \\\"\\\"))\\n\"\n              \"    return nullptr;\\n\"\n              \"  return e->b();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer52() {\n        check(\"int f(int a, int* b) {\\n\"\n              \"    int* c = nullptr;\\n\"\n              \"    if(b) c = b;\\n\"\n              \"    if (!c) c = &a;\\n\"\n              \"    return *c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int a, int* b) {\\n\"\n              \"    int* c = nullptr;\\n\"\n              \"    if(b) c = b;\\n\"\n              \"    bool d = !c;\\n\"\n              \"    if (d) c = &a;\\n\"\n              \"    return *c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int* x; };\\n\"\n              \"int f(int a, int* b) {\\n\"\n              \"    A c;\\n\"\n              \"    c.x = nullptr;\\n\"\n              \"    if(b) c.x = b;\\n\"\n              \"    if (!c.x) c.x = &a;\\n\"\n              \"    return *c.x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int* x; };\\n\"\n              \"int f(int a, int* b) {\\n\"\n              \"    A c;\\n\"\n              \"    c.x = nullptr;\\n\"\n              \"    if(b) c.x = b;\\n\"\n              \"    bool d = !c.x;\\n\"\n              \"    if (d) c.x = &a;\\n\"\n              \"    return *c.x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int* x; };\\n\"\n              \"int f(int a, int* b) {\\n\"\n              \"    A c;\\n\"\n              \"    c.x = nullptr;\\n\"\n              \"    if(b) c.x = b;\\n\"\n              \"    bool d = !c.x;\\n\"\n              \"    if (!d) c.x = &a;\\n\"\n              \"    return *c.x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (warning) Possible null pointer dereference: c.x [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer53() {\n        check(\"void f(int nParams, int* params) {\\n\"\n              \"  for (int n=1; n<nParams+10; ++n) {\\n\"\n              \"    params[n]=42;\\n\"\n              \"  }\\n\"\n              \"}\\n\"\n              \"void bar() {\\n\"\n              \"  f(0, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning) Possible null pointer dereference: params [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer54() {\n        check(\"int foo (int **array, size_t n_array) {\\n\"\n              \"    size_t i;\\n\"\n              \"    for (i = 0; i < n_array; ++i) {\\n\"\n              \"        if (*array[i] == 1)\\n\"\n              \"            return 1;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\"\n              \"int bar() {\\n\"\n              \"    int **array = NULL;\\n\"\n              \"    foo (array, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer55() {\n        check(\"void f(const Token* tok) {\\n\"\n              \"    const Token* tok3 = tok;\\n\"\n              \"    while (tok3->astParent() && tok3->str() == \\\",\\\")\\n\"\n              \"        tok3 = tok3->astParent();\\n\"\n              \"    if (tok3 && tok3->str() == \\\"(\\\") {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:9] -> [test.cpp:3:12]: (warning) Either the condition 'tok3' is redundant or there is possible null pointer dereference: tok3. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"void f(int* t1, int* t2) {\\n\"\n              \"    while (t1 && t2 &&\\n\"\n              \"       *t1 == *t2) {\\n\"\n              \"        t1 = nullptr;\\n\"\n              \"        t2 = nullptr;\\n\"\n              \"    }\\n\"\n              \"    if (!t1 || !t2)\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int* i);\\n\"\n              \"void g(int* i) {\\n\"\n              \"    while(f(i) && *i == 0)\\n\"\n              \"        i++;\\n\"\n              \"    if (!i) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer56() {\n        check(\"struct ListEntry {\\n\"\n              \"    struct ListEntry *next;\\n\"\n              \"};\\n\"\n              \"static void dostuff(ListEntry * listHead) {\\n\"\n              \"    ListEntry *prev = NULL;\\n\"\n              \"    for (ListEntry *cursor = listHead; cursor != NULL; prev = cursor, cursor = cursor->next) {}\\n\"\n              \"    if (prev) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer57() {\n        check(\"void f() {\\n\"\n              \"    FILE* fptr = fopen(\\\"test\\\", \\\"r\\\");\\n\"\n              \"    if (fptr != nullptr) {\\n\"\n              \"        std::function<void()> fn([&] {\\n\"\n              \"            fclose(fptr);\\n\"\n              \"            fptr = NULL;\\n\"\n              \"        });\\n\"\n              \"        fgetc(fptr);\\n\"\n              \"        fn();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer58() {\n        check(\"struct myStruct { char entry[0]; };\\n\"\n              \"void f() {\\n\"\n              \"    struct myStruct* sPtr = NULL;\\n\"\n              \"    int sz = (!*(&sPtr) || ((*(&sPtr))->entry[0] > 15)) ?\\n\"\n              \"        sizeof((*(&sPtr))->entry[0]) : 123456789;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer59() {\n        check(\"struct Box {\\n\"\n              \"    struct Box* prev;\\n\"\n              \"    struct Box* next;\\n\"\n              \"};\\n\"\n              \"void foo(Box** pfreeboxes) {\\n\"\n              \"    Box *b = *pfreeboxes;\\n\"\n              \"    *pfreeboxes = b->next;\\n\"\n              \"    if( *pfreeboxes )\\n\"\n              \"        (*pfreeboxes)->prev = nullptr;\\n\"\n              \"    b->next = nullptr;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer60() {\n        check(\"void f(){\\n\"\n              \"    char uuid[128];\\n\"\n              \"    char *s1;\\n\"\n              \"    memset(uuid, 0, sizeof(uuid));\\n\"\n              \"    s1 = strchr(uuid, '=');\\n\"\n              \"    s1 = s1 ? s1 + 1 : &uuid[5];\\n\"\n              \"    if (!strcmp(\\\"00000000000000000000000000000000\\\", s1) )\\n\"\n              \"        return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer61() {\n        check(\"struct a {\\n\"\n              \"  int *e;\\n\"\n              \"};\\n\"\n              \"struct f {\\n\"\n              \"  a *g() const;\\n\"\n              \"};\\n\"\n              \"void h() {\\n\"\n              \"  for (f b;;) {\\n\"\n              \"    a *c = b.g();\\n\"\n              \"    int *d = c->e;\\n\"\n              \"    if (d)\\n\"\n              \"      ;\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  A* g() const;\\n\"\n              \"  A* h() const;\\n\"\n              \"};\\n\"\n              \"void f(A* a) {\\n\"\n              \"  if (!a->h())\\n\"\n              \"    return;\\n\"\n              \"  const A *b = a;\\n\"\n              \"  while (b && !b->h())\\n\"\n              \"      b = b->g();\\n\"\n              \"  if (!b || b == b->g()->h())\\n\"\n              \"      return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer62() {\n        check(\"struct A {\\n\"\n              \"  bool f()() const;\\n\"\n              \"};\\n\"\n              \"void a(A *x) {\\n\"\n              \"  std::string b = x && x->f() ? \\\"\\\" : \\\"\\\";\\n\"\n              \"  if (x) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  bool f()() const;\\n\"\n              \"};\\n\"\n              \"void a(A *x) {\\n\"\n              \"  std::string b = (!x || x->f()) ? \\\"\\\" : \\\"\\\";\\n\"\n              \"  if (x) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  A * aa;\\n\"\n              \"};\\n\"\n              \"void b(A*);\\n\"\n              \"void a(A *x) {\\n\"\n              \"  b(x ? x->aa : nullptr);\\n\"\n              \"  if (!x) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer63() {\n        check(\"struct A {\\n\"\n              \"    A* a() const;\\n\"\n              \"    A* b() const;\\n\"\n              \"};\\n\"\n              \"A* f(A*);\\n\"\n              \"void g(const A* x) {\\n\"\n              \"    A *d = x->a();\\n\"\n              \"    d = f(d->b()) ? d->a() : nullptr;\\n\"\n              \"    if (d && f(d->b())) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer64() {\n        check(\"struct A {\\n\"\n              \"  A* f() const;\\n\"\n              \"  int g() const;\\n\"\n              \"};\\n\"\n              \"bool a;\\n\"\n              \"bool b(A* c) {\\n\"\n              \"    if (c->g() == 0)\\n\"\n              \"      ;\\n\"\n              \"    A *aq = c;\\n\"\n              \"    if (c->g() == 0)\\n\"\n              \"      c = c->f();\\n\"\n              \"    if (c)\\n\"\n              \"      for (A *d = c; d != aq; d = d->f()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  A* g() const;\\n\"\n              \"  A* h() const;\\n\"\n              \"};\\n\"\n              \"bool i(A*);\\n\"\n              \"void f(A* x) {\\n\"\n              \"  if (i(x->g())) {\\n\"\n              \"    A *y = x->g();\\n\"\n              \"    x = x->g()->h();\\n\"\n              \"    if (x && x->g()) {\\n\"\n              \"        y = x->g()->h();\\n\"\n              \"    }\\n\"\n              \"    if (!y) {}\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer65() {\n        check(\"struct A {\\n\"\n              \"    double get();\\n\"\n              \"};\\n\"\n              \"double x;\\n\"\n              \"double run(A** begin, A** end) {\\n\"\n              \"    A* a = nullptr;\\n\"\n              \"    while (begin != end) {\\n\"\n              \"        a = *begin;\\n\"\n              \"        x = a->get();\\n\"\n              \"        ++begin;\\n\"\n              \"    }\\n\"\n              \"    x = 0;\\n\"\n              \"    if (a)\\n\"\n              \"        return a->get();\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer66() {\n        check(\"int f() {\\n\"\n              \"    int ret = 0;\\n\"\n              \"    int *v = nullptr;\\n\"\n              \"    if (!MyAlloc(&v)) {\\n\"\n              \"        ret = -1;\\n\"\n              \"        goto done;\\n\"\n              \"    }\\n\"\n              \"    DoSomething(*v);\\n\"\n              \"done:\\n\"\n              \"    if (v)\\n\"\n              \"      MyFree(&v);\\n\"\n              \"    return ret;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer67() {\n        check(\"int result;\\n\"\n              \"\\n\"\n              \"int test_b(void) {\\n\"\n              \"    char **string = NULL;\\n\"\n              \"\\n\"\n              \"    /* The bug disappears if \\\"result =\\\" is omitted. */\\n\"\n              \"    result = some_other_call(&string);\\n\"\n              \"    if (string && string[0])\\n\"\n              \"        return 0;\\n\"\n              \"    return -1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int result;\\n\"\n              \"\\n\"\n              \"int test_b(void) {\\n\"\n              \"    char **string = NULL;\\n\"\n              \"\\n\"\n              \"    some_other_call(&string);\\n\"\n              \"    if (string && string[0])\\n\"\n              \"        return 0;\\n\"\n              \"    return -1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer68() {\n        check(\"struct A {\\n\"\n              \"    A* b;\\n\"\n              \"};\\n\"\n              \"void f(A* c) {\\n\"\n              \"    c = c->b;\\n\"\n              \"    if (c->b) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    A* b;\\n\"\n              \"};\\n\"\n              \"void f(A* c) {\\n\"\n              \"    A* d = c->b;\\n\"\n              \"    A *e = c;\\n\"\n              \"    while (nullptr != (e = e->b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer69() {\n        check(\"void f(const Scope *scope) {\\n\"\n              \"    if (scope->definedType) {}\\n\"\n              \"    while (scope) {\\n\"\n              \"        scope = scope->nestedIn;\\n\"\n              \"        enumerator = scope->findEnumerator();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12] -> [test.cpp:5:22]: (warning) Either the condition 'scope' is redundant or there is possible null pointer dereference: scope. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"void f(const Scope *scope) {\\n\"\n              \"    if (scope->definedType) {}\\n\"\n              \"    while (scope && scope->nestedIn) {\\n\"\n              \"        if (scope->type == Scope::eFunction && scope->functionOf)\\n\"\n              \"            scope = scope->functionOf;\\n\"\n              \"        else\\n\"\n              \"            scope = scope->nestedIn;\\n\"\n              \"        enumerator = scope->findEnumerator();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12] -> [test.cpp:8:22]: (warning) Either the condition 'scope' is redundant or there is possible null pointer dereference: scope. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"struct a {\\n\"\n              \"  a *b() const;\\n\"\n              \"  void c();\\n\"\n              \"};\\n\"\n              \"void d() {\\n\"\n              \"  for (a *e;;) {\\n\"\n              \"    e->b()->c();\\n\"\n              \"    while (e)\\n\"\n              \"      e = e->b();\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer70() {\n        check(\"struct Token {\\n\"\n              \"    const Token* nextArgument() const;\\n\"\n              \"    const Token* next() const;\\n\"\n              \"    int varId() const;\\n\"\n              \"};\\n\"\n              \"int f(const Token *first, const Token* second) {\\n\"\n              \"    first = first->nextArgument();\\n\"\n              \"    if (first)\\n\"\n              \"        first = first->next();\\n\"\n              \"    if (second->next()->varId() == 0) {\\n\"\n              \"        second = second->nextArgument();\\n\"\n              \"        if (!first || !second)\\n\"\n              \"            return 0;\\n\"\n              \"    } else if (!first) {\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"    return first->varId();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Token {\\n\"\n              \"    const Token* nextArgument() const;\\n\"\n              \"    const Token* next() const;\\n\"\n              \"    int varId() const;\\n\"\n              \"    void str() const;\"\n              \"};\\n\"\n              \"void f(const Token *first) {\\n\"\n              \"    first = first->nextArgument();\\n\"\n              \"    if (first)\\n\"\n              \"        first = first->next();\\n\"\n              \"    first->str();\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:8] -> [test.cpp:10]: (warning) Either the condition 'first' is redundant or there is possible null pointer dereference: first.\\n\",\n            \"\",\n            errout_str());\n    }\n\n    void nullpointer71() {\n        check(\"void f() {\\n\"\n              \"  Device* dev = Get();\\n\"\n              \"  SetCount(dev == nullptr ? 0 : dev->size());\\n\"\n              \"  if (dev)\\n\"\n              \"    DoSomething(dev);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  Device* dev = Get();\\n\"\n              \"  SetCount(dev != nullptr ? dev->size() : 0);\\n\"\n              \"  if (dev)\\n\"\n              \"    DoSomething(dev);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer72() { // #10215\n        check(\"int test() {\\n\"\n              \"  int* p0 = nullptr, *p1 = nullptr;\\n\"\n              \"  getFoo(p0);\\n\"\n              \"  getBar(p1);\\n\"\n              \"  if (!(p0 != nullptr && p1 != nullptr))\\n\"\n              \"    return {};\\n\"\n              \"  return *p0 + *p1;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int test2() {\\n\"\n              \"  int* p0 = nullptr;\\n\"\n              \"  if (!(getBaz(p0) && p0 != nullptr))\\n\"\n              \"    return 0;\\n\"\n              \"  return *p0;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int test3() {\\n\"\n              \"  Obj* PObj = nullptr;\\n\"\n              \"  if (!(GetObj(PObj) && PObj != nullptr))\\n\"\n              \"    return 1;\\n\"\n              \"  if (!PObj->foo())\\n\"\n              \"    test();\\n\"\n              \"  PObj->bar();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer73() {\n        check(\"void f(bool flag2, int* ptr) {\\n\"\n              \"    bool flag1 = true;\\n\"\n              \"    if (flag2) {\\n\"\n              \"        if (ptr != nullptr)\\n\"\n              \"            (*ptr)++;\\n\"\n              \"        else\\n\"\n              \"            flag1 = false;\\n\"\n              \"    }\\n\"\n              \"    if (flag1 && flag2)\\n\"\n              \"        (*ptr)++;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool flag2, int* ptr) {\\n\"\n              \"    bool flag1 = true;\\n\"\n              \"    if (flag2) {\\n\"\n              \"        if (ptr != nullptr)\\n\"\n              \"            (*ptr)++;\\n\"\n              \"        else\\n\"\n              \"            flag1 = false;\\n\"\n              \"    }\\n\"\n              \"    if (!flag1 && flag2)\\n\"\n              \"        (*ptr)++;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:17] -> [test.cpp:10:11]: (warning) Either the condition 'ptr!=nullptr' is redundant or there is possible null pointer dereference: ptr. [nullPointerRedundantCheck]\\n\", errout_str());\n    }\n\n    void nullpointer74() {\n        check(\"struct d {\\n\"\n              \"  d* e();\\n\"\n              \"};\\n\"\n              \"void g(d* f) {\\n\"\n              \"  do {\\n\"\n              \"    f = f->e();\\n\"\n              \"    if (f) {}\\n\"\n              \"  } while (0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct d {\\n\"\n              \"  d* e();\\n\"\n              \"};\\n\"\n              \"void g(d* f, int i) {\\n\"\n              \"  do {\\n\"\n              \"    i--;\\n\"\n              \"    f = f->e();\\n\"\n              \"    if (f) {}\\n\"\n              \"  } while (i > 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:8:9] -> [test.cpp:7:9]: (warning) Either the condition 'f' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"struct d {\\n\"\n              \"  d* e();\\n\"\n              \"};\\n\"\n              \"void g(d* f, int i) {\\n\"\n              \"  do {\\n\"\n              \"    i--;\\n\"\n              \"    f = f->e();\\n\"\n              \"    if (f) {}\\n\"\n              \"  } while (f && i > 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer75() {\n        check(\"struct a {\\n\"\n              \"  a *b() const;\\n\"\n              \"  void c();\\n\"\n              \"  int d() const;\\n\"\n              \"};\\n\"\n              \"void e(a *x) {\\n\"\n              \"  while (x->b()->d() == 0)\\n\"\n              \"    x->c();\\n\"\n              \"  x->c();\\n\"\n              \"  if (x->b()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer76()\n    {\n        check(\"int* foo(int y) {\\n\"\n              \"    std::unique_ptr<int> x = std::make_unique<int>(0);\\n\"\n              \"    if( y == 0 )\\n\"\n              \"        return x.release();\\n\"\n              \"    (*x) ++;\\n\"\n              \"    return x.release();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer77()\n    {\n        check(\"bool h(int*);\\n\"\n              \"void f(int* i) {\\n\"\n              \"    int* i = nullptr;\\n\"\n              \"    if (h(i) && *i == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool h(int*);\\n\"\n              \"void f(int* i) {\\n\"\n              \"    int* i = nullptr;\\n\"\n              \"    if (h(i))\\n\"\n              \"        if (*i == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool h(int*);\\n\"\n              \"void f(int* x) {\\n\"\n              \"    int* i = x;\\n\"\n              \"    if (h(i))\\n\"\n              \"        i = nullptr;\\n\"\n              \"    if (h(i) && *i == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer78() // #7802\n    {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int **pp;\\n\"\n              \"    int *p = 0;\\n\"\n              \"    pp = &p;\\n\"\n              \"    **pp = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:6]: (error) Null pointer dereference: *pp [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer79() // #10400\n    {\n        check(\"void resize(size_t nF, size_t nT) {\\n\"\n              \"    double* pValues = nullptr;\\n\"\n              \"    if (nF > 0 && nT > 0)\\n\"\n              \"        pValues = new double[nF * nT];\\n\"\n              \"    for (size_t cc = 0; cc < nF * nT; ++cc)\\n\"\n              \"        pValues[cc] = 42;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer80() // #10410\n    {\n        check(\"int f(int* a, int* b) {\\n\"\n              \"    if( a || b ) {\\n\"\n              \"        int n = a ? *a : *b;\\n\"\n              \"        if( b )\\n\"\n              \"            n++;\\n\"\n              \"        return n;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer81() // #8724\n    {\n        check(\"void f(A **list) {\\n\"\n              \"  A *tmp_List = NULL;\\n\"\n              \"  *list = NULL;\\n\"\n              \"  while (1) {\\n\"\n              \"    if (*list == NULL) {\\n\"\n              \"      tmp_List = malloc (sizeof (ArchiveList_struct));\\n\"\n              \"      *list = tmp_List;\\n\"\n              \"    } else {\\n\"\n              \"      tmp_List->next = malloc (sizeof (ArchiveList_struct));\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer82() // #10331\n    {\n        check(\"bool g();\\n\"\n              \"int* h();\\n\"\n              \"void f(int* ptr) {\\n\"\n              \"    if (!ptr) {\\n\"\n              \"        if (g())\\n\"\n              \"            goto done;\\n\"\n              \"        ptr = h();\\n\"\n              \"        if (!ptr)\\n\"\n              \"            return;\\n\"\n              \"    }\\n\"\n              \"    if (*ptr == 1)\\n\"\n              \"        return;\\n\"\n              \"\\n\"\n              \"done:\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer83() // #9870\n    {\n        check(\"int* qux();\\n\"\n              \"int* f7c2(int *x) {\\n\"\n              \"  int* p = 0;\\n\"\n              \"  if (nullptr == x)\\n\"\n              \"    p = qux();\\n\"\n              \"  if (nullptr == x)\\n\"\n              \"    return x;\\n\"\n              \"  *p = 1;\\n\"\n              \"  return x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:4]: (warning) Possible null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer84() // #9873\n    {\n        check(\"void f(std::unique_ptr<A> P) {\\n\"\n              \"  A *RP = P.get();\\n\"\n              \"  if (!RP) {\\n\"\n              \"    P->foo();\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:7] -> [test.cpp:4:5]: (warning) Either the condition '!RP' is redundant or there is possible null pointer dereference: P. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer85() // #10210\n    {\n        check(\"struct MyStruct {\\n\"\n              \"  int GetId() const {\\n\"\n              \"      int id = 0;\\n\"\n              \"      int page = m_notebook->GetSelection();\\n\"\n              \"      if (m_notebook && (m_notebook->GetPageCount() > 0))\\n\"\n              \"        id = page;\\n\"\n              \"      return id;\\n\"\n              \"  }\\n\"\n              \"  wxNoteBook *m_notebook = nullptr;\\n\"\n              \"};\\n\"\n              \"int f() {\\n\"\n              \"  const MyStruct &s = Get();\\n\"\n              \"  return s.GetId();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:11] -> [test.cpp:4:18]: (warning) Either the condition 'm_notebook' is redundant or there is possible null pointer dereference: m_notebook. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer86()\n    {\n        check(\"struct A {\\n\"\n              \"    A* a() const;\\n\"\n              \"    int b() const;\\n\"\n              \"};\\n\"\n              \"A* f(A* t) {\\n\"\n              \"    if (t->b() == 0) {\\n\"\n              \"        return t;\\n\"\n              \"    }\\n\"\n              \"    return t->a();\\n\"\n              \"}\\n\"\n              \"void g(A* t) {\\n\"\n              \"    t = f(t->a());\\n\"\n              \"    if (!t->a()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer87() // #9291\n    {\n        check(\"int f(bool b, int* x) {\\n\"\n              \"    if (b && x == nullptr)\\n\"\n              \"        return 0;\\n\"\n              \"    else if (!b && x == nullptr)\\n\"\n              \"        return 1;\\n\"\n              \"    else if (!b && x != nullptr)\\n\"\n              \"        return *x;\\n\"\n              \"    else\\n\"\n              \"        return *x + 1;\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:6:22] -> [test.cpp:9:17]: (warning) Either the condition 'x!=nullptr' is redundant or there is possible null pointer dereference: x. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(int n, int* p) {\\n\"\n              \"    int* r = nullptr;\\n\"\n              \"    if (n < 0)\\n\"\n              \"        return;\\n\"\n              \"    if (n == 0)\\n\"\n              \"        r = p;\\n\"\n              \"    else if (n > 0)\\n\"\n              \"        r = p + 1;\\n\"\n              \"    *r;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer88() // #9949\n    {\n        check(\"struct S { char **ppc; };\\n\"\n              \"int alloc(struct S* s) {\\n\"\n              \"    char** ppc = malloc(4096);\\n\"\n              \"    if (ppc != NULL) {\\n\"\n              \"        s->ppc = ppc;\\n\"\n              \"        return 1;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    struct S* s = malloc(sizeof(struct S));\\n\"\n              \"    if (!s) return;\\n\"\n              \"    s->ppc = NULL;\\n\"\n              \"    if (alloc(s))\\n\"\n              \"        s->ppc[0] = \\\"\\\";\\n\"\n              \"}\\n\", dinit(CheckOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer89() // #10640\n    {\n        check(\"typedef struct {\\n\"\n              \"    int x;\\n\"\n              \"} foo_t;\\n\"\n              \"typedef struct {\\n\"\n              \"    foo_t *y;\\n\"\n              \"} bar_t;\\n\"\n              \"void f(bar_t *ptr) {\\n\"\n              \"    if(ptr->y->x)\\n\"\n              \"        if(ptr->y != nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:9:19] -> [test.cpp:8:11]: (warning) Either the condition 'ptr->y!=nullptr' is redundant or there is possible null pointer dereference: ptr->y. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n\n        check(\"bool argsMatch(const Token *first, const Token *second) {\\n\" // #6145\n              \"    if (first->str() == \\\")\\\")\\n\"\n              \"        return true;\\n\"\n              \"    else if (first->next()->str() == \\\"=\\\")\\n\"\n              \"        first = first->nextArgument();\\n\"\n              \"    else if (second->next()->str() == \\\"=\\\") {\\n\"\n              \"        second = second->nextArgument();\\n\"\n              \"        if (second)\\n\"\n              \"            second = second->tokAt(-2);\\n\"\n              \"        if (!first || !second) {\\n\"\n              \"            return !first && !second;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:10:13] -> [test.cpp:2:9]: (warning) Either the condition '!first' is redundant or there is possible null pointer dereference: first. [nullPointerRedundantCheck]\\n\"\n            \"[test.cpp:10:13] -> [test.cpp:4:14]: (warning) Either the condition '!first' is redundant or there is possible null pointer dereference: first. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer90() // #6098\n    {\n        check(\"std::string definitionToName(Definition *ctx)\\n\"\n              \"{\\n\"\n              \"  if (ctx->definitionType()==Definition::TypeMember)\\n\"                           // possible null pointer dereference\n              \"  {\\n\"\n              \"     return \\\"y\\\";\\n\"\n              \"  }\\n\"\n              \"  else if (ctx)\\n\"                           // ctx is checked against null\n              \"  {\\n\"\n              \"    if(ctx->definitionType()!=Definition::TypeMember)\\n\"\n              \"    {\\n\"\n              \"       return \\\"x\\\";\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"  return \\\"unknown\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:7:12] -> [test.cpp:3:7]: (warning) Either the condition 'ctx' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]\\n\",\n            errout_str());\n    }\n\n    void nullpointer91() // #10678\n    {\n        check(\"void f(const char* PBeg, const char* PEnd) {\\n\"\n              \"  while (PEnd != nullptr) {\\n\"\n              \"    const int N = h(PEnd);\\n\"\n              \"    PEnd = g();\\n\"\n              \"    const int Length = PEnd == nullptr ? 0 : PEnd - PBeg;\\n\"\n              \"  };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer92()\n    {\n        check(\"bool g(bool);\\n\"\n              \"int f(int* i) {\\n\"\n              \"    if (!g(!!i)) return 0;\\n\"\n              \"    return *i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(bool);\\n\"\n              \"int f(int* i) {\\n\"\n              \"    if (!g(!i)) return 0;\\n\"\n              \"    return *i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer93() // #3929\n    {\n        check(\"int* GetThing( ) { return 0; }\\n\"\n              \"int main() {\\n\"\n              \"        int* myNull = GetThing();\\n\"\n              \"        *myNull=42;\\n\"\n              \"        return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Null pointer dereference: myNull [nullPointer]\\n\", errout_str());\n\n        check(\"struct foo {\\n\"\n              \"    int* GetThing(void) { return 0; }\\n\"\n              \"};\\n\"\n              \"int main(void) {\\n\"\n              \"        foo myFoo;\\n\"\n              \"        int* myNull = myFoo.GetThing();\\n\"\n              \"        *myNull=42;\\n\"\n              \"        return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (error) Null pointer dereference: myNull [nullPointer]\\n\", errout_str());\n\n        check(\"struct T { bool g() const; };\\n\"\n              \"void f(T* p) {\\n\"\n              \"    if (!p)\\n\"\n              \"        return;\\n\"\n              \"    while (p->g())\\n\"\n              \"        p = nullptr;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (warning) Possible null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer94() // #11040\n    {\n        check(\"struct entry { struct entry* next; size_t len; };\\n\"\n              \"void f(struct entry **kep, size_t slen) {\\n\"\n              \"    while (*kep)\\n\"\n              \"        kep = &(*kep)->next;\\n\"\n              \"    *kep = (struct entry*)malloc(sizeof(**kep));\\n\"\n              \"    (*kep)->next = 0;\\n\"\n              \"    (*kep)->len = slen;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:6]: (warning) If memory allocation fails, then there is a possible null pointer dereference: *kep [nullPointerOutOfMemory]\\n\", errout_str());\n    }\n\n    void nullpointer95() // #11142\n    {\n        check(\"void f(std::vector<int*>& v) {\\n\"\n              \"    for (auto& p : v)\\n\"\n              \"        if (*p < 2)\\n\"\n              \"            p = nullptr;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer96()\n    {\n        check(\"struct S {\\n\"\n              \"  int x;\\n\"\n              \"};\\n\"\n              \"S *create_s();\\n\"\n              \"void test() {\\n\"\n              \"  S *s = create_s();\\n\"\n              \"  for (int i = 0; i < s->x; i++) {\\n\"\n              \"    if (s->x == 17) {\\n\"\n              \"      s = nullptr;\\n\"\n              \"      break;\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"  if (s) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer97() // #11229\n    {\n        check(\"struct B { virtual int f() = 0; };\\n\"\n              \"struct D : public B { int f() override; };\\n\"\n              \"int g(B* p) {\\n\"\n              \"    if (p) {\\n\"\n              \"        auto d = dynamic_cast<D*>(p);\\n\"\n              \"        return d ? d->f() : 0;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer98() // #11458\n    {\n        check(\"struct S { double* d() const; };\\n\"\n              \"struct T {\\n\"\n              \"    virtual void g(double* b, double* d) const = 0;\\n\"\n              \"    void g(S* b) const { g(b->d(), nullptr); }\\n\"\n              \"    void g(S* b, S* d) const { g(b->d(), d->d()); }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer99() // #10602\n    {\n        check(\"class A\\n\"\n              \"{\\n\"\n              \"    int *foo(const bool b)\\n\"\n              \"    {\\n\"\n              \"        if(b)\\n\"\n              \"            return nullptr;\\n\"\n              \"        else\\n\"\n              \"            return new int [10];\\n\"\n              \"    }\\n\"\n              \"public:\\n\"\n              \"    void bar(void)\\n\"\n              \"    {\\n\"\n              \"        int * buf = foo(true);\\n\"\n              \"        buf[2] = 0;\" // <<\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:14:9]: (error) Null pointer dereference: buf [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer100() // #11636\n    {\n        check(\"const char* type_of(double) { return \\\"unknown\\\"; }\\n\"\n              \"void f() {\\n\"\n              \"    double tmp = 0.0;\\n\"\n              \"    const char* t = type_of(tmp);\\n\"\n              \"    std::cout << t;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer101() // #11382\n    {\n        check(\"struct Base { virtual ~Base(); };\\n\"\n              \"struct Derived : Base {};\\n\"\n              \"bool is_valid(const Derived&);\\n\"\n              \"void f(const Base* base) {\\n\"\n              \"    const Derived* derived = dynamic_cast<const Derived*>(base);\\n\"\n              \"    if (derived && !is_valid(*derived) || base == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer102()\n    {\n        check(\"struct S { std::string str; };\\n\" // #11534\n              \"struct T { S s; };\\n\"\n              \"struct U { T t[1]; };\\n\"\n              \"void f(const T& t, const U& u, std::string& str) {\\n\"\n              \"    if (str.empty())\\n\"\n              \"        str = t.s.str;\\n\"\n              \"    else\\n\"\n              \"        str = u.t[0].s.str;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer103()\n    {\n        check(\"struct S {\\n\" // #10572\n              \"    int f();\\n\"\n              \"    int* m_P{};\\n\"\n              \"};\\n\"\n              \"int S::f() {\\n\"\n              \"    if (!m_P) {\\n\"\n              \"        try {\\n\"\n              \"            m_P = new int(1);\\n\"\n              \"        }\\n\"\n              \"        catch (...) {\\n\"\n              \"            return 0;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return *m_P;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int* p, const int* q) {\\n\" // #11873\n              \"    if (*q == -1)\\n\"\n              \"        *p = 0;\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    int x = -2;\\n\"\n              \"    f(nullptr, &x);\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:3:10]: (warning) Possible null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer104() // #13881\n    {\n        check(\"using std::max;\\n\"\n              \"void f(int i) {\\n\"\n              \"    const size_t maxlen = i == 1 ? 8 : (std::numeric_limits<std::size_t>::max());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer105() // #13861\n    {\n        check(\"struct AB { int a; int b; };\\n\"\n              \"namespace ns { typedef AB S[10]; }\\n\"\n              \"void foo(void) {\\n\"\n              \"    ns::S x = {0};\\n\"\n              \"    x[1].a = 2;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer_addressOf() { // address of\n        check(\"void f() {\\n\"\n              \"  struct X *x = 0;\\n\"\n              \"  if (addr == &x->y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  struct X *x = 0;\\n\"\n              \"  if (addr == &x->y.z[0]) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"typedef int Count;\\n\" // #10018\n               \"#define offsetof(TYPE, MEMBER) ((Count) & ((TYPE*)0)->MEMBER)\\n\"\n               \"struct S {\\n\"\n               \"    int a[20];\\n\"\n               \"};\\n\"\n               \"int g(int i) {\\n\"\n               \"    return offsetof(S, a[i]);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointerSwitch() { // #2626\n        // extracttests.start: char *do_something();\n        check(\"char *f(int x) {\\n\"\n              \"    char *p = do_something();\\n\"\n              \"    switch (x) {\\n\"\n              \"      case 1:\\n\"\n              \"        p = 0;\\n\"\n              \"      case 2:\\n\"\n              \"        *p = 0;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"    return p;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (warning) Possible null pointer dereference: p [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointer_cast() {\n        check(\"char *nasm_skip_spaces(const char *p) {\\n\" // #4692\n              \"    if (p)\\n\"\n              \"        while (*p && nasm_isspace(*p))\\n\"\n              \"            p++;\\n\"\n              \"    return p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char* origin) {\\n\" // #11449\n              \"    char* cp = (strchr)(origin, '\\\\0');\\n\"\n              \"    if (cp[-1] != '/')\\n\"\n              \"        *cp++ = '/';\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer_castToVoid() {  // #3771\n        check(\"void f () {\\n\"\n              \"    int *buf; buf = NULL;\\n\"\n              \"    buf;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer_subfunction() {\n        check(\"int f(int* x, int* y) {\\n\"\n              \"    if (!x)\\n\"\n              \"        return;\\n\"\n              \"    return *x + *y;\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    f(nullptr, nullptr);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Check if pointer is null and the dereference it\n    void pointerCheckAndDeRef() {\n        check(\"void foo(char *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:6]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (p && *p == 0) {\\n\"\n              \"    }\\n\"\n              \"    printf(\\\"%c\\\", *p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:19]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (p && *p == 0) {\\n\"\n              \"    } else { *p = 0; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:15]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (p) {\\n\"\n              \"    }\\n\"\n              \"    strcpy(p, \\\"abc\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:12]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (p) {\\n\"\n              \"    }\\n\"\n              \"    bar();\\n\"\n              \"    strcpy(p, \\\"abc\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:5:12]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(abc *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"    }\\n\"\n              \"    else { if (!p->x) {\\n\"\n              \"    } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            static const char code[] =\n                \"void foo(char *p) {\\n\"\n                \"    if (!p) {\\n\"\n                \"        abort();\\n\"\n                \"    }\\n\"\n                \"    *p = 0;\\n\"\n                \"}\";\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n\n            check(code, dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"        (*bail)();\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"        throw x;\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"        ab.abort();\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"        switch (x) { }\\n\"\n              \"    }\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"    }\\n\"\n              \"    return *x;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int *p) {\\n\"\n              \"    if (!p) {\\n\"\n              \"        x = *p;\\n\"\n              \"        return 5+*p;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:14]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\"\n                      \"[test.cpp:2:9] -> [test.cpp:4:19]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // operator!\n        check(\"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    if (!a) {\\n\"\n              \"        a.x();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // This is why this check can't be used on the simplified token list\n        check(\"void f(Foo *foo) {\\n\"\n              \"    if (!dynamic_cast<bar *>(foo)) {\\n\"\n              \"        *foo = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket: #2300 - calling unknown function that may initialize the pointer\n        check(\"Fred *fred;\\n\"\n              \"void a() {\\n\"\n              \"    if (!fred) {\\n\"\n              \"        initfred();\\n\"\n              \"        fred->x = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #1219\n        check(\"void foo(char *p) {\\n\"\n              \"    if (p) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:5:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // #2467 - unknown macro may terminate the application\n        check(\"void f(Fred *fred) {\\n\"\n              \"    if (fred == NULL) {\\n\"\n              \"        MACRO;\\n\"\n              \"    }\\n\"\n              \"    fred->a();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2493 - switch\n        check(\"void f(Fred *fred) {\\n\"\n              \"    if (fred == NULL) {\\n\"\n              \"        x = 0;\\n\"\n              \"    }\\n\"\n              \"    switch (x) {\\n\"\n              \"        case 1:\\n\"\n              \"            fred->a();\\n\"\n              \"            break;\\n\"\n              \"    };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4118 - second if\n        check(\"void f(char *p) {\\n\"\n              \"    int x = 1;\\n\"\n              \"    if (!p) x = 0;\\n\"\n              \"    if (x) *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2674 - different functions\n        check(\"class Fred {\\n\"\n              \"public:\\n\"\n              \"    Wilma *wilma;\\n\"\n              \"    void a();\\n\"\n              \"    void b();\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void Fred::a() {\\n\"\n              \"    if ( wilma ) { }\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void Fred::b() {\\n\"\n              \"    wilma->Reload();\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(int *i) {\\n\"\n              \"  if(i == NULL) { }\\n\"\n              \"  else {\\n\"\n              \"    int b = *i;\\n\"\n              \"  }\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2696 - false positives nr 1\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   struct foo *pFoo = NULL;\\n\"\n              \"   size_t len;\\n\"\n              \"\\n\"\n              \"   len = sizeof(*pFoo) - sizeof(pFoo->data);\\n\"\n              \"\\n\"\n              \"   if (pFoo)\\n\"\n              \"      bar();\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2696 - false positives nr 2\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   struct foo *pFoo = NULL;\\n\"\n              \"   size_t len;\\n\"\n              \"\\n\"\n              \"   while (pFoo)\\n\"\n              \"      pFoo = pFoo->next;\\n\"\n              \"\\n\"\n              \"   len = sizeof(pFoo->data);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2696 - false positives nr 3\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   struct foo *pFoo = NULL;\\n\"\n              \"   size_t len;\\n\"\n              \"\\n\"\n              \"   while (pFoo)\\n\"\n              \"      pFoo = pFoo->next;\\n\"\n              \"\\n\"\n              \"   len = decltype(*pFoo);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(struct Fred *fred) {\\n\"\n              \"    if (fred) { }\\n\"\n              \"    return fred->a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:12]: (warning) Either the condition 'fred' is redundant or there is possible null pointer dereference: fred. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // #2789 - assign and check pointer\n        check(\"void f() {\\n\"\n              \"    char *p; p = x();\\n\"\n              \"    if (!p) { }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:4:6]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // check, assign and use\n        check(\"void f() {\\n\"\n              \"    char *p;\\n\"\n              \"    if (p == 0 && (p = malloc(10)) != 0) {\\n\"\n              \"        *p = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // check, assign and use\n        check(\"void f() {\\n\"\n              \"    char *p;\\n\"\n              \"    if (p == 0 && (p = malloc(10)) != a && (*p = a)) {\\n\"\n              \"        *p = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // check, and use\n        check(\"void f() {\\n\"\n              \"    char *p;\\n\"\n              \"    if (p == 0 && (*p = 0)) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:3:21]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // check, and use\n        check(\"void f() {\\n\"\n              \"    struct foo *p;\\n\"\n              \"    if (p == 0 && p->x == 10) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:3:19]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // check, and use\n        check(\"void f() {\\n\"\n              \"    struct foo *p;\\n\"\n              \"    if (p == 0 || p->x == 10) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // check, and use\n        check(\"void f() {\\n\"\n              \"    char *p; p = malloc(10);\\n\"\n              \"    if (p == NULL && (*p = a)) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:3:24]: (warning) Either the condition 'p==NULL' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // check, and use\n        check(\"void f(struct X *p, int x) {\\n\"\n              \"    if (!p && x==1 || p && p->x==0) {\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            const char code[] = \"void f(Fred *fred) {\\n\"\n                                \"    if (fred == NULL) { }\\n\"\n                                \"    fred->x();\\n\"\n                                \"}\";\n\n            check(code);     // inconclusive\n            ASSERT_EQUALS(\"[test.cpp:2:14] -> [test.cpp:3:5]: (warning) Either the condition 'fred==NULL' is redundant or there is possible null pointer dereference: fred. [nullPointerRedundantCheck]\\n\", errout_str());\n        }\n\n        check(\"void f(char *s) {\\n\"   // #3358\n              \"    if (s==0);\\n\"\n              \"    strcpy(a, s?b:c);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // sizeof\n        check(\"void f(struct fred_t *fred) {\\n\"\n              \"    if (!fred)\\n\"\n              \"        int sz = sizeof(fred->x);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // check in macro\n        check(\"void f(int *x) {\\n\"\n              \"    $if (!x) {}\\n\"\n              \"    *x = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // return ?:\n        check(\"int f(ABC *p) {\\n\" // FP : return ?:\n              \"    if (!p) {}\\n\"\n              \"    return p ? p->x : 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"int f(ABC *p) {\\n\" // no fn\n              \"    if (!p) {}\\n\"\n              \"    return q ? p->x : 0;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2] -> [test.cpp:3]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p.\\n\", \"\", errout_str());\n\n        check(\"int f(ABC *p) {\\n\" // FP : return &&\n              \"    if (!p) {}\\n\"\n              \"    return p && p->x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int *p) {\\n\"\n              \"    if (x || !p) {}\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14] -> [test.cpp:3:6]: (warning) Either the condition '!p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        // sizeof\n        check(\"void f() {\\n\"\n              \"  int *pointer = NULL;\\n\"\n              \"  pointer = func(sizeof pointer[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Test CheckNullPointer::nullConstantDereference\n    void nullConstantDereference() {\n        check(\"int f() {\\n\"\n              \"    int* p = 0;\\n\"\n              \"    return p[4];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    typeof(*NULL) y;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int * f() {\\n\"\n              \"    return NULL;\\n\"\n              \"}\\n\"\n              \"int main() {\\n\"\n              \"  return *f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Null pointer dereference: f() [nullPointer]\\n\", errout_str());\n    }\n\n    void gcc_statement_expression() {\n        // Ticket #2621\n        check(\"void f(struct ABC *abc) {\\n\"\n              \"    ({ if (abc) dbg(); })\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void snprintf_with_zero_size() {\n        // Ticket #2840\n        check(\"void f() {\\n\"\n              \"    int bytes = snprintf(0, 0, \\\"%u\\\", 1);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void snprintf_with_non_zero_size() {\n        // Ticket #2840\n        check(\"void f() {\\n\"\n              \"    int bytes = snprintf(0, 10, \\\"%u\\\", 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n    }\n\n    void printf_with_invalid_va_argument() {\n        check(\"void f() {\\n\"\n              \"    printf(\\\"%s\\\", 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        check(\"void f(char* s) {\\n\"\n              \"    printf(\\\"%s\\\", s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char* s = 0;\\n\"\n              \"    printf(\\\"%s\\\", s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:18]: (error) Null pointer dereference: s [nullPointer]\\n\"\n            \"[test.cpp:3:18]: (error) Null pointer dereference [nullPointer]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char *s = 0;\\n\"\n              \"    printf(\\\"%s\\\", s == 0 ? a : s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    printf(\\\"%u%s\\\", 0, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        check(\"void f(char* s) {\\n\"\n              \"    printf(\\\"%u%s\\\", 0, s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char* s = 0;\\n\"\n              \"    printf(\\\"%u%s\\\", 123, s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:25]: (error) Null pointer dereference: s [nullPointer]\\n\"\n            \"[test.cpp:3:25]: (error) Null pointer dereference [nullPointer]\\n\",\n            errout_str());\n\n\n        check(\"void f() {\\n\"\n              \"    printf(\\\"%%%s%%\\\", 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        check(\"void f(char* s) {\\n\"\n              \"    printf(\\\"text: %s, %s\\\", s, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:31]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n\n        check(\"void f() {\\n\"\n              \"    char* s = \\\"blabla\\\";\\n\"\n              \"    printf(\\\"%s\\\", s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"void f(char* s) {\\n\"\n              \"    printf(\\\"text: %m%s, %s\\\", s, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:33]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        check(\"void f(char* s) {\\n\"\n              \"    printf(\\\"text: %*s, %s\\\", s, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:32]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        // Ticket #3364\n        check(\"void f() {\\n\"\n              \"    printf(\\\"%-*.*s\\\", s, 0);\\n\"\n              \"    sprintf(\\\"%*\\\", s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void scanf_with_invalid_va_argument() {\n        check(\"void f(char* s) {\\n\"\n              \"    sscanf(s, \\\"%s\\\", 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:21]: (error) Null pointer dereference [nullPointer]\\n\"\n            \"[test.cpp:2:21]: (error) Null pointer dereference [nullPointer]\\n\",   // duplicate\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"    scanf(\\\"%d\\\", 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:17]: (error) Null pointer dereference [nullPointer]\\n\"\n            \"[test.cpp:2:17]: (error) Null pointer dereference [nullPointer]\\n\",   // duplicate\n            errout_str());\n\n        check(\"void f(char* foo) {\\n\"\n              \"    char location[200];\\n\"\n              \"    int width, height;\\n\"\n              \"    sscanf(imgInfo, \\\"%s %d %d\\\", location, &width, &height);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // ticket #3207\n\n        check(\"void f(char *dummy) {\\n\"\n              \"    int iVal;\\n\"\n              \"    sscanf(dummy, \\\"%d%c\\\", &iVal);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // ticket #3211\n\n        check(\"void f(char *dummy) {\\n\"\n              \"    int* iVal = 0;\\n\"\n              \"    sscanf(dummy, \\\"%d\\\", iVal);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:25]: (error) Null pointer dereference: iVal [nullPointer]\\n\"\n            \"[test.cpp:3:25]: (error) Null pointer dereference [nullPointer]\\n\"\n            \"[test.cpp:3:25]: (error) Null pointer dereference [nullPointer]\\n\",   // duplicate\n            errout_str());\n\n        check(\"void f(char *dummy) {\\n\"\n              \"    int* iVal;\\n\"\n              \"    sscanf(dummy, \\\"%d\\\", foo(iVal));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *dummy) {\\n\"\n              \"    int* iVal = 0;\\n\"\n              \"    sscanf(dummy, \\\"%d%d\\\", foo(iVal), iVal);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char* dummy) {\\n\"\n              \"    sscanf(dummy, \\\"%*d%u\\\", 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:28]: (error) Null pointer dereference [nullPointer]\\n\"\n            \"[test.cpp:2:28]: (error) Null pointer dereference [nullPointer]\\n\",   // duplicate\n            errout_str());\n    }\n\n    void nullpointer_in_return() {\n        // extracttests.start: int maybe(); int *g();\n        check(\"int foo() {\\n\"\n              \"    int* iVal = 0;\\n\"\n              \"    if(maybe()) iVal = g();\\n\"\n              \"    return iVal[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (warning) Possible null pointer dereference: iVal [nullPointer]\\n\", errout_str());\n\n        check(\"int foo(int* iVal) {\\n\"\n              \"    return iVal[0];\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer_in_typeid() {\n        // Should throw std::bad_typeid\n        check(\"struct PolymorphicA { virtual ~A() {} };\\n\"\n              \"bool foo() {\\n\"\n              \"     PolymorphicA* a = 0;\\n\"\n              \"     return typeid(*a) == typeid(*a);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct NonPolymorphicA { ~A() {} };\\n\"\n              \"bool foo() {\\n\"\n              \"     NonPolymorphicA* a = 0;\\n\"\n              \"     return typeid(*a) == typeid(*a);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo() {\\n\"\n              \"     char* c = 0;\\n\"\n              \"     return typeid(*c) == typeid(*c);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer_in_alignof() // #11401\n    {\n        check(\"size_t foo() {\\n\"\n              \"    char* c = 0;\\n\"\n              \"    return alignof(*c);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t foo() {\\n\"\n              \"    return alignof(*0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int *p) {\\n\"\n              \"    f(alignof(*p));\\n\"\n              \"    if (p) {}\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t foo() {\\n\"\n              \"    char* c = 0;\\n\"\n              \"    return _Alignof(*c);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t foo() {\\n\"\n              \"    return _alignof(*0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t foo() {\\n\"\n              \"    return __alignof(*0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t foo() {\\n\"\n              \"    return __alignof__(*0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointer_in_for_loop() {\n        // Ticket #3278\n        check(\"void f(int* ptr, int cnt){\\n\"\n              \" if (!ptr)\\n\"\n              \"  cnt = 0;\\n\"\n              \" for (int i = 0; i < cnt; ++i)\\n\"\n              \"  *ptr++ = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11635\n        check(\"void f(char *cons, int rlen, int pos) {\\n\"\n              \"    int i;\\n\"\n              \"    char* cp1;\\n\"\n              \"    for (cp1 = &cons[pos], i = 1; i < rlen; cp1--)\\n\"\n              \"        if (*cp1 == '*')\\n\"\n              \"            continue;\\n\"\n              \"        else\\n\"\n              \"            i++;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointerDeadCode() {\n        // Ticket #11311\n        check (\"void f() {\\n\"\n               \"    if (0)\\n\"\n               \"        *(int *)0 = 1;\\n\"\n               \"    else\\n\"\n               \"         ;\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check (\"void f() {\\n\"\n               \"    if (0)\\n\"\n               \"        *(int *)0 = 1;\\n\"\n               \"    else {\\n\"\n               \"        if (0)\\n\"\n               \"            *(int *)0 = 2;\\n\"\n               \"        else\\n\"\n               \"            ;\\n\"\n               \"    }\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check (\"void f() {\\n\"\n               \"    while(0)\\n\"\n               \"        *(int*)0 = 1;\\n\"\n               \"    do {\\n\"\n               \"    } while(0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check (\"int f() {\\n\"\n               \"    return 0 ? *(int*)0 = 1 : 1;\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check (\"int f() {\\n\"\n               \"    return 1 ? 1 : *(int*)0 = 1;\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointerDelete() {\n        check(\"void f() {\\n\"\n              \"  K *k = getK();\\n\"\n              \"  if (k)\\n\"\n              \"     k->doStuff();\\n\"\n              \"  delete k;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  K *k = getK();\\n\"\n              \"  if (k)\\n\"\n              \"     k[0] = ptr;\\n\"\n              \"  delete [] k;\\n\"\n              \"  k = new K[10];\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointerSubFunction() {\n        check(\"void g(int* x) { *x; }\\n\"\n              \"void f(int* x) {\\n\"\n              \"    if (x)\\n\"\n              \"        g(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointerExit() {\n        check(\"void f() {\\n\"\n              \"  K *k = getK();\\n\"\n              \"  if (!k)\\n\"\n              \"     exit(1);\\n\"\n              \"  k->f();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nullpointerStdString() {\n        check(\"void f(std::string s1) {\\n\"\n              \"    void* p = 0;\\n\"\n              \"    s1 = 0;\\n\"\n              \"    s1 = '\\\\0';\\n\"\n              \"    std::string s2 = 0;\\n\"\n              \"    std::string s2 = '\\\\0';\\n\"\n              \"    std::string s3(0);\\n\"\n              \"    foo(std::string(0));\\n\"\n              \"    s1 = p;\\n\"\n              \"    std::string s4 = p;\\n\"\n              \"    std::string s5(p);\\n\"\n              \"    foo(std::string(p));\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:9:10]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:10:22]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:11:20]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:12:21]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:3:10]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:5:22]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:7:17]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:8:9]: (error) Null pointer dereference [nullPointer]\\n\"\n                      , errout_str());\n\n        check(\"void f(std::string s1) {\\n\"\n              \"    s1 = nullptr;\\n\"\n              \"    std::string s2 = nullptr;\\n\"\n              \"    std::string s3(nullptr);\\n\"\n              \"    foo(std::string(nullptr));\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:3:22]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:4:17]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:5:9]: (error) Null pointer dereference [nullPointer]\\n\"\n                      , errout_str());\n\n        check(\"void f(std::string s1) {\\n\"\n              \"    s1 = NULL;\\n\"\n              \"    std::string s2 = NULL;\\n\"\n              \"    std::string s3(NULL);\\n\"\n              \"    foo(std::string(NULL));\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:3:22]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:4:17]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:5:9]: (error) Null pointer dereference [nullPointer]\\n\"\n                      , errout_str());\n\n        check(\"void f(std::string s1, const std::string& s2, const std::string* s3) {\\n\"\n              \"    void* p = 0;\\n\"\n              \"    if (x) { return; }\\n\"\n              \"    foo(s1 == p);\\n\"\n              \"    foo(s2 == p);\\n\"\n              \"    foo(s3 == p);\\n\"\n              \"    foo(p == s1);\\n\"\n              \"    foo(p == s2);\\n\"\n              \"    foo(p == s3);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:5:15]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:7:9]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:8:9]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"void f(std::string s1, const std::string& s2, const std::string* s3) {\\n\"\n              \"    void* p = 0;\\n\"\n              \"    if (x) { return; }\\n\"\n              \"    foo(0 == s1.size());\\n\"\n              \"    foo(0 == s2.size());\\n\"\n              \"    foo(0 == s3->size());\\n\"\n              \"    foo(s1.size() == 0);\\n\"\n              \"    foo(s2.size() == 0);\\n\"\n              \"    foo(s3->size() == 0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string s1, const std::string& s2) {\\n\"\n              \"    if (x) { return; }\\n\"\n              \"    foo(0 == s1[0]);\\n\"\n              \"    foo(0 == s2[0]);\\n\"\n              \"    foo(s1[0] == 0);\\n\"\n              \"    foo(s2[0] == 0);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string s1, const std::string& s2) {\\n\"\n              \"    if (x) { return; }\\n\"\n              \"    foo(s1 == '\\\\0');\\n\"\n              \"    foo(s2 == '\\\\0');\\n\"\n              \"    foo('\\\\0' == s1);\\n\"\n              \"    foo('\\\\0' == s2);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class Bar {\\n\"\n              \"    std::string s;\\n\"\n              \"    Bar() : s(0) {}\\n\"\n              \"};\\n\"\n              \"class Foo {\\n\"\n              \"    std::string s;\\n\"\n              \"    Foo();\\n\"\n              \"};\\n\"\n              \"Foo::Foo() : s(0) {}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:9:14]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::string s = 0 == x ? \\\"a\\\" : \\\"b\\\";\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  const std::string s = g();\\n\"\n              \"  ASSERT_MESSAGE(\\\"Error on s\\\", 0 == s.compare(\\\"Some text\\\"));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int i, std::string s);\\n\"\n              \"void bar() {\\n\"\n              \"  foo(0, \\\"\\\");\\n\"\n              \"  foo(0, 0);\\n\"\n              \"  foo(var, 0);\\n\"\n              \"  foo(var, NULL);\\n\"\n              \"  foo(var, nullptr);\\n\"\n              \"  foo(0, var);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:5:12]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:6:12]: (error) Null pointer dereference [nullPointer]\\n\"\n                      \"[test.cpp:7:12]: (error) Null pointer dereference [nullPointer]\\n\", errout_str());\n\n        check(\"std::string f() {\\n\" // #9827\n              \"  char* p = NULL;\\n\"\n              \"  int r = g(p);\\n\"\n              \"  if (!r)\\n\"\n              \"    return \\\"\\\";\\n\"\n              \"  std::string s(p);\\n\"\n              \"  return s;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #11078\n              \"    const char* p = nullptr;\\n\"\n              \"    std::string s1{ p };\\n\"\n              \"    std::string s2{ nullptr };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:21]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:4:17]: (error) Null pointer dereference [nullPointer]\\n\",\n                      errout_str());\n\n        check(\"const char* g(long) { return nullptr; }\\n\" // #11561\n              \"void f() { std::string s = g(0L); }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:29]: (error) Null pointer dereference: g(0L) [nullPointer]\\n\",\n                      errout_str());\n    }\n\n    void nullpointerStdStream() {\n        check(\"void f(std::ifstream& is) {\\n\"\n              \"    char* p = 0;\\n\"\n              \"    is >> p;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (error) Possible null pointer dereference: p\\n\", \"\", errout_str());\n\n        check(\"void f(const std::ostringstream& oss, char* q) {\\n\"\n              \"    char const* p = 0;\\n\" // Simplification makes detection of bug difficult\n              \"    oss << p;\\n\"\n              \"    oss << foo << p;\\n\"\n              \"    if(q == 0)\\n\"\n              \"        oss << foo << q;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:4:19]: (error) Null pointer dereference: p [nullPointer]\\n\"\n                      \"[test.cpp:5:10] -> [test.cpp:6:23]: (warning) Either the condition 'q==0' is redundant or there is possible null pointer dereference: q. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(const char* p) {\\n\"\n              \"    if(p == 0) {\\n\"\n              \"        std::cout << p;\\n\"\n              \"        std::cerr << p;\\n\"\n              \"        std::cin >> p;\\n\"\n              \"        std::cout << abc << p;\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:3:22]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\"\n                           \"[test.cpp:2:10] -> [test.cpp:4:22]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\"\n                           \"[test.cpp:2:10] -> [test.cpp:5]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\"\n                           \"[test.cpp:2:10] -> [test.cpp:6]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n                           \"[test.cpp:2:10] -> [test.cpp:3:22]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\"\n                           \"[test.cpp:2:10] -> [test.cpp:4:22]: (warning) Either the condition 'p==0' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n                           errout_str());\n\n        check(\"void f() {\\n\"\n              \"    void* p1 = 0;\\n\"\n              \"    std::cout << p1;\\n\" // No char*\n              \"    char* p2 = 0;\\n\"\n              \"    std::cin >> (int)p;\\n\" // result casted\n              \"    std::cout << (int)p;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::string& str) {\\n\"\n              \"    long long ret = 0;\\n\"\n              \"    std::istringstream istr(str);\\n\"\n              \"    istr >> std::hex >> ret;\\n\" // Read integer\n              \"    return ret;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int* i) {\\n\"\n              \"    if(i) return;\\n\"\n              \"    std::cout << i;\\n\" // Its no char* (#4240)\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5811 false positive: (error) Null pointer dereference\n        check(\"using namespace std;\\n\"\n              \"std::string itoip(int ip) {\\n\"\n              \"    stringstream out;\\n\"\n              \"    out << ((ip >> 0) & 0xFF);\\n\"\n              \"    return out.str();\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n        // avoid regression from first fix attempt for #5811...\n        check(\"void deserialize(const std::string &data) {\\n\"\n              \"std::istringstream iss(data);\\n\"\n              \"unsigned int len = 0;\\n\"\n              \"if (!(iss >> len))\\n\"\n              \"    return;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void nullpointerSmartPointer() {\n        // extracttests.start: void dostuff(int);\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::shared_ptr<Fred> p) {\\n\"\n              \"  if (p) {}\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7] -> [test.cpp:4:11]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::shared_ptr<Fred> p) {\\n\"\n              \"  p = nullptr;\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::unique_ptr<Fred> p) {\\n\"\n              \"  if (p) {}\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7] -> [test.cpp:4:11]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::unique_ptr<Fred> p) {\\n\"\n              \"  p = nullptr;\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f() {\\n\"\n              \"  std::shared_ptr<Fred> p;\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::shared_ptr<Fred> p) {\\n\"\n              \"  p.reset();\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::shared_ptr<Fred> p) {\\n\"\n              \"  Fred * pp = nullptr;\\n\"\n              \"  p.reset(pp);\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(Fred& f) {\\n\"\n              \"  std::shared_ptr<Fred> p;\\n\"\n              \"  p.reset(&f);\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f(std::shared_ptr<Fred> p) {\\n\"\n              \"  p.reset();\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct Fred { int x; };\\n\"\n              \"void f() {\\n\"\n              \"  std::shared_ptr<Fred> p(nullptr);\\n\"\n              \"  dostuff(p->x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Null pointer dereference: p [nullPointer]\\n\", errout_str());\n\n        check(\"struct A {};\\n\"\n              \"void f(int n) {\\n\"\n              \"    std::unique_ptr<const A*[]> p;\\n\"\n              \"    p.reset(new const A*[n]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9216\n        check(\"struct A {\\n\"\n              \"    void reset();\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void g(std::unique_ptr<A> var) {\\n\"\n              \"    var->reset();\\n\"\n              \"    var->f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9439\n        check(\"char* g();\\n\"\n              \"char* f() {\\n\"\n              \"    std::unique_ptr<char> x(g());\\n\"\n              \"    if( x ) {}\\n\"\n              \"    return x.release();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9496\n        check(\"std::shared_ptr<int> f() {\\n\"\n              \"    return std::shared_ptr<int>(nullptr);\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    int a = *f();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (error) Null pointer dereference: f() [nullPointer]\\n\", errout_str());\n    }\n\n    void nullpointerOutOfMemory() {\n        check(\"void f() {\\n\"\n              \"    int *p = malloc(10);\\n\"\n              \"    *p = 0;\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (warning) If memory allocation fails, then there is a possible null pointer dereference: p [nullPointerOutOfMemory]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *p = malloc(10);\\n\"\n              \"    *(p+2) = 0;\\n\"\n              \"    free(p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (error) If memory allocation fails: pointer addition with NULL pointer. [nullPointerArithmeticOutOfMemory]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #13676\n              \"    int* q = static_cast<int*>(std::malloc(4));\\n\"\n              \"    *q = 0;\\n\"\n              \"    std::free(q);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (warning) If memory allocation fails, then there is a possible null pointer dereference: q [nullPointerOutOfMemory]\\n\", errout_str());\n    }\n\n    void functioncall() {    // #3443 - function calls\n        // dereference pointer and then check if it's null\n        {\n            // function not seen\n            check(\"void f(int *p) {\\n\"\n                  \"    *p = 0;\\n\"\n                  \"    foo(p);\\n\"\n                  \"    if (p) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // function seen (taking pointer parameter)\n            check(\"void foo(int *p) { }\\n\"\n                  \"\\n\"\n                  \"void f(int *p) {\\n\"\n                  \"    *p = 0;\\n\"\n                  \"    foo(p);\\n\"\n                  \"    if (p) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\n                \"[test.cpp:6:9] -> [test.cpp:4:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n\n            // function seen (taking reference parameter)\n            check(\"void foo(int *&p) { }\\n\"\n                  \"\\n\"\n                  \"void f(int *p) {\\n\"\n                  \"    *p = 0;\\n\"\n                  \"    foo(p);\\n\"\n                  \"    if (p) { }\\n\"\n                  \"}\", dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // function implementation not seen\n            check(\"void foo(int *p);\\n\"\n                  \"\\n\"\n                  \"void f(int *p) {\\n\"\n                  \"    *p = 0;\\n\"\n                  \"    foo(p);\\n\"\n                  \"    if (p) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\n                \"[test.cpp:6:9] -> [test.cpp:4:6]: (warning) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n\n            // inconclusive\n            check(\"void f(int *p) {\\n\"\n                  \"    *p = 0;\\n\"\n                  \"    foo(p);\\n\"\n                  \"    if (p) { }\\n\"\n                  \"}\", dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\n                \"[test.cpp:4:9] -> [test.cpp:2:6]: (warning, inconclusive) Either the condition 'p' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n        }\n\n        // dereference struct pointer and then check if it's null\n        {\n            // function not seen\n            check(\"void f(struct ABC *abc) {\\n\"\n                  \"    abc->a = 0;\\n\"\n                  \"    foo(abc);\\n\"\n                  \"    if (abc) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // function seen (taking pointer parameter)\n            check(\"void foo(struct ABC *abc) { }\\n\"\n                  \"\\n\"\n                  \"void f(struct ABC *abc) {\\n\"\n                  \"    abc->a = 0;\\n\"\n                  \"    foo(abc);\\n\"\n                  \"    if (abc) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\n                \"[test.cpp:6:9] -> [test.cpp:4:5]: (warning) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n\n            // function implementation not seen\n            check(\"void foo(struct ABC *abc);\\n\"\n                  \"\\n\"\n                  \"void f(struct ABC *abc) {\\n\"\n                  \"    abc->a = 0;\\n\"\n                  \"    foo(abc);\\n\"\n                  \"    if (abc) { }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\n                \"[test.cpp:6:9] -> [test.cpp:4:5]: (warning) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n\n            // inconclusive\n            check(\"void f(struct ABC *abc) {\\n\"\n                  \"    abc->a = 0;\\n\"\n                  \"    foo(abc);\\n\"\n                  \"    if (abc) { }\\n\"\n                  \"}\", dinit(CheckOptions, $.inconclusive = true));\n            ASSERT_EQUALS(\n                \"[test.cpp:4:9] -> [test.cpp:2:5]: (warning, inconclusive) Either the condition 'abc' is redundant or there is possible null pointer dereference: abc. [nullPointerRedundantCheck]\\n\",\n                errout_str());\n        }\n    }\n\n    void functioncalllibrary() {\n        SimpleTokenizer tokenizer(settingsDefault,*this,false);\n        const char code[] = \"void f() { int a,b,c; x(a,b,c); }\";\n        ASSERT_EQUALS(true, tokenizer.tokenize(code));\n        const Token *xtok = Token::findsimplematch(tokenizer.tokens(), \"x\");\n\n        // nothing bad..\n        {\n            constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                       \"<def>\\n\"\n                                       \"  <function name=\\\"x\\\">\\n\"\n                                       \"    <arg nr=\\\"1\\\"></arg>\\n\"\n                                       \"    <arg nr=\\\"2\\\"></arg>\\n\"\n                                       \"    <arg nr=\\\"3\\\"></arg>\\n\"\n                                       \"  </function>\\n\"\n                                       \"</def>\";\n\n            Library library;\n            ASSERT(LibraryHelper::loadxmldata(library, xmldata, sizeof(xmldata)));\n\n            std::list<const Token *> null;\n            CheckNullPointer::parseFunctionCall(*xtok, null, library);\n            ASSERT_EQUALS(0U, null.size());\n        }\n\n        // for 1st parameter null pointer is not ok..\n        {\n            constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                       \"<def>\\n\"\n                                       \"  <function name=\\\"x\\\">\\n\"\n                                       \"    <arg nr=\\\"1\\\"><not-null/></arg>\\n\"\n                                       \"    <arg nr=\\\"2\\\"></arg>\\n\"\n                                       \"    <arg nr=\\\"3\\\"></arg>\\n\"\n                                       \"  </function>\\n\"\n                                       \"</def>\";\n\n            Library library;\n            ASSERT(LibraryHelper::loadxmldata(library, xmldata, sizeof(xmldata)));\n\n            std::list<const Token *> null;\n            CheckNullPointer::parseFunctionCall(*xtok, null, library);\n            ASSERT_EQUALS(1U, null.size());\n            ASSERT_EQUALS(\"a\", null.front()->str());\n        }\n    }\n\n    void functioncallDefaultArguments() {\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    if (!p)\\n\"\n              \"        return;\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char a, int *p = 0) {\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    printf(\\\"p = %d\\\", *p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    printf(\\\"p[1] = %d\\\", p[1]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    buf[p] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    if (p != 0 && bar())\\n\"\n              \"      *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p) {\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    if (p != 0)\\n\"\n              \"      *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    int y;\\n\"\n              \"    if (p == 0)\\n\"\n              \"      p = &y;\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a, int *p = 0) {\\n\"\n              \"    if (a != 0)\\n\"\n              \"      *p = 0;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:3:8]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\",\n            errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    p = a;\\n\"\n              \"    *p = 0;\\n\" // <- don't simplify and verify\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    p += a;\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int *p = 0) {\\n\"\n              \"    if (p == 0) {\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"    return *p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    std::cout << p ? *p : 0;\\n\" // Due to operator precedence, this is equivalent to: (std::cout << p) ? *p : 0;\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str()); // Check the first branch of ternary\n\n        check(\"void f(char *p = 0) {\\n\"\n              \"    std::cout << p ? *p : 0;\\n\" // Due to operator precedence, this is equivalent to: (std::cout << p) ? *p : 0;\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:18]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\"\n            \"[test.cpp:2:23]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\",   // duplicate\n            errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    std::cout << (p ? *p : 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    std::cout << p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    std::cout << (p && p[0] ? *p : 42);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void isEmpty(int *p = 0) {\\n\"\n              \"    return p && *p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int *p = 0) {\\n\"\n              \"    return !p || *p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        // bar may initialize p but be can't know for sure without knowing\n        // if p is passed in by reference and is modified by bar()\n        check(\"void f(int *p = 0) {\\n\"\n              \"    bar(p);\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    printf(\\\"%p\\\", p);\\n\"\n              \"    *p = 0;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str());\n\n        // The init() function may or may not initialize p, but since the address\n        // of p is passed in, it's a good bet that p may be modified and\n        // so we should not report an error.\n        check(\"void f(int *p = 0) {\\n\"\n              \"    init(&p);\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void init(int* &g);\\n\"\n              \"void f(int *p = 0) {\\n\"\n              \"    init(p);\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    if (p == 0) {\\n\"\n              \"        init(&p);\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *p = 0) {\\n\"\n              \"    if (p == 0) {\\n\"\n              \"        throw SomeException;\\n\"\n              \"    }\\n\"\n              \"    *p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int x, int *p = 0) {\\n\"\n              \"    int var1 = x ? *p : 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:21]: (warning) Possible null pointer dereference if the default parameter value is used: p [nullPointerDefaultArg]\\n\", errout_str());\n\n        check(\"void f(int* i = nullptr) { *i = 0; }\\n\" // #11567\n              \"void g() { f(); }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:29]: (warning) Possible null pointer dereference if the default parameter value is used: i [nullPointerDefaultArg]\\n\", errout_str());\n    }\n\n    void nullpointer_internal_error() { // ticket #5080\n        check(\"struct A { unsigned int size; };\\n\"\n              \"struct B { struct A *a; };\\n\"\n              \"void f(struct B *b) {\\n\"\n              \"    unsigned int j;\\n\"\n              \"    for (j = 0; j < b[0].a->size; ++j) {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ticket6505() {\n        check(\"void foo(MythSocket *socket) {\\n\"\n              \"  bool do_write=0;\\n\"\n              \"  if (socket) {\\n\"\n              \"    do_write=something();\\n\"\n              \"  }\\n\"\n              \"  if (do_write) {\\n\"\n              \"    socket->func();\\n\"\n              \"  }\\n\"\n              \"}\\n\"\n              \"void bar() {\\n\"\n              \"  foo(0);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void subtract() {\n        check(\"void foo(char *s) {\\n\"\n              \"  char *p = s - 20;\\n\"\n              \"}\\n\"\n              \"void bar() { foo(0); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (error) Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]\\n\",\n                      errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  if (!s) {}\\n\"\n              \"  char *p = s - 20;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7] -> [test.cpp:3:15]: (warning) Either the condition '!s' is redundant or there is overflow in pointer subtraction. [nullPointerArithmeticRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  s -= 20;\\n\"\n              \"}\\n\"\n              \"void bar() { foo(0); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (error) Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]\\n\",\n                      errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  if (!s) {}\\n\"\n              \"  s -= 20;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7] -> [test.cpp:3:5]: (warning) Either the condition '!s' is redundant or there is overflow in pointer subtraction. [nullPointerArithmeticRedundantCheck]\\n\", errout_str());\n\n        check(\"int* f8() { int *x = NULL; return --x; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:35]: (error) Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]\\n\", errout_str());\n\n        check(\"int* f9() { int *x = NULL; return x--; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:36]: (error) Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]\\n\", errout_str());\n    }\n\n    void addNull() {\n        check(\"void foo(char *s) {\\n\"\n              \"  char * p = s + 20;\\n\"\n              \"}\\n\"\n              \"void bar() { foo(0); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (error) Pointer addition with NULL pointer. [nullPointerArithmetic]\\n\", errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  if (!s) {}\\n\"\n              \"  char * p = s + 20;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7] -> [test.cpp:3:16]: (warning) Either the condition '!s' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  char * p = 20 + s;\\n\"\n              \"}\\n\"\n              \"void bar() { foo(0); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (error) Pointer addition with NULL pointer. [nullPointerArithmetic]\\n\", errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  if (!s) {}\\n\"\n              \"  char * p = 20 + s;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7] -> [test.cpp:3:17]: (warning) Either the condition '!s' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]\\n\", errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  s += 20;\\n\"\n              \"}\\n\"\n              \"void bar() { foo(0); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (error) Pointer addition with NULL pointer. [nullPointerArithmetic]\\n\", errout_str());\n\n        check(\"void foo(char *s) {\\n\"\n              \"  if (!s) {}\\n\"\n              \"  s += 20;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7] -> [test.cpp:3:5]: (warning) Either the condition '!s' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]\\n\", errout_str());\n\n        check(\"int* f7() { int *x = NULL; return ++x; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:35]: (error) Pointer addition with NULL pointer. [nullPointerArithmetic]\\n\", errout_str());\n\n        check(\"int* f10() { int *x = NULL; return x++; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:37]: (error) Pointer addition with NULL pointer. [nullPointerArithmetic]\\n\", errout_str());\n\n        check(\"class foo {};\\n\"\n              \"const char* get() const { return 0; }\\n\"\n              \"void f(foo x) { if (get()) x += get(); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typedef struct { uint8_t* buf, *buf_end; } S;\\n\" // #11117\n              \"void f(S* s, uint8_t* buffer, int buffer_size) {\\n\"\n              \"    if (buffer_size < 0) {\\n\"\n              \"        buffer_size = 0;\\n\"\n              \"        buffer = NULL;\\n\"\n              \"    }\\n\"\n              \"    s->buf = buffer;\\n\"\n              \"    s->buf_end = s->buf + buffer_size;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void isPointerDeRefFunctionDecl() {\n        check(\"const char** get() { return 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define ctu(code) ctu_(code, __FILE__, __LINE__)\n    template<size_t size>\n    void ctu_(const char (&code)[size], const char* file, int line) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CTU::FileInfo *ctu = CTU::getFileInfo(tokenizer);\n\n        // Check code..\n        std::list<Check::FileInfo*> fileInfo;\n        Check& c = getCheck<CheckNullPointer>();\n        fileInfo.push_back(c.getFileInfo(tokenizer, settings, \"\"));\n        c.analyseWholeProgram(*ctu, fileInfo, settings, *this); // TODO: check result\n        while (!fileInfo.empty()) {\n            delete fileInfo.back();\n            fileInfo.pop_back();\n        }\n        delete ctu;\n    }\n\n    void ctuTest() {\n        setMultiline();\n\n        ctu(\"void f(int *fp) {\\n\"\n            \"    a = *fp;\\n\"\n            \"}\\n\"\n            \"int main() {\\n\"\n            \"  int *p = 0;\\n\"\n            \"  f(p);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: error: Null pointer dereference: fp [ctunullpointer]\\n\"\n                      \"[test.cpp:5:12]: note: Assignment 'p=0', assigned value is 0\\n\"\n                      \"[test.cpp:6:4]: note: Calling function f, 1st argument is null\\n\"\n                      \"[test.cpp:2:10]: note: Dereferencing argument fp that is null\\n\", errout_str());\n\n        ctu(\"void use(int *p) { a = *p + 3; }\\n\"\n            \"void call(int x, int *p) { x++; use(p); }\\n\"\n            \"int main() {\\n\"\n            \"  call(4,0);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:25]: error: Null pointer dereference: p [ctunullpointer]\\n\"\n                      \"[test.cpp:4:7]: note: Calling function call, 2nd argument is null\\n\"\n                      \"[test.cpp:2:33]: note: Calling function use, 1st argument is null\\n\"\n                      \"[test.cpp:1:25]: note: Dereferencing argument p that is null\\n\", errout_str());\n\n        ctu(\"void dostuff(int *x, int *y) {\\n\"\n            \"  if (!var)\\n\"\n            \"    return -1;\\n\"  // <- early return\n            \"  *x = *y;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void f() {\\n\"\n            \"  dostuff(a, 0);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void dostuff(int *x, int *y) {\\n\"\n            \"  if (cond)\\n\"\n            \"    *y = -1;\\n\"  // <- conditionally written\n            \"  *x = *y;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void f() {\\n\"\n            \"  dostuff(a, 0);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // else\n        ctu(\"void dostuff(int mask, int *p) {\\n\"\n            \"  if (mask == 13) ;\\n\"\n            \"  else *p = 45;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void f() {\\n\"\n            \"  dostuff(0, 0);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ?, &&, ||\n        ctu(\"void dostuff(int mask, int *p) {\\n\"\n            \"  x = (mask & 1) ? *p : 0;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void f() {\\n\"\n            \"  dostuff(0, 0);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void g(int* x) { *x; }\\n\"\n            \"void f(int* x) {\\n\"\n            \"    if (x)\\n\"\n            \"        g(x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"size_t f(int* p) {\\n\"\n            \"    size_t len = sizeof(*p);\\n\"\n            \"    return len;\\n\"\n            \"}\\n\"\n            \"void g() {\\n\"\n            \"    f(NULL);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"size_t f(int* p) {\\n\"\n            \"    size_t len = alignof(*p);\\n\"\n            \"    return len;\\n\"\n            \"}\\n\"\n            \"void g() {\\n\"\n            \"    f(NULL);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ctu: memory allocation fails\n        ctu(\"void f(int* p) {\\n\"\n            \"    *p = 0;\\n\"\n            \"}\\n\"\n            \"void g() {\\n\"\n            \"    int* q = (int*)malloc(4);\\n\"\n            \"    f(q);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:6]: warning: If memory allocation fails, then there is a possible null pointer dereference: p [ctunullpointerOutOfMemory]\\n\"\n                      \"[test.cpp:5:26]: note: Assuming allocation function fails\\n\"\n                      \"[test.cpp:5:14]: note: Assignment 'q=(int*)malloc(4)', assigned value is 0\\n\"\n                      \"[test.cpp:6:6]: note: Calling function f, 1st argument is null\\n\"\n                      \"[test.cpp:2:6]: note: Dereferencing argument p that is null\\n\", errout_str());\n\n        // ctu: resource allocation fails\n        ctu(\"void foo(FILE* f) {\\n\"\n            \"    fprintf(f, a);\\n\"\n            \"}\\n\"\n            \"void bar() {\\n\"\n            \"    FILE* f = fopen(notexist,t);\\n\"\n            \"    foo(f);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: warning: If resource allocation fails, then there is a possible null pointer dereference: f [ctunullpointerOutOfResources]\\n\"\n                      \"[test.cpp:5:20]: note: Assuming allocation function fails\\n\"\n                      \"[test.cpp:5:20]: note: Assignment 'f=fopen(notexist,t)', assigned value is 0\\n\"\n                      \"[test.cpp:6:8]: note: Calling function foo, 1st argument is null\\n\"\n                      \"[test.cpp:2:13]: note: Dereferencing argument f that is null\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestNullPointer)\n"
    }
  ]
}