{
  "name": "checkIncorrectLogicOperator",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 182,
  "branches": 39,
  "apis": 152,
  "test": [
    {
      "description": null,
      "expected-problems": 17,
      "expected-linenumbers": [
        954,
        1048,
        1273,
        1286,
        1302,
        1309,
        1336,
        1370,
        1377,
        1386,
        1395,
        1409,
        1503,
        1518,
        1725,
        1748,
        1755
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkcondition.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"platform.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n#include <limits>\n#include <string>\n\nclass TestCondition : public TestFixture {\npublic:\n    TestCondition() : TestFixture(\"TestCondition\") {}\n\nprivate:\n    const Settings settings0 = settingsBuilder().library(\"qt.cfg\").library(\"std.cfg\").severity(Severity::style).severity(Severity::warning).build();\n    /*const*/ Settings settings1 = settingsBuilder().severity(Severity::style).severity(Severity::warning).build();\n\n    void run() override {\n        const char cfg[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                           \"<def>\\n\"\n                           \"  <function name=\\\"bar\\\"> <pure/> </function>\\n\"\n                           \"</def>\";\n        settings1 = settingsBuilder(settings1).libraryxml(cfg).build();\n\n        mNewTemplate = true;\n        TEST_CASE(assignAndCompare);   // assignment and comparison don't match\n        TEST_CASE(mismatchingBitAnd);  // overlapping bitmasks\n        TEST_CASE(comparison);         // CheckCondition::comparison test cases\n        TEST_CASE(multicompare);       // mismatching comparisons\n        TEST_CASE(overlappingElseIfCondition);  // overlapping conditions in if and else-if\n        TEST_CASE(oppositeElseIfCondition); // opposite conditions in if and else-if\n\n        TEST_CASE(checkBadBitmaskCheck);\n\n        TEST_CASE(incorrectLogicOperator1);\n        TEST_CASE(incorrectLogicOperator2);\n        TEST_CASE(incorrectLogicOperator3);\n        TEST_CASE(incorrectLogicOperator4);\n        TEST_CASE(incorrectLogicOperator5); // complex expressions\n        TEST_CASE(incorrectLogicOperator6); // char literals\n        TEST_CASE(incorrectLogicOperator7); // opposite expressions: (expr || !expr)\n        TEST_CASE(incorrectLogicOperator8); // !\n        TEST_CASE(incorrectLogicOperator9);\n        TEST_CASE(incorrectLogicOperator10); // enum\n        TEST_CASE(incorrectLogicOperator11);\n        TEST_CASE(incorrectLogicOperator12);\n        TEST_CASE(incorrectLogicOperator13);\n        TEST_CASE(incorrectLogicOperator14);\n        TEST_CASE(incorrectLogicOperator15);\n        TEST_CASE(incorrectLogicOperator16); // #10070\n        TEST_CASE(incorrectLogicOperator17);\n        TEST_CASE(secondAlwaysTrueFalseWhenFirstTrueError);\n        TEST_CASE(incorrectLogicOp_condSwapping);\n        TEST_CASE(testBug5895);\n        TEST_CASE(testBug5309);\n\n        TEST_CASE(modulo);\n\n        TEST_CASE(oppositeInnerCondition);\n        TEST_CASE(oppositeInnerConditionPointers);\n        TEST_CASE(oppositeInnerConditionClass);\n        TEST_CASE(oppositeInnerConditionUndeclaredVariable);\n        TEST_CASE(oppositeInnerConditionAlias);\n        TEST_CASE(oppositeInnerCondition2);\n        TEST_CASE(oppositeInnerCondition3);\n        TEST_CASE(oppositeInnerConditionAnd);\n        TEST_CASE(oppositeInnerConditionOr);\n        TEST_CASE(oppositeInnerConditionEmpty);\n        TEST_CASE(oppositeInnerConditionFollowVar);\n        TEST_CASE(oppositeInnerConditionLambda);\n\n        TEST_CASE(identicalInnerCondition);\n\n        TEST_CASE(identicalConditionAfterEarlyExit);\n        TEST_CASE(innerConditionModified);\n\n        TEST_CASE(clarifyCondition1);     // if (a = b() < 0)\n        TEST_CASE(clarifyCondition2);     // if (a & b == c)\n        TEST_CASE(clarifyCondition3);     // if (! a & b)\n        TEST_CASE(clarifyCondition4);     // ticket #3110\n        TEST_CASE(clarifyCondition5);     // #3609 CWinTraits<WS_CHILD|WS_VISIBLE>..\n        TEST_CASE(clarifyCondition6);     // #3818\n        TEST_CASE(clarifyCondition7);\n        TEST_CASE(clarifyCondition8);\n\n        TEST_CASE(alwaysTrue);\n        TEST_CASE(alwaysTrueSymbolic);\n        TEST_CASE(alwaysTrueInfer);\n        TEST_CASE(alwaysTrueContainer);\n        TEST_CASE(alwaysTrueLoop);\n        TEST_CASE(alwaysTrueTryCatch);\n        TEST_CASE(multiConditionAlwaysTrue);\n        TEST_CASE(duplicateCondition);\n\n        TEST_CASE(checkInvalidTestForOverflow);\n        TEST_CASE(checkConditionIsAlwaysTrueOrFalseInsideIfWhile);\n        TEST_CASE(alwaysTrueFalseInLogicalOperators);\n        TEST_CASE(pointerAdditionResultNotNull);\n        TEST_CASE(duplicateConditionalAssign);\n\n        TEST_CASE(checkAssignmentInCondition);\n        TEST_CASE(compareOutOfTypeRange);\n        TEST_CASE(knownConditionCast); // #9976\n        TEST_CASE(knownConditionIncrementLoop); // #9808\n        TEST_CASE(knownConditionAfterBailout); // #12526\n        TEST_CASE(knownConditionIncDecOperator);\n        TEST_CASE(knownConditionFloating);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        const Settings* s = nullptr;\n        bool cpp = true;\n        bool inconclusive = false;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    void check_(const char* file, int line, const char code[], const CheckOptions& options = make_default_obj()) {\n        const Settings settings = settingsBuilder(options.s ? *options.s : settings0).certainty(Certainty::inconclusive, options.inconclusive).build();\n\n        SimpleTokenizer2 tokenizer(settings, *this, code, options.cpp ? \"test.cpp\" : \"test.c\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Run checks..\n        runChecks<CheckCondition>(tokenizer, this);\n    }\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    void checkP_(const char* file, int line, const char code[])\n    {\n        const Settings settings = settingsBuilder(settings0).severity(Severity::performance).certainty(Certainty::inconclusive).build();\n\n        SimpleTokenizer2 tokenizer(settings, *this, code, \"test.cpp\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Run checks..\n        runChecks<CheckCondition>(tokenizer, this);\n    }\n\n    void assignAndCompare() {\n        // &\n        check(\"void foo(int x)\\n\"\n              \"{\\n\"\n              \"    int y = x & 4;\\n\"\n              \"    if (y == 3);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:4:8]: (style) Mismatching assignment and comparison, comparison 'y==3' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void foo(int x)\\n\"\n              \"{\\n\"\n              \"    int y = x & 4;\\n\"\n              \"    if (y != 3);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:4:8]: (style) Mismatching assignment and comparison, comparison 'y!=3' is always true. [assignIfError]\\n\", errout_str());\n\n        // |\n        check(\"void foo(int x) {\\n\"\n              \"    int y = x | 0x14;\\n\"\n              \"    if (y == 0x710);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:8]: (style) Mismatching assignment and comparison, comparison 'y==0x710' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    int y = x | 0x14;\\n\"\n              \"    if (y == 0x71f);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // various simple assignments\n        check(\"void foo(int x) {\\n\"\n              \"    int y = (x+1) | 1;\\n\"\n              \"    if (y == 2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:8]: (style) Mismatching assignment and comparison, comparison 'y==2' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int y = 1 | x();\\n\"\n              \"    if (y == 2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:8]: (style) Mismatching assignment and comparison, comparison 'y==2' is always false. [assignIfError]\\n\", errout_str());\n\n        // multiple conditions\n        check(\"void foo(int x) {\\n\"\n              \"    int y = x & 4;\\n\"\n              \"    if ((y == 3) && (z == 1));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:9]: (style) Mismatching assignment and comparison, comparison 'y==3' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    int y = x & 4;\\n\"\n              \"    if ((x==123) || ((y == 3) && (z == 1)));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:22]: (style) Mismatching assignment and comparison, comparison 'y==3' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    int y = x & 7;\\n\"\n              \"    if (setvalue(&y) && y != 8);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // recursive checking into scopes\n        check(\"void f(int x) {\\n\"\n              \"    int y = x & 7;\\n\"\n              \"    if (z) y=0;\\n\"\n              \"    else { if (y==8); }\\n\" // always false\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:4:15]: (style) Mismatching assignment and comparison, comparison 'y==8' is always false. [assignIfError]\\n\", errout_str());\n\n        // while\n        check(\"void f(int x) {\\n\"\n              \"    int y = x & 7;\\n\"\n              \"    while (y==8);\\n\" // local variable => always false\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:11]: (style) Mismatching assignment and comparison, comparison 'y==8' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    extern int y; y = x & 7;\\n\"\n              \"    while (y==8);\\n\" // non-local variable => no error\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    int a = 100;\\n\"\n              \"    while (x) {\\n\"\n              \"        int y = 16 | a;\\n\"\n              \"        while (y != 0) y--;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int x);\\n\"\n              \"void f(int x) {\\n\"\n              \"    int a = 100;\\n\"\n              \"    while (x) {\\n\"\n              \"        int y = 16 | a;\\n\"\n              \"        while (y != 0) g(y);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:15] -> [test.cpp:6:15]: (style) Mismatching assignment and comparison, comparison 'y!=0' is always true. [assignIfError]\\n\",\n            errout_str());\n\n        check(\"void g(int &x);\\n\"\n              \"void f(int x) {\\n\"\n              \"    int a = 100;\\n\"\n              \"    while (x) {\\n\"\n              \"        int y = 16 | a;\\n\"\n              \"        while (y != 0) g(y);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // calling function\n        check(\"void f(int x) {\\n\"\n              \"    int y = x & 7;\\n\"\n              \"    do_something();\\n\"\n              \"    if (y==8);\\n\" // local variable => always false\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:4:8]: (style) Mismatching assignment and comparison, comparison 'y==8' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    int y = x & 7;\\n\"\n              \"    do_something(&y);\\n\" // passing variable => no error\n              \"    if (y==8);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void do_something(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"    int y = x & 7;\\n\"\n              \"    do_something(y);\\n\"\n              \"    if (y==8);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:5:8]: (style) Mismatching assignment and comparison, comparison 'y==8' is always false. [assignIfError]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    extern int y; y = x & 7;\\n\"\n              \"    do_something();\\n\"\n              \"    if (y==8);\\n\" // non-local variable => no error\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4434 : false positive: ?:\n        check(\"void f(int x) {\\n\"\n              \"    x = x & 1;\\n\"\n              \"    x = x & 1 ? 1 : -1;\\n\"\n              \"    if(x != -1) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4735\n        check(\"void f() {\\n\"\n              \"    int x = *(char*)&0x12345678;\\n\"\n              \"    if (x==18) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // bailout: no variable info\n        check(\"void foo(int x) {\\n\"\n              \"    y = 2 | x;\\n\"  // y not declared => no error\n              \"    if(y == 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // bailout: negative number\n        check(\"void foo(int x) {\\n\"\n              \"    int y = -2 | x;\\n\" // negative number => no error\n              \"    if (y==1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // bailout: pass variable to function\n        check(\"void foo(int x) {\\n\"\n              \"    int y = 2 | x;\\n\"\n              \"    bar(&y);\\n\"  // pass variable to function => no error\n              \"    if (y==1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // no crash on unary operator& (#5643)\n        // #11610\n        check(\"SdrObject* ApplyGraphicToObject() {\\n\"\n              \"    if (&rHitObject) {}\\n\"\n              \"    else if (rHitObject.IsClosedObj() && !&rHitObject) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Condition '&rHitObject' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:3:42]: (style) Condition '!&rHitObject' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        // #5695: increment\n        check(\"void f(int a0, int n) {\\n\"\n              \"  int c = a0 & 3;\\n\"\n              \"  for (int a = 0; a < n; a++) {\\n\"\n              \"    c++;\\n\"\n              \"    if (c == 4)\\n\"\n              \"      c  = 0;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a) {\\n\" // #6662\n              \"  int x = a & 1;\\n\"\n              \"  while (x <= 4) {\\n\"\n              \"    if (x != 5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:8]: (style) Mismatching assignment and comparison, comparison 'x!=5' is always true. [assignIfError]\\n\", errout_str());\n\n        check(\"void f(int a) {\\n\" // #6662\n              \"  int x = a & 1;\\n\"\n              \"  while ((x += 4) < 10) {\\n\"\n              \"    if (x != 5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int x = 100;\\n\"\n              \"    while (x) {\\n\"\n              \"        g(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int x);\\n\"\n              \"void f() {\\n\"\n              \"    int x = 100;\\n\"\n              \"    while (x) {\\n\"\n              \"        g(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (style) Condition 'x' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void g(int & x);\\n\"\n              \"void f() {\\n\"\n              \"    int x = 100;\\n\"\n              \"    while (x) {\\n\"\n              \"        g(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void mismatchingBitAnd() {\n        check(\"void f(int a) {\\n\"\n              \"    int b = a & 0xf0;\\n\"\n              \"    b &= 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:5]: (style) Mismatching bitmasks. Result is always 0 (X = Y & 0xf0; Z = X & 0x1; => Z=0). [mismatchingBitAnd]\\n\", errout_str());\n\n        check(\"void f(int a) {\\n\"\n              \"    int b = a & 0xf0;\\n\"\n              \"    int c = b & 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:9]: (style) Mismatching bitmasks. Result is always 0 (X = Y & 0xf0; Z = X & 0x1; => Z=0). [mismatchingBitAnd]\\n\", errout_str());\n\n        check(\"void f(int a) {\\n\"\n              \"    int b = a;\"\n              \"    switch (x) {\\n\"\n              \"    case 1: b &= 1; break;\\n\"\n              \"    case 2: b &= 2; break;\\n\"\n              \"    };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void comparison() {\n        // CheckCondition::comparison test cases\n        // '=='\n        check(\"void f(int a) {\\n assert( (a & 0x07) == 8U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X & 0x7) == 0x8' is always false. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & b & 4 & c ) == 3 );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:21]: (style) Expression '(X & 0x4) == 0x3' is always false. [comparisonError]\\n\", errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x07) == 8U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X | 0x7) == 0x8' is always false. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & 0x07) == 7U );\\n}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x01) == -15 );\\n}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        // '!='\n        check(\"void f(int a) {\\n assert( (a & 0x07) != 8U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X & 0x7) != 0x8' is always true. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x07) != 8U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X | 0x7) != 0x8' is always true. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & 0x07) != 7U );\\n}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x07) != 7U );\\n}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        // '>='\n        check(\"void f(int a) {\\n assert( (a & 0x07) >= 8U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X & 0x7) >= 0x8' is always false. [comparisonError]\\n\",errout_str());\n        check(\"void f(unsigned int a) {\\n assert( (a | 0x7) >= 7U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X | 0x7) >= 0x7' is always true. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & 0x07) >= 7U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x07) >= 8U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str()); //correct for negative 'a'\n        // '>'\n        check(\"void f(int a) {\\n assert( (a & 0x07) > 7U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X & 0x7) > 0x7' is always false. [comparisonError]\\n\",errout_str());\n        check(\"void f(unsigned int a) {\\n assert( (a | 0x7) > 6U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X | 0x7) > 0x6' is always true. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & 0x07) > 6U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x07) > 7U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str()); //correct for negative 'a'\n        // '<='\n        check(\"void f(int a) {\\n assert( (a & 0x07) <= 7U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X & 0x7) <= 0x7' is always true. [comparisonError]\\n\",errout_str());\n        check(\"void f(unsigned int a) {\\n assert( (a | 0x08) <= 7U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X | 0x8) <= 0x7' is always false. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & 0x07) <= 6U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x08) <= 7U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str()); //correct for negative 'a'\n        // '<'\n        check(\"void f(int a) {\\n assert( (a & 0x07) < 8U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X & 0x7) < 0x8' is always true. [comparisonError]\\n\",errout_str());\n        check(\"void f(unsigned int a) {\\n assert( (a | 0x07) < 7U );\\n}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Expression '(X | 0x7) < 0x7' is always false. [comparisonError]\\n\",errout_str());\n        check(\"void f(int a) {\\n assert( (a & 0x07) < 3U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str());\n        check(\"void f(int a) {\\n assert( (a | 0x07) < 7U );\\n}\");\n        ASSERT_EQUALS(\"\",errout_str()); //correct for negative 'a'\n\n        check(\"void f(int i) {\\n\" // #11998\n              \"    if ((i & 0x100) == 0x200) {}\\n\"\n              \"    if (0x200 == (i & 0x100)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:21] -> [test.cpp:3:15]: (style) The if condition is the same as the previous if condition [duplicateCondition]\\n\"\n                      \"[test.cpp:2:12]: (style) Expression '(X & 0x100) == 0x200' is always false. [comparisonError]\\n\"\n                      \"[test.cpp:3:21]: (style) Expression '(X & 0x100) == 0x200' is always false. [comparisonError]\\n\",\n                      errout_str());\n\n        checkP(\"#define MACRO1 (0x0010)\\n\" // #13222\n               \"#define MACRO2 (0x0020)\\n\"\n               \"#define MACRO_ALL (MACRO1 | MACRO2)\\n\"\n               \"void f() {\\n\"\n               \"    if (MACRO_ALL == 0) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"void f(int i, int j) {\\n\" // #13360\n               \"    int X = 0x10;\\n\"\n               \"    if ((i & 0xff00) == X) {}\\n\"\n               \"    if (X == (j & 0xff00)) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) Expression '(X & 0xff00) == 0x10' is always false. [comparisonError]\\n\"\n                      \"[test.cpp:4:17]: (style) Expression '(X & 0xff00) == 0x10' is always false. [comparisonError]\\n\",\n                      errout_str());\n    }\n\n#define checkPureFunction(code) checkPureFunction_(code, __FILE__, __LINE__)\n    void multicompare() {\n        check(\"void foo(int x)\\n\"\n              \"{\\n\"\n              \"    if (x & 7);\\n\"\n              \"    else { if (x == 1); }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (style) Expression is always false because 'else if' condition matches previous condition at line 3. [multiCondition]\\n\", errout_str());\n\n        check(\"void foo(int x)\\n\"\n              \"{\\n\"\n              \"    if (x & 7);\\n\"\n              \"    else { if (x & 1); }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (style) Expression is always false because 'else if' condition matches previous condition at line 3. [multiCondition]\\n\", errout_str());\n\n        check(\"extern int bar() __attribute__((pure));\\n\"\n              \"void foo(int x)\\n\"\n              \"{\\n\"\n              \"    if ( bar() >1 && b) {}\\n\"\n              \"    else if (bar() >1 && b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (style) Expression is always false because 'else if' condition matches previous condition at line 4. [multiCondition]\\n\", errout_str());\n\n        checkPureFunction(\"extern int bar();\\n\"\n                          \"void foo(int x)\\n\"\n                          \"{\\n\"\n                          \"    if ( bar() >1 && b) {}\\n\"\n                          \"    else if (bar() >1 && b) {}\\n\"\n                          \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (style) Expression is always false because 'else if' condition matches previous condition at line 4. [multiCondition]\\n\", errout_str());\n\n        // 7284\n        check(\"void foo() {\\n\"\n              \"    if (a) {}\\n\"\n              \"    else if (!!a) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        // #11059\n        check(\"int f();\\n\"\n              \"void g() {\\n\"\n              \"    int i = f();\\n\"\n              \"    if (i == 3) {}\\n\"\n              \"    else if ((i = f()) == 5) {}\\n\"\n              \"    else if (i == 3) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f();\\n\"\n              \"void g() {\\n\"\n              \"    int i = f();\\n\"\n              \"    if (i == 3) {}\\n\"\n              \"    else if ((i = f()) == 5) {}\\n\"\n              \"    else if (i != 3) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    template<size_t size>\n    void checkPureFunction_(const char (&code)[size], const char* file, int line) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        runChecks<CheckCondition>(tokenizer, this);\n    }\n\n    void overlappingElseIfCondition() {\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a) { b = 1; }\\n\"\n              \"    else { if (a) { b = 2; } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a) { b = 1; }\\n\"\n              \"    else { if (a) { b = 2; } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a == 1) { b = 1; }\\n\"\n              \"    else { if (a == 2) { b = 2; }\\n\"\n              \"    else { if (a == 1) { b = 3; } } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a == 1) { b = 1; }\\n\"\n              \"    else { if (a == 2) { b = 2; }\\n\"\n              \"    else { if (a == 2) { b = 3; } } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (style) Expression is always false because 'else if' condition matches previous condition at line 3. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a++) { b = 1; }\\n\"\n              \"    else { if (a++) { b = 2; }\\n\"\n              \"    else { if (a++) { b = 3; } } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (!strtok(NULL, \\\" \\\")) { b = 1; }\\n\"\n              \"    else { if (!strtok(NULL, \\\" \\\")) { b = 2; } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            check(\"void f(Class &c) {\\n\"\n                  \"    if (c.dostuff() == 3) {}\\n\"\n                  \"    else { if (c.dostuff() == 3) {} }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            check(\"void f(const Class &c) {\\n\"\n                  \"    if (c.dostuff() == 3) {}\\n\"\n                  \"    else { if (c.dostuff() == 3) {} }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:28]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n        }\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"   x = x / 2;\\n\"\n              \"   if (x < 100) { b = 1; }\\n\"\n              \"   else { x = x / 2; if (x < 100) { b = 2; } }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int64_t i) {\\n\"\n              \"   if(i == 0x02e2000000 || i == 0xa0c6000000)\\n\"\n              \"       foo(i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket 3689 ( avoid false positive )\n        check(\"int fitInt(long long int nValue){\\n\"\n              \"    if( nValue < 0x7fffffffLL )\\n\"\n              \"    {\\n\"\n              \"        return 32;\\n\"\n              \"    }\\n\"\n              \"    if( nValue < 0x7fffffffffffLL )\\n\"\n              \"    {\\n\"\n              \"        return 48;\\n\"\n              \"    }\\n\"\n              \"    else {\\n\"\n              \"        if( nValue < 0x7fffffffffffffffLL )\\n\"\n              \"        {\\n\"\n              \"            return 64;\\n\"\n              \"        } else\\n\"\n              \"        {\\n\"\n              \"            return -1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(WIDGET *widget) {\\n\"\n              \"  if (dynamic_cast<BUTTON*>(widget)){}\\n\"\n              \"  else if (dynamic_cast<LABEL*>(widget)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class B { virtual void v() {} };\\n\" // #11037\n              \"class D1 : public B {};\\n\"\n              \"class D2 : public B {};\\n\"\n              \"void f(const std::shared_ptr<B>&p) {\\n\"\n              \"    const auto d1 = dynamic_cast<D1*>(p.get());\\n\"\n              \"    const auto d2 = dynamic_cast<D2*>(p.get());\\n\"\n              \"    if (d1) {}\\n\"\n              \"    else if (d2) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\" // #6482\n              \"  if (x & 1) {}\\n\"\n              \"  else if (x == 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x & 15) {}\\n\"\n              \"  else if (x == 40) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x == sizeof(double)) {}\\n\"\n              \"  else { if (x == sizeof(long double)) {} }\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x & 0x08) {}\\n\"\n              \"  else if (x & 0xF8) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x & 0xF8) {}\\n\"\n              \"  else if (x & 0x08) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"   if(a && b){}\\n\"\n              \"   else if( !!b && !!a){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"   if(a && b){}\\n\"\n              \"   else if( !!b && a){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"   if(a && b){}\\n\"\n              \"   else if( b && !!a){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"   if(a && b){}\\n\"\n              \"   else if( b && !(!a)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"   if(a && b){}\\n\"\n              \"   else if( !!b && !(!a)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) Expression is always false because 'else if' condition matches previous condition at line 2. [multiCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"   if(a && b){}\\n\"\n              \"   else if( !!(b) && !!(a+b)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8168\n        check(\"enum MaskValues\\n\"\n              \"{\\n\"\n              \"    Value1 = 0x00000001,\\n\"\n              \"    Value2 = 0x00000002\\n\"\n              \"};\\n\"\n              \"void TestFunction(int value) {\\n\"\n              \"    if ( value & (int)Value1 ) {}\\n\"\n              \"    else if ( value & (int)Value2 ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(size_t x) {\\n\"\n              \"    if (x == sizeof(int)) {}\\n\"\n              \"    else { if (x == sizeof(long))} {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(size_t x) {\\n\"\n              \"    if (x == sizeof(long)) {}\\n\"\n              \"    else { if (x == sizeof(long long))} {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeElseIfCondition() {\n        setMultiline();\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x) {}\\n\"\n              \"    else if (!x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: style: Expression is always true because 'else if' condition is opposite to previous condition at line 2. [multiCondition]\\n\"\n                      \"[test.cpp:2:9]: note: first condition\\n\"\n                      \"[test.cpp:3:14]: note: else if condition is opposite to first condition\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    int y = x;\\n\"\n              \"    if (x) {}\\n\"\n              \"    else if (!y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: style: Expression is always true because 'else if' condition is opposite to previous condition at line 3. [multiCondition]\\n\"\n                      \"[test.cpp:2:13]: note: 'y' is assigned value 'x' here.\\n\"\n                      \"[test.cpp:3:9]: note: first condition\\n\"\n                      \"[test.cpp:4:14]: note: else if condition is opposite to first condition\\n\", errout_str());\n    }\n\n    void checkBadBitmaskCheck() {\n        check(\"bool f(int x) {\\n\"\n              \"    bool b = x | 0x02;\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"    bool b = 0x02 | x;\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"int f(int x) {\\n\"\n              \"    int b = x | 0x02;\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"    bool b = x & 0x02;\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"    if(x | 0x02)\\n\"\n              \"        return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"    int y = 0x1;\\n\"\n              \"    if(b) y = 0;\\n\"\n              \"    if(x | y)\\n\"\n              \"        return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"    foo(a && (x | 0x02));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"int f(int x) {\\n\"\n              \"    return (x | 0x02) ? 0 : 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"int f(int x) {\\n\"\n              \"    return x ? (x | 0x02) : 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"    return x | 0x02;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"  if (x) {\\n\"\n              \"    return x | 0x02;\\n\"\n              \"  }\\n\"\n              \"  return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"const bool f(int x) {\\n\"\n              \"    return x | 0x02;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"struct F {\\n\"\n              \"  static const bool f(int x) {\\n\"\n              \"      return x | 0x02;\\n\"\n              \"  }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"struct F {\\n\"\n              \"  typedef bool b_t;\\n\"\n              \"};\\n\"\n              \"F::b_t f(int x) {\\n\"\n              \"  return x | 0x02;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (warning) Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"int f(int x) {\\n\"\n              \"    return x | 0x02;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void create_rop_masks_4( rop_mask_bits *bits) {\\n\"\n              \"DWORD mask_offset;\\n\"\n              \"BYTE *and_bits = bits->and;\\n\"\n              \"rop_mask *rop_mask;\\n\"\n              \"and_bits[mask_offset] |= (rop_mask->and & 0x0f);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(unsigned a, unsigned b) {\\n\"\n              \"  unsigned cmd1 = b & 0x0F;\\n\"\n              \"  if (cmd1 | a) {\\n\"\n              \"    if (b == 0x0C) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i) {\\n\" // #11082\n              \"    int j = 0;\\n\"\n              \"    if (i | j) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Operator '|' with one operand equal to zero is redundant. [badBitmaskCheck]\\n\", errout_str());\n\n        check(\"#define EIGHTTOIS(x) (((x) << 8) | (x))\\n\"\n              \"int f() {\\n\"\n              \"    return EIGHTTOIS(0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"#define O_RDONLY 0\\n\"\n              \"void f(const char* s, int* pFd) {\\n\"\n              \"    *pFd = open(s, O_RDONLY | O_BINARY, 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const int FEATURE_BITS = x |\\n\"\n              \"#if FOO_ENABLED\\n\"\n              \"    FEATURE_FOO |\\n\"\n              \"#endif\\n\"\n              \"#if BAR_ENABLED\\n\"\n              \"    FEATURE_BAR |\\n\"\n              \"#endif\\n\"\n              \"    0;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"enum precedence { PC0, UNARY };\\n\"\n              \"int x = PC0   | UNARY;\\n\"\n              \"int y = UNARY | PC0;\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"#define MASK 0\\n\"\n              \"#define SHIFT 1\\n\"\n              \"int x = 1 | (MASK << SHIFT);\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void incorrectLogicOperator1() {\n        check(\"void f(int x) {\\n\"\n              \"    if ((x != 1) || (x != 3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Logical disjunction always evaluates to true: x != 1 || x != 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (1 != x || 3 != x)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical disjunction always evaluates to true: x != 1 || x != 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x<0 && !x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Logical conjunction always evaluates to false: x < 0 && !x. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x==0 && x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning) Logical conjunction always evaluates to false: x == 0 && x. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\" // ast..\n              \"    if (y == 1 && x == 1 && x == 7) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (warning) Logical conjunction always evaluates to false: x == 1 && x == 7. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if (x != 1 || y != 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if ((y == 1) && (x != 1) || (x != 3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if ((x != 1) || (x != 3) && (y == 1))\\n\"\n              \"        a++;\\n\"\n              \"}\"\n              );\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:2:24]: (style) Condition 'x!=3' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x != 1) && (x != 3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x == 1) || (x == 3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if ((x != 1) || (y != 3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if ((x != hotdog) || (y != hotdog))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if ((x != 5) || (y != 5))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x != 5) || (x != 6))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (warning) Logical disjunction always evaluates to true: x != 5 || x != 6. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(unsigned int a, unsigned int b, unsigned int c) {\\n\"\n              \"    if((a != b) || (c != b) || (c != a))\\n\"\n              \"    {\\n\"\n              \"        return true;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23] -> [test.cpp:2:35]: (style) Condition 'c!=a' is always false [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator2() {\n        check(\"void f(float x) {\\n\"\n              \"    if ((x == 1) && (x == 1.0))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x == 1) && (x == 0x00000001))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:2:24]: (style) Condition 'x==0x00000001' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x == 1 && x == 3)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical conjunction always evaluates to false: x == 1 && x == 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x == 1.0 && x == 3.0)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // float comparisons with == and != are not checked right now - such comparison is a bad idea\n\n        check(\"void f(float x) {\\n\"\n              \"    if (x == 1 && x == 1.0)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void bar(float f) {\\n\" // #5246\n              \"    if ((f > 0) && (f < 1)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1 && x > 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 1. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1.0 && x > 1.0)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) Logical conjunction always evaluates to false: x < 1.0 && x > 1.0. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1 && x > 1.0)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 1.0. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x >= 1.0 && x <= 1.001)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1 && x > 3)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(float x) {\\n\"\n              \"    if (x < 1.0 && x > 3.0)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (warning) Logical conjunction always evaluates to false: x < 1.0 && x > 3.0. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (1 > x && 3 < x)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 3 && x > 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 3 || x < 10)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical disjunction always evaluates to true: x > 3 || x < 10. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x >= 3 || x <= 10)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical disjunction always evaluates to true: x >= 3 || x <= 10. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x >= 3 || x < 10)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical disjunction always evaluates to true: x >= 3 || x < 10. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 3 || x <= 10)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical disjunction always evaluates to true: x > 3 || x <= 10. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 3 || x < 3)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x >= 3 || x <= 3)\\n\"\n              \"        a++;\\n\"\n              \"}\"\n              );\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical disjunction always evaluates to true: x >= 3 || x <= 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x >= 3 || x < 3)\\n\"\n              \"        a++;\\n\"\n              \"}\"\n              );\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical disjunction always evaluates to true: x >= 3 || x < 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 3 || x <= 3)\\n\"\n              \"        a++;\\n\"\n              \"}\"\n              );\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical disjunction always evaluates to true: x > 3 || x <= 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"   if((x==3) && (x!=4))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Redundant condition: The condition 'x != 4' is redundant since 'x == 3' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(const std::string &s) {\\n\" // #8860\n              \"    const std::size_t p = s.find(\\\"42\\\");\\n\"\n              \"    const std::size_t * const ptr = &p;\\n\"\n              \"    if(p != std::string::npos && p == 0 && *ptr != 1){;}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:36] -> [test.cpp:4:49]: (style) Condition '*ptr!=1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x!=4) && (x==3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Redundant condition: The condition 'x != 4' is redundant since 'x == 3' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x==3) || (x!=4))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Redundant condition: The condition 'x == 3' is redundant since 'x != 4' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x!=4) || (x==3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Redundant condition: The condition 'x == 3' is redundant since 'x != 4' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x==3) && (x!=3))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical conjunction always evaluates to false: x == 3 && x != 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x==6) || (x!=6))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical disjunction always evaluates to true: x == 6 || x != 6. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 10 || x < 3)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 5 && x == 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x > 5 && x == 1. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 5 && x == 6)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Redundant condition: The condition 'x > 5' is redundant since 'x == 6' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        // #3419\n        check(\"void f() {\\n\"\n              \"    if ( &q != &a && &q != &b ) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3676\n        check(\"void f(int m_x2, int w, int x) {\\n\"\n              \"    if (x + w - 1 > m_x2 || m_x2 < 0 )\\n\"\n              \"        m_x2 = x + w - 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(float x) {\\n\" // x+1 => x\n              \"  if (x <= 1.0e20 && x >= -1.0e20) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(float x) {\\n\" // x+1 => x\n              \"  if (x >= 1.0e20 && x <= 1.0e21) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(float x) {\\n\" // x+1 => x\n              \"  if (x <= -1.0e20 && x >= -1.0e21) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incorrectLogicOperator3() {\n        check(\"void f(int x, bool& b) {\\n\"\n              \"    b = x > 5 && x == 1;\\n\"\n              \"    c = x < 1 && x == 3;\\n\"\n              \"    d = x >= 5 && x == 1;\\n\"\n              \"    e = x <= 1 && x == 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x > 5 && x == 1. [incorrectLogicOperator]\\n\"\n                      \"[test.cpp:3:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x == 3. [incorrectLogicOperator]\\n\"\n                      \"[test.cpp:4:16]: (warning) Logical conjunction always evaluates to false: x >= 5 && x == 1. [incorrectLogicOperator]\\n\"\n                      \"[test.cpp:5:16]: (warning) Logical conjunction always evaluates to false: x <= 1 && x == 3. [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator4() {\n        check(\"#define ZERO 0\\n\"\n              \"void f(int x) {\\n\"\n              \"  if (x && x != ZERO) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int N) {\\n\" // #9789\n              \"    T a[20] = { 0 };\\n\"\n              \"    for (int i = 0; i < N; ++i) {\\n\"\n              \"        if (0 < a[i] && a[i] < 1) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incorrectLogicOperator5() { // complex expressions\n        check(\"void f(int x) {\\n\"\n              \"  if (x+3 > 2 || x+3 < 10) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical disjunction always evaluates to true: x+3 > 2 || x+3 < 10. [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator6() { // char literals\n        check(\"void f(char x) {\\n\"\n              \"  if (x == '1' || x == '2') {}\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char x) {\\n\"\n              \"  if (x == '1' && x == '2') {}\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical conjunction always evaluates to false: x == '1' && x == '2'. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"int f(char c) {\\n\"\n              \"  return (c >= 'a' && c <= 'z');\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(char c) {\\n\"\n              \"  return (c <= 'a' && c >= 'z');\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (warning, inconclusive) Logical conjunction always evaluates to false: c <= 'a' && c >= 'z'. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"int f(char c) {\\n\"\n              \"  return (c <= 'a' && c >= 'z');\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:2:25]: (style) Return value 'c>='z'' is always false [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator7() { // opposite expressions\n        check(\"void f(int i) {\\n\"\n              \"  if (i || !i) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (warning) Logical disjunction always evaluates to true: i || !(i). [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int a, int b) {\\n\"\n              \"  if (a>b || a<=b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Logical disjunction always evaluates to true: a > b || a <= b. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int a, int b) {\\n\"\n              \"  if (a>b || a<b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6064 False positive incorrectLogicOperator - invalid assumption about template type?\n        check(\"template<typename T> T icdf( const T uniform ) {\\n\"\n              \"   if ((0<uniform) && (uniform<1))\\n\"\n              \"     {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6081 False positive: incorrectLogicOperator, with close negative comparisons\n        check(\"double neg = -1.0 - 1.0e-13;\\n\"\n              \"void foo() {\\n\"\n              \"    if ((neg < -1.0) && (neg > -1.0 - 1.0e-12))\\n\"\n              \"        return;\\n\"\n              \"    else\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incorrectLogicOperator8() { // opposite expressions\n        check(\"void f(int i) {\\n\"\n              \"  if (!(i!=10) && !(i!=20)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (warning) Logical conjunction always evaluates to false: !(i != 10) && !(i != 20). [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator9() { //  #6069 \"False positive incorrectLogicOperator due to dynamic_cast\"\n        check(\"class MyType;\\n\"\n              \"class OtherType;\\n\"\n              \"void foo (OtherType* obj) {\\n\"\n              \"    assert((!obj) || dynamic_cast<MyType*>(obj));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incorrectLogicOperator10() { //  #7794 - enum\n        check(\"typedef enum { A, B } Type_t;\\n\"\n              \"void f(Type_t t) {\\n\"\n              \"    if ((t == A) && (t == B))\\n\"\n              \"    {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (warning) Logical conjunction always evaluates to false: t == 0 && t == 1. [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator11() {\n        check(\"void foo(int i, const int n) { if ( i < n && i == n ) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:43]: (warning) Logical conjunction always evaluates to false: i < n && i == n. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void foo(int i, const int n) { if ( i > n && i == n ) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:43]: (warning) Logical conjunction always evaluates to false: i > n && i == n. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void foo(int i, const int n) { if ( i == n && i > n ) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:44]: (warning) Logical conjunction always evaluates to false: i == n && i > n. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void foo(int i, const int n) { if ( i == n && i < n ) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:44]: (warning) Logical conjunction always evaluates to false: i == n && i < n. [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator12() { // #8696\n        check(\"struct A {\\n\"\n              \"    void f() const;\\n\"\n              \"};\\n\"\n              \"void foo(A a, A b) {\\n\"\n              \"  A x = b;\\n\"\n              \"  A y = b;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:9] -> [test.cpp:6:9] -> [test.cpp:8:13]: (warning) Logical conjunction always evaluates to false: a > x && a < y. [incorrectLogicOperator]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void foo(A a, A b) {\\n\"\n              \"  A x = b;\\n\"\n              \"  A y = b;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(A a, A b) {\\n\"\n              \"  A x = b;\\n\"\n              \"  A y = b;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(A a, A b) {\\n\"\n              \"  const A x = b;\\n\"\n              \"  const A y = b;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:15] -> [test.cpp:3:15] -> [test.cpp:5:13]: (warning) Logical conjunction always evaluates to false: a > x && a < y. [incorrectLogicOperator]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\"\n              \"    void f() const;\\n\"\n              \"};\\n\"\n              \"void foo(A a) {\\n\"\n              \"  A x = a;\\n\"\n              \"  A y = a;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9]: (style) Condition 'a>x' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:8:18]: (style) Condition 'a<y' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"struct A {\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void foo(A a) {\\n\"\n              \"  A x = a;\\n\"\n              \"  A y = a;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9]: (style) Condition 'a>x' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(A a) {\\n\"\n              \"  A x = a;\\n\"\n              \"  A y = a;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style) Condition 'a>x' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(A a) {\\n\"\n              \"  const A x = a;\\n\"\n              \"  const A y = a;\\n\"\n              \"  y.f();\\n\"\n              \"  if (a > x && a < y)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style) Condition 'a>x' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:5:18]: (style) Condition 'a<y' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n    }\n\n    void incorrectLogicOperator13() {\n        // 8780\n        check(\"void f(const int &v) {\\n\"\n              \"    const int x=v;\\n\"\n              \"    if ((v == 1) && (x == 2)) {;}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17] -> [test.cpp:3:18]: (warning) Logical conjunction always evaluates to false: v == 1 && x == 2. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f2(const int *v) {\\n\"\n              \"    const int *x=v;\\n\"\n              \"    if ((*v == 1) && (*x == 2)) {;}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18] -> [test.cpp:3:19]: (warning) Logical conjunction always evaluates to false: *(v) == 1 && *(x) == 2. [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator14() {\n        check(\"static const std ::string h;\\n\"\n              \"class i {\\n\"\n              \"public:\\n\"\n              \"  struct j {\\n\"\n              \"    std ::string k;\\n\"\n              \"    std ::string l;\\n\"\n              \"  };\\n\"\n              \"  struct a {\\n\"\n              \"    enum { m = 1 };\\n\"\n              \"  };\\n\"\n              \"} b;\\n\"\n              \"namespace n {\\n\"\n              \"class c;\\n\"\n              \"}\\n\"\n              \"struct o {\\n\"\n              \"  enum { p, d, q, r };\\n\"\n              \"  enum { e, f };\\n\"\n              \"\\n\"\n              \"public:\\n\"\n              \"  class j {\\n\"\n              \"  public:\\n\"\n              \"    class s {\\n\"\n              \"      std ::string a;\\n\"\n              \"    };\\n\"\n              \"  };\\n\"\n              \"};\\n\"\n              \"namespace n {\\n\"\n              \"class b;\\n\"\n              \"}\\n\"\n              \"namespace aa {\\n\"\n              \"class d {\\n\"\n              \"public:\\n\"\n              \"  char t;\\n\"\n              \"  enum {} u;\\n\"\n              \"};\\n\"\n              \"} // namespace aa\\n\"\n              \"namespace aa {\\n\"\n              \"struct e {};\\n\"\n              \"} // namespace aa\\n\"\n              \"class a;\\n\"\n              \"class w {\\n\"\n              \"public:\\n\"\n              \"  enum { x };\\n\"\n              \"  struct {\\n\"\n              \"  } y;\\n\"\n              \"  std ::string z;\\n\"\n              \"};\\n\"\n              \"class ab {\\n\"\n              \"  friend class c;\\n\"\n              \"\\n\"\n              \"public:\\n\"\n              \"  class ac {\\n\"\n              \"    void e(const ac &v) const;\\n\"\n              \"  };\\n\"\n              \"};\\n\"\n              \"class f;\\n\"\n              \"class ad {\\n\"\n              \"  friend class e;\\n\"\n              \"  enum { e, ae, ag, ah, ai, aj, ak, a, b };\\n\"\n              \"  class c {};\\n\"\n              \"  class d {\\n\"\n              \"    enum am { f, an, ao, ap, aq, ar, b, as, at, c, au };\\n\"\n              \"    enum av { aw, ax, ay, az, e, ba, bb, bc, bd, a };\\n\"\n              \"    struct b {\\n\"\n              \"      am action;\\n\"\n              \"      av c;\\n\"\n              \"    };\\n\"\n              \"  };\\n\"\n              \"  class e {\\n\"\n              \"  public:\\n\"\n              \"    std ::string e;\\n\"\n              \"    class f {\\n\"\n              \"    } f;\\n\"\n              \"    class be {\\n\"\n              \"    public:\\n\"\n              \"    };\\n\"\n              \"    std ::vector<be> bf;\\n\"\n              \"    enum { bg, b } c;\\n\"\n              \"  };\\n\"\n              \"  struct bh {\\n\"\n              \"    std ::map<int, d> b;\\n\"\n              \"  };\\n\"\n              \"  std ::map<std ::string, bh> bi;\\n\"\n              \"  struct {\\n\"\n              \"    int b;\\n\"\n              \"    char bj;\\n\"\n              \"  } bk;\\n\"\n              \"  class a {\\n\"\n              \"  public:\\n\"\n              \"    std ::set<std ::string> b;\\n\"\n              \"  };\\n\"\n              \"};\\n\"\n              \"class bl;\\n\"\n              \"class al;\\n\"\n              \"class bm;\\n\"\n              \"class f;\\n\"\n              \"class b;\\n\"\n              \"class bn;\\n\"\n              \"namespace bo {\\n\"\n              \"class bp {\\n\"\n              \"public:\\n\"\n              \"  typedef std ::pair<const f *, std ::string> bq;\\n\"\n              \"  typedef std ::list<bq> br;\\n\"\n              \"};\\n\"\n              \"const bo ::bp *dg(const f *a, const al *b);\\n\"\n              \"} // namespace bo\\n\"\n              \"const bn *dh(const f *d, bo ::bp ::br &bs);\\n\"\n              \"class f {\\n\"\n              \"public:\\n\"\n              \"  struct bt {};\\n\"\n              \"  std ::vector<a> f;\\n\"\n              \"};\\n\"\n              \"class bu;\\n\"\n              \"class a;\\n\"\n              \"class c;\\n\"\n              \"struct bv {};\\n\"\n              \"class af {\\n\"\n              \"private:\\n\"\n              \"public:\\n\"\n              \"  enum { b, d, e, f, c, bw };\\n\"\n              \"  void a(int c);\\n\"\n              \"  af *bx() const;\\n\"\n              \"};\\n\"\n              \"namespace by {\\n\"\n              \"class b;\\n\"\n              \"}\\n\"\n              \"class b {\\n\"\n              \"public:\\n\"\n              \"  bool d, c;\\n\"\n              \"};\\n\"\n              \"class bz;\\n\"\n              \"class f;\\n\"\n              \"class ca {\\n\"\n              \"  friend class b;\\n\"\n              \"\\n\"\n              \"public:\\n\"\n              \"  const bm *cb() const { return cc; }\\n\"\n              \"  f *d(f *e, bool f) const;\\n\"\n              \"  int e() { return ++cd; }\\n\"\n              \"  bl *const c;\\n\"\n              \"  bm *cc;\\n\"\n              \"  std ::map<std ::string, int> ce;\\n\"\n              \"  int cd;\\n\"\n              \"  bz *a;\\n\"\n              \"};\\n\"\n              \"namespace n {\\n\"\n              \"class c;\\n\"\n              \"class d;\\n\"\n              \"} // namespace n\\n\"\n              \"class cf {\\n\"\n              \"public:\\n\"\n              \"  explicit cf(const std ::string &aname);\\n\"\n              \"  cf(const std ::string &aname, const ca *cg, const al *ch, bl *ci)\\n\"\n              \"      : cj(cg), ck(ch), cl(ci), cn(aname) {}\\n\"\n              \"\\n\"\n              \"protected:\\n\"\n              \"  const ca *const cj;\\n\"\n              \"  const al *const ck;\\n\"\n              \"  bl *const cl;\\n\"\n              \"  const std ::string cn;\\n\"\n              \"};\\n\"\n              \"class cm : public cf {\\n\"\n              \"public:\\n\"\n              \"  void cp();\\n\"\n              \"  std ::string d() const;\\n\"\n              \"};\\n\"\n              \"struct co {\\n\"\n              \"  co();\\n\"\n              \"  const bu *a;\\n\"\n              \"  enum f {};\\n\"\n              \"  enum {\\n\"\n              \"    b = (1 << 0),\\n\"\n              \"    c = (1 << 1),\\n\"\n              \"  };\\n\"\n              \"  void d(bool e);\\n\"\n              \"};\\n\"\n              \"class bu {\\n\"\n              \"  friend class e;\\n\"\n              \"\\n\"\n              \"public:\\n\"\n              \"  struct f {};\\n\"\n              \"  enum { d, cr, cq, ct, cs, e, a, b, c, dd, cu, cv, cw, cx, cy, cz, da };\\n\"\n              \"  const f *db;\\n\"\n              \"  const af *dc;\\n\"\n              \"} f{};\\n\"\n              \"class bm {\\n\"\n              \"public:\\n\"\n              \"  std ::list<bu> df;\\n\"\n              \"  std ::vector<const bu *> de;\\n\"\n              \"  mutable std ::set<std ::string> f;\\n\"\n              \"};\\n\"\n              \"void cm ::cp() {\\n\"\n              \"  const bm *a = cj->cb();\\n\"\n              \"  for (const bu *b : a->de)\\n\"\n              \"    for (af *c = b->dc->bx();;) {\\n\"\n              \"      af *d = c;\\n\"\n              \"      af *e = c;\\n\"\n              \"      bool f(d);\\n\"\n              \"      bool g(e);\\n\"\n              \"      if (f && g)\\n\"\n              \"        ;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:200:11] -> [test.cpp:200:16]: (style) Condition 'g' is always true [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void incorrectLogicOperator15() {\n        // 10022\n        check(\"struct PipeRoute {\\n\"\n              \"    std::deque<int> points;\\n\"\n              \"    std::deque<int> estimates;\\n\"\n              \"};\\n\"\n              \"void CleanPipeRoutes(std::map<int, PipeRoute*>& pipeRoutes) {\\n\"\n              \"    for (auto it = pipeRoutes.begin(); it != pipeRoutes.end(); ) {\\n\"\n              \"        PipeRoute* curRoute = it->second;\\n\"\n              \"        if (curRoute->points.empty() && curRoute->estimates.size() != 2)\\n\"\n              \"        {\\n\"\n              \"            delete curRoute;\\n\"\n              \"            it = pipeRoutes.erase(it);\\n\"\n              \"        }\\n\"\n              \"        else\\n\"\n              \"        {\\n\"\n              \"            ++it;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incorrectLogicOperator16() { // #10070\n        check(\"void foo(void* p) {\\n\"\n              \"    if (!p || p == -1) { }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incorrectLogicOperator17() { // #12471\n        check(\"struct R {\\n\"\n              \"    void set() { i = 1; }\\n\"\n              \"    int get() const { return i; }\\n\"\n              \"    int i;\\n\"\n              \"};\\n\"\n              \"struct P {\\n\"\n              \"    void f();\\n\"\n              \"    R* r;\\n\"\n              \"};\\n\"\n              \"void P::f() {\\n\"\n              \"    int a = r->get();\\n\"\n              \"    r->set();\\n\"\n              \"    if (a == 0 && r->get()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void secondAlwaysTrueFalseWhenFirstTrueError() {\n        check(\"void f(void) {\\n\" // #8892\n              \"    const char c[1] = { \\'x\\' }; \\n\"\n              \"    if(c[0] == \\'x\\'){;}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Condition 'c[0]=='x'' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 5 && x != 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Redundant condition: The condition 'x != 1' is redundant since 'x > 5' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 5 && x != 6)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x > 5) && (x != 1))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Redundant condition: The condition 'x != 1' is redundant since 'x > 5' is sufficient. [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x > 5) && (x != 6))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, bool& b) {\\n\"\n              \"    b = x > 3 || x == 4;\\n\"\n              \"    c = x < 5 || x == 4;\\n\"\n              \"    d = x >= 3 || x == 4;\\n\"\n              \"    e = x <= 5 || x == 4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Redundant condition: The condition 'x == 4' is redundant since 'x > 3' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:3:15]: (style) Redundant condition: The condition 'x == 4' is redundant since 'x < 5' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:4:16]: (style) Redundant condition: The condition 'x == 4' is redundant since 'x >= 3' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:5:16]: (style) Redundant condition: The condition 'x == 4' is redundant since 'x <= 5' is sufficient. [redundantCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(int x, bool& b) {\\n\"\n              \"    b = x > 5 || x != 1;\\n\"\n              \"    c = x < 1 || x != 3;\\n\"\n              \"    d = x >= 5 || x != 1;\\n\"\n              \"    e = x <= 1 || x != 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Redundant condition: The condition 'x > 5' is redundant since 'x != 1' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:3:15]: (style) Redundant condition: The condition 'x < 1' is redundant since 'x != 3' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:4:16]: (style) Redundant condition: The condition 'x >= 5' is redundant since 'x != 1' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:5:16]: (style) Redundant condition: The condition 'x <= 1' is redundant since 'x != 3' is sufficient. [redundantCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(int x, bool& b) {\\n\"\n              \"    b = x > 6 && x > 5;\\n\"\n              \"    c = x > 5 || x > 6;\\n\"\n              \"    d = x < 6 && x < 5;\\n\"\n              \"    e = x < 5 || x < 6;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Redundant condition: The condition 'x > 5' is redundant since 'x > 6' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:3:15]: (style) Redundant condition: The condition 'x > 6' is redundant since 'x > 5' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:4:15]: (style) Redundant condition: The condition 'x < 6' is redundant since 'x < 5' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:5:15]: (style) Redundant condition: The condition 'x < 5' is redundant since 'x < 6' is sufficient. [redundantCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(double x, bool& b) {\\n\"\n              \"    b = x > 6.5 && x > 5.5;\\n\"\n              \"    c = x > 5.5 || x > 6.5;\\n\"\n              \"    d = x < 6.5 && x < 5.5;\\n\"\n              \"    e = x < 5.5 || x < 6.5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Redundant condition: The condition 'x > 5.5' is redundant since 'x > 6.5' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:3:17]: (style) Redundant condition: The condition 'x > 6.5' is redundant since 'x > 5.5' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:4:17]: (style) Redundant condition: The condition 'x < 6.5' is redundant since 'x < 5.5' is sufficient. [redundantCondition]\\n\"\n                      \"[test.cpp:5:17]: (style) Redundant condition: The condition 'x < 5.5' is redundant since 'x < 6.5' is sufficient. [redundantCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(const char *p) {\\n\" // #10320\n              \"    if (!p || !*p || *p != 'x') {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (style) Redundant condition: The condition '!*p' is redundant since '*p != 'x'' is sufficient. [redundantCondition]\\n\",\n                      errout_str());\n    }\n\n    void incorrectLogicOp_condSwapping() {\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1 && x > 3)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (1 > x && x > 3)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1 && 3 < x)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (1 > x && 3 < x)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x < 1 && x > 3. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 3 && x < 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x > 3 && x < 1. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (3 < x && x < 1)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x > 3 && x < 1. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 3 && 1 > x)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x > 3 && x < 1. [incorrectLogicOperator]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (3 < x && 1 > x)\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Logical conjunction always evaluates to false: x > 3 && x < 1. [incorrectLogicOperator]\\n\", errout_str());\n    }\n\n    void modulo() {\n        check(\"bool f(bool& b1, bool& b2, bool& b3) {\\n\"\n              \"    b1 = a % 5 == 4;\\n\"\n              \"    b2 = a % c == 100000;\\n\"\n              \"    b3 = a % 5 == c;\\n\"\n              \"    return a % 5 == 5-p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(bool& b1, bool& b2, bool& b3, bool& b4, bool& b5) {\\n\"\n              \"    b1 = a % 5 < 5;\\n\"\n              \"    b2 = a % 5 <= 5;\\n\"\n              \"    b3 = a % 5 == 5;\\n\"\n              \"    b4 = a % 5 != 5;\\n\"\n              \"    b5 = a % 5 >= 5;\\n\"\n              \"    return a % 5 > 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:16]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:3:16]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:4:16]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:5:16]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:6:16]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:7:18]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void f(bool& b1, bool& b2) {\\n\"\n              \"    b1 = bar() % 5 < 889;\\n\"\n              \"    if(x[593] % 5 <= 5)\\n\"\n              \"        b2 = x.a % 5 == 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:20]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:3:19]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\"\n            \"[test.cpp:4:22]: (warning) Comparison of modulo result is predetermined, because it is always less than 5. [moduloAlwaysTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (a % 2 + b % 2 == 2)\\n\"\n              \"        foo();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeInnerCondition() {\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if(a==b)\\n\"\n              \"        if(a!=b)\\n\"\n              \"            cout << a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:13]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"bool foo(int a, int b) {\\n\"\n              \"    if(a==b)\\n\"\n              \"        return a!=b;\\n\"\n              \"    return false;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:17]: (warning) Opposite inner 'return' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if(a==b)\\n\"\n              \"        if(b!=a)\\n\"\n              \"            cout << a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:13]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"    if(a >= 50) {\\n\"\n              \"        if(a < 50)\\n\"\n              \"            cout << a;\\n\"\n              \"        else\\n\"\n              \"            cout << 100;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:3:14]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        // #4186\n        check(\"void foo(int a) {\\n\"\n              \"    if(a >= 50) {\\n\"\n              \"        if(a > 50)\\n\"\n              \"            cout << a;\\n\"\n              \"        else\\n\"\n              \"            cout << 100;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // 4170\n        check(\"class foo {\\n\"\n              \"    void bar() {\\n\"\n              \"        if (tok == '(') {\\n\"\n              \"            next();\\n\"\n              \"            if (tok == ',') {\\n\"\n              \"                next();\\n\"\n              \"                if (tok != ',') {\\n\"\n              \"                    op->reg2 = asm_parse_reg();\\n\"\n              \"                }\\n\"\n              \"                skip(',');\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    void next();\\n\"\n              \"    const char *tok;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int i)\\n\"\n              \"{\\n\"\n              \"   if(i > 5) {\\n\"\n              \"       i = bar();\\n\"\n              \"       if(i < 5) {\\n\"\n              \"           cout << a;\\n\"\n              \"       }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int& i) {\\n\"\n              \"    i=6;\\n\"\n              \"}\\n\"\n              \"void bar(int i) {\\n\"\n              \"    if(i>5) {\\n\"\n              \"        foo(i);\\n\"\n              \"        if(i<5) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int& i);\\n\"\n              \"void bar() {\\n\"\n              \"    int i; i = func();\\n\"\n              \"    if(i>5) {\\n\"\n              \"        foo(i);\\n\"\n              \"        if(i<5) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int i);\\n\"\n              \"void bar(int i) {\\n\"\n              \"    if(i>5) {\\n\"\n              \"        foo(i);\\n\"\n              \"        if(i<5) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:5:13]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void foo(const int &i);\\n\"\n              \"void bar(int i) {\\n\"\n              \"    if(i>5) {\\n\"\n              \"        foo(i);\\n\"\n              \"        if(i<5) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:5:13]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void foo(int i);\\n\"\n              \"void bar() {\\n\"\n              \"    int i; i = func();\\n\"\n              \"    if(i>5) {\\n\"\n              \"        foo(i);\\n\"\n              \"        if(i<5) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:6:13]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"class C { void f(int &i) const; };\\n\" // #7028 - variable is changed by const method\n              \"void foo(C c, int i) {\\n\"\n              \"  if (i==5) {\\n\"\n              \"    c.f(i);\\n\"\n              \"    if (i != 5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // see linux revision 1f80c0cc\n        check(\"int generic_write_sync(int,int,int);\\n\"\n              \"\\n\"\n              \"void cifs_writev(int i) {\\n\"\n              \"   int rc = __generic_file_aio_write();\\n\"\n              \"   if (rc > 0){\\n\"\n              \"       err = generic_write_sync(file, iocb->ki_pos - rc, rc);\\n\"\n              \"       if(rc < 0) {\\n\"  // <- condition is always false\n              \"           err = rc;\\n\"\n              \"       }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:11] -> [test.cpp:7:14]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n\n        // #5874 - array\n        check(\"void testOppositeConditions2() {\\n\"\n              \"  int array[2] = { 0, 0 };\\n\"\n              \"  if (array[0] < 2) {\\n\"\n              \"    array[0] += 5;\\n\"\n              \"    if (array[0] > 2) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6227 - FP caused by simplifications of casts and known variables\n        check(\"void foo(A *a) {\\n\"\n              \"   if(a) {\\n\"\n              \"       B *b = dynamic_cast<B*>(a);\\n\"\n              \"       if(!b) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"   if(a) {\\n\"\n              \"       int b = a;\\n\"\n              \"       if(!b) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16] -> [test.cpp:2:7] -> [test.cpp:4:11]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void foo(unsigned u) {\\n\"\n              \"  if (u != 0) {\\n\"\n              \"    for (int i=0; i<32; i++) {\\n\"\n              \"      if (u == 0) {}\\n\"  // <- don't warn\n              \"      u = x;\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8186\n        check(\"void f() {\\n\"\n              \"  for (int i=0;i<4;i++) {\\n\"\n              \"    if (i==5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17] -> [test.cpp:3:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        // #8938\n        check(\"void Delete(SS_CELLCOORD upperleft) {\\n\"\n              \"    if ((upperleft.Col == -1) && (upperleft.Row == -1)) {\\n\"\n              \"        GetActiveCell(&(upperleft.Col), &(upperleft.Row));\\n\"\n              \"        if (upperleft.Row == -1) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9702\n        check(\"struct A {\\n\"\n              \"    void DoTest() {\\n\"\n              \"        if (!IsSet()) {\\n\"\n              \"            m_value = true;\\n\"\n              \"            if (IsSet());\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    bool IsSet() const { return m_value; }\\n\"\n              \"    bool m_value = false;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12725\n        check(\"bool f(bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        return !b;\\n\"\n              \"    b = g();\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:16]: (style) Return value '!b' is always false [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void oppositeInnerConditionPointers() {\n        check(\"void f(struct ABC *abc) {\\n\"\n              \"   struct AB *ab = abc->ab;\\n\"\n              \"   if (ab->a == 123){\\n\"\n              \"       do_something(abc);\\n\" // might change ab->a\n              \"       if (ab->a != 123) {\\n\"\n              \"           err = rc;\\n\"\n              \"       }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fred::f() {\\n\" // daca: ace\n              \"  if (this->next_ == map_man_->table_) {\\n\"\n              \"    this->next_ = n;\\n\"\n              \"    if (this->next_ != map_man_->table_) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(float *f) {\\n\" // #7405\n              \"  if(*f>10) {\\n\"\n              \"    (*f) += 0.1f;\\n\"\n              \"    if(*f<10) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int * f(int * x, int * y) {\\n\"\n              \"    if(!x) return x;\\n\"\n              \"    return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeInnerConditionClass() {\n        // #6095 - calling member function that might change the state\n        check(\"void f() {\\n\"\n              \"  const Fred fred;\\n\" // <- fred is const, warn\n              \"  if (fred.isValid()) {\\n\"\n              \"    fred.dostuff();\\n\"\n              \"    if (!fred.isValid()) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19] -> [test.cpp:5:9]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"class Fred { public: bool isValid() const; void dostuff() const; };\\n\"\n              \"void f() {\\n\"\n              \"  Fred fred;\\n\"\n              \"  if (fred.isValid()) {\\n\"\n              \"    fred.dostuff();\\n\" // <- dostuff() is const, warn\n              \"    if (!fred.isValid()) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:19] -> [test.cpp:6:9]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  Fred fred;\\n\"\n              \"  if (fred.isValid()) {\\n\"\n              \"    fred.dostuff();\\n\"\n              \"    if (!fred.isValid()) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6385 \"crash in Variable::getFlag()\"\n        check(\"class TranslationHandler {\\n\"\n              \"QTranslator *mTranslator;\\n\"\n              \"void SetLanguage() {\\n\"\n              \"   if (mTranslator) {\\n\"\n              \"             qApp->removeTranslator(mTranslator);\\n\"\n              \"        }\\n\"\n              \"   }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str()); // just don't crash...\n\n        check(\"bool f(std::ofstream &CFileStream) {\\n\" // #8198\n              \"  if(!CFileStream.good()) { return; }\\n\"\n              \"  CFileStream << \\\"abc\\\";\\n\"\n              \"  if (!CFileStream.good()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeInnerConditionUndeclaredVariable() {\n        // #5731 - fp when undeclared variable is used\n        check(\"void f() {\\n\"\n              \"   if (x == -1){\\n\"\n              \"       x = do_something();\\n\"\n              \"       if (x != -1) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5750 - another fp when undeclared variable is used\n        check(\"void f() {\\n\"\n              \"   if (r < w){\\n\"\n              \"       r += 3;\\n\"\n              \"       if (r > w) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6574 - another fp when undeclared variable is used\n        check(\"void foo() {\\n\"\n              \"   if(i) {\\n\"\n              \"       i++;\\n\"\n              \"       if(!i) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // undeclared array\n        check(\"void f(int x) {\\n\"\n              \"  if (a[x] > 0) {\\n\"\n              \"    a[x] -= dt;\\n\"\n              \"    if (a[x] < 0) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6313 - false positive: opposite conditions in nested if blocks when condition changed\n        check(\"void Foo::Bar() {\\n\"\n              \"   if(var){\\n\"\n              \"      --var;\\n\"\n              \"      if(!var){}\\n\"\n              \"      else {}\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // daca hyphy\n        check(\"bool f() {\\n\"\n              \"  if (rec.lLength==0) {\\n\"\n              \"    rec.Delete(i);\\n\"\n              \"    if (rec.lLength!=0) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeInnerConditionAlias() {\n        check(\"void f() {\\n\"\n              \"  struct S s;\\n\"\n              \"  bool hasFailed = false;\\n\"\n              \"  s.status = &hasFailed;\\n\"\n              \"\\n\"\n              \"  if (! hasFailed) {\\n\"\n              \"    doStuff(&s);\\n\"\n              \"    if (hasFailed) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:7]: (style) Condition '!hasFailed' is always true [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void oppositeInnerCondition2() {\n        // first comparison: <\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<4) {\\n\"\n              \"    if (x==5) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<4) {\\n\"\n              \"    if (x!=5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x!=5' is always true [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<4) {\\n\"\n              \"    if (x>5) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<4) {\\n\"\n              \"    if (x>=5) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<4) {\\n\"\n              \"    if (x<5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x<5' is always true [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<4) {\\n\"\n              \"    if (x<=5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x<=5' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x==4) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x!=4) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x!=6) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x!=6' is always true [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x>4) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x>4' is always false [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x>=4) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x<4) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x<5) {\\n\"\n              \"    if (x<=4) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x<=4' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // first comparison: >\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>4) {\\n\"\n              \"    if (x==5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>4) {\\n\"\n              \"    if (x>5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>4) {\\n\"\n              \"    if (x>=5) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x>=5' is always true [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>4) {\\n\"\n              \"    if (x<5) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x<5' is always false [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>4) {\\n\"\n              \"    if (x<=5) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>5) {\\n\"\n              \"    if (x==4) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>5) {\\n\"\n              \"    if (x>4) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x>4' is always true [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>5) {\\n\"\n              \"    if (x>=4) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (style) Condition 'x>=4' is always true [knownConditionTrueFalse]\\n\", errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>5) {\\n\"\n              \"    if (x<4) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n        check(\"void f(int x) {\\n\"\n              \"\\n\"\n              \"  if (x>5) {\\n\"\n              \"    if (x<=4) {}\\n\" // <- Warning\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:4:10]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x < 4) {\\n\"\n              \"    if (10 < x) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:12]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n    }\n\n    void oppositeInnerCondition3() {\n        check(\"void f3(char c) { if(c=='x') if(c=='y') {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:23] -> [test.cpp:1:34]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f4(char *p) { if(*p=='x') if(*p=='y') {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:25] -> [test.cpp:1:37]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f5(const char * const p) { if(*p=='x') if(*p=='y') {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:38] -> [test.cpp:1:50]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f5(const char * const p) { if('x'==*p) if('y'==*p) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:39] -> [test.cpp:1:51]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f6(char * const p) { if(*p=='x') if(*p=='y') {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:32] -> [test.cpp:1:44]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f7(const char * p) { if(*p=='x') if(*p=='y') {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:32] -> [test.cpp:1:44]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f8(int i) { if(i==4) if(i==2) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:22] -> [test.cpp:1:31]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f9(int *p) { if (*p==4) if(*p==2) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:25] -> [test.cpp:1:35]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f10(int * const p) { if (*p==4) if(*p==2) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:33] -> [test.cpp:1:43]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f11(const int *p) { if (*p==4) if(*p==2) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:32] -> [test.cpp:1:42]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f12(const int * const p) { if (*p==4) if(*p==2) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:39] -> [test.cpp:1:49]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"struct foo {\\n\"\n              \"    int a;\\n\"\n              \"    int b;\\n\"\n              \"};\\n\"\n              \"void f(foo x) { if(x.a==4) if(x.b==2) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct foo {\\n\"\n              \"    int a;\\n\"\n              \"    int b;\\n\"\n              \"};\\n\"\n              \"void f(foo x) { if(x.a==4) if(x.b==4) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f3(char a, char b) { if(a==b) if(a==0) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { if (x == 1) if (x != 1) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:23] -> [test.cpp:1:35]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n    }\n\n    void oppositeInnerConditionAnd() {\n        check(\"void f(int x) {\\n\"\n              \"  if (a>3 && x > 100) {\\n\"\n              \"    if (x < 10) {}\\n\"\n              \"  }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:3:11]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f(bool x, const int a, const int b) {\\n\"\n              \"        if(x && a < b)\\n\"\n              \"            if( x && a > b){}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:14] -> [test.cpp:3:19]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n    }\n\n    void oppositeInnerConditionOr()\n    {\n        check(\"void f(int x) {\\n\"\n              \"    if (x == 1 || x == 2) {\\n\"\n              \"        if (x == 3) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:3:15]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x == 1 || x == 2) {\\n\"\n              \"        if (x == 1) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x == 1 || x == 2) {\\n\"\n              \"        if (x == 2) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string x) {\\n\"\n              \"    if (x == \\\"1\\\" || x == \\\"2\\\") {\\n\"\n              \"        if (x == \\\"1\\\") {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x < 1 || x > 3) {\\n\"\n              \"        if (x == 3) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:15] -> [test.cpp:3:15]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\",\n                      errout_str());\n    }\n\n    void oppositeInnerConditionEmpty() {\n        check(\"void f1(const std::string &s) { if(s.size() > 42) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:45] -> [test.cpp:1:61]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.size() > 0) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:45] -> [test.cpp:1:60]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.size() < 0) if(s.empty()) {}} \"); // <- CheckOther reports: checking if unsigned expression is less than zero\n        ASSERT_EQUALS(\"[test.cpp:1:45] -> [test.cpp:1:60]: (style) Condition 's.empty()' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.empty()) if(s.size() > 42) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:43] -> [test.cpp:1:59]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"template<class T> void f1(const T &s) { if(s.size() > 42) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str()); //We don't know the type of T so we don't know the relationship between size() and empty(). e.g. s might be a 50 tonne truck with nothing in it.\n\n        check(\"void f2(const std::wstring &s) { if(s.empty()) if(s.size() > 42) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:44] -> [test.cpp:1:60]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f1(QString s) { if(s.isEmpty()) if(s.length() > 42) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:34] -> [test.cpp:1:52]: (warning) Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]\\n\", errout_str());\n\n        check(\"void f1(const std::string &s, bool b) { if(s.empty() || ((s.size() == 1) && b)) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &x, const std::string &y) { if(x.size() > 42) if(y.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &x, const std::string &y) { if(y.empty()) if(x.size() > 42) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string v[10]) { if(v[0].size() > 42) if(v[1].empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.size() <= 1) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.size() <= 2) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.size() < 2) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.size() >= 0) if(s.empty()) {}} \"); // CheckOther says: Unsigned expression 's.size()' can't be negative so it is unnecessary to test it. [unsignedPositive]\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // TODO: These are identical condition since size cannot be negative\n        check(\"void f1(const std::string &s) { if(s.size() <= 0) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // TODO: These are identical condition since size cannot be negative\n        check(\"void f1(const std::string &s) { if(s.size() < 1) if(s.empty()) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeInnerConditionFollowVar() {\n        check(\"struct X {\\n\"\n              \"    void f() {\\n\"\n              \"        const int flag = get();\\n\"\n              \"        if (flag) {\\n\"\n              \"            bar();\\n\"\n              \"            if (!get()) {}\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    void bar();\\n\"\n              \"    int get() const;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct CD {\\n\"\n              \"    bool state;\\n\"\n              \"    void foo()  {\\n\"\n              \"        const bool flag = this->get();\\n\"\n              \"        if (flag) {\\n\"\n              \"            this->bar();\\n\"\n              \"            if (!this->get()) return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    bool get() const;\\n\"\n              \"    void bar();\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C {\\n\"\n              \"public:\\n\"\n              \"  bool f() const { return x > 0; }\\n\"\n              \"  void g();\\n\"\n              \"  int x = 0;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void C::g() {\\n\"\n              \"  bool b = f();\\n\"\n              \"  x += 1;\\n\"\n              \"  if (!b && f()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(double d) {\\n\"\n              \"    if (d != 0) {\\n\"\n              \"        int i = d;\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeInnerConditionLambda() {\n        check(\"void f() {\\n\" // #13728\n              \"    for (int i = 0; i < 2;) {\\n\"\n              \"        auto inc = [&]() {\\n\"\n              \"            if (i >= 2)\\n\"\n              \"                throw 0;\\n\"\n              \"            return i++;\\n\"\n              \"        };\\n\"\n              \"        inc();\\n\"\n              \"        inc();\\n\"\n              \"        inc();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void identicalInnerCondition() {\n        check(\"void f1(int a, int b) { if(a==b) if(a==b) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:29] -> [test.cpp:1:38]: (warning) Identical inner 'if' condition is always true. [identicalInnerCondition]\\n\", errout_str());\n\n        check(\"void f2(int a, int b) { if(a!=b) if(a!=b) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:29] -> [test.cpp:1:38]: (warning) Identical inner 'if' condition is always true. [identicalInnerCondition]\\n\", errout_str());\n\n        // #6645 false negative: condition is always false\n        check(\"void f(bool a, bool b) {\\n\"\n              \"  if(a && b) {\\n\"\n              \"     if(a) {}\\n\"\n              \"     else  {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:6] -> [test.cpp:3:9]: (warning) Identical inner 'if' condition is always true. [identicalInnerCondition]\\n\", errout_str());\n\n        check(\"bool f(int a, int b) {\\n\"\n              \"    if(a == b) { return a == b; }\\n\"\n              \"    return false;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:2:27]: (warning) Identical inner 'return' condition is always true. [identicalInnerCondition]\\n\", errout_str());\n\n        check(\"bool f(bool a) {\\n\"\n              \"    if(a) { return a; }\\n\"\n              \"    return false;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int* f(int* a, int * b) {\\n\"\n              \"    if(a) { return a; }\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int* f(std::shared_ptr<int> a, std::shared_ptr<int> b) {\\n\"\n              \"    if(a.get()) { return a.get(); }\\n\"\n              \"    return b.get();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int * x; };\\n\"\n              \"int* f(A a, int * b) {\\n\"\n              \"    if(a.x) { return a.x; }\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    uint32_t value;\\n\"\n              \"    get_value(&value);\\n\"\n              \"    int opt_function_capable = (value >> 28) & 1;\\n\"\n              \"    if (opt_function_capable) {\\n\"\n              \"        value = 0;\\n\"\n              \"        get_value (&value);\\n\"\n              \"        if ((value >> 28) & 1) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define TYPE_1 \\\"a\\\"\\n\" // #13202\n               \"#define TYPE_2 \\\"b\\\"\\n\"\n               \"#define TYPE_3 \\\"c\\\"\\n\"\n               \"void f(const std::string& s) {\\n\"\n               \"    if (s == TYPE_1) {}\\n\"\n               \"    else if (s == TYPE_2 || s == TYPE_3) {\\n\"\n               \"        if (s == TYPE_2) {}\\n\"\n               \"        else if (s == TYPE_3) {}\\n\"\n               \"    }\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void identicalConditionAfterEarlyExit() {\n        check(\"void f(int x) {\\n\" // #8137\n              \"  if (x > 100) { return; }\\n\"\n              \"  if (x > 100) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:9]: (warning) Identical condition 'x>100', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"  if (x > 100) { return false; }\\n\"\n              \"  return x > 100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:12]: (warning) Identical condition and return expression 'x>100', return value is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x > 100) { return; }\\n\"\n              \"  if (x > 100 || y > 100) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:9]: (warning) Identical condition 'x>100', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x > 100) { return; }\\n\"\n              \"  if (x > 100 && y > 100) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:9]: (warning) Identical condition 'x>100', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x > 100) { return; }\\n\"\n              \"  if (abc) {}\\n\"\n              \"  if (x > 100) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:9]: (warning) Identical condition 'x>100', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x > 100) { return; }\\n\"\n              \"  while (abc) { y = x; }\\n\"\n              \"  if (x > 100) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:9]: (warning) Identical condition 'x>100', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        ASSERT_THROW_INTERNAL(check(\"void f(int x) {\\n\"  // #8217 - crash for incomplete code\n                                    \"  if (x > 100) { return; }\\n\"\n                                    \"  X(do);\\n\"\n                                    \"  if (x > 100) {}\\n\"\n                                    \"}\"),\n                              SYNTAX);\n\n        check(\"void f(const int *i) {\\n\"\n              \"  if (!i) return;\\n\"\n              \"  if (!num1tok) { *num1 = *num2; }\\n\"\n              \"  if (!i) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7] -> [test.cpp:4:7]: (warning) Identical condition '!i', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void C::f(Tree &coreTree) {\\n\" // daca\n              \"  if(!coreTree.build())\\n\"\n              \"    return;\\n\"\n              \"  coreTree.dostuff();\\n\"\n              \"  if(!coreTree.build()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct C { void f(const Tree &coreTree); };\\n\"\n              \"void C::f(const Tree &coreTree) {\\n\"\n              \"  if(!coreTree.build())\\n\"\n              \"    return;\\n\"\n              \"  coreTree.dostuff();\\n\"\n              \"  if(!coreTree.build()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6] -> [test.cpp:6:6]: (warning) Identical condition '!coreTree.build()', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\" // daca: labplot\n              \"  switch(type) {\\n\"\n              \"  case 1:\\n\"\n              \"    if (x == 0) return 1;\\n\"\n              \"    else return 2;\\n\"\n              \"  case 2:\\n\"\n              \"    if (x == 0) return 3;\\n\"\n              \"    else return 4;\\n\"\n              \"  }\\n\"\n              \"  return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"static int failed = 0;\\n\"\n              \"void f() {\\n\"\n              \"  if (failed) return;\\n\"\n              \"  checkBuffer();\\n\"\n              \"  if (failed) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // daca icu\n        check(\"void f(const uint32_t *section, int32_t  start) {\\n\"\n              \"  if(10<=section[start]) { return; }\\n\"\n              \"  if(++start<100 && 10<=section[start]) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // daca iqtree\n        check(\"void readNCBITree(std::istream &in) {\\n\"\n              \"  char ch;\\n\"\n              \"  in >> ch;\\n\"\n              \"  if (ch != '|') return;\\n\"\n              \"  in >> ch;\\n\"\n              \"  if (ch != '|') {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8924\n        check(\"struct A {\\n\"\n              \"    void f() {\\n\"\n              \"        if (this->FileIndex >= 0) return;\\n\"\n              \"        this->FileIndex = 1 ;\\n\"\n              \"        if (this->FileIndex < 0) return;\\n\"\n              \"    }\\n\"\n              \"    int FileIndex;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:29]: (style) Condition 'this->FileIndex<0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #8858 - #if\n        check(\"short Do() {\\n\"\n              \"    short ret = bar1();\\n\"\n              \"    if ( ret )\\n\"\n              \"        return ret;\\n\"\n              \"#ifdef FEATURE\\n\"\n              \"    ret = bar2();\\n\"\n              \"#endif\\n\"\n              \"    return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10456\n        check(\"int f() {\\n\"\n              \"    int i = 0;\\n\"\n              \"    auto f = [&](bool b) { if (b) ++i; };\\n\"\n              \"    if (i) return i;\\n\"\n              \"    f(true);\\n\"\n              \"    if (i) return i;\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11478\n        check(\"struct S {\\n\"\n              \"    void run();\\n\"\n              \"    bool b = false;\\n\"\n              \"    const std::function<void(S&)> f;\\n\"\n              \"};\\n\"\n              \"void S::run() {\\n\"\n              \"    while (true) {\\n\"\n              \"        if (b)\\n\"\n              \"            return;\\n\"\n              \"        f(*this);\\n\"\n              \"        if (b)\\n\"\n              \"            return;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void innerConditionModified() {\n        check(\"void f(int x, int y) {\\n\"\n              \"  if (x == 0) {\\n\"\n              \"    x += y;\\n\"\n              \"    if (x == 0) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x == 0) {\\n\"\n              \"    x += y;\\n\"\n              \"    if (x == 1) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int * x, int * y) {\\n\"\n              \"  if (x[*y] == 0) {\\n\"\n              \"    (*y)++;\\n\"\n              \"    if (x[*y] == 0) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // clarify conditions with = and comparison\n    void clarifyCondition1() {\n        check(\"void f() {\\n\"\n              \"    if (x = b() < 0) {}\\n\" // don't simplify and verify this code\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:8]: (style) Suspicious condition (assignment + comparison); Clarify expression with parentheses. [clarifyCondition]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    for (i = 0; i < 10; i++) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    x = a<int>(); if (x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (x = b < 0 ? 1 : 2) {}\\n\" // don't simplify and verify this code\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int y = rand(), z = rand();\\n\"\n              \"    if (y || (!y && z));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Redundant condition: !y. 'y || (!y && z)' is equivalent to 'y || z' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int y = rand(), z = rand();\\n\"\n              \"    if (y || !y && z);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Redundant condition: !y. 'y || (!y && z)' is equivalent to 'y || z' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (!a || a && b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Redundant condition: a. '!a || (a && b)' is equivalent to '!a || b' [redundantCondition]\\n\", errout_str());\n\n\n        check(\"void f(const Token *tok) {\\n\"\n              \"    if (!tok->next()->function() ||\\n\"\n              \"        (tok->next()->function() && tok->next()->function()->isConstructor()));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:34]: (style) Redundant condition: tok->next()->function(). '!A || (A && B)' is equivalent to '!A || B' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (!tok->next()->function() ||\\n\"\n              \"        (!tok->next()->function() && tok->next()->function()->isConstructor()));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (!tok->next()->function() ||\\n\"\n              \"        (!tok2->next()->function() && tok->next()->function()->isConstructor()));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const Token *tok) {\\n\"\n              \"    if (!tok->next(1)->function(1) ||\\n\"\n              \"        (tok->next(1)->function(1) && tok->next(1)->function(1)->isConstructor()));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:36]: (style) Redundant condition: tok->next(1)->function(1). '!A || (A && B)' is equivalent to '!A || B' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (!tok->next()->function(1) ||\\n\"\n              \"        (tok->next()->function(2) && tok->next()->function()->isConstructor()));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int y = rand(), z = rand();\\n\"\n              \"   if (y==0 || y!=0 && z);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Redundant condition: y!=0. 'y==0 || (y!=0 && z)' is equivalent to 'y==0 || z' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if (x>0 || (x<0 && y)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test Token::expressionString, TODO move this test\n        check(\"void f() {\\n\"\n              \"  if (!dead || (dead && (*it).ticks > 0)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Redundant condition: dead. '!dead || (dead && (*it).ticks>0)' is equivalent to '!dead || (*it).ticks>0' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if (!x || (x && (2>(y-1)))) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Redundant condition: x. '!x || (x && 2>(y-1))' is equivalent to '!x || 2>(y-1)' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"    if (a || (a && b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Redundant condition: a. 'a || (a && b)' is equivalent to 'a' [redundantCondition]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"    if (a && (a || b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Redundant condition: a. 'a && (a || b)' is equivalent to 'a' [redundantCondition]\\n\", errout_str());\n    }\n\n    // clarify conditions with bitwise operator and comparison\n    void clarifyCondition2() {\n        check(\"void f() {\\n\"\n              \"    if (x & 3 == 2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:8]: (style) Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses. [clarifyCondition]\\n\"\n                      \"[test.cpp:2:11]: (style) Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]\\n\"\n                      \"[test.cpp:2:11]: (style) Condition 'x&3==2' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (a & fred1.x == fred2.y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:8]: (style) Suspicious condition (bitwise operator + comparison); Clarify expression with parentheses. [clarifyCondition]\\n\"\n                      \"[test.cpp:2:11]: (style) Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]\\n\"\n                      , errout_str());\n    }\n\n    // clarify condition that uses ! operator and then bitwise operator\n    void clarifyCondition3() {\n        check(\"void f(int w) {\\n\"\n              \"    if(!w & 0x8000) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]\\n\", errout_str());\n\n        check(\"void f(int w) {\\n\"\n              \"    if((!w) & 0x8000) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (x == foo() & 2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (style) Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (2 & x == foo()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (2 & (x == foo())) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::list<int> &ints) { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { A<x &> a; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { a(x<y|z,0); }\", dinit(CheckOptions, $.cpp = false));  // language is c => there are never templates\n        ASSERT_EQUALS(\"[test.c:1:17]: (style) Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]\\n\", errout_str());\n\n        check(\"class A<B&,C>;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (result != (char *)&inline_result) { }\\n\" // don't simplify and verify cast\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8495\n        check(\"void f(bool a, bool b) {\\n\"\n              \"    C & a & b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyCondition4() { // ticket #3110\n        check(\"typedef double SomeType;\\n\"\n              \"typedef std::pair<std::string,SomeType> PairType;\\n\"\n              \"struct S\\n\"\n              \"{\\n\"\n              \"     bool operator()\\n\"\n              \"         ( PairType const & left\\n\"\n              \"         , PairType const & right) const\\n\"\n              \"     {\\n\"\n              \"         return left.first < right.first;\\n\"\n              \"     }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyCondition5() { // ticket #3609 (using | in template instantiation)\n        check(\"template<bool B> struct CWinTraits;\\n\"\n              \"CWinTraits<WS_CHILD|WS_VISIBLE>::GetWndStyle(0);\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyCondition6() {\n        check(\"template<class Y>\\n\"\n              \"SharedPtr& operator=( SharedPtr<Y> const & r ) {\\n\"\n              \"    px = r.px;\\n\"\n              \"    return *this;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyCondition7() {\n        // Ensure that binary and unary &, and & in declarations are distinguished properly\n        check(\"void f(bool error) {\\n\"\n              \"    bool & withoutSideEffects=found.first->second;\\n\" // Declaring a reference to a boolean; & is no operator at all\n              \"    execute(secondExpression, &programMemory, &result, &error);\\n\" // Unary &\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyCondition8() {\n        // don't warn when boolean result comes from function call, array index, etc\n        // the operator precedence is not unknown then\n        check(\"bool a();\\n\"\n              \"bool f(bool b) {\\n\"\n              \"    return (a() & b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(bool *a, bool b) {\\n\"\n              \"    return (a[10] & b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { bool a; };\\n\"\n              \"bool f(struct A a, bool b) {\\n\"\n              \"    return (a.a & b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { bool a; };\\n\"\n              \"bool f(struct A a, bool b) {\\n\"\n              \"    return (A::a & b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testBug5895() {\n        check(\"void png_parse(uint64_t init, int buf_size) {\\n\"\n              \"    if (init == 0x89504e470d0a1a0a || init == 0x8a4d4e470d0a1a0a)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testBug5309() {\n        check(\"extern uint64_t value;\\n\"\n              \"void foo() {\\n\"\n              \"    if( ( value >= 0x7ff0000000000001ULL )\\n\"\n              \"            && ( value <= 0x7fffffffffffffffULL ) );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void alwaysTrue() {\n\n        check(\"void f(const struct S *s) {\\n\" //#8196\n              \"  int x1 = s->x;\\n\"\n              \"  int x2 = s->x;\\n\"\n              \"  if (x1 == 10 && x2 == 10) {}\\n\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10] -> [test.cpp:4:22]: (style) Condition 'x2==10' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f ()\\n\"// #8220\n              \"{\\n\"\n              \"    int a;\\n\"\n              \"    int b = 0;\\n\"\n              \"    int ret;\\n\"\n              \" \\n\"\n              \"    a = rand();\\n\"\n              \"    while (((0 < a) && (a < 2)) && ((8 < a) && (a < 10))) \\n\"\n              \"    {\\n\"\n              \"        b += a;\\n\"\n              \"        a ++;\\n\"\n              \"    }\\n\"\n              \"    ret = b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:27] -> [test.cpp:8:40]: (style) Condition '8<a' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #4842\n              \"  int x = 0;\\n\"\n              \"  if (a) { return; }\\n\" // <- this is just here to fool simplifyKnownVariabels\n              \"  if (!x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) Condition '!x' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"bool f(int x) {\\n\"\n              \"  if(x == 0) { x++; return x == 0; }\\n\"\n              \"  return false;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:8] -> [test.cpp:2:30]: (style) Return value 'x==0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #6898 (Token::expressionString)\n              \"  int x = 0;\\n\"\n              \"  A(x++ == 1);\\n\"\n              \"  A(x++ == 2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Condition 'x++==1' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:4:9]: (style) Condition 'x++==2' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"bool foo(int bar) {\\n\"\n              \"  bool ret = false;\\n\"\n              \"  if (bar == 1)\\n\"\n              \"    return ret;\\n\" // <- #9326 - FP condition is always false\n              \"  if (bar == 2)\\n\"\n              \"    ret = true;\\n\"\n              \"  return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(const std::string &s) { if(s.empty()) if(s.size() == 0) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:43] -> [test.cpp:1:59]: (style) Condition 's.size()==0' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   if( buf != 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) Condition 'buf!=0' is always true [knownConditionTrueFalse]\\n\", errout_str()); // #8924\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   if( !buf ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (style) Condition '!buf' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   bool b = buf;\\n\"\n              \"   if( b ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (style) Condition 'b' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   bool b = buf;\\n\"\n              \"   if( !b ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (style) Condition '!b' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   int * p = nullptr;\\n\"\n              \"   if( buf == p ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (style) Condition 'buf==p' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(bool x) {\\n\"\n              \"   int buf[42];\\n\"\n              \"   if( buf || x ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (style) Condition 'buf' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int * p) {\\n\"\n              \"   int buf[42];\\n\"\n              \"   if( buf == p ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   int p[42];\\n\"\n              \"   if( buf == p ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int buf[42];\\n\"\n              \"   if( buf == 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Avoid FP when condition comes from macro\n        check(\"#define NOT !\\n\"\n              \"void f() {\\n\"\n              \"  int x = 0;\\n\"\n              \"  if (a) { return; }\\n\" // <- this is just here to fool simplifyKnownVariabels\n              \"  if (NOT x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"#define M  x != 0\\n\"\n              \"void f() {\\n\"\n              \"  int x = 0;\\n\"\n              \"  if (a) { return; }\\n\" // <- this is just here to fool simplifyKnownVariabels\n              \"  if (M) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"#define IF(X)  if (X && x())\\n\"\n              \"void f() {\\n\"\n              \"  IF(1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Avoid FP for sizeof condition\n        check(\"void f() {\\n\"\n              \"  if (sizeof(char) != 123) {}\\n\"\n              \"  if (123 != sizeof(char)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int x = 123;\\n\"\n              \"  if (sizeof(char) != x) {}\\n\"\n              \"  if (x != sizeof(char)) {}\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Condition 'sizeof(char)!=x' is always true\\n\"\n                           \"[test.cpp:4]: (style) Condition 'x!=sizeof(char)' is always true\\n\", \"\", errout_str());\n\n        // Don't warn in assertions. Condition is often 'always true' by intention.\n        // If platform,defines,etc cause an 'always false' assertion then that is not very dangerous neither\n        check(\"void f() {\\n\"\n              \"  int x = 0;\\n\"\n              \"  assert(x == 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9363 - do not warn about value passed to function\n        check(\"void f(bool b) {\\n\"\n              \"    if (b) {\\n\"\n              \"        if (bar(!b)) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        // #7783  FP knownConditionTrueFalse on assert(0 && \"message\")\n        check(\"void foo(int x) {\\n\"\n              \"    if (x<0)\\n\"\n              \"    {\\n\"\n              \"        assert(0 && \\\"bla\\\");\\n\"\n              \"        ASSERT(0 && \\\"bla\\\");\\n\"\n              \"        assert_foo(0 && \\\"bla\\\");\\n\"\n              \"        ASSERT_FOO(0 && \\\"bla\\\");\\n\"\n              \"        assert((int)(0==0));\\n\"\n              \"        assert((int)(0==0) && \\\"bla\\\");\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7750 char literals in boolean expressions\n        check(\"void f() {\\n\"\n              \"  if('a'){}\\n\"\n              \"  if(L'b'){}\\n\"\n              \"  if(1 && 'c'){}\\n\"\n              \"  int x = 'd' ? 1 : 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8206 - knownCondition always false\n        check(\"void f(int i)\\n\"\n              \"{\\n\"\n              \"        if(i > 4)\\n\"\n              \"          for( int x = 0; i < 3; ++x){}\\n\" // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14] -> [test.cpp:4:29]: (style) Condition 'i<3' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // Skip literals\n        check(\"void f() { if(true) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { if(false) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { if(!true) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { if(!false) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { if(0) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { if(1) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    bool b = false;\\n\"\n              \"    if (i == 0) b = true;\\n\"\n              \"    else if (!b && i == 1) {}\\n\"\n              \"    if (b)\\n\"\n              \"    {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (style) Condition '!b' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"bool f() { return nullptr; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"enum E { A };\\n\"\n              \"bool f() { return A; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    const int x = 0;\\n\"\n              \"    return x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(void){return 1/abs(10);}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    return x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    const int a = 50;\\n\"\n              \"    const int b = 52;\\n\"\n              \"    return a+b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Return value 'a+b' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int a = 50;\\n\"\n              \"    int b = 52;\\n\"\n              \"    a++;\\n\"\n              \"    b++;\\n\"\n              \"    return a+b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool& g();\\n\"\n              \"bool f() {\\n\"\n              \"    bool & b = g();\\n\"\n              \"    b = false;\\n\"\n              \"    return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    bool b;\\n\"\n              \"    bool f() {\\n\"\n              \"        b = false;\\n\"\n              \"        return b;\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(long maxtime) {\\n\"\n              \"  if (std::time(0) > maxtime)\\n\"\n              \"    return std::time(0) > maxtime;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(double param) {\\n\"\n              \"  while(bar()) {\\n\"\n              \"    if (param<0.)\\n\"\n              \"       return;\\n\"\n              \"  }\\n\"\n              \"  if (param<0.)\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int i) {\\n\"\n              \"  if (i==42)\\n\"\n              \"  {\\n\"\n              \"    bar();\\n\"\n              \"  }\\n\"\n              \"  if (cond && (42==i))\\n\"\n              \"    return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // 8842 crash\n        check(\"class a {\\n\"\n              \"  int b;\\n\"\n              \"  c(b);\\n\"\n              \"  void f() {\\n\"\n              \"    if (b) return;\\n\"\n              \"  }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const char* x, const char* t) {\\n\"\n              \"    if (!(strcmp(x, y) == 0)) { return; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int a[]){ if (a == 0){} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"  bool operator<(const S&);\\n\"\n              \"};\\n\"\n              \"int main() {\\n\"\n              \"  S s;\\n\"\n              \"  bool c = s<s;\\n\"\n              \"  if (c) return 0;\\n\"\n              \"  else return 42;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"long X::g(bool unknown, int& result) {\\n\"\n              \"    long ret = 0;\\n\"\n              \"    bool f = false;\\n\"\n              \"    f = f || unknown;\\n\"\n              \"    f ? result = 42 : ret = -1;\\n\"\n              \"    return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(void *handle) {\\n\"\n              \"    if (!handle) return 0;\\n\"\n              \"    if (handle) return 1;\\n\"\n              \"    else return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:9]: (style) Condition 'handle' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"int f(void *handle) {\\n\"\n              \"    if (handle == 0) return 0;\\n\"\n              \"    if (handle) return 1;\\n\"\n              \"    else return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Condition 'handle' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"int f(void *handle) {\\n\"\n              \"    if (handle != 0) return 0;\\n\"\n              \"    if (handle) return 1;\\n\"\n              \"    else return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:3:9]: (warning) Identical condition 'handle!=0', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"int f(void *handle) {\\n\"\n              \"    if (handle != nullptr) return 0;\\n\"\n              \"    if (handle) return 1;\\n\"\n              \"    else return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:3:9]: (warning) Identical condition 'handle!=nullptr', second condition is always false [identicalConditionAfterEarlyExit]\\n\", errout_str());\n\n        check(\"void f(void* x, void* y) {\\n\"\n              \"    if (x == nullptr && y == nullptr)\\n\"\n              \"        return;\\n\"\n              \"    if (x == nullptr || y == nullptr)\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* g();\\n\"\n              \"void f(void* a, void* b) {\\n\"\n              \"    while (a) {\\n\"\n              \"        a = g();\\n\"\n              \"        if (a == b)\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"    if (a) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void* g();\\n\"\n              \"void f(void* a, void* b) {\\n\"\n              \"    while (a) {\\n\"\n              \"        a = g();\\n\"\n              \"    }\\n\"\n              \"    if (a) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12] -> [test.cpp:6:9]: (style) Condition 'a' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int * x, bool b) {\\n\"\n              \"    if (!x && b) {}\\n\"\n              \"    else if (x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const std::string x=\\\"xyz\\\";\\n\"\n              \"    if(!x.empty()){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (style) Condition '!x.empty()' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"std::string g();\\n\"\n              \"void f() {\\n\"\n              \"    const std::string msg = g();\\n\"\n              \"    if(!msg.empty()){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *array, int size ) {\\n\"\n              \"    for(int i = 0; i < size; ++i) {\\n\"\n              \"        if(array == 0)\\n\"\n              \"            continue;\\n\"\n              \"        if(array){}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (style) Condition 'array' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int *array, int size ) {\\n\"\n              \"    for(int i = 0; i < size; ++i) {\\n\"\n              \"        if(array == 0)\\n\"\n              \"            continue;\\n\"\n              \"        else if(array){}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (style) Condition 'array' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #9277\n        check(\"int f() {\\n\"\n              \"    constexpr bool x = true;\\n\"\n              \"    if constexpr (x)\\n\"\n              \"        return 0;\\n\"\n              \"    else\\n\"\n              \"        return 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9954\n        check(\"void f() {\\n\"\n              \"    const size_t a(8 * sizeof(short));\\n\"\n              \"    const size_t b(8 * sizeof(int));\\n\"\n              \"    if constexpr (a == 16 && b == 16) {}\\n\"\n              \"    else if constexpr (a == 16 && b == 32) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9319\n        check(\"struct S {\\n\"\n              \"  int a;\\n\"\n              \"  int b;\\n\"\n              \"};\\n\"\n              \"void g(S s, bool& x);\\n\"\n              \"void f() {\\n\"\n              \"  bool x = false;\\n\"\n              \"  g({0, 1}, x);\\n\"\n              \"  if (x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9318\n        check(\"class A {};\\n\"\n              \"class B : public A {};\\n\"\n              \"void f(A* x) {\\n\"\n              \"  if (!x)\\n\"\n              \"    return;\\n\"\n              \"  auto b = dynamic_cast<B*>(x);\\n\"\n              \"  if (b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    auto x = getX();\\n\"\n              \"    if (x == nullptr)\\n\"\n              \"        return 1;\\n\"\n              \"    auto y = dynamic_cast<Y*>(x)\\n\"\n              \"    if (y == nullptr)\\n\"\n              \"        return 2;\\n\"\n              \"    return 3;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // handleKnownValuesInLoop\n        check(\"bool g();\\n\"\n              \"void f(bool x) {\\n\"\n              \"    if (x) while(x) x = g();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // isLikelyStream\n        check(\"void f(std::istringstream& iss) {\\n\"\n              \"   std::string x;\\n\"\n              \"   while (iss) {\\n\"\n              \"       iss >> x;\\n\"\n              \"       if (!iss) break;\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9332\n        check(\"struct A { void* g(); };\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    void* b = a.g();\\n\"\n              \"    if (!b) return;\\n\"\n              \"    void* c = a.g();\\n\"\n              \"    if (!c) return;\\n\"\n              \"    bool compare = c == b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9361\n        check(\"void f(char c) {\\n\"\n              \"    if (c == '.') {}\\n\"\n              \"    else if (isdigit(c) != 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9351\n        check(\"int f(int x) {\\n\"\n              \"    const bool b = x < 42;\\n\"\n              \"    if(b) return b?0:-1;\\n\"\n              \"    return 42;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:3:18]: (style) Condition 'b' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #9362\n        check(\"uint8_t g();\\n\"\n              \"void f() {\\n\"\n              \"    const uint8_t v = g();\\n\"\n              \"    if((v != 0x00)) {\\n\"\n              \"        if( (v & 0x01) == 0x00) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9367\n        check(\"void f(long x) {\\n\"\n              \"    if (x <= 0L)\\n\"\n              \"        return;\\n\"\n              \"    if (x % 360L == 0)\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int a, int b) {\\n\"\n              \"    static const int x = 10;\\n\"\n              \"    return x == 1 ? a : b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const bool x = false;\\n\"\n              \"void f() {\\n\"\n              \"    if (x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const bool x = false;\\n\"\n              \"void f() {\\n\"\n              \"    if (!x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9709\n        check(\"void f(int a) {\\n\"\n              \"    bool ok = false;\\n\"\n              \"    const char * r = nullptr;\\n\"\n              \"    do_something(&r);\\n\"\n              \"    if (r != nullptr)\\n\"\n              \"        ok = a != 0;\\n\"\n              \"    if (ok) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9816\n        check(\"bool g();\\n\"\n              \"void f() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    do {\\n\"\n              \"        do {\\n\"\n              \"            if (g())\\n\"\n              \"                break;\\n\"\n              \"            b = true;\\n\"\n              \"        } while(false);\\n\"\n              \"    } while(!b);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9865\n        check(\"void f(const std::string &s) {\\n\"\n              \"    for (std::string::const_iterator it = s.begin(); it != s.end(); ++it) {\\n\"\n              \"        const unsigned char c = static_cast<unsigned char>(*it);\\n\"\n              \"        if (c == '0') {}\\n\"\n              \"        else if ((c == 'a' || c == 'A')\\n\"\n              \"                 || (c == 'b' || c == 'B')) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9711\n        check(\"int main(int argc, char* argv[]) {\\n\"\n              \"  int foo = 0;\\n\"\n              \"  struct option options[] = {\\n\"\n              \"    {\\\"foo\\\", no_argument, &foo, \\'f\\'},\\n\"\n              \"    {NULL, 0, NULL, 0},\\n\"\n              \"  };\\n\"\n              \"  getopt_long(argc, argv, \\\"f\\\", options, NULL);\\n\"\n              \"  if (foo) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // TODO: if (!v) is a known condition as well\n        check(\"struct a {\\n\"\n              \"  int *b();\\n\"\n              \"};\\n\"\n              \"bool g(a c, a* d) {\\n\"\n              \"  a *v, *e = v = &c;\\n\"\n              \"  if (!v)\\n\"\n              \"    return true;\\n\"\n              \"  int *f = v->b();\\n\"\n              \"  if (f)\\n\"\n              \"    v = nullptr;\\n\"\n              \"  if (v == nullptr && e) {}\\n\"\n              \"  return d;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:11:23]: (style) Condition 'e' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10037\n        check(\"struct a {\\n\"\n              \"    int* p;\\n\"\n              \"};\\n\"\n              \"void g(a*);\\n\"\n              \"void f() {\\n\"\n              \"    struct a b;\\n\"\n              \"    uint32_t p = (uint32_t) -1;\\n\"\n              \"    b.p = (void *) &p;\\n\"\n              \"    int r = g(&b);\\n\"\n              \"    if (r == 0)\\n\"\n              \"        if (p != (uint32_t) -1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9890\n        check(\"int g(int);\\n\"\n              \"bool h(int*);\\n\"\n              \"int f(int *x) {\\n\"\n              \"    int y = g(0);\\n\"\n              \"    if (!y) {\\n\"\n              \"        if (h(x)) {\\n\"\n              \"            y = g(1);\\n\"\n              \"            if (y) {}\\n\"\n              \"            return 0;\\n\"\n              \"        }\\n\"\n              \"        if (!y) {}\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:11:13]: (style) Condition '!y' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10134\n        check(\"bool foo(bool b);\\n\"\n              \"bool thud(const std::vector<std::wstring>& Arr, const std::wstring& Str) {\\n\"\n              \"  if (Arr.empty() && Str.empty())\\n\"\n              \"    return false;\\n\"\n              \"  bool OldFormat = Arr.empty() && !Str.empty();\\n\"\n              \"  if (OldFormat)\\n\"\n              \"    return foo(OldFormat);\\n\"\n              \"  return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10208\n        check(\"bool GetFirst(std::string &first);\\n\"\n              \"bool GetNext(std::string &next);\\n\"\n              \"void g(const std::string& name);\\n\"\n              \"void f() {\\n\"\n              \"  for (std::string name; name.empty() ? GetFirst(name) : GetNext(name);)\\n\"\n              \"    g(name);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool GetFirst(std::string &first);\\n\"\n              \"bool GetNext(std::string &next);\\n\"\n              \"void g(const std::string& name);\\n\"\n              \"void f() {\\n\"\n              \"  for (std::string name{}; name.empty() ? GetFirst(name) : GetNext(name);)\\n\"\n              \"    g(name);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool GetFirst(std::string &first);\\n\"\n              \"bool GetNext(std::string &next);\\n\"\n              \"void g(const std::string& name);\\n\"\n              \"void f() {\\n\"\n              \"  for (std::string name{'a', 'b'}; name.empty() ? GetFirst(name) : GetNext(name);)\\n\"\n              \"    g(name);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool GetFirst(const std::string &first);\\n\"\n              \"bool GetNext(const std::string &next);\\n\"\n              \"void g(const std::string& name);\\n\"\n              \"void f() {\\n\"\n              \"  for (std::string name; name.empty() ? GetFirst(name) : GetNext(name);)\\n\"\n              \"    g(name);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:36]: (style) Condition 'name.empty()' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10278\n        check(\"void foo(unsigned int x) {\\n\"\n              \"    if ((100 - x) > 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10298\n        check(\"void foo(unsigned int x) {\\n\"\n              \"    if (x == -1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10121\n        check(\"struct AB {\\n\"\n              \"    int a;\\n\"\n              \"};\\n\"\n              \"struct ABC {\\n\"\n              \"    AB* ab;\\n\"\n              \"};\\n\"\n              \"void g(ABC*);\\n\"\n              \"int f(struct ABC *abc) {\\n\"\n              \"    int err = 0;\\n\"\n              \"    AB *ab = abc->ab;\\n\"\n              \"    if (ab->a == 123){\\n\"\n              \"        g(abc);\\n\"\n              \"        if (ab->a != 123) {\\n\"\n              \"            err = 1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return err;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10323\n        check(\"void foo(int x) {\\n\"\n              \"    if(x)\\n\"\n              \"        if(x == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    if(x) {}\\n\"\n              \"    else\\n\"\n              \"        if(x == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:8] -> [test.cpp:4:14]: (style) Condition 'x==1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // do not report both unsignedLessThanZero and knownConditionTrueFalse\n        check(\"void foo(unsigned int max) {\\n\"\n              \"    unsigned int num = max - 1;\\n\"\n              \"    if (num < 0) {}\\n\" // <- do not report knownConditionTrueFalse\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10297\n        check(\"void foo(size_t len, int start) {\\n\"\n              \"    if (start < 0) {\\n\"\n              \"        start = len+start;\\n\"\n              \"        if (start < 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10362\n        check(\"int tok;\\n\"\n              \"void next();\\n\"\n              \"void parse_attribute() {\\n\"\n              \"    if (tok == '(') {\\n\"\n              \"        int parenthesis = 0;\\n\"\n              \"        do {\\n\"\n              \"            if (tok == '(')\\n\"\n              \"                parenthesis++;\\n\"\n              \"            else if (tok == ')')\\n\"\n              \"                parenthesis--;\\n\"\n              \"            next();\\n\"\n              \"        } while (parenthesis && tok != -1);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7843\n        check(\"void f(int i) {\\n\"\n              \"    if(abs(i) == -1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Condition 'abs(i)==-1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #7844\n        check(\"void f(int i) {\\n\"\n              \"    if(i > 0 && abs(i) == i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:24]: (style) Condition 'abs(i)==i' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    if(i < 0 && abs(i) == i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:2:24]: (style) Condition 'abs(i)==i' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    if(i > -3 && abs(i) == i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9948\n        check(\"bool f(bool a, bool b) {\\n\"\n              \"    return a || ! b || ! a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:2:24]: (style) Return value '!a' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10148\n        check(\"void f(int i) {\\n\"\n              \"    if (i >= 64) {}\\n\"\n              \"    else if (i >= 32) {\\n\"\n              \"        i &= 31;\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10548\n        check(\"void f() {\\n\"\n              \"    int i = 0;\\n\"\n              \"    do {} while (i++ == 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10582\n        check(\"static void fun(message_t *message) {\\n\"\n              \"    if (message->length >= 1) {\\n\"\n              \"        switch (data[0]) {}\\n\"\n              \"    }\\n\"\n              \"    uint8_t d0 = message->length > 0 ? data[0] : 0xff;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8266\n        check(\"void f(bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        return;\\n\"\n              \"    if (g(&b) || b)\\n\"\n              \"        return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9720\n        check(\"bool bar(int &);\\n\"\n              \"void f(int a, int b) {\\n\"\n              \"    if (a + b == 3)\\n\"\n              \"        return;\\n\"\n              \"    if (bar(a) && (a + b == 3)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10437\n        check(\"void f() {\\n\"\n              \"  Obj* PObj = nullptr;\\n\"\n              \"  bool b = false;\\n\"\n              \"  if (GetObj(PObj) && PObj != nullptr)\\n\"\n              \"    b = true;\\n\"\n              \"  if (b) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10223\n        check(\"static volatile sig_atomic_t is_running;\\n\"\n              \"static void handler(int signum) {\\n\"\n              \"    is_running = 0;\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    signal(SIGINT, &handler);\\n\"\n              \"    is_running = 1;\\n\"\n              \"    while (is_running) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10659\n        check(\"auto func(const std::tuple<int, int>& t) {\\n\"\n              \"  auto& [foo, bar] = t;\\n\"\n              \"  std::cout << foo << bar << std::endl;\\n\"\n              \"  return foo < bar;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10484\n        check(\"void f() {\\n\"\n              \"    static bool init = true;\\n\"\n              \"    if (init)\\n\"\n              \"        init = false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14] -> [test.cpp:3:9]: (style) The statement 'if (init) init=false' is logically equivalent to 'init=false'. [duplicateConditionalAssign]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static bool init(true);\\n\"\n              \"    if (init)\\n\"\n              \"        init = false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14] -> [test.cpp:3:9]: (style) The statement 'if (init) init=false' is logically equivalent to 'init=false'. [duplicateConditionalAssign]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static bool init{ true };\\n\"\n              \"    if (init)\\n\"\n              \"        init = false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14] -> [test.cpp:3:9]: (style) The statement 'if (init) init=false' is logically equivalent to 'init=false'. [duplicateConditionalAssign]\\n\", errout_str());\n\n        // #10248\n        check(\"void f() {\\n\"\n              \"    static int var(1);\\n\"\n              \"    if (var == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int var{ 1 };\\n\"\n              \"    if (var == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fun();\\n\"\n              \"using Fn = void (*)();\\n\"\n              \"void f() {\\n\"\n              \"    static Fn logger = nullptr;\\n\"\n              \"    if (logger == nullptr)\\n\"\n              \"        logger = Fun;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fun();\\n\"\n              \"using Fn = void (*)();\\n\"\n              \"void f() {\\n\"\n              \"    static Fn logger(nullptr);\\n\"\n              \"    if (logger == nullptr)\\n\"\n              \"        logger = Fun;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fun();\\n\"\n              \"using Fn = void (*)();\\n\"\n              \"void f() {\\n\"\n              \"    static Fn logger{ nullptr };\\n\"\n              \"    if (logger == nullptr)\\n\"\n              \"        logger = Fun;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fun();\\n\"\n              \"typedef void (*Fn)();\\n\"\n              \"void f() {\\n\"\n              \"    static Fn logger = nullptr;\\n\"\n              \"    if (logger == nullptr)\\n\"\n              \"        logger = Fun;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fun();\\n\"\n              \"typedef void (*Fn)();\\n\"\n              \"void f() {\\n\"\n              \"    static Fn logger(nullptr);\\n\"\n              \"    if (logger == nullptr)\\n\"\n              \"        logger = Fun;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Fun();\\n\"\n              \"typedef void (*Fn)();\\n\"\n              \"void f() {\\n\"\n              \"    static Fn logger{ nullptr };\\n\"\n              \"    if (logger == nullptr)\\n\"\n              \"        logger = Fun;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9256\n        check(\"bool f() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    b = true;\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10702\n        check(\"struct Object {\\n\"\n              \"  int _count=0;\\n\"\n              \"   void increment() { ++_count;}\\n\"\n              \"   auto get() const { return _count; }\\n\"\n              \"};\\n\"\n              \"struct Modifier {\\n\"\n              \"Object & _object;\\n\"\n              \"  explicit Modifier(Object & object) : _object(object) {}\\n\"\n              \"  void do_something() { _object.increment(); }\\n\"\n              \"};\\n\"\n              \"struct Foo {\\n\"\n              \"  Object _object;\\n\"\n              \"  void foo() {\\n\"\n              \"    Modifier mod(_object);\\n\"\n              \"    if (_object.get()>0)\\n\"\n              \"      return;\\n\"\n              \"    mod.do_something();\\n\"\n              \"    if (_object.get()>0)\\n\"\n              \"      return;\\n\"\n              \"  }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Object {\\n\"\n              \"  int _count=0;\\n\"\n              \"   auto get() const;\\n\"\n              \"};\\n\"\n              \"struct Modifier {\\n\"\n              \"Object & _object;\\n\"\n              \"  explicit Modifier(Object & object);\\n\"\n              \"  void do_something();\\n\"\n              \"};\\n\"\n              \"struct Foo {\\n\"\n              \"  Object _object;\\n\"\n              \"  void foo() {\\n\"\n              \"    Modifier mod(_object);\\n\"\n              \"    if (_object.get()>0)\\n\"\n              \"      return;\\n\"\n              \"    mod.do_something();\\n\"\n              \"    if (_object.get()>0)\\n\"\n              \"      return;\\n\"\n              \"  }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const uint32_t u) {\\n\"\n              \"\tconst uint32_t v = u < 4;\\n\"\n              \"\tif (v) {\\n\"\n              \"\t\tconst uint32_t w = v < 2;\\n\"\n              \"\t\tif (w) {}\\n\"\n              \"\t}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:24]: (style) Condition 'v<2' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:5:7]: (style) Condition 'w' is always true [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"void f(double d) {\\n\" // #10792\n              \"    if (d != 0) {\\n\"\n              \"        int i = (int)d;\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(double d) {\\n\"\n              \"    if (0 != d) {\\n\"\n              \"        int i = (int)d;\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { double d; }\\n\"\n              \"void f(A a) {\\n\"\n              \"    if (a.d != 0) {\\n\"\n              \"        int i = a.d;\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if(strlen(\\\"abc\\\") == 3) {;}\\n\"\n              \"    if(strlen(\\\"abc\\\") == 1) {;}\\n\"\n              \"    if(wcslen(L\\\"abc\\\") == 3) {;}\\n\"\n              \"    if(wcslen(L\\\"abc\\\") == 1) {;}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (style) Condition 'strlen(\\\"abc\\\")==3' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:3:22]: (style) Condition 'strlen(\\\"abc\\\")==1' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:4:23]: (style) Condition 'wcslen(L\\\"abc\\\")==3' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:5:23]: (style) Condition 'wcslen(L\\\"abc\\\")==1' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"int foo(bool a, bool b) {\\n\"\n              \"  if(!a && b && (!a == !b))\\n\"\n              \"   return 1;\\n\"\n              \"  return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:6] -> [test.cpp:2:21]: (style) Condition '!a==!b' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10454\n        check(\"struct S {\\n\"\n              \"    int f() const { return g() ? 0 : 1; }\\n\"\n              \"    bool g() const { return u == 18446744073709551615ULL; }\\n\"\n              \"    unsigned long long u{};\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8358\n        check(\"void f(double d) { if ((d * 0) != 0) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6870\n        check(\"struct S {\\n\"\n              \"    int* p;\\n\"\n              \"    void f() const;\\n\"\n              \"    int g();\\n\"\n              \"};\\n\"\n              \"void S::f() {\\n\"\n              \"    if ((p == NULL) || ((p) && (g() >= *p))) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:26]: (style) Condition 'p' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10749\n        check(\"struct Interface {\\n\"\n              \"    virtual int method() = 0;\\n\"\n              \"};\\n\"\n              \"struct Child : Interface {\\n\"\n              \"   int method() override { return 0; }\\n\"\n              \"   auto foo() {\\n\"\n              \"       if (method() == 0)\\n\"\n              \"           return true;\\n\"\n              \"       else\\n\"\n              \"           return false;\\n\"\n              \"   }\\n\"\n              \"};\\n\"\n              \"struct GrandChild : Child {\\n\"\n              \"   int method() override  { return 1; }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6855\n        check(\"struct S { int i; };\\n\"\n              \"void f(S& s) {\\n\"\n              \"    if (!(s.i > 0) && (s.i != 0))\\n\"\n              \"        s.i = 0;\\n\"\n              \"    else if (s.i < 0)\\n\"\n              \"        s.s = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:15] -> [test.cpp:5:18]: (style) Condition 's.i<0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #6857\n        check(\"int bar(int i) { return i; }\\n\"\n              \"void foo() {\\n\"\n              \"    if (bar(1) == 0 && bar(1) > 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Condition 'bar(1)==0' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:3:31]: (style) Condition 'bar(1)>0' is always true [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"struct S { int bar(int i) const; };\\n\"\n              \"void foo(const S& s) {\\n\"\n              \"    if (s.bar(1) == 0 && s.bar(1) > 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (warning) Logical conjunction always evaluates to false: s.bar(1) == 0 && s.bar(1) > 0. [incorrectLogicOperator]\\n\",\n                      errout_str());\n\n        check(\"struct B {\\n\" // #10618\n              \"    void Modify();\\n\"\n              \"    static void Static();\\n\"\n              \"    virtual void CalledByModify();\\n\"\n              \"};\\n\"\n              \"struct D : B {\\n\"\n              \"    int i{};\\n\"\n              \"    void testV();\\n\"\n              \"    void testS();\\n\"\n              \"    void CalledByModify() override { i = 0; }\\n\"\n              \"};\\n\"\n              \"void D::testV() {\\n\"\n              \"    i = 1;\\n\"\n              \"    B::Modify();\\n\"\n              \"    if (i == 1) {}\\n\"\n              \"}\\n\"\n              \"void D::testS() {\\n\"\n              \"    i = 1;\\n\"\n              \"    B::Static();\\n\"\n              \"    if (i == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:20:11]: (style) Condition 'i==1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"typedef struct { bool x; } s_t;\\n\" // #8446\n              \"unsigned f(bool a, bool b) {\\n\"\n              \"    s_t s;\\n\"\n              \"    const unsigned col = a ? (s.x = false) : (b = true);\\n\"\n              \"    if (!s.x) {}\\n\"\n              \"    return col;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #11233\n              \"    static std::string m;\\n\"\n              \"    static void f() { m = \\\"abc\\\"; }\\n\"\n              \"    static void g() {\\n\"\n              \"        m.clear();\\n\"\n              \"        f();\\n\"\n              \"        if (m.empty()) {}\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11203\n        check(\"void f() {\\n\"\n              \"    int i = 10;\\n\"\n              \"    if(i > 9.9){}\\n\"\n              \"    float f = 9.9f;\\n\"\n              \"    if(f < 10) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:10]: (style) Condition 'i>9.9' is always true [knownConditionTrueFalse]\\n\"\n            \"[test.cpp:5:10]: (style) Condition 'f<10' is always true [knownConditionTrueFalse]\\n\",\n            errout_str());\n        check(\"constexpr int f() {\\n\" // #11238\n              \"    return 1;\\n\"\n              \"}\\n\"\n              \"constexpr bool g() {\\n\"\n              \"    return f() == 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g() { return -1; }\\n\"\n              \"void f() {\\n\"\n              \"    if (g() == 1 && g() == -1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Condition 'g()==1' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:3:25]: (style) Condition 'g()==-1' is always true [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        // #9817\n        check(\"void f(float x) {\\n\"\n              \"    if (x <= 0) {}\\n\"\n              \"    else if (x < 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10426\n        check(\"int f() {\\n\"\n              \"    std::string s;\\n\"\n              \"    for (; !s.empty();) {}\\n\"\n              \"    for (; s.empty();) {}\\n\"\n              \"    if (s.empty()) {}\\n\"\n              \"    if ((bool)0) {}\\n\"\n              \"    return s.empty();\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) Condition '!s.empty()' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:4:19]: (style) Condition 's.empty()' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:5:16]: (style) Condition 's.empty()' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:6:9]: (style) Condition '(bool)0' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:7:19]: (style) Return value 's.empty()' is always true [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"int f(bool b) {\\n\"\n              \"    if (b) return static_cast<int>(1);\\n\"\n              \"    return (int)0;\\n\"\n              \"}\\n\"\n              \"bool g(bool b) {\\n\"\n              \"    if (b) return static_cast<int>(1);\\n\"\n              \"    return (int)0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:35]: (style) Return value 'static_cast<int>(1)' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:7:12]: (style) Return value '(int)0' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"int f() { return 3; }\\n\"\n              \"int g() { return f(); }\\n\"\n              \"int h() { if (f()) {} }\\n\"\n              \"int i() { return f() == 3; }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Condition 'f()' is always true [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:4:22]: (style) Return value 'f()==3' is always true [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"int f() {\\n\"\n              \"    const char *n;\\n\"\n              \"    return((n=42) &&\\n\"\n              \"           *n == 'A');\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::istringstream& i) {\\n\" // #9327\n              \"    std::string s;\\n\"\n              \"    if (!(i >> s))\\n\"\n              \"        return;\\n\"\n              \"    if (!(i >> s))\\n\"\n              \"        return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11227\n        check(\"struct S {\\n\"\n              \"\tint get();\\n\"\n              \"};\\n\"\n              \"void f(const S* s) {\\n\"\n              \"    if (!s)\\n\"\n              \"        return;\\n\"\n              \"    g(s ? s->get() : 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:7:7]: (style) Condition 's' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const char* o) {\\n\" // #11558\n              \"    if (!o || !o[0])\\n\"\n              \"        return;\\n\"\n              \"    if (o[0] == '-' && o[1]) {\\n\"\n              \"        if (o[1] == '-') {}\\n\"\n              \"        if (o[1] == '\\\\0') {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        if (std::numeric_limits<char>::is_signed) {\n            ASSERT_EQUALS(\"[test.cpp:6:18]: (style) Condition 'o[1]=='\\\\0'' is always false [knownConditionTrueFalse]\\n\", errout_str());\n        } else {\n            ASSERT_EQUALS(\"[test.cpp:4] -> [test.cpp:6]: (style) Condition 'o[1]=='\\\\0'' is always false [knownConditionTrueFalse]\\n\", errout_str());\n        }\n\n        check(\"void f(int x) {\\n\" // #11449\n              \"    int i = x;\\n\"\n              \"    i = (std::min)(i, 1);\\n\"\n              \"    if (i == 1) {}\\n\"\n              \"    int j = x;\\n\"\n              \"    j = (::std::min)(j, 1);\\n\"\n              \"    if (j == 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void h(int);\\n\" // #11679\n              \"bool g(int a) { h(a); return false; }\\n\"\n              \"bool f(int i) {\\n\"\n              \"    return g(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string a) {\\n\" // #11051\n              \"    a = \\\"x\\\";\\n\"\n              \"    if (a == \\\"x\\\") {}\\n\"\n              \"    return a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'a==\\\"x\\\"' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void g(bool);\\n\"\n              \"void f() {\\n\"\n              \"    int i = 5;\\n\"\n              \"    int* p = &i;\\n\"\n              \"    g(i == 7);\\n\"\n              \"    g(p == nullptr);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style) Condition 'i==7' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:6:9]: (style) Condition 'p==nullptr' is always false [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"enum E { E0, E1 };\\n\"\n              \"void f() {\\n\"\n              \"\tstatic_assert(static_cast<int>(E::E1) == 1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct a {\\n\"\n              \"  bool g();\\n\"\n              \"  int h();\\n\"\n              \"};\\n\"\n              \"void f(a c, int d, int e) {\\n\"\n              \"  if (c.g() && c.h()) {}\\n\"\n              \"  else {\\n\"\n              \"    bool u = false;\\n\"\n              \"    if (d && e)\\n\"\n              \"      u = true;\\n\"\n              \"    if (u) {}\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\" // #11741\n              \"    i = -i - 1;\\n\"\n              \"    if (i < 0 || i >= 20)\\n\"\n              \"        return 0;\\n\"\n              \"    return 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace S { int s{}; };\\n\" // #11046\n              \"void f(bool b) {\\n\"\n              \"    if (S::s) {\\n\"\n              \"        if (b) {\\n\"\n              \"            if (S::s) {}\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:18]: (style) Condition 'S::s' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #10811\n              \"    int i = 0;\\n\"\n              \"    if ((i = g(), 1) != 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (style) Condition '(i=g(),1)!=0' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(unsigned i) {\\n\"\n              \"    const int a[2] = {};\\n\"\n              \"    const int* q = a + i;\\n\"\n              \"    if (q) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Condition 'q' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #12786\n              \"    const int b[2] = {};\\n\"\n              \"    if (b) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Condition 'b' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int j = 0;\\n\"\n              \"    switch (i) {\\n\"\n              \"    case 1:\\n\"\n              \"        j = 0;\\n\"\n              \"        break;\\n\"\n              \"    default:\\n\"\n              \"        j = 1;\\n\"\n              \"    }\\n\"\n              \"    if (j != 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const char *s1 = foo();\\n\"\n              \"    const char *s2 = bar();\\n\"\n              \"    if (s2 == NULL)\\n\"\n              \"        return;\\n\"\n              \"    size_t len = s2 - s1;\\n\"\n              \"    if (len == 0)\\n\"\n              \"        return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int h();\\n\" // #12858\n              \"bool g() {\\n\"\n              \"    bool b{};\\n\"\n              \"    try {\\n\"\n              \"        int x = h();\\n\"\n              \"        switch (x) {\\n\"\n              \"        default:\\n\"\n              \"            b = true;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    catch (...) {\\n\"\n              \"        b = false;\\n\"\n              \"    }\\n\"\n              \"    return b;\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    if (g()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int x, int y) {\\n\" // #11822\n              \"    if (x) {\\n\"\n              \"        switch (y) {\\n\"\n              \"        case 1:\\n\"\n              \"            return 7;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \" \\n\"\n              \"    if (y)\\n\"\n              \"        return 8;\\n\"\n              \" \\n\"\n              \"    if (x)\\n\"\n              \"        return 9;\\n\"\n              \" \\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g();\\n\" // #10561\n              \"bool h();\\n\"\n              \"int f() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    try {\\n\"\n              \"        switch (g()) {\\n\"\n              \"        default:\\n\"\n              \"            b = h();\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    catch (...) {}\\n\"\n              \"    return b ? 1 : 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    const S* get2() const {\\n\"\n              \"        if (mS)\\n\"\n              \"            return mS;\\n\"\n              \"        return this;\\n\"\n              \"    }\\n\"\n              \"    S* mS = nullptr;\\n\"\n              \"};\\n\"\n              \"void f2() {\\n\"\n              \"    const S s;\\n\"\n              \"    const S* sp2 = s.get2();\\n\"\n              \"    if (sp2) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:12:9]: (style) Condition 'sp2' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    void f(int i);\\n\"\n              \"    bool g() const { return !m.empty(); }\\n\"\n              \"    std::set<int> m;\\n\"\n              \"};\\n\"\n              \"void S::f(int i) {\\n\"\n              \"    bool b = g();\\n\"\n              \"    auto it = m.find(i);\\n\"\n              \"    if (it != m.end()) {\\n\"\n              \"        m.erase(it);\\n\"\n              \"        if (g() != b) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void alwaysTrueSymbolic()\n    {\n        check(\"void f(const uint32_t x) {\\n\"\n              \"    uint32_t y[1];\\n\"\n              \"    y[0]=x;\\n\"\n              \"    if(x > 0 || y[0] < 42){}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10] -> [test.cpp:4:22]: (style) Condition 'y[0]<42' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"    if(x < y && x < 42) {\\n\"\n              \"        --x;\\n\"\n              \"        if(x == y) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:4:14]: (style) Condition 'x==y' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(bool a, bool b) {  if (a == b && a && !b){} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:41] -> [test.cpp:1:46]: (style) Condition '!b' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"bool f(bool a, bool b) { if(a && b && (!a)){} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:29] -> [test.cpp:1:40]: (style) Condition '!a' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"  if (x < y) {\\n\"\n              \"    auto z = y - x;\\n\"\n              \"    if (z < 1) {}\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:11]: (style) Condition 'z<1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"bool f(int &index, const int s, const double * const array, double & x) {\\n\"\n              \"    if (index >= s)\\n\"\n              \"        return false;\\n\"\n              \"    else {\\n\"\n              \"        x = array[index];\\n\"\n              \"        return (index++) >= s;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:15] -> [test.cpp:6:26]: (style) Return value '(index++)>=s' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct a {\\n\"\n              \"  a *b() const;\\n\"\n              \"} c;\\n\"\n              \"void d() {\\n\"\n              \"  a *e = nullptr;\\n\"\n              \"  e = c.b();\\n\"\n              \"  if (e) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g(int i) {\\n\"\n              \"  if (i < 256)\\n\"\n              \"    return 1;\\n\"\n              \"  const int N = 2 * i;\\n\"\n              \"  i -= 256;\\n\"\n              \"  if (i == 0)\\n\"\n              \"    return 0;\\n\"\n              \"  return N;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i, int j) {\\n\"\n              \"    if (i < j) {\\n\"\n              \"        i++;\\n\"\n              \"        if (i >= j)\\n\"\n              \"            return;\\n\"\n              \"        i++;\\n\"\n              \"        if (i >= j) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int get_delta() {\\n\"\n              \"    clock_t now_ms = (clock() / (CLOCKS_PER_SEC / 1000));\\n\"\n              \"    static clock_t last_clock_ms = now_ms;\\n\"\n              \"    clock_t delta = now_ms - last_clock_ms;\\n\"\n              \"    last_clock_ms = now_ms;\\n\"\n              \"    if (delta > 50)\\n\"\n              \"        delta = 50;\\n\"\n              \"    return delta;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10555\n        check(\"struct C {\\n\"\n              \"  int GetI() const { return i; }\\n\"\n              \"  int i{};\\n\"\n              \"};\\n\"\n              \"struct B {\\n\"\n              \"    C *m_PC{};\\n\"\n              \"    Modify();\\n\"\n              \"};\\n\"\n              \"struct D : B {\\n\"\n              \"  void test();  \\n\"\n              \"};\\n\"\n              \"void D::test() {\\n\"\n              \"    const int I = m_PC->GetI();\\n\"\n              \"    Modify();\\n\"\n              \"    if (m_PC->GetI() != I) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10624\n        check(\"struct Data {\\n\"\n              \"  Base* PBase{};\\n\"\n              \"};\\n\"\n              \"void f(Data* BaseData) {\\n\"\n              \"  Base* PObj = BaseData->PBase;\\n\"\n              \"  if (PObj == nullptr)\\n\"\n              \"    return;\\n\"\n              \"  Derived* pD = dynamic_cast<Derived*>(PObj);\\n\"\n              \"  if (pD) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9549\n        check(\"void f(const uint32_t v) {\\n\"\n              \"    const uint32_t v16 = v >> 16;\\n\"\n              \"    if (v16) {\\n\"\n              \"        const uint32_t v8 = v16 >> 8;\\n\"\n              \"        if (v8) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10649\n        check(\"void foo(struct diag_msg *msg) {\\n\"\n              \"    msg = msg->next;\\n\"\n              \"    if (msg == NULL)\\n\"\n              \"        return CMD_OK;\\n\"\n              \"    msg = msg->next;\\n\"\n              \"    if (msg == NULL)\\n\"\n              \"        return CMD_OK;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(bool a, bool b) {\\n\"\n              \"  if((!a == !b) && !a && b)\\n\"\n              \"   return 1;\\n\"\n              \"  return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:2:26]: (style) Condition 'b' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #11124\n        check(\"struct Basket {\\n\"\n              \"\tstd::vector<int> getApples() const;\\n\"\n              \"\tstd::vector<int> getBananas() const;\t\\n\"\n              \"};\\n\"\n              \"int getFruit(const Basket & b, bool preferApples)\\n\"\n              \"{\\n\"\n              \"    std::vector<int> apples = b.getApples();\\n\"\n              \"    int apple = apples.empty() ? -1 : apples.front();\\n\"\n              \"    std::vector<int> bananas = b.getBananas();\\n\"\n              \"    int banana = bananas.empty() ? -1 : bananas.front();\\n\"\n              \"    int fruit = std::max(apple, banana);\\n\"\n              \"    if (fruit == -1)\\n\"\n              \"        return fruit;\\n\"\n              \"    if (std::min(apple, banana) != -1)\\n\"\n              \"        fruit = preferApples ? apple : banana;\\n\"\n              \"    return fruit;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::string & s, int i) {\\n\"\n              \"    const char c = s[i];\\n\"\n              \"    if (!std::isalnum(c)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #11404\n              \"    int f() const;\\n\"\n              \"    void g();\\n\"\n              \"};\\n\"\n              \"void h(std::vector<S*>::iterator it) {\\n\"\n              \"    auto i = (*it)->f();\\n\"\n              \"    (*it)->g();\\n\"\n              \"    auto j = (*it)->f();\\n\"\n              \"    if (i == j) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11384\n        check(\"bool f(const int* it, const int* end) {\\n\"\n              \"\treturn (it != end) && *it++ &&\\n\"\n              \"           (it != end) && *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12116\n        check(\"void f(int n) {\\n\"\n              \"    for (int i = 0; i < N; ++i) {\\n\"\n              \"        if (i < n) {}\\n\"\n              \"        else if (i > n) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12681\n        check(\"void f(unsigned u) {\\n\"\n              \"      if (u > 0) {\\n\"\n              \"             u--;\\n\"\n              \"             if (u == 0) {}\\n\"\n              \"      }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(unsigned u) {\\n\"\n              \"      if (u < 0xFFFFFFFF) {\\n\"\n              \"             u++;\\n\"\n              \"             if (u == 0xFFFFFFFF) {}\\n\"\n              \"      }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\" // #12937\n              \"    bool c = !a && b;\\n\"\n              \"    if (a) {}\\n\"\n              \"    else {\\n\"\n              \"        if (c) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(unsigned x) {\\n\" // #13522\n              \"    unsigned u = x;\\n\"\n              \"    int i = u - 0;\\n\"\n              \"    if (i < 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void alwaysTrueInfer() {\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 5) {\\n\"\n              \"        x++;\\n\"\n              \"        if (x == 1) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:4:15]: (style) Condition 'x==1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 5) {\\n\"\n              \"        x++;\\n\"\n              \"        if (x != 1) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:4:15]: (style) Condition 'x!=1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #6890\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x == -1) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x==-1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x != -1) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x!=-1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x >= -1) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x>=-1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x > -1) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x>-1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x < -1) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x<-1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x <= -1) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x<=-1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x > 7) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:6:15]: (style) Condition 'x>7' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x > 9) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    int x = i;\\n\"\n              \"    if (x >= 1) {}\\n\"\n              \"    else {\\n\"\n              \"        x = 8 - x;\\n\"\n              \"        if (x > 10) {}\\n\"\n              \"        else {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11100\n        check(\"struct T {\\n\"\n              \"  bool m{};\\n\"\n              \"  void f(bool b);\\n\"\n              \"  bool get() const { return m; }\\n\"\n              \"  void set(bool v) { m = v; }\\n\"\n              \"};\\n\"\n              \"void T::f(bool b) {\\n\"\n              \"\tbool tmp = get();\\n\"\n              \"\tset(b);\\n\"\n              \"\tif (tmp != get()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9541\n        check(\"int f(int pos, int a) {\\n\"\n              \"    if (pos <= 0)\\n\"\n              \"        pos = 0;\\n\"\n              \"    else if (pos < a)\\n\"\n              \"        if(pos > 0)\\n\"\n              \"            --pos;\\n\"\n              \"    return pos;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:5:16]: (style) Condition 'pos>0' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #9721\n        check(\"void f(int x) {\\n\"\n              \"    if (x > 127) {\\n\"\n              \"        if ( (x>255) || (-128>x) )\\n\"\n              \"            return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:30]: (style) Condition '-128>x' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #8778\n        check(\"void f() {\\n\"\n              \"    for(int i = 0; i < 19; ++i)\\n\"\n              \"        if(i<=18) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Condition 'i<=18' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #8209\n        check(\"void f() {\\n\"\n              \"    for(int x = 0; x < 3; ++x)\\n\"\n              \"        if(x == -5) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Condition 'x==-5' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #8407\n        check(\"int f(void) {\\n\"\n              \"    for(int i = 0; i <1; ++i)\\n\"\n              \"        if(i == 0) return 1; \\n\" // <<\n              \"        else return 0;\\n\"\n              \"    return -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Condition 'i==0' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(unsigned int u1, unsigned int u2) {\\n\"\n              \"    if (u1 <= 10 && u2 >= 20) {\\n\"\n              \"        if (u1 != u2) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:12] -> [test.cpp:3:16]: (style) Condition 'u1!=u2' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10544\n        check(\"void f(int N) {\\n\"\n              \"    if (N > 0) {\\n\"\n              \"        while (N)\\n\"\n              \"            N = test();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11098\n        check(\"void f(unsigned int x) { if (x == -1u) {} }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(const int *p, const int *q) {\\n\"\n              \"    return p != NULL && q != NULL && p == NULL;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:40]: (style) Return value 'p==NULL' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct S {\\n\" // #11789\n              \"    std::vector<int> v;\\n\"\n              \"    void f(int i) const;\\n\"\n              \"};\\n\"\n              \"void S::f(int i) const {\\n\"\n              \"    int j = i - v.size();\\n\"\n              \"    if (j >= 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i) {\\n\" // #12039\n              \"    if ((128 + i < 255 ? 128 + i : 255) > 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12727\n              \"    bool f() const {\\n\"\n              \"        return g() > 0;\\n\"\n              \"    }\\n\"\n              \"    std::size_t g() const {\\n\"\n              \"        return 5 - h();\\n\"\n              \"    }\\n\"\n              \"    std::size_t h() const {\\n\"\n              \"        if (x > 7)\\n\"\n              \"            return 5;\\n\"\n              \"        return (5 + x) % 5;\\n\"\n              \"    }\\n\"\n              \"    std::size_t x;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void alwaysTrueContainer() {\n        // #9329\n        check(\"void c1(std::vector<double>&);\\n\"\n              \"void c2(std::vector<double>&);\\n\"\n              \"void foo(int flag) {\\n\"\n              \"    std::vector<double> g;\\n\"\n              \"    if (flag)\\n\"\n              \"        c1(g );\\n\"\n              \"    else\\n\"\n              \"        c2(g );\\n\"\n              \"    if ( !g.empty() )\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int flag) {\\n\"\n              \"    std::vector<double> g;\\n\"\n              \"    if (flag)\\n\"\n              \"        c1(g );\\n\"\n              \"    else\\n\"\n              \"        c2(g );\\n\"\n              \"    if ( !g.empty() )\\n\"\n              \"        return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    void g();\\n\"\n              \"    void f(bool b) {\\n\"\n              \"        v.clear();\\n\"\n              \"        g();\\n\"\n              \"        return !v.empty();\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10409\n        check(\"void foo(const std::string& s) {\\n\"\n              \"    if( s.size() < 2 ) return;\\n\"\n              \"    if( s == \\\"ab\\\" ) return;\\n\"\n              \"    if( s.size() < 3 ) return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const std::string& s) {\\n\"\n              \"    if( s.size() < 2 ) return;\\n\"\n              \"    if( s != \\\"ab\\\" )\\n\"\n              \"        if( s.size() < 3 ) return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10226\n        check(\"int f(std::vector<int>::iterator it, const std::vector<int>& vector) {\\n\"\n              \"    if (!(it != vector.end() && it != vector.begin()))\\n\"\n              \"        throw 0;\\n\"\n              \"    if (it != vector.end() && *it == 0)\\n\"\n              \"        return -1;\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (style) Condition 'it!=vector.end()' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #11303\n        check(\"void f(int n) {\\n\"\n              \"    std::vector<char> buffer(n);\\n\"\n              \"    if(buffer.back() == 0 ||\\n\"\n              \"       buffer.back() == '\\\\n' ||\\n\"\n              \"       buffer.back() == '\\\\0') {}\\n\"\n              \"}\\n\");\n        if (std::numeric_limits<char>::is_signed) {\n            ASSERT_EQUALS(\"[test.cpp:5:22]: (style) Condition 'buffer.back()=='\\\\0'' is always false [knownConditionTrueFalse]\\n\", errout_str());\n        } else {\n            ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:5]: (style) Condition 'buffer.back()=='\\\\0'' is always false\\n\", errout_str());\n        }\n\n        // #9353\n        check(\"struct X { std::string s; };\\n\"\n              \"void f(const std::vector<X>&v) {\\n\"\n              \"    for (std::vector<X>::const_iterator it = v.begin(); it != v.end(); ++it)\\n\"\n              \"        if (!it->s.empty()) {\\n\"\n              \"            if (!it->s.empty()) {}\\n\"\n              \"        }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:5:17]: (style) Condition '!it->s.empty()' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct X { std::string s; };\\n\"\n              \"void f(const std::vector<struct X>&v) {\\n\"\n              \"    for (std::vector<struct X>::const_iterator it = v.begin(); it != v.end(); ++it)\\n\"\n              \"        if (!it->s.empty()) {\\n\"\n              \"            if (!it->s.empty()) {}\\n\"\n              \"        }\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:5:17]: (style) Condition '!it->s.empty()' is always true [knownConditionTrueFalse]\\n\", \"\", errout_str());\n\n        // #10508\n        check(\"bool f(const std::string& a, const std::string& b) {\\n\"\n              \"    return a.empty() || (b.empty() && a.empty());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:19] -> [test.cpp:2:46]: (style) Return value 'a.empty()' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    struct iterator;\\n\"\n              \"    iterator begin() const;\\n\"\n              \"    iterator end() const;\\n\"\n              \"};\\n\"\n              \"A g();\\n\"\n              \"void f(bool b) {\\n\"\n              \"    std::set<int> s;\\n\"\n              \"    auto v = g();\\n\"\n              \"    s.insert(v.begin(), v.end());\\n\"\n              \"    if(!b && s.size() != 1)\\n\"\n              \"        return;\\n\"\n              \"    if(!s.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::string s) {\\n\"\n              \"    if (s.empty())\\n\"\n              \"        return -1;\\n\"\n              \"    s += '\\\\n';\\n\"\n              \"    if (s.empty())\\n\"\n              \"        return -1;\\n\"\n              \"    return -1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (style) Condition 's.empty()' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(std::string& p) {\\n\"\n              \"    const std::string d{ \\\"abc\\\" };\\n\"\n              \"    p += d;\\n\"\n              \"    if(p.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (style) Condition 'p.empty()' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"bool f(int i, FILE* fp) {\\n\"\n              \"  std::string s = \\\"abc\\\";\\n\"\n              \"  s += std::to_string(i);\\n\"\n              \"  s += \\\"\\\\n\\\";\\n\"\n              \"  return fwrite(s.c_str(), 1, s.length(), fp) == s.length();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::string& s) {\\n\" // #9148\n              \"    if (s.empty() || s.size() < 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:2:31]: (style) Condition 's.size()<1' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void bar(std::vector<int>& vv) {\\n\" // #11464\n              \"    class F {\\n\"\n              \"    public:\\n\"\n              \"        F(int, std::vector<int>& lv) : mV(lv) {\\n\"\n              \"            mV.push_back(0);\\n\"\n              \"        }\\n\"\n              \"    private:\\n\"\n              \"        std::vector<int>& mV;\\n\"\n              \"    } fi(1, vv);\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    bar(v);\\n\"\n              \"    if (v.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct F {\\n\"\n              \"    F(int, std::vector<int>&lv) : mV(lv) {\\n\"\n              \"        mV.push_back(0);\\n\"\n              \"    }\\n\"\n              \"    std::vector<int>& mV;\\n\"\n              \"};\\n\"\n              \"void g(std::vector<int>& vv) {\\n\"\n              \"    F(1, vv);\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    g(v);\\n\"\n              \"    if (v.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void alwaysTrueLoop()\n    {\n        check(\"long foo() {\\n\"\n              \"  bool bUpdated = false;\\n\"\n              \"  long Ret{};\\n\"\n              \"  do {\\n\"\n              \"    Ret = bar();\\n\"\n              \"    if (Ret == 0) {\\n\"\n              \"      if (bUpdated)\\n\"\n              \"        return 1;\\n\"\n              \"      bUpdated = true;\\n\"\n              \"    }\\n\"\n              \"    else\\n\"\n              \"      bUpdated = false;\\n\"\n              \"  }\\n\"\n              \"  while (bUpdated);\\n\"\n              \"  return Ret;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo() {\\n\"\n              \"  bool bFirst = true;\\n\"\n              \"  do {\\n\"\n              \"    if (bFirst)\\n\"\n              \"      bar();\\n\"\n              \"    if (baz())\\n\"\n              \"      break;       \\n\"\n              \"    bFirst = false;\\n\"\n              \"  } while (true);\\n\"\n              \"  return bFirst;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   void * pool = NULL;\\n\"\n              \"   do {\\n\"\n              \"      pool = malloc(40);\\n\"\n              \"      if (dostuff())\\n\"\n              \"         break;\\n\"\n              \"      pool = NULL;\\n\"\n              \"   }\\n\"\n              \"   while (0);\\n\"\n              \"   if (pool) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8499\n        check(\"void f(void)\\n\"\n              \"{\\n\"\n              \"    for (int i = 0; i < 2; ++i)\\n\"\n              \"    {\\n\"\n              \"        for (int j = 0; j < 8; ++j)\\n\"\n              \"        {\\n\"\n              \"            if ( (i==0|| i==1)\\n\" // << always true\n              \"              && (j==0) )\\n\"\n              \"            {;}\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:20] -> [test.cpp:7:27]: (style) Condition 'i==1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #10863\n        check(\"void f(const int A[], int Len) {\\n\"\n              \"  if (Len <= 0)\\n\"\n              \"    return;\\n\"\n              \"  int I = 0;\\n\"\n              \"  while (I < Len) {\\n\"\n              \"    int K = I + 1;\\n\"\n              \"    for (; K < Len; K++) {\\n\"\n              \"      if (A[I] != A[K])\\n\"\n              \"        break;\\n\"\n              \"    } \\n\"\n              \"    I = K;   \\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #11434\n              \"    const int N = 5;\\n\"\n              \"    bool a[N];\\n\"\n              \"    for (int i = 0; i < N; a[i++] = false);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #8192\n              \"    for (int i = 0; i > 10; ++i) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2]: (style) Condition 'i>10' is always false\\n\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    for (int i = 1000; i < 20; ++i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (style) Condition 'i<20' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"int foo(int foo, int bar, bool baz, bool flag) {\\n\"\n              \"    if (baz && flag) {\\n\"\n              \"        do {\\n\"\n              \"            if (bar==42)\\n\"\n              \"                return 0;\\n\"\n              \"        } while (flag);\\n\"\n              \"    }\\n\"\n              \"    return foo;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:6:18]: (style) Condition 'flag' is always true [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void alwaysTrueTryCatch()\n    {\n        check(\"void g();\\n\"\n              \"void f(int x)\\n\"\n              \"{\\n\"\n              \"    if( x ) {\\n\"\n              \"        try {\\n\"\n              \"            g();\\n\"\n              \"        }\\n\"\n              \"        catch(...) {\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    g();\\n\"\n              \"    if( x ) {\\n\"\n              \"        g();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g();\\n\"\n              \"void h();\\n\"\n              \"void f(int x) {\\n\"\n              \"    if( x ) {\\n\"\n              \"        try {\\n\"\n              \"            g();\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"        catch( ... ) {}\\n\"\n              \"    }\\n\"\n              \"    h();\\n\"\n              \"    if( x ) {\\n\"\n              \"        g();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #10701\n              \"    std::string s;\\n\"\n              \"    try {\\n\"\n              \"        try {\\n\"\n              \"            s = g();\\n\"\n              \"        }\\n\"\n              \"        catch (const Err& err) {}\\n\"\n              \"    }\\n\"\n              \"    catch (const std::exception& e) {}\\n\"\n              \"    if (s != \\\"abc\\\") {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void multiConditionAlwaysTrue() {\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  if (val < 0) continue;\\n\"\n              \"  if (val > 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  if (val < 0) {\\n\"\n              \"    if (val > 0) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  if (val < 0) {\\n\"\n              \"    if (val < 0) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int activate = 0;\\n\"\n              \"  int foo = 0;\\n\"\n              \"  if (activate) {}\\n\"\n              \"  else if (foo) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) Condition 'activate' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:5:12]: (style) Condition 'foo' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #6904\n        check(\"void f() {\\n\"\n              \"  const int b[2] = { 1,0 };\\n\"\n              \"  if(b[1] == 2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'b[1]==2' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #9878\n        check(\"void f(bool a, bool b) {\\n\"\n              \"    if (a && b){;}\\n\"\n              \"    else if (!a && b){;}\\n\"\n              \"    else if (!a && !b){;}\\n\"\n              \"    else {;}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateCondition() {\n        check(\"void f(bool x) {\\n\"\n              \"    if(x) {}\\n\"\n              \"    if(x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:8] -> [test.cpp:3:8]: (style) The if condition is the same as the previous if condition [duplicateCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if(x == 1) {}\\n\"\n              \"    if(x == 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10] -> [test.cpp:3:10]: (style) The if condition is the same as the previous if condition [duplicateCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if(x == 1) {}\\n\"\n              \"    if(x == 2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if(x == 1) {}\\n\"\n              \"    if(x != 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool x) {\\n\"\n              \"    if(x) {}\\n\"\n              \"    g();\\n\"\n              \"    if(x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if(x == 1) { x++; }\\n\"\n              \"    if(x == 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8996\n        check(\"void g(int** v);\\n\"\n              \"void f() {\\n\"\n              \"  int a = 0;\\n\"\n              \"  int b = 0;\\n\"\n              \"  int* d[] = {&a, &b};\\n\"\n              \"  g(d);\\n\"\n              \"  if (a) {}\\n\"\n              \"  if (b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9311\n        check(\"struct c {\\n\"\n              \"  int* p;\\n\"\n              \"};\\n\"\n              \"void g(struct c* v);\\n\"\n              \"void f() {\\n\"\n              \"  int a = 0;\\n\"\n              \"  int b = 0;\\n\"\n              \"  struct c d[] = {{&a}, {&b}};\\n\"\n              \"  g(d);\\n\"\n              \"  if (a) {}\\n\"\n              \"  if (b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8993\n        check(\"void f(const std::string& x) {\\n\"\n              \"  auto y = x;\\n\"\n              \"  if (x.empty()) y = \\\"1\\\";\\n\"\n              \"  if (y.empty()) return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9106\n        check(\"struct A {int b;};\\n\"\n              \"void f(A a, int c) {\\n\"\n              \"    if (a.b) a.b = c;\\n\"\n              \"    if (a.b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int a;\\n\"\n              \"    void b() const {\\n\"\n              \"        return a == 1;\\n\"\n              \"    }\\n\"\n              \"    void c();\\n\"\n              \"    void d() {\\n\"\n              \"        if(b()) {\\n\"\n              \"            c();\\n\"\n              \"        }\\n\"\n              \"        if (b()) {\\n\"\n              \"            a = 3;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int a;\\n\"\n              \"    void b() const {\\n\"\n              \"        return a == 1;\\n\"\n              \"    }\\n\"\n              \"    void d() {\\n\"\n              \"        if(b()) {\\n\"\n              \"            a = 2;\\n\"\n              \"        }\\n\"\n              \"        if (b()) {\\n\"\n              \"            a = 3;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int a;\\n\"\n              \"    void b() const {\\n\"\n              \"        return a == 1;\\n\"\n              \"    }\\n\"\n              \"    void d() {\\n\"\n              \"        if(b()) {\\n\"\n              \"        }\\n\"\n              \"        if (b()) {\\n\"\n              \"            a = 3;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:13] -> [test.cpp:9:14]: (style) The if condition is the same as the previous if condition [duplicateCondition]\\n\",\n                      errout_str());\n\n        check(\"void f(bool a, bool b) {\\n\"\n              \"    auto g = [&] { b = !a; };\\n\"\n              \"    if (b)\\n\"\n              \"        g();\\n\"\n              \"    if (b) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(bool& a);\\n\"\n              \"void f(bool b) {\\n\"\n              \"    auto h = std::bind(&g, std::ref(b));\\n\"\n              \"    if (b)\\n\"\n              \"        h();\\n\"\n              \"    if (b) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int *i) {\\n\"\n              \"  if (*i == 0) {\\n\"\n              \"    *i = 1;\\n\"\n              \"  }\\n\"\n              \"  if (*i == 0) {\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(std::function<void()>);\\n\"\n              \"void f(std::vector<int> v) {\\n\"\n              \"    auto x = [&v] { v.push_back(1); };\\n\"\n              \"    if(v.empty()) {\\n\"\n              \"        g(x);\\n\"\n              \"    }\\n\"\n              \"    if(v.empty())\\n\"\n              \"        return;\\n\"\n              \"    return;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int i; };\\n\"\n              \"int f(const S& s) {\\n\"\n              \"    int a = 0, b = 0;\\n\"\n              \"    if (s.i == 0)\\n\"\n              \"        a = 1;\\n\"\n              \"    if (s.i == 0)\\n\"\n              \"        b = 1;\\n\"\n              \"    return a + b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:6:13]: (style) The if condition is the same as the previous if condition [duplicateCondition]\\n\", errout_str());\n\n        check(\"void f(double d) {\\n\" // #12712\n              \"    if (std::isfinite(d)) {}\\n\"\n              \"    if (std::isfinite(d)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:22] -> [test.cpp:3:22]: (style) The if condition is the same as the previous if condition [duplicateCondition]\\n\", errout_str());\n\n        check(\"struct S { int x; };\\n\" // #12391\n              \"int f(const struct S* a, const struct S* b) {\\n\"\n              \"    const struct S* p = b;\\n\"\n              \"    if (a->x < p->x) p++;\\n\"\n              \"    if (a->x < p->x) p++;\\n\"\n              \"    return p->x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // do not crash\n        check(\"void assign(const MMA& other) {\\n\"\n              \"    if (mPA.cols != other.mPA.cols || mPA.rows != other.mPA.rows)\\n\"\n              \"        ;\\n\"\n              \"    if (other.mPA.cols > 0 && other.mPA.rows > 0)\\n\"\n              \"        ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\" // #11202\n              \"    float f = 0x1.4p+3;\\n\"\n              \"    if (f > 10.0) {}\\n\"\n              \"    if (f < 10.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkInvalidTestForOverflow() {\n        check(\"void f(char *p, unsigned int x) {\\n\"\n              \"    assert((p + x) < p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (warning) Invalid test for overflow '(p+x)<p'; pointer overflow is undefined behavior. Some mainstream compilers remove such overflow tests when optimising the code and assume it's always false. [invalidTestForOverflow]\\n\", errout_str());\n\n        check(\"void f(char *p, unsigned int x) {\\n\"\n              \"    assert((p + x) >= p);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (warning) Invalid test for overflow '(p+x)>=p'; pointer overflow is undefined behavior. Some mainstream compilers remove such overflow tests when optimising the code and assume it's always true. [invalidTestForOverflow]\\n\", errout_str());\n\n        check(\"void f(char *p, unsigned int x) {\\n\"\n              \"    assert(p > (p + x));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) Invalid test for overflow 'p>(p+x)'; pointer overflow is undefined behavior. Some mainstream compilers remove such overflow tests when optimising the code and assume it's always false. [invalidTestForOverflow]\\n\", errout_str());\n\n        check(\"void f(char *p, unsigned int x) {\\n\"\n              \"    assert(p <= (p + x));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning) Invalid test for overflow 'p<=(p+x)'; pointer overflow is undefined behavior. Some mainstream compilers remove such overflow tests when optimising the code and assume it's always true. [invalidTestForOverflow]\\n\", errout_str());\n\n        check(\"void f(signed int x) {\\n\" // unsigned overflow => don't warn\n              \"    assert(x + 100U < x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        // x + c < x\n\n#define MSG(EXPR, RESULT)   \"[test.cpp:1:30]: (warning) Invalid test for overflow '\" EXPR \"'; signed integer overflow is undefined behavior. Some mainstream compilers remove such overflow tests when optimising the code and assume it's always \" RESULT \". [invalidTestForOverflow]\\n\"\n\n        check(\"int f(int x) { return x + 10 > x; }\");\n        ASSERT_EQUALS(MSG(\"x+10>x\", \"true\"), errout_str());\n\n        check(\"int f(int x) { return x + 10 >= x; }\");\n        ASSERT_EQUALS(MSG(\"x+10>=x\", \"true\"), errout_str());\n\n        check(\"int f(int x) { return x + 10 < x; }\");\n        ASSERT_EQUALS(MSG(\"x+10<x\", \"false\"), errout_str());\n\n        check(\"int f(int x) { return x + 10 <= x; }\");\n        ASSERT_EQUALS(MSG(\"x+10<=x\", \"false\"), errout_str());\n\n        check(\"int f(int x) { return x - 10 > x; }\");\n        ASSERT_EQUALS(MSG(\"x-10>x\", \"false\"), errout_str());\n\n        check(\"int f(int x) { return x - 10 >= x; }\");\n        ASSERT_EQUALS(MSG(\"x-10>=x\", \"false\"), errout_str());\n\n        check(\"int f(int x) { return x - 10 < x; }\");\n        ASSERT_EQUALS(MSG(\"x-10<x\", \"true\"), errout_str());\n\n        check(\"int f(int x) { return x - 10 <= x; }\");\n        ASSERT_EQUALS(MSG(\"x-10<=x\", \"true\"), errout_str());\n\n        // x + y < x\n#undef MSG\n#define MSG(EXPR, RESULT)   \"[test.cpp:1:36]: (warning) Invalid test for overflow '\" EXPR \"'; signed integer overflow is undefined behavior. Some mainstream compilers removes handling of overflows when optimising the code and change the code to '\" RESULT \"'. [invalidTestForOverflow]\\n\"\n\n        check(\"int f(int x, int y) { return x + y < x; }\");\n        ASSERT_EQUALS(MSG(\"x+y<x\", \"y<0\"), errout_str());\n\n        check(\"int f(int x, int y) { return x + y <= x; }\");\n        ASSERT_EQUALS(MSG(\"x+y<=x\", \"y<=0\"), errout_str());\n\n        check(\"int f(int x, int y) { return x + y > x; }\");\n        ASSERT_EQUALS(MSG(\"x+y>x\", \"y>0\"), errout_str());\n\n        check(\"int f(int x, int y) { return x + y >= x; }\");\n        ASSERT_EQUALS(MSG(\"x+y>=x\", \"y>=0\"), errout_str());\n\n        // x - y < x\n        check(\"int f(int x, int y) { return x - y < x; }\");\n        ASSERT_EQUALS(MSG(\"x-y<x\", \"y>0\"), errout_str());\n\n        check(\"int f(int x, int y) { return x - y <= x; }\");\n        ASSERT_EQUALS(MSG(\"x-y<=x\", \"y>=0\"), errout_str());\n\n        check(\"int f(int x, int y) { return x - y > x; }\");\n        ASSERT_EQUALS(MSG(\"x-y>x\", \"y<0\"), errout_str());\n\n        check(\"int f(int x, int y) { return x - y >= x; }\");\n        ASSERT_EQUALS(MSG(\"x-y>=x\", \"y<=0\"), errout_str());\n    }\n\n    void checkConditionIsAlwaysTrueOrFalseInsideIfWhile() {\n        check(\"void f() {\\n\"\n              \"    enum states {A,B,C};\\n\"\n              \"    const unsigned g_flags = B|C;\\n\"\n              \"    if(g_flags & A) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) Condition 'g_flags&A' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 5;\"\n              \"    if(a) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (style) Condition 'a' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 5;\"\n              \"    while(a + 1) { a--; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 5;\"\n              \"    while(a + 1) { return; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:27]: (style) Condition 'a+1' is always true [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void alwaysTrueFalseInLogicalOperators() {\n        check(\"bool f();\\n\"\n              \"void foo() { bool x = true; if(x||f()) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:2:32]: (style) Condition 'x' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(bool b) { bool x = true; if(x||b) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:38]: (style) Condition 'x' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(bool b) { if(true||b) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f();\\n\"\n              \"void foo() { bool x = false; if(x||f()) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:2:33]: (style) Condition 'x' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"bool f();\\n\"\n              \"void foo() { bool x = false; if(x&&f()) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:2:33]: (style) Condition 'x' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(bool b) { bool x = false; if(x&&b) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:39]: (style) Condition 'x' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(bool b) { if(false&&b) {}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f();\\n\"\n              \"void foo() { bool x = true; if(x&&f()) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:2:32]: (style) Condition 'x' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #9578\n        check(\"bool f(const std::string &s) {\\n\"\n              \"        return s.size()>2U && s[0]=='4' && s[0]=='2';\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:35] -> [test.cpp:2:48]: (style) Return value 's[0]=='2'' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int i) { if (i == 1 || 2) {} }\\n\"); // #12487\n        ASSERT_EQUALS(\"[test.cpp:1:28]: (style) Condition 'i==1||2' is always true [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"enum E { E1 = 1, E2 = 2 };\\n\"\n              \"void f(int i) { if (i == E1 || E2) {} }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:29]: (style) Condition 'i==E1||E2' is always true [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void pointerAdditionResultNotNull() {\n        check(\"void f(char *ptr) {\\n\"\n              \"  if (ptr + 1 != 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning) Comparison is wrong. Result of 'ptr+1' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour. [pointerAdditionResultNotNull]\\n\", errout_str());\n    }\n\n    void duplicateConditionalAssign() {\n        setMultiline();\n\n        check(\"void f(int& x, int y) {\\n\"\n              \"    if (x == y)\\n\"\n              \"        x = y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: style: Assignment 'x=y' is redundant with condition 'x==y'. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:2:11]: note: Condition 'x==y'\\n\"\n                      \"[test.cpp:3:11]: note: Assignment 'x=y' is redundant\\n\", errout_str());\n\n        check(\"void f(int& x, int y) {\\n\"\n              \"    if (x != y)\\n\"\n              \"        x = y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: style: The statement 'if (x!=y) x=y' is logically equivalent to 'x=y'. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:3:11]: note: Assignment 'x=y'\\n\"\n                      \"[test.cpp:2:11]: note: Condition 'x!=y' is redundant\\n\", errout_str());\n\n        check(\"void f(int& x, int y) {\\n\"\n              \"    if (x == y)\\n\"\n              \"        x = y;\\n\"\n              \"    else\\n\"\n              \"        x = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: style: Assignment 'x=y' is redundant with condition 'x==y'. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:2:11]: note: Condition 'x==y'\\n\"\n                      \"[test.cpp:3:11]: note: Assignment 'x=y' is redundant\\n\", errout_str());\n\n        check(\"void f(int& x, int y) {\\n\"\n              \"    if (x != y)\\n\"\n              \"        x = y;\\n\"\n              \"    else\\n\"\n              \"        x = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int& x, int y) {\\n\"\n              \"    if (x == y)\\n\"\n              \"        x = y + 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g();\\n\"\n              \"void f(int& x, int y) {\\n\"\n              \"    if (x == y) {\\n\"\n              \"        x = y;\\n\"\n              \"        g();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(bool b) {\\n\"\n              \"    if (b)\\n\"\n              \"        b = false;\\n\"\n              \"    else\\n\"\n              \"        g();\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int& i) {\\n\"\n              \"    if (!i)\\n\"\n              \"        i = 1; \\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #9406\n              \"    S() : b(false) {}\\n\"\n              \"    void f() {\\n\"\n              \"        if (b) b = true;\\n\"\n              \"        if (b) b = false;\\n\"\n              \"        if (!b) b = true;\\n\"\n              \"        if (!b) b = false;\\n\"\n              \"    }\\n\"\n              \"    bool b;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: style: The statement 'if (b) b=true' is redundant. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:4:18]: note: Assignment 'b=true'\\n\"\n                      \"[test.cpp:4:13]: note: Condition 'b' is redundant\\n\"\n                      \"[test.cpp:5:13]: style: The statement 'if (b) b=false' is logically equivalent to 'b=false'. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:5:18]: note: Assignment 'b=false'\\n\"\n                      \"[test.cpp:5:13]: note: Condition 'b' is redundant\\n\"\n                      \"[test.cpp:6:13]: style: The statement 'if (!b) b=true' is logically equivalent to 'b=true'. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:6:19]: note: Assignment 'b=true'\\n\"\n                      \"[test.cpp:6:13]: note: Condition '!b' is redundant\\n\"\n                      \"[test.cpp:7:13]: style: The statement 'if (!b) b=false' is redundant. [duplicateConditionalAssign]\\n\"\n                      \"[test.cpp:7:19]: note: Assignment 'b=false'\\n\"\n                      \"[test.cpp:7:13]: note: Condition '!b' is redundant\\n\",\n                      errout_str());\n    }\n\n    void checkAssignmentInCondition() {\n        check(\"void f(std::string s) {\\n\"\n              \"    if (s=\\\"123\\\"){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Suspicious assignment in condition. Condition 's=\\\"123\\\"' is always true. [assignmentInCondition]\\n\", errout_str());\n\n        check(\"void f(std::string *p) {\\n\"\n              \"    if (p=foo()){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(uint32_t u) {\\n\" // #2490\n              \"    if ((u = 0x00000000) || (u = 0xffffffff)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Condition 'u=0x00000000' is always false [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:2:32]: (style) Condition 'u=0xffffffff' is always true [knownConditionTrueFalse]\\n\",\n                      errout_str());\n    }\n\n    void compareOutOfTypeRange() {\n        const Settings settingsUnix64 = settingsBuilder().severity(Severity::style).platform(Platform::Type::Unix64).build();\n\n        check(\"void f(unsigned char c) {\\n\"\n              \"  if (c == 256) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Comparing expression of type 'unsigned char' against value 256. Condition is always false. [compareValueOutOfTypeRangeError]\\n\", errout_str());\n\n        check(\"void f(unsigned char* b, int i) {\\n\" // #6372\n              \"  if (b[i] == 256) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Comparing expression of type 'unsigned char' against value 256. Condition is always false. [compareValueOutOfTypeRangeError]\\n\", errout_str());\n\n        check(\"void f(unsigned char c) {\\n\"\n              \"  if (c == 255) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"  if (b == true) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10372\n        check(\"void f(signed char x) {\\n\"\n              \"  if (x == 0xff) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Comparing expression of type 'signed char' against value 255. Condition is always false. [compareValueOutOfTypeRangeError]\\n\", errout_str());\n\n        check(\"void f(short x) {\\n\"\n              \"  if (x == 0xffff) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Comparing expression of type 'signed short' against value 65535. Condition is always false. [compareValueOutOfTypeRangeError]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x == 0xffffffff) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(long x) {\\n\"\n              \"  if (x == ~0L) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(long long x) {\\n\"\n              \"  if (x == ~0LL) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int x) {\\n\"\n              \"    const int i = 0xFFFFFFFF;\\n\"\n              \"    if (x == i) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  char c;\\n\"\n              \"  if ((c = foo()) != -1) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  if (x < 3000000000) {}\\n\"\n              \"}\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Comparing expression of type 'signed int' against value 3000000000. Condition is always true. [compareValueOutOfTypeRangeError]\\n\", errout_str());\n\n        check(\"void f(const signed char i) {\\n\" // #8545\n              \"    if (i >  -129) {}\\n\" // warn\n              \"    if (i >= -128) {}\\n\" // warn\n              \"    if (i >= -127) {}\\n\"\n              \"    if (i <  +128) {}\\n\" // warn\n              \"    if (i <= +127) {}\\n\" // warn\n              \"    if (i <= +126) {}\\n\"\n              \"}\\n\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Comparing expression of type 'const signed char' against value -129. Condition is always true. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:3:15]: (style) Comparing expression of type 'const signed char' against value -128. Condition is always true. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:5:15]: (style) Comparing expression of type 'const signed char' against value 128. Condition is always true. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:6:15]: (style) Comparing expression of type 'const signed char' against value 127. Condition is always true. [compareValueOutOfTypeRangeError]\\n\",\n                      errout_str());\n\n        check(\"void f(const unsigned char u) {\\n\"\n              \"    if (u >  0) {}\\n\"\n              \"    if (u <  0) {}\\n\" // warn\n              \"    if (u >= 0) {}\\n\" // warn\n              \"    if (u <= 0) {}\\n\"\n              \"    if (u >  255) {}\\n\" // warn\n              \"    if (u <  255) {}\\n\"\n              \"    if (u >= 255) {}\\n\"\n              \"    if (u <= 255) {}\\n\" // warn\n              \"    if (0   <  u) {}\\n\"\n              \"    if (0   >  u) {}\\n\" // warn\n              \"    if (0   <= u) {}\\n\" // warn\n              \"    if (0   >= u) {}\\n\"\n              \"    if (255 <  u) {}\\n\" // warn\n              \"    if (255 >  u) {}\\n\"\n              \"    if (255 <= u) {}\\n\"\n              \"    if (255 >= u) {}\\n\" // warn\n              \"}\\n\", dinit(CheckOptions, $.s = &settingsUnix64));\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Comparing expression of type 'const unsigned char' against value 0. Condition is always false. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:4:14]: (style) Comparing expression of type 'const unsigned char' against value 0. Condition is always true. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:6:14]: (style) Comparing expression of type 'const unsigned char' against value 255. Condition is always false. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:9:14]: (style) Comparing expression of type 'const unsigned char' against value 255. Condition is always true. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:11:9]: (style) Comparing expression of type 'const unsigned char' against value 0. Condition is always false. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:12:9]: (style) Comparing expression of type 'const unsigned char' against value 0. Condition is always true. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:14:9]: (style) Comparing expression of type 'const unsigned char' against value 255. Condition is always false. [compareValueOutOfTypeRangeError]\\n\"\n                      \"[test.cpp:17:9]: (style) Comparing expression of type 'const unsigned char' against value 255. Condition is always true. [compareValueOutOfTypeRangeError]\\n\",\n                      errout_str());\n    }\n\n    void knownConditionCast() {\n        check(\"void f(int i) {\\n\" // #9976\n              \"    if (i < 0 || (unsigned)i > 5) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct B {\\n\" // #12941\n              \"    virtual void f();\\n\"\n              \"};\\n\"\n              \"struct One : public B {};\\n\"\n              \"struct Two : public B {};\\n\"\n              \"void g(const B& b) {\\n\"\n              \"    const Two* two = nullptr;\\n\"\n              \"    const One* one = dynamic_cast<const One*>(&b);\\n\"\n              \"    if (one == nullptr)\\n\"\n              \"        two = dynamic_cast<const Two*>(&b);\\n\"\n              \"    if (two) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void knownConditionIncrementLoop() { // #9808\n        check(\"void f() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    while (++a < 5) {}\\n\"\n              \"    if (a == 1) {}\\n\"\n              \"    std::cout << a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void knownConditionAfterBailout() { // #12526\n        check(\n            \"#include <list>\\n\"\n            \"int func()\\n\"\n            \"{\\n\"\n            \"  return VALUE_1;\"\n            \"}\\n\"\n            \"\\n\"\n            \"struct S1 {\\n\"\n            \"  bool b{};\\n\"\n            \"};\\n\"\n            \"\\n\"\n            \"struct S {\\n\"\n            \"  void f(const std::list<int>& l) const\\n\"\n            \"  {\\n\"\n            \"    if (mS.b)\\n\"\n            \"      return;\\n\"\n            \"    for (int i : l)\\n\"\n            \"    {\\n\"\n            \"      (void)i;\\n\"\n            \"      if (mS.b)\\n\"\n            \"        continue;\\n\"\n            \"    }\\n\"\n            \"  }\\n\"\n            \"\\n\"\n            \"  S1 mS;\\n\"\n            \"};\"\n            );\n        ASSERT_EQUALS(\"[test.cpp:13:11] -> [test.cpp:18:13]: (style) Condition 'mS.b' is always false [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void knownConditionIncDecOperator() {\n        check(\n            \"void f() {\\n\"\n            \"    unsigned int d = 0;\\n\"\n            \"    for (int i = 0; i < 4; ++i) {\\n\"\n            \"        if (i < 3)\\n\"\n            \"            ++d;\\n\"\n            \"        else if (--d == 0)\\n\"\n            \"            ;\\n\"\n            \"    }\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void knownConditionFloating() {\n        check(\"void foo() {\\n\"   // #11199\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.0f) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f>1.0f' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #11199\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.0L) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f>1.0L' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"   // #11199\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f>1.0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #11199\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1.0L) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f>1.0L' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #11199\n              \"    float f = 1.0L;\\n\"\n              \"    if (f > 1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f>1.0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #11199\n              \"    float f = 1.0L;\\n\"\n              \"    if (f > 1.0f) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f>1.0f' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"   // #11201\n              \"    float f = 0x1.4p+3;\\n\" // hex fraction 1.4 (decimal 1.25) scaled by 2^3, that is 10.0\n              \"    if (f > 9.9) {}\\n\"\n              \"    if (f < 9.9) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11]: (style) Condition 'f>9.9' is always true [knownConditionTrueFalse]\\n\"\n            \"[test.cpp:4:11]: (style) Condition 'f<9.9' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #12330\n              \"    double d = 1.0;\\n\"\n              \"    if (d < 0.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'd<0.0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #12330\n              \"    long double ld = 1.0;\\n\"\n              \"    if (ld < 0.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) Condition 'ld<0.0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #12330\n              \"    float f = 1.0;\\n\"\n              \"    if (f < 0.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Condition 'f<0.0' is always false [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"     // #12774\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1.01f) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11]: (style) Condition 'f>1.01f' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\"     // #12774\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.01) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11]: (style) Condition 'f>1.01' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11]: (style) Condition 'f>1' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1.00f) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:3]: (style) Condition 'f>1.00f' is always false\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11]: (style) Condition 'f>1' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\"// #13508\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.00) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:3]: (style) Condition 'f>1.00' is always false\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13506\n              \"    float nf = -1.0;\\n\"\n              \"    if (nf > +1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12]: (style) Condition 'nf>+1.0' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #11200\n              \"    float f = 1.0;\\n\"\n              \"    if (f > -1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:11]: (style) Condition 'f>-1.0' is always true [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:3]: (style) Condition 'f>1.0' is always true\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #11200\n              \"    float pf = +1.0;\\n\"\n              \"    if (pf > -1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12]: (style) Condition 'pf>-1.0' is always true [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float pf = +1.0;\\n\"\n              \"    if (pf > 1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:3]: (style) Condition 'pf>1.0' is always true\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #11200\n              \"    float nf = -1.0;\\n\"\n              \"    if (nf > 1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12]: (style) Condition 'nf>1.0' is always false [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // / #13508\n              \"    float nf = -1.0;\\n\"\n              \"    if (nf > -1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:3]: (style) Condition 'nf>-1.0' is always false\\n\",\n            \"\",\n            errout_str());\n    }\n};\n\nREGISTER_TEST(TestCondition)\n"
    }
  ]
}