{
  "name": "va_start_argument",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 30,
  "branches": 9,
  "apis": 34,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        55
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkvaarg.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n\nclass TestVaarg : public TestFixture {\npublic:\n    TestVaarg() : TestFixture(\"TestVaarg\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().severity(Severity::warning).build();\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        runChecks<CheckVaarg>(tokenizer, this);\n    }\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(wrongParameterTo_va_start);\n        TEST_CASE(referenceAs_va_start);\n        TEST_CASE(va_end_missing);\n        TEST_CASE(va_list_usedBeforeStarted);\n        TEST_CASE(va_start_subsequentCalls);\n        TEST_CASE(unknownFunctionScope);\n    }\n\n    void wrongParameterTo_va_start() {\n        check(\"void Format(char* szFormat, char* szBuffer, size_t nSize, ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szFormat);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning) 'szFormat' given to va_start() is not last named argument of the function. Did you intend to pass 'nSize'? [va_start_wrongParameter]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char* szBuffer, size_t nSize, ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning) 'szBuffer' given to va_start() is not last named argument of the function. Did you intend to pass 'nSize'? [va_start_wrongParameter]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char* szBuffer, size_t nSize, ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, nSize);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main(int argc, char *argv[]) {\\n\"\n              \"    long(^addthem)(const char *, ...) = ^long(const char *format, ...) {\\n\"\n              \"        va_list argp;\\n\"\n              \"        va_start(argp, format);\\n\"\n              \"        c = va_arg(argp, int);\\n\"\n              \"    };\\n\"\n              \"}\"); // Don't crash (#6032)\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) va_list 'argp' was opened but not closed by va_end(). [va_end_missing]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char* szBuffer, size_t nSize, ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\"); // Don't crash if less than expected arguments are given.\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void assertf_fail(const char *assertion, const char *file, int line, const char *func, const char* msg, ...) {\\n\"\n              \"    struct A {\\n\"\n              \"        A(char* buf, int size) {}\\n\"\n              \"            void printf(const char * format, ...) {\\n\"\n              \"                va_list args;\\n\"\n              \"                va_start(args, format);\\n\"\n              \"                va_end(args);\\n\"\n              \"        }\\n\"\n              \"    };\\n\"\n              \"}\"); // Inner class (#6453)\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void referenceAs_va_start() {\n        check(\"void Format(char* szFormat, char (&szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Using reference 'szBuffer' as parameter for va_start() results in undefined behaviour. [va_start_referencePassed]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void va_end_missing() {\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6186\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    try {\\n\"\n              \"        throw sth;\\n\"\n              \"    } catch(...) {\\n\"\n              \"        va_end(arg_ptr);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:1]: (error) va_list 'arg_ptr' was opened but not closed by va_end(). [va_end_missing]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    if(sth) return;\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:19]: (error) va_list 'arg_ptr' was opened but not closed by va_end(). [va_end_missing]\\n\", errout_str());\n\n        // #8124\n        check(\"void f(int n, ...)\\n\"\n              \"{\\n\"\n              \"    va_list ap;\\n\"\n              \"    va_start(ap, n);\\n\"\n              \"    std::vector<std::string> v(n);\\n\"\n              \"    std::generate_n(v.begin(), n, [&ap]()\\n\"\n              \"    {\\n\"\n              \"        return va_arg(ap, const char*);\\n\"\n              \"    });\\n\"\n              \"    va_end(ap);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int n, ...)\\n\"\n              \"{\\n\"\n              \"    va_list ap;\\n\"\n              \"    va_start(ap, n);\\n\"\n              \"    std::vector<std::string> v(n);\\n\"\n              \"    std::generate_n(v.begin(), n, [&ap]()\\n\"\n              \"    {\\n\"\n              \"        return va_arg(ap, const char*);\\n\"\n              \"    });\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:1]: (error) va_list 'ap' was opened but not closed by va_end(). [va_end_missing]\\n\", errout_str());\n    }\n\n    void va_list_usedBeforeStarted() {\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    return va_arg(arg_ptr, float);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) va_list 'arg_ptr' used before va_start() was called. [va_list_usedBeforeStarted]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    foo(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) va_list 'arg_ptr' used before va_start() was called. [va_list_usedBeforeStarted]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_copy(f, arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) va_list 'arg_ptr' used before va_start() was called. [va_list_usedBeforeStarted]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"    return va_arg(arg_ptr, float);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (error) va_list 'arg_ptr' used before va_start() was called. [va_list_usedBeforeStarted]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) va_list 'arg_ptr' used before va_start() was called. [va_list_usedBeforeStarted]\\n\", errout_str());\n\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    foo(va_arg(arg_ptr, float));\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6066\n        check(\"void Format(va_list v1) {\\n\"\n              \"    va_list v2;\\n\"\n              \"    va_copy(v2, v1);\\n\"\n              \"    foo(va_arg(v1, float));\\n\"\n              \"    va_end(v2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7527\n        check(\"void foo(int flag1, int flag2, ...) {\\n\"\n              \"    switch (flag1) {\\n\"\n              \"    default:\\n\"\n              \"        va_list vargs;\\n\"\n              \"        va_start(vargs, flag2);\\n\"\n              \"        if (flag2) {\\n\"\n              \"            va_end(vargs);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"        int data = va_arg(vargs, int);\\n\"\n              \"        va_end(vargs);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7533\n        check(\"void action_push(int type, ...) {\\n\"\n              \"    va_list args;\\n\"\n              \"    va_start(args, type);\\n\"\n              \"    switch (push_mode) {\\n\"\n              \"    case UNDO:\\n\"\n              \"        list_add(&act->node, &to_redo);\\n\"\n              \"        break;\\n\"\n              \"    case REDO:\\n\"\n              \"        list_add(&act->node, &to_undo);\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"    va_end(args);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void action_push(int type, ...) {\\n\"\n              \"    va_list args;\\n\"\n              \"    va_start(args, type);\\n\"\n              \"    switch (push_mode) {\\n\"\n              \"    case UNDO:\\n\"\n              \"        list_add(&act->node, &to_redo);\\n\"\n              \"        va_end(args);\\n\"\n              \"        break;\\n\"\n              \"    case REDO:\\n\"\n              \"        list_add(&act->node, &to_undo);\\n\"\n              \"        va_end(args);\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void action_push(int type, ...) {\\n\"\n              \"    va_list args;\\n\"\n              \"    va_start(args, type);\\n\"\n              \"    switch (push_mode) {\\n\"\n              \"    case UNDO:\\n\"\n              \"        list_add(&act->node, &to_redo);\\n\"\n              \"        break;\\n\"\n              \"    case REDO:\\n\"\n              \"        list_add(&act->node, &to_undo);\\n\"\n              \"        va_end(args);\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:13:1]: (error) va_list 'args' was opened but not closed by va_end(). [va_end_missing]\\n\", errout_str());\n\n        // #8043\n        check(\"void redisvFormatCommand(char *format, va_list ap, bool flag) {\\n\"\n              \"    va_list _cpy;\\n\"\n              \"    va_copy(_cpy, ap);\\n\"\n              \"    if (flag)\\n\"\n              \"        goto fmt_valid;\\n\"\n              \"    va_end(_cpy);\\n\"\n              \"    goto format_err;\\n\"\n              \"fmt_valid:\\n\"\n              \"    sdscatvprintf(curarg, _format, _cpy);\\n\"\n              \"    va_end(_cpy);\\n\"\n              \"format_err:\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void va_start_subsequentCalls() {\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) va_start() or va_copy() called subsequently on 'arg_ptr' without va_end() in between. [va_start_subsequentCalls]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list vl1;\\n\"\n              \"    va_start(vl1, szBuffer);\\n\"\n              \"    va_copy(vl1, vl1);\\n\"\n              \"    va_end(vl1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) va_start() or va_copy() called subsequently on 'vl1' without va_end() in between. [va_start_subsequentCalls]\\n\", errout_str());\n\n        check(\"void Format(char* szFormat, char (*szBuffer)[_Size], ...) {\\n\"\n              \"    va_list arg_ptr;\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"    va_start(arg_ptr, szBuffer);\\n\"\n              \"    va_end(arg_ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void unknownFunctionScope() {\n        check(\"void BG_TString::Format() {\\n\"\n              \"  BG_TChar * f;\\n\"\n              \"  va_start(args,f);\\n\"\n              \"  BG_TString result(f);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7559\n        check(\"void mowgli_object_message_broadcast(mowgli_object_t *self, const char *name, ...) {\\n\"\n              \"  va_list va;\\n\"\n              \"  MOWGLI_LIST_FOREACH(n, self->klass->message_handlers.head) {\\n\"\n              \"    if (!strcasecmp(sig2->name, name))\\n\"\n              \"      break;\\n\"\n              \"  }\\n\"\n              \"  va_start(va, name);\\n\"\n              \"  va_end(va);\\n\"\n              \"}\");\n    }\n};\n\nREGISTER_TEST(TestVaarg)\n"
    }
  ]
}