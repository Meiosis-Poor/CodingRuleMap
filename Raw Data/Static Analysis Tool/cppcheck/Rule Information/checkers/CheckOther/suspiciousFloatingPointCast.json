{
  "name": "suspiciousFloatingPointCast",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 39,
  "branches": 13,
  "apis": 43,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        6105
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkother.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"platform.h\"\n#include \"settings.h\"\n#include \"standards.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestOther : public TestFixture {\npublic:\n    TestOther() : TestFixture(\"TestOther\") {}\n\nprivate:\n    /*const*/ Settings _settings = settingsBuilder().library(\"std.cfg\").build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(emptyBrackets);\n\n        TEST_CASE(zeroDiv1);\n        TEST_CASE(zeroDiv2);\n        TEST_CASE(zeroDiv3);\n        TEST_CASE(zeroDiv4);\n        TEST_CASE(zeroDiv5);\n        TEST_CASE(zeroDiv6);\n        TEST_CASE(zeroDiv7);  // #4930\n        TEST_CASE(zeroDiv8);\n        TEST_CASE(zeroDiv9);\n        TEST_CASE(zeroDiv10);\n        TEST_CASE(zeroDiv11);\n        TEST_CASE(zeroDiv12);\n        TEST_CASE(zeroDiv13);\n        TEST_CASE(zeroDiv14); // #1169\n        TEST_CASE(zeroDiv15); // #8319\n        TEST_CASE(zeroDiv16); // #11158\n        TEST_CASE(zeroDiv17); // #9931\n        TEST_CASE(zeroDiv18);\n        TEST_CASE(zeroDiv19);\n        TEST_CASE(zeroDiv20); // #11175\n        TEST_CASE(zeroDiv21);\n        TEST_CASE(zeroDiv22);\n\n        TEST_CASE(zeroDivCond); // division by zero / useless condition\n\n        TEST_CASE(nanInArithmeticExpression);\n\n        TEST_CASE(varScope1);\n        TEST_CASE(varScope2);\n        TEST_CASE(varScope3);\n        TEST_CASE(varScope4);\n        TEST_CASE(varScope5);\n        TEST_CASE(varScope6);\n        TEST_CASE(varScope7);\n        TEST_CASE(varScope8);\n        TEST_CASE(varScope9);       // classes may have extra side-effects\n        TEST_CASE(varScope10);      // Undefined macro FOR\n        TEST_CASE(varScope11);      // #2475 - struct initialization is not inner scope\n        TEST_CASE(varScope12);\n        TEST_CASE(varScope13);      // variable usage in inner loop\n        TEST_CASE(varScope14);\n        TEST_CASE(varScope15);      // #4573 if-else-if\n        TEST_CASE(varScope16);\n        TEST_CASE(varScope17);\n        TEST_CASE(varScope18);\n        TEST_CASE(varScope20);      // Ticket #5103\n        TEST_CASE(varScope21);      // Ticket #5382\n        TEST_CASE(varScope22);      // Ticket #5684\n        TEST_CASE(varScope23);      // Ticket #6154\n        TEST_CASE(varScope24);      // pointer / reference\n        TEST_CASE(varScope25);      // time_t\n        TEST_CASE(varScope26);      // range for loop, map\n        TEST_CASE(varScope27);      // #7733 - #if\n        TEST_CASE(varScope28);      // #10527\n        TEST_CASE(varScope29);      // #10888\n        TEST_CASE(varScope30);      // #8541\n        TEST_CASE(varScope31);      // #11099\n        TEST_CASE(varScope32);      // #11441\n        TEST_CASE(varScope33);\n        TEST_CASE(varScope34);\n        TEST_CASE(varScope35);\n        TEST_CASE(varScope36);      // #12158\n        TEST_CASE(varScope37);      // #12158\n        TEST_CASE(varScope38);\n        TEST_CASE(varScope39);\n        TEST_CASE(varScope40);\n        TEST_CASE(varScope41);      // #11845\n        TEST_CASE(varScope42);\n        TEST_CASE(varScope43);\n\n        TEST_CASE(oldStylePointerCast);\n        TEST_CASE(intToPointerCast);\n        TEST_CASE(invalidPointerCast);\n\n        TEST_CASE(passedByValue);\n        TEST_CASE(passedByValue_nonConst);\n        TEST_CASE(passedByValue_externC);\n\n        TEST_CASE(constVariable);\n        TEST_CASE(constParameterCallback);\n        TEST_CASE(constPointer);\n        TEST_CASE(constArray);\n\n        TEST_CASE(switchRedundantAssignmentTest);\n        TEST_CASE(switchRedundantOperationTest);\n        TEST_CASE(switchRedundantBitwiseOperationTest);\n        TEST_CASE(unreachableCode);\n        TEST_CASE(redundantContinue);\n\n        TEST_CASE(suspiciousCase);\n        TEST_CASE(suspiciousEqualityComparison);\n        TEST_CASE(suspiciousUnaryPlusMinus); // #8004\n        TEST_CASE(suspiciousFloatingPointCast);\n\n        TEST_CASE(selfAssignment);\n        TEST_CASE(trac1132);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickFunction1);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickFunction2);\n        TEST_CASE(testMisusedScopeObjectPicksClass);\n        TEST_CASE(testMisusedScopeObjectPicksStruct);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickIf);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickConstructorDeclaration);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickFunctor);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickLocalClassConstructors);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickUsedObject);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickPureC);\n        TEST_CASE(testMisusedScopeObjectDoesNotPickNestedClass);\n        TEST_CASE(testMisusedScopeObjectInConstructor);\n        TEST_CASE(testMisusedScopeObjectStandardType);\n        TEST_CASE(testMisusedScopeObjectNamespace);\n        TEST_CASE(testMisusedScopeObjectAssignment); // #11371\n        TEST_CASE(trac2071);\n        TEST_CASE(trac2084);\n        TEST_CASE(trac3693);\n\n        TEST_CASE(clarifyCalculation);\n        TEST_CASE(clarifyStatement);\n\n        TEST_CASE(duplicateBranch);\n        TEST_CASE(duplicateBranch1); // tests extracted by http://www.viva64.com/en/b/0149/ ( Comparison between PVS-Studio and cppcheck ): Errors detected in Quake 3: Arena by PVS-Studio: Fragment 2\n        TEST_CASE(duplicateBranch2); // empty macro\n        TEST_CASE(duplicateBranch3);\n        TEST_CASE(duplicateBranch4);\n        TEST_CASE(duplicateBranch5); // make sure the Token attributes are compared\n        TEST_CASE(duplicateBranch6);\n        TEST_CASE(duplicateExpression1);\n        TEST_CASE(duplicateExpression2); // ticket #2730\n        TEST_CASE(duplicateExpression3); // ticket #3317\n        TEST_CASE(duplicateExpression4); // ticket #3354 (++)\n        TEST_CASE(duplicateExpression5); // ticket #3749 (macros with same values)\n        TEST_CASE(duplicateExpression6); // ticket #4639\n        TEST_CASE(duplicateExpression7);\n        TEST_CASE(duplicateExpression8);\n        TEST_CASE(duplicateExpression9); // #9320\n        TEST_CASE(duplicateExpression10); // #9485\n        TEST_CASE(duplicateExpression11); // #8916 (function call)\n        TEST_CASE(duplicateExpression12); // #10026\n        TEST_CASE(duplicateExpression13); // #7899\n        TEST_CASE(duplicateExpression14); // #9871\n        TEST_CASE(duplicateExpression15); // #10650\n        TEST_CASE(duplicateExpression16); // #10569\n        TEST_CASE(duplicateExpression17); // #12036\n        TEST_CASE(duplicateExpression18);\n        TEST_CASE(duplicateExpressionLoop);\n        TEST_CASE(duplicateValueTernary);\n        TEST_CASE(duplicateExpressionTernary); // #6391\n        TEST_CASE(duplicateExpressionTemplate); // #6930\n        TEST_CASE(duplicateExpressionCompareWithZero);\n        TEST_CASE(oppositeExpression);\n        TEST_CASE(duplicateVarExpression);\n        TEST_CASE(duplicateVarExpressionUnique);\n        TEST_CASE(duplicateVarExpressionAssign);\n        TEST_CASE(duplicateVarExpressionCrash);\n        TEST_CASE(multiConditionSameExpression);\n\n        TEST_CASE(checkSignOfUnsignedVariable);\n        TEST_CASE(checkSignOfPointer);\n\n        TEST_CASE(checkSuspiciousSemicolon1);\n        TEST_CASE(checkSuspiciousSemicolon2);\n        TEST_CASE(checkSuspiciousSemicolon3);\n        TEST_CASE(checkSuspiciousComparison);\n\n        TEST_CASE(checkInvalidFree);\n\n        TEST_CASE(checkRedundantCopy);\n\n        TEST_CASE(checkNegativeShift);\n\n        TEST_CASE(incompleteArrayFill);\n\n        TEST_CASE(redundantVarAssignment);\n        TEST_CASE(redundantVarAssignment_trivial);\n        TEST_CASE(redundantVarAssignment_struct);\n        TEST_CASE(redundantVarAssignment_union);\n        TEST_CASE(redundantVarAssignment_7133);\n        TEST_CASE(redundantVarAssignment_stackoverflow);\n        TEST_CASE(redundantVarAssignment_lambda);\n        TEST_CASE(redundantVarAssignment_loop);\n        TEST_CASE(redundantVarAssignment_after_switch);\n        TEST_CASE(redundantVarAssignment_pointer);\n        TEST_CASE(redundantVarAssignment_pointer_parameter);\n        TEST_CASE(redundantVarAssignment_array);\n        TEST_CASE(redundantVarAssignment_switch_break);\n        TEST_CASE(redundantInitialization);\n        //TEST_CASE(redundantMemWrite); // FIXME: temporary hack\n        TEST_CASE(redundantAssignmentSameValue);\n\n        TEST_CASE(varFuncNullUB);\n\n        TEST_CASE(checkCastIntToCharAndBack); // ticket #160\n\n        TEST_CASE(checkCommaSeparatedReturn);\n        TEST_CASE(checkPassByReference);\n\n        TEST_CASE(checkComparisonFunctionIsAlwaysTrueOrFalse);\n\n        TEST_CASE(integerOverflow); // #5895\n\n        TEST_CASE(redundantPointerOp);\n        TEST_CASE(test_isSameExpression);\n        TEST_CASE(raceAfterInterlockedDecrement);\n\n        TEST_CASE(testUnusedLabel);\n\n        TEST_CASE(testEvaluationOrder);\n        TEST_CASE(testEvaluationOrderSelfAssignment);\n        TEST_CASE(testEvaluationOrderMacro);\n        TEST_CASE(testEvaluationOrderSequencePointsFunctionCall);\n        TEST_CASE(testEvaluationOrderSequencePointsComma);\n        TEST_CASE(testEvaluationOrderSizeof);\n\n        TEST_CASE(testUnsignedLessThanZero);\n\n        TEST_CASE(doubleMove1);\n        TEST_CASE(doubleMoveMemberInitialization1);\n        TEST_CASE(doubleMoveMemberInitialization2);\n        TEST_CASE(doubleMoveMemberInitialization3); // #9974\n        TEST_CASE(doubleMoveMemberInitialization4);\n        TEST_CASE(moveAndAssign1);\n        TEST_CASE(moveAndAssign2);\n        TEST_CASE(moveAssignMoveAssign);\n        TEST_CASE(moveAndReset1);\n        TEST_CASE(moveAndReset2);\n        TEST_CASE(moveResetMoveReset);\n        TEST_CASE(moveAndFunctionParameter);\n        TEST_CASE(moveAndFunctionParameterReference);\n        TEST_CASE(moveAndFunctionParameterConstReference);\n        TEST_CASE(moveAndFunctionParameterUnknown);\n        TEST_CASE(moveAndReturn);\n        TEST_CASE(moveAndClear);\n        TEST_CASE(movedPointer);\n        TEST_CASE(moveAndAddressOf);\n        TEST_CASE(partiallyMoved);\n        TEST_CASE(moveAndLambda);\n        TEST_CASE(moveInLoop);\n        TEST_CASE(moveCallback);\n        TEST_CASE(moveClassVariable);\n        TEST_CASE(forwardAndUsed);\n        TEST_CASE(moveAndReference);\n        TEST_CASE(moveForRange);\n        TEST_CASE(moveTernary);\n        TEST_CASE(movePointerAlias);\n\n        TEST_CASE(funcArgNamesDifferent);\n        TEST_CASE(funcArgOrderDifferent);\n        TEST_CASE(cpp11FunctionArgInit); // #7846 - \"void foo(int declaration = {}) {\"\n\n        TEST_CASE(shadowVariables);\n        TEST_CASE(knownArgument);\n        TEST_CASE(knownArgumentHiddenVariableExpression);\n        TEST_CASE(knownArgumentTernaryOperator);\n        TEST_CASE(checkComparePointers);\n\n        TEST_CASE(unusedVariableValueTemplate); // #8994\n\n        TEST_CASE(moduloOfOne);\n\n        TEST_CASE(sameExpressionPointers);\n\n        TEST_CASE(checkOverlappingWrite);\n\n        TEST_CASE(constVariableArrayMember); // #10371\n\n        TEST_CASE(knownPointerToBool);\n        TEST_CASE(iterateByValue);\n\n        TEST_CASE(knownConditionFloating);\n        TEST_CASE(knownConditionPrefixed);\n    }\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], bool cpp = true, bool inconclusive = true, bool runSimpleChecks=true, bool verbose=false, Settings* settings = nullptr) {\n        if (!settings) {\n            settings = &_settings;\n        }\n        settings->severity.enable(Severity::style);\n        settings->severity.enable(Severity::warning);\n        settings->severity.enable(Severity::portability);\n        settings->severity.enable(Severity::performance);\n        settings->standards.c = Standards::CLatest;\n        settings->standards.cpp = Standards::CPPLatest;\n        settings->certainty.setEnabled(Certainty::inconclusive, inconclusive);\n        settings->verbose = verbose;\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(*settings, *this, cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        runChecks<CheckOther>(tokenizer, this);\n\n        (void)runSimpleChecks; // TODO Remove this\n    }\n\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], Settings *s) {\n        check_(file, line, code, true, true, true, false, s);\n    }\n\n    struct CheckPOptions\n    {\n        CheckPOptions() = default;\n        bool cpp = true;\n    };\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkP_(const char* file, int line, const char (&code)[size], const CheckPOptions& options = make_default_obj()) {\n        Settings* settings = &_settings;\n        settings->severity.enable(Severity::style);\n        settings->severity.enable(Severity::warning);\n        settings->severity.enable(Severity::portability);\n        settings->severity.enable(Severity::performance);\n        settings->standards.c = Standards::CLatest;\n        settings->standards.cpp = Standards::CPPLatest;\n        settings->certainty.enable(Certainty::inconclusive);\n\n        SimpleTokenizer2 tokenizer(*settings, *this, code, options.cpp ? \"test.cpp\" : \"test.c\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check..\n        runChecks<CheckOther>(tokenizer, this);\n    }\n\n    template<size_t size>\n    void checkInterlockedDecrement(const char (&code)[size]) {\n        /*const*/ Settings settings = settingsBuilder().platform(Platform::Type::Win32A).build();\n\n        check(code, true, false, true, false, &settings);\n    }\n\n    void emptyBrackets() {\n        check(\"{\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void zeroDiv1() { // floating point division by zero => no error\n        check(\"void foo() {\\n\"\n              \"    cout << 1. / 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    cout << 42 / (double)0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    cout << 42 / (float)0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    cout << 42 / (int)0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv2() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int sum = 0;\\n\"\n              \"    for(int i = 0; i < n; i ++)\\n\"\n              \"    {\\n\"\n              \"        sum += i;\\n\"\n              \"    }\\n\"\n              \"    cout<<b/sum;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv3() {\n        check(\"int foo(int i) {\\n\"\n              \"    return i / 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        check(\"int foo(int i) {\\n\"\n              \"    return i % 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        check(\"void foo(int& i) {\\n\"\n              \"    i /= 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        check(\"void foo(int& i) {\\n\"\n              \"    i %= 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        check(\"uint8_t foo(uint8_t i) {\\n\"\n              \"    return i / 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv4() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   long a = b / 0x6;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   long a = b / 0x0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(long b)\\n\"\n              \"{\\n\"\n              \"   long a = b / 0x0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   long a = b / 0L;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(long b)\\n\"\n              \"{\\n\"\n              \"   long a = b / 0L;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   long a = b / 0ul;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(long b)\\n\"\n              \"{\\n\"\n              \"   long a = b / 0ul;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n\n        // Don't warn about floating points (gcc doesn't warn either)\n        // and floating points are handled differently than integers.\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   long a = b / 0.0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   long a = b / 0.5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv5() {\n        check(\"void f()\\n\"\n              \"{ { {\\n\"\n              \"   long a = b / 0;\\n\"\n              \"} } }\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(long b)\\n\"\n              \"{ { {\\n\"\n              \"   long a = b / 0;\\n\"\n              \"} } }\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv6() {\n        check(\"void f()\\n\"\n              \"{ { {\\n\"\n              \"   int a = b % 0;\\n\"\n              \"} } }\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int b)\\n\"\n              \"{ { {\\n\"\n              \"   int a = b % 0;\\n\"\n              \"} } }\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv7() {\n        // unknown types for x and y --> do not warn\n        check(\"void f() {\\n\"\n              \"  int a = x/2*3/0;\\n\"\n              \"  int b = y/2*3%0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f(int x, int y) {\\n\"\n              \"  int a = x/2*3/0;\\n\"\n              \"  int b = y/2*3%0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (error) Division by zero. [zerodiv]\\n\"\n                      \"[test.cpp:3:16]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv8() {\n        // #5584 - FP when function is unknown\n        check(\"void f() {\\n\"\n              \"  int a = 0;\\n\"\n              \"  do_something(a);\\n\"\n              \"  return 4 / a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error, inconclusive) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv9() {\n        // #6403 FP zerodiv - inside protecting if-clause\n        check(\"void foo() {\\n\"\n              \"  double fStepHelp = 0;\\n\"\n              \"   if( (rOuterValue >>= fStepHelp) ) {\\n\"\n              \"     if( fStepHelp != 0.0) {\\n\"\n              \"       double fStepMain = 1;\\n\"\n              \"       sal_Int32 nIntervalCount = static_cast< sal_Int32 >(fStepMain / fStepHelp);\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv10() {\n        // #5402 false positive: (error) Division by zero -- with boost::format\n        check(\"int main() {\\n\"\n              \"  std::cout\\n\"\n              \"    << boost::format(\\\" %d :: %s <> %s\\\") % 0 % \\\"a\\\" % \\\"b\\\"\\n\"\n              \"    << std::endl;\\n\"\n              \"  return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv11() {\n        check(\"void f(int a) {\\n\"\n              \"  int res = (a+2)/0;\\n\"\n              \"  int res = (a*2)/0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (error) Division by zero. [zerodiv]\\n\"\n                      \"[test.cpp:3:18]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n        check(\"void f() {\\n\"\n              \"  int res = (a+2)/0;\\n\"\n              \"  int res = (a*2)/0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv12() {\n        // #8141\n        check(\"intmax_t f() {\\n\"\n              \"  return 1 / imaxabs(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n    void zeroDiv13() {\n        // #7324\n        check(\"int f () {\\n\"\n              \"    int dividend = 10;\\n\"\n              \"        int divisor = 1;\\n\"\n              \"    dividend = dividend / (--divisor);\\n\"\n              \"    return dividend;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:25]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv14() {\n        check(\"void f() {\\n\" // #1169\n              \"    double dx = 1.;\\n\"\n              \"    int ix = 1;\\n\"\n              \"    int i = 1;\\n\"\n              \"    std::cout << ix / (i >> 1) << std::endl;\\n\"\n              \"    std::cout << dx / (i >> 1) << std::endl;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:21]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv15() { // #8319\n        check(\"int f(int i) { return i - 1; }\\n\"\n              \"int f() {\\n\"\n              \"    const int d = 1;\\n\"\n              \"    const int r = 1 / f(d);\\n\"\n              \"    return r;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:21]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    // #11158\n    void zeroDiv16()\n    {\n        check(\"int f(int i) {\\n\"\n              \"    int number = 10, a = 0;\\n\"\n              \"    for (int count = 0; count < 2; count++) {\\n\"\n              \"        a += (i / number) % 10;\\n\"\n              \"        number = number / 10;\\n\"\n              \"    }\\n\"\n              \"    return a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\"\n              \"    int number = 10, a = 0;\\n\"\n              \"    for (int count = 0; count < 2; count++) {\\n\"\n              \"        int x = number / 10;\\n\"\n              \"        a += (i / number) % 10;\\n\"\n              \"        number = x;\\n\"\n              \"    }\\n\"\n              \"    return a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv17() { // #9931\n        check(\"int f(int len) {\\n\"\n              \"    int sz = sizeof(void*[255]) / 255;\\n\"\n              \"    int x = len % sz;\\n\"\n              \"    return x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void zeroDiv18()\n    {\n        check(\"int f(int x, int y) {\\n\"\n              \"    if (x == y) {}\\n\"\n              \"    return 1 / (x-y);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:11] -> [test.cpp:3:14]: (warning) Either the condition 'x==y' is redundant or there is division by zero at line 3. [zerodivcond]\\n\",\n            errout_str());\n    }\n\n    void zeroDiv19()\n    {\n        check(\"void f() {\\n\" // #2456\n              \"    for (int i = 0;;)\\n\"\n              \"        int j = 10 / i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv20()\n    {\n        check(\"uint16_t f(void)\\n\" // #11175\n              \"{\\n\"\n              \"    uint16_t x = 0xFFFFU;\\n\" // UINT16_MAX=0xFFFF\n              \"    return 42/(++x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv21()\n    {\n        check(\"int f(int n) {\\n\"\n              \"    return 1 / ((1 / n) - 1);\\n\"\n              \"}\\n\"\n              \"int g() {\\n\"\n              \"    return f(1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDiv22()\n    {\n        check(\"int main() {\\n\"\n              \"    return _Generic((0), int: (42) / (0), default: 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:36]: (error) Division by zero. [zerodiv]\\n\", errout_str());\n    }\n\n    void zeroDivCond() {\n        check(\"void f(unsigned int x) {\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  if (x > 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:14]: (warning) Either the condition 'x>0' is redundant or there is division by zero at line 2. [zerodivcond]\\n\", errout_str());\n\n        check(\"void f(unsigned int x) {\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  if (x >= 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:14]: (warning) Either the condition 'x>=1' is redundant or there is division by zero at line 2. [zerodivcond]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  if (x == 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:14]: (warning) Either the condition 'x==0' is redundant or there is division by zero at line 2. [zerodivcond]\\n\", errout_str());\n\n        check(\"void f(unsigned int x) {\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  if (x != 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:14]: (warning) Either the condition 'x!=0' is redundant or there is division by zero at line 2. [zerodivcond]\\n\", errout_str());\n\n        // function call\n        check(\"void f1(int x, int y) { c=x/y; }\\n\"\n              \"void f2(unsigned int y) {\\n\"\n              \"    f1(123,y);\\n\"\n              \"    if (y>0){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:10] -> [test.cpp:1:28]: (warning) Either the condition 'y>0' is redundant or there is division by zero at line 1. [zerodivcond]\\n\",\n            errout_str());\n\n        // avoid false positives when variable is changed after division\n        check(\"void f() {\\n\"\n              \"  unsigned int x = do_something();\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  x = some+calculation;\\n\"\n              \"  if (x != 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            // function is called that might modify global variable\n            check(\"void do_something();\\n\"\n                  \"int x;\\n\"\n                  \"void f() {\\n\"\n                  \"  int y = 17 / x;\\n\"\n                  \"  do_something();\\n\"\n                  \"  if (x != 0) {}\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // function is called. but don't care, variable is local\n            check(\"void do_something();\\n\"\n                  \"void f() {\\n\"\n                  \"  int x = some + calculation;\\n\"\n                  \"  int y = 17 / x;\\n\"\n                  \"  do_something();\\n\"\n                  \"  if (x != 0) {}\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"[test.cpp:6:9] -> [test.cpp:4:14]: (warning) Either the condition 'x!=0' is redundant or there is division by zero at line 4. [zerodivcond]\\n\", errout_str());\n        }\n\n        check(\"void do_something(int value);\\n\"\n              \"void f(int x) {\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  do_something(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int x;\\n\"\n              \"void f() {\\n\"\n              \"  int y = 17 / x;\\n\"\n              \"  while (y || x == 0) { x--; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket 5033 segmentation fault (valid code) in CheckOther::checkZeroDivisionOrUselessCondition\n        check(\"void f() {\\n\"\n              \"double* p1= new double[1];\\n\"\n              \"double* p2= new double[1];\\n\"\n              \"double* p3= new double[1];\\n\"\n              \"double* pp[3] = {p1,p2,p3};\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5105 - FP\n        check(\"int f(int a, int b) {\\n\"\n              \"  int r = a / b;\\n\"\n              \"  if (func(b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown types for b and c --> do not warn\n        check(\"int f(int d) {\\n\"\n              \"  int r = (a?b:c) / d;\\n\"\n              \"  if (d == 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int a) {\\n\"\n              \"  int r = a ? 1 / a : 0;\\n\"\n              \"  if (a == 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int a) {\\n\"\n              \"  int r = (a == 0) ? 0 : 1 / a;\\n\"\n              \"  if (a == 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g();\\n\"\n              \"void f(int b) {\\n\"\n              \"  int x = g();\\n\"\n              \"  if (x == 0) {}\\n\"\n              \"  else if (x > 0) {}\\n\"\n              \"  else\\n\"\n              \"    a = b / -x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int x;\\n\"\n              \"};\\n\"\n              \"int f(A* a) {\\n\"\n              \"    if (a->x == 0) \\n\"\n              \"        a->x = 1;\\n\"\n              \"    return 1/a->x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10049\n        check(\"int f(int argc) {\\n\"\n              \"    int quotient, remainder;\\n\"\n              \"    remainder = argc % 2;\\n\"\n              \"    argc = 2;\\n\"\n              \"    quotient = argc;\\n\"\n              \"    if (quotient != 0) \\n\"\n              \"        return quotient;\\n\"\n              \"    return remainder;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11315\n        checkP(\"#define STATIC_ASSERT(c) \\\\\\n\"\n               \"do { enum { sa = 1/(int)(!!(c)) }; } while (0)\\n\"\n               \"void f() {\\n\"\n               \"    STATIC_ASSERT(sizeof(int) == sizeof(FOO));\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11505\n        check(\"void f(uint16_t num, uint8_t radix) {\\n\"\n              \"    int c = num % radix;\\n\"\n              \"    num /= radix;\\n\"\n              \"    if (!num) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nanInArithmeticExpression() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   double x = 3.0 / 0.0 + 1.0;\\n\"\n              \"   printf(\\\"%f\\\", x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (style) Using NaN/Inf in a computation. [nanInArithmeticExpression]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   double x = 3.0 / 0.0 - 1.0;\\n\"\n              \"   printf(\\\"%f\\\", x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (style) Using NaN/Inf in a computation. [nanInArithmeticExpression]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   double x = 1.0 + 3.0 / 0.0;\\n\"\n              \"   printf(\\\"%f\\\", x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (style) Using NaN/Inf in a computation. [nanInArithmeticExpression]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   double x = 1.0 - 3.0 / 0.0;\\n\"\n              \"   printf(\\\"%f\\\", x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (style) Using NaN/Inf in a computation. [nanInArithmeticExpression]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"   double x = 3.0 / 0.0;\\n\"\n              \"   printf(\\\"%f\\\", x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void varScope1() {\n        check(\"unsigned short foo()\\n\"\n              \"{\\n\"\n              \"    test_client CClient;\\n\"\n              \"    try\\n\"\n              \"    {\\n\"\n              \"        if (CClient.Open())\\n\"\n              \"        {\\n\"\n              \"            return 0;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    catch (...)\\n\"\n              \"    {\\n\"\n              \"        return 2;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    try\\n\"\n              \"    {\\n\"\n              \"        CClient.Close();\\n\"\n              \"    }\\n\"\n              \"    catch (...)\\n\"\n              \"    {\\n\"\n              \"        return 2;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    return 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope2() {\n        check(\"int foo()\\n\"\n              \"{\\n\"\n              \"    Error e;\\n\"\n              \"    e.SetValue(12);\\n\"\n              \"    throw e;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope3() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int i;\\n\"\n              \"    int *p = 0;\\n\"\n              \"    if (abc)\\n\"\n              \"    {\\n\"\n              \"        p = &i;\\n\"\n              \"    }\\n\"\n              \"    *p = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope4() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope5() {\n        check(\"void f(int x)\\n\"\n              \"{\\n\"\n              \"    int i = 0;\\n\"\n              \"    if (x) {\\n\"\n              \"        for ( ; i < 10; ++i) ;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) The scope of the variable 'i' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    const unsigned char i = 0;\\n\"\n              \"    if (x) {\\n\"\n              \"        for ( ; i < 10; ++i) ;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x)\\n\"\n              \"{\\n\"\n              \"    int i = 0;\\n\"\n              \"    if (x) {b()}\\n\"\n              \"    else {\\n\"\n              \"        for ( ; i < 10; ++i) ;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) The scope of the variable 'i' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope6() {\n        check(\"void f(int x)\\n\"\n              \"{\\n\"\n              \"    int i = x;\\n\"\n              \"    if (a) {\\n\"\n              \"        x++;\\n\"\n              \"    }\\n\"\n              \"    if (b) {\\n\"\n              \"        c(i);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #5398\n              \"    bool success = false;\\n\"\n              \"    int notReducable(someClass.getX(&success));\\n\"\n              \"    if (success) {\\n\"\n              \"        foo(notReducable);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(Test &test) {\\n\"\n              \"  int& x = test.getData();\\n\"\n              \"  if (test.process())\\n\"\n              \"    x = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"int foo = 0;\\n\"\n              \"std::vector<int> vec(10);\\n\"\n              \"BOOST_FOREACH(int& i, vec)\\n\"\n              \"{\\n\"\n              \" foo += 1;\\n\"\n              \" if(foo == 10)\\n\"\n              \" {\\n\"\n              \"  return 0;\\n\"\n              \" }\\n\"\n              \"}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int &x)\\n\"\n              \"{\\n\"\n              \"  int n = 1;\\n\"\n              \"  do\\n\"\n              \"  {\\n\"\n              \"    ++n;\\n\"\n              \"    ++x;\\n\"\n              \"  } while (x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope7() {\n        check(\"void f(int x)\\n\"\n              \"{\\n\"\n              \"    int y = 0;\\n\"\n              \"    b(y);\\n\"\n              \"    if (x) {\\n\"\n              \"        y++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope8() {\n        check(\"void test() {\\n\"\n              \"    float edgeResistance=1;\\n\"\n              \"    std::vector<int> edges;\\n\"\n              \"    BOOST_FOREACH(int edge, edges) {\\n\"\n              \"        edgeResistance = (edge+1) / 2.0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) The scope of the variable 'edgeResistance' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope9() {\n        // classes may have extra side effects\n        check(\"class fred {\\n\"\n              \"public:\\n\"\n              \"    void x();\\n\"\n              \"};\\n\"\n              \"void test(int a) {\\n\"\n              \"    fred f;\\n\"\n              \"    if (a == 2) {\\n\"\n              \"        f.x();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope10() {\n        check(\"int f()\\n\"\n              \"{\\n\"\n              \"    int x = 0;\\n\"\n              \"    FOR {\\n\"\n              \"        foo(x++);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope11() {\n        check(\"int f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    AB ab = { x, 0 };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    if (a == 0) { ++x; }\\n\"\n              \"    AB ab = { x, 0 };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    if (a == 0) { ++x; }\\n\"\n              \"    if (a == 1) { AB ab = { x, 0 }; }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope12() {\n        check(\"void f(int x) {\\n\"\n              \"    int i[5];\\n\"\n              \"    int* j = y;\\n\"\n              \"    if (x)\\n\"\n              \"        foo(i);\\n\"\n              \"    foo(j);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) The scope of the variable 'i' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    int i[5];\\n\"\n              \"    int* j;\\n\"\n              \"    if (x)\\n\"\n              \"        j = i;\\n\"\n              \"    foo(j);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    const bool b = true;\\n\"\n              \"    x++;\\n\"\n              \"    if (x == 5)\\n\"\n              \"        foo(b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    const bool b = x;\\n\"\n              \"    x++;\\n\"\n              \"    if (x == 5)\\n\"\n              \"        foo(b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope13() {\n        // #2770\n        check(\"void f() {\\n\"\n              \"    int i = 0;\\n\"\n              \"    forever {\\n\"\n              \"        if (i++ == 42) { break; }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope14() {\n        // #3941\n        check(\"void f() {\\n\"\n              \"    const int i( foo());\\n\"\n              \"    if(a) {\\n\"\n              \"        for ( ; i < 10; ++i) ;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope15() {\n        // #4573\n        check(\"void f() {\\n\"\n              \"    int a,b,c;\\n\"\n              \"    if (a);\\n\"\n              \"    else if(b);\\n\"\n              \"    else if(c);\\n\"\n              \"    else;\\n\"\n              \"}\", true, false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope16() {\n        check(\"void f() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    while((++a) < 56) {\\n\"\n              \"        foo();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    do {\\n\"\n              \"        foo();\\n\"\n              \"    } while((++a) < 56);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    do {\\n\"\n              \"        a = 64;\\n\"\n              \"        foo(a);\\n\"\n              \"    } while((++a) < 56);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    do {\\n\"\n              \"        a = 64;\\n\"\n              \"        foo(a);\\n\"\n              \"    } while(z());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) The scope of the variable 'a' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope17() {\n        check(\"void f() {\\n\"\n              \"    int x;\\n\"\n              \"    if (a) {\\n\"\n              \"        x = stuff(x);\\n\"\n              \"        morestuff(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int x;\\n\"\n              \"    if (a) {\\n\"\n              \"        x = stuff(x);\\n\"\n              \"        morestuff(x);\\n\"\n              \"    }\\n\"\n              \"    if (b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope18() {\n        check(\"void f() {\\n\"\n              \"    short x;\\n\"\n              \"\\n\"\n              \"    switch (ab) {\\n\"\n              \"        case A:\\n\"\n              \"            break;\\n\"\n              \"        case B:\\n\"\n              \"        default:\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    if (c) {\\n\"\n              \"        x = foo();\\n\"\n              \"        do_something(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    short x;\\n\"\n              \"\\n\"\n              \"    switch (ab) {\\n\"\n              \"        case A:\\n\"\n              \"            x = 10;\\n\"\n              \"            break;\\n\"\n              \"        case B:\\n\"\n              \"        default:\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    if (c) {\\n\"\n              \"        x = foo();\\n\"\n              \"        do_something(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    short x;\\n\"\n              \"\\n\"\n              \"    switch (ab) {\\n\"\n              \"        case A:\\n\"\n              \"            if(c)\\n\"\n              \"                do_something(x);\\n\"\n              \"            break;\\n\"\n              \"        case B:\\n\"\n              \"        default:\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    short x;\\n\"\n              \"\\n\"\n              \"    switch (ab) {\\n\"\n              \"        case A:\\n\"\n              \"            if(c)\\n\"\n              \"                do_something(x);\\n\"\n              \"            break;\\n\"\n              \"        case B:\\n\"\n              \"        default:\\n\"\n              \"            if(d)\\n\"\n              \"                do_something(x);\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope20() { // Ticket #5103 - constant variable only used in inner scope\n        check(\"int f(int a) {\\n\"\n              \"  const int x = 234;\\n\"\n              \"  int b = a;\\n\"\n              \"  if (b > 32) b = x;\\n\"\n              \"  return b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope21() { // Ticket #5382 - initializing two-dimensional array\n        check(\"int test() {\\n\"\n              \"    int test_value = 3;\\n\"\n              \"    int test_array[1][1] = { { test_value } };\\n\"\n              \"    return sizeof(test_array);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope22() { // Ticket #5684 - \"The scope of the variable 'p' can be reduced\" - But it can not.\n        check(\"void foo() {\\n\"\n              \"   int* p( 42 );\\n\"\n              \"   int i = 0;\\n\"\n              \"   while ( i != 100 ) {\\n\"\n              \"      *p = i;\\n\"\n              \"      ++p;\\n\"\n              \"      ++i;\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        // try to avoid an obvious false negative after applying the fix for the example above:\n        check(\"void foo() {\\n\"\n              \"   int* p( 42 );\\n\"\n              \"   int i = 0;\\n\"\n              \"   int dummy = 0;\\n\"\n              \"   while ( i != 100 ) {\\n\"\n              \"      p = & dummy;\\n\"\n              \"      *p = i;\\n\"\n              \"      ++p;\\n\"\n              \"      ++i;\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) The scope of the variable 'p' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope23() { // #6154: Don't suggest to reduce scope if inner scope is a lambda\n        check(\"int main() {\\n\"\n              \"   size_t myCounter = 0;\\n\"\n              \"   Test myTest([&](size_t aX){\\n\"\n              \"       std::cout << myCounter += aX << std::endl;\\n\"\n              \"   });\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope24() {\n        check(\"void f(Foo x) {\\n\"\n              \"   Foo &r = x;\\n\"\n              \"   if (cond) {\\n\"\n              \"       r.dostuff();\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) The scope of the variable 'r' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f(Foo x) {\\n\"\n              \"   Foo foo = x;\\n\"\n              \"   if (cond) {\\n\"\n              \"       foo.dostuff();\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope25() {\n        check(\"void f() {\\n\"\n              \"    time_t currtime;\\n\"\n              \"    if (a) {\\n\"\n              \"        currtime = time(&dummy);\\n\"\n              \"        if (currtime > t) {}\\n\"\n              \"    }\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"[test.c:2:12]: (style) The scope of the variable 'currtime' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope26() {\n        check(\"void f(const std::map<int,int> &m) {\\n\"\n              \"  for (auto it : m) {\\n\"\n              \"     if (cond1) {\\n\"\n              \"       int& key = it.first;\\n\"\n              \"       if (cond2) { dostuff(key); }\\n\"\n              \"     }\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope27() {\n        checkP(\"void f() {\\n\"\n               \"  int x = 0;\\n\"\n               \"#ifdef X\\n\"\n               \"#endif\\n\"\n               \"  if (id == ABC) { return x; }\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"void f() {\\n\"\n               \"#ifdef X\\n\"\n               \"#endif\\n\"\n               \"  int x = 0;\\n\"\n               \"  if (id == ABC) { return x; }\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope28() {\n        check(\"void f() {\\n\" // #10527\n              \"    int i{};\\n\"\n              \"    if (double d = g(i); d == 1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope29() { // #10888\n        check(\"enum E { E0 };\\n\"\n              \"struct S { int i; };\\n\"\n              \"void f(int b) {\\n\"\n              \"    enum E e;\\n\"\n              \"    struct S s;\\n\"\n              \"    if (b) {\\n\"\n              \"        e = E0;\\n\"\n              \"        s.i = 0;\\n\"\n              \"        g(e, s);\\n\"\n              \"    }\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"[test.c:4:12]: (style) The scope of the variable 'e' can be reduced. [variableScope]\\n\"\n                      \"[test.c:5:14]: (style) The scope of the variable 's' can be reduced. [variableScope]\\n\",\n                      errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"    std::string s;\\n\"\n              \"    if (b) {\\n\"\n              \"        s = \\\"abc\\\";\\n\"\n              \"        g(s);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) The scope of the variable 's' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"auto foo(std::vector<int>& vec, bool flag) {\\n\"\n              \"    std::vector<int> dummy;\\n\"\n              \"    std::vector<int>::iterator iter;\\n\"\n              \"    if (flag)\\n\"\n              \"        iter = vec.begin();\\n\"\n              \"    else {\\n\"\n              \"        dummy.push_back(42);\\n\"\n              \"        iter = dummy.begin();\\n\"\n              \"    }\\n\"\n              \"    return *iter;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:28]: (style) Parameter 'vec' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"auto& foo(std::vector<int>& vec, bool flag) {\\n\"\n              \"    std::vector<int> dummy;\\n\"\n              \"    std::vector<int>::iterator iter;\\n\"\n              \"    if (flag)\\n\"\n              \"        iter = vec.begin();\\n\"\n              \"    else {\\n\"\n              \"        dummy.push_back(42);\\n\"\n              \"        iter = dummy.begin();\\n\"\n              \"    }\\n\"\n              \"    return *iter;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope30() { // #8541\n        check(\"bool f(std::vector<int>& v, int i) {\\n\"\n              \"    int n = 0;\\n\"\n              \"    bool b = false;\\n\"\n              \"    std::for_each(v.begin(), v.end(), [&](int j) {\\n\"\n              \"        if (j == i) {\\n\"\n              \"            ++n;\\n\"\n              \"            if (n > 5)\\n\"\n              \"                b = true;\\n\"\n              \"        }\\n\"\n              \"    });\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope31() { // #11099\n        check(\"bool g(std::vector<int>&);\\n\"\n              \"void h(std::vector<int>);\\n\"\n              \"void f0(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w{ v };\\n\"\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f1(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w{ v.begin(), v.end() };\\n\"\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f2(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w{ 10, 0, std::allocator<int>() };\\n\" // FN\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f3(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w{ 10, 0 };\\n\" // warn\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f4(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w{ 10 };\\n\" // warn\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f5(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w(v);\\n\"\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f6(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w(v.begin(), v.end());\\n\"\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f7(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w(10, 0, std::allocator<int>);\\n\" // FN\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f8(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w(10, 0);\\n\" // warn\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f9(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w(10);\\n\" // warn\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\"\n              \"void f10(std::vector<int> v) {\\n\"\n              \"    std::vector<int> w{};\\n\" // warn\n              \"    bool b = g(v);\\n\"\n              \"    if (b)\\n\"\n              \"        h(w);\\n\"\n              \"    h(v);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:25:22]: (style) The scope of the variable 'w' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:32:22]: (style) The scope of the variable 'w' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:60:22]: (style) The scope of the variable 'w' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:67:22]: (style) The scope of the variable 'w' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:74:22]: (style) The scope of the variable 'w' can be reduced. [variableScope]\\n\",\n                      errout_str());\n    }\n\n    void varScope32() { // #11441\n        check(\"template <class F>\\n\"\n              \"std::vector<int> g(F, const std::vector<int>&);\\n\"\n              \"void f(const std::vector<int>&v) {\\n\"\n              \"    std::vector<int> w;\\n\"\n              \"    for (auto x : v)\\n\"\n              \"        w = g([&]() { x; }, w);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:23]: (warning) Unused variable value 'x' [constStatement]\\n\", errout_str());\n    }\n\n    void varScope33() { // #11131\n        check(\"struct S {\\n\"\n              \"    const std::string& getStr() const;\\n\"\n              \"    void mutate();\\n\"\n              \"    bool getB() const;\\n\"\n              \"};\\n\"\n              \"void g(S& s) {\\n\"\n              \"    std::string str = s.getStr();\\n\"\n              \"    s.mutate();\\n\"\n              \"    if (s.getB()) {\\n\"\n              \"        if (str == \\\"abc\\\") {}\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void g(char* s, bool b) {\\n\"\n              \"    int i = strlen(s);\\n\"\n              \"    s[0] = '\\\\0';\\n\"\n              \"    if (b) {\\n\"\n              \"        if (i == 5) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void f(const S& s) {\\n\"\n              \"    std::string str = s.getStr();\\n\"\n              \"    std::string str2{ s.getStr() };\\n\"\n              \"    std::string str3(s.getStr());\\n\"\n              \"    if (s.getB()) {\\n\"\n              \"        if (str == \\\"abc\\\") {}\\n\"\n              \"        if (str2 == \\\"abc\\\") {}\\n\"\n              \"        if (str3 == \\\"abc\\\") {}\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void f(const char* s, bool b) {\\n\"\n              \"    int i = strlen(s);\\n\"\n              \"    if (b) {\\n\"\n              \"        if (i == 5) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void f(int j, bool b) {\\n\"\n              \"    int k = j;\\n\"\n              \"    if (b) {\\n\"\n              \"        if (k == 5) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:21:17]: (style) The scope of the variable 'str' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:22:17]: (style) The scope of the variable 'str2' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:23:17]: (style) The scope of the variable 'str3' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:31:9]: (style) The scope of the variable 'i' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:37:9]: (style) The scope of the variable 'k' can be reduced. [variableScope]\\n\",\n                      errout_str());\n    }\n\n    void varScope34() { // #11742\n        check(\"void f() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    int i = 1;\\n\"\n              \"    for (int k = 0; k < 20; ++k) {\\n\"\n              \"        b = !b;\\n\"\n              \"        if (b)\\n\"\n              \"            i++;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope35() { // #11845\n        check(\"void f(int err, const char* src) {\\n\"\n              \"    const char* msg = \\\"Success\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (err != 0)\\n\"\n              \"        msg = strcpy(buf, src);\\n\"\n              \"    printf(\\\"%d: %s\\\\n\\\", err, msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char* g(char* dst, const char* src);\\n\"\n              \"void f(int err, const char* src) {\\n\"\n              \"    const char* msg = \\\"Success\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (err != 0)\\n\"\n              \"        msg = g(buf, src);\\n\"\n              \"    printf(\\\"%d: %s\\\\n\\\", err, msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char* g(char* dst, const char* src);\\n\"\n              \"void f(int err, const char* src) {\\n\"\n              \"    const char* msg = \\\"Success\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (err != 0)\\n\"\n              \"        g(buf, src);\\n\"\n              \"    printf(\\\"%d: %s\\\\n\\\", err, msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style) The scope of the variable 'buf' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope36() {\n        // #12158\n        check(\"void f( uint32_t value ) {\\n\"\n              \"    uint32_t i = 0U;\\n\"\n              \"    if ( value > 100U ) { }\\n\"\n              \"    else if( value > 50U ) { }\\n\"\n              \"    else{\\n\"\n              \"         for( i = 0U; i < 5U; i++ ) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\", true, false);\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) The scope of the variable 'i' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope37() {\n        // #12158\n        check(\"void f( uint32_t value ) {\\n\"\n              \"    uint32_t i = 0U;\\n\"\n              \"    if ( value > 100U ) { }\\n\"\n              \"    else {\\n\"\n              \"        if( value > 50U ) { }\\n\"\n              \"        else{\\n\"\n              \"            for( i = 0U; i < 5U; i++ ) {}\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\", true, false);\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) The scope of the variable 'i' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope38() {\n        checkP(\"bool dostuff();\\n\" // #12519\n               \"#define DOSTUFF(c) if (c < 5) { if (c) b = dostuff(); }\\n\"\n               \"#define DOSTUFFEX(c) { bool b = false; DOSTUFF(c); }\\n\"\n               \"void f(int a) {\\n\"\n               \"    DOSTUFFEX(a);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope39() {\n        check(\"struct S {\\n\" // #12405\n              \"    void f(const std::string&) const;\\n\"\n              \"    const int* g(std::string&) const;\\n\"\n              \"};\\n\"\n              \"void h(int);\\n\"\n              \"void S::f(const std::string& s) const {\\n\"\n              \"    std::string n = s;\\n\"\n              \"    const int* a = g(n);\\n\"\n              \"    if (n == \\\"abc\\\") {\\n\"\n              \"        h(a[0]);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varScope40() {\n        checkP(\"#define NUM (-999.9)\\n\" // #8862\n               \"double f(int i) {\\n\"\n               \"    double a = NUM;\\n\"\n               \"    double b = -NUM;\\n\"\n               \"    double c = -1.0 * NUM;\\n\"\n               \"    if (i == 1) {\\n\"\n               \"        return a;\\n\"\n               \"    }\\n\"\n               \"    if (i == 2) {\\n\"\n               \"        return b;\\n\"\n               \"    }\\n\"\n               \"    if (i == 3) {\\n\"\n               \"        return c;\\n\"\n               \"    }\\n\"\n               \"    return 0.0;\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) The scope of the variable 'a' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:4:12]: (style) The scope of the variable 'b' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:5:12]: (style) The scope of the variable 'c' can be reduced. [variableScope]\\n\",\n                      errout_str());\n\n        check(\"struct S { int a; };\\n\" // #12618\n              \"int f(const S* s, int i) {\\n\"\n              \"    int x = s->a;\\n\"\n              \"    const int b[] = { 1, 2, 3 };\\n\"\n              \"    int y = b[1];\\n\"\n              \"    if (i)\\n\"\n              \"        return x + y;\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:5:9]: (style) The scope of the variable 'y' can be reduced. [variableScope]\\n\",\n                      errout_str());\n    }\n\n    void varScope41() {    // #11845\n        check(\"void get_errmsg(const char **msg, char *buf, size_t bufsiz, int err);\\n\"\n              \"void test(int err)\\n\"\n              \"{\\n\"\n              \"    const char *msg = \\\"Success\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (err != 0)\\n\"\n              \"        get_errmsg(&msg, buf, sizeof(buf), err);\\n\"\n              \"    printf(\\\"%d: %s\\\\n\\\", err, msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void get_errmsg(char *buf, size_t bufsiz, int err);\\n\"\n              \"void test(int err)\\n\"\n              \"{\\n\"\n              \"    const char *msg = \\\"Success\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (err != 0)\\n\"\n              \"        get_errmsg(buf, sizeof(buf), err);\\n\"\n              \"    printf(\\\"%d: %s\\\\n\\\", err, msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (style) The scope of the variable 'buf' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope42() {\n        check(\"void f(const char **, char *);\\n\"\n              \"void g(int e) {\\n\"\n              \"    const char *msg = \\\"Something\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (e != 0)\\n\"\n              \"        f(&msg, buf);\\n\"\n              \"    printf(\\\"result: %s\\\\n\\\", msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char *, char *);\\n\"\n              \"void g(int e) {\\n\"\n              \"    char msg [42] = \\\"Something\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (e != 0)\\n\"\n              \"        f(msg, buf);\\n\"\n              \"    printf(\\\"result: %s\\\\n\\\", msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const char *, char *);\\n\"\n              \"void g(int e) {\\n\"\n              \"    const char *msg = \\\"Something\\\";\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (e != 0)\\n\"\n              \"        f(msg, buf);\\n\"\n              \"    printf(\\\"result: %s\\\\n\\\", msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style) The scope of the variable 'buf' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f(int **, char *);\\n\"\n              \"void g(int e) {\\n\"\n              \"    int *msg = calloc(0, sizeof(*msg));\\n\"\n              \"    char buf[42];\\n\"\n              \"    if (e != 0)\\n\"\n              \"        f(&msg, buf);\\n\"\n              \"    printf(\\\"result: %d\\\\n\\\", *msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style) The scope of the variable 'buf' can be reduced. [variableScope]\\n\", errout_str());\n\n        check(\"void f(const char *&, const char *&);\\n\"\n              \"void g(int e) {\\n\"\n              \"    const char *msg = \\\"Something\\\";\\n\"\n              \"    char *buf = malloc(42);\\n\"\n              \"    if (e != 0)\\n\"\n              \"        f(msg, buf);\\n\"\n              \"    printf(\\\"result: %d\\\\n\\\", msg);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(const char* format, ...);\\n\"\n              \"void f(bool b) {\\n\"\n              \"    const char* s = \\\"abc\\\";\\n\"\n              \"    if (b)\\n\"\n              \"       g(\\\"%d %s\\\", 1, s);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) The scope of the variable 's' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n    void varScope43() {\n        check(\"struct S { int a, b; };\\n\" // #13838\n              \"int f(S s) {\\n\"\n              \"    auto& [x, y] = s;\\n\"\n              \"    if (x < 5) {\\n\"\n              \"        return y;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int a; };\\n\"\n              \"int f(S s) {\\n\"\n              \"    auto& [x] = s;\\n\"\n              \"    if (y) {\\n\"\n              \"        return x;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) The scope of the variable 'x' can be reduced. [variableScope]\\n\", errout_str());\n    }\n\n#define checkOldStylePointerCast(...) checkOldStylePointerCast_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkOldStylePointerCast_(const char* file, int line, const char (&code)[size], Standards::cppstd_t std = Standards::CPPLatest) {\n\n        const Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::style).cpp(std).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizerCpp(settings, *this);\n        ASSERT_LOC(tokenizerCpp.tokenize(code), file, line);\n\n        CheckOther checkOtherCpp(&tokenizerCpp, &settings, this);\n        checkOtherCpp.warningOldStylePointerCast();\n        checkOtherCpp.warningDangerousTypeCast();\n    }\n\n    void oldStylePointerCast() {\n        checkOldStylePointerCast(\"class Base{};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void foo(Base* base)\\n\"\n                                 \"{\\n\"\n                                 \"    Derived * d = (Derived *) base;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base{};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void foo(Derived* derived)\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (Base *) derived;\\n\" // <- cast from derived to base is safe => cstyleCast\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"void foo(Base* base)\\n\"\n                                 \"{\\n\"\n                                 \"    Derived * d = (Derived *) base;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base{};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void foo(Base* base)\\n\"\n                                 \"{\\n\"\n                                 \"    Derived * d = (const Derived *) base;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base{};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Derived * d = (const Derived *) ( new Base() );\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base{};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Derived * d = (const Derived *) new Base();\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base{};\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (Base *) new short[10];\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (volatile Base *) derived;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (volatile Base * const) derived;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (const volatile Base *) derived;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (const volatile Base * const) derived;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (const Base *) ( new Derived() );\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (const Base *) new Derived();\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class Base;\\n\"\n                                 \"void foo()\\n\"\n                                 \"{\\n\"\n                                 \"    Base * b = (const Base *) new short[10];\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class B;\\n\"\n                                 \"class A\\n\"\n                                 \"{\\n\"\n                                 \"  virtual void abc(B *) const = 0;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOldStylePointerCast(\"class B;\\n\"\n                                 \"class A\\n\"\n                                 \"{\\n\"\n                                 \"  virtual void abc(const B *) const = 0;\\n\"\n                                 \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3630\n        checkOldStylePointerCast(\"class SomeType{};\\n\"\n                                 \"class X : public Base {\\n\"\n                                 \"    X() : Base((SomeType*)7) {}\\n\" // <- intToPointerCast\n                                 \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOldStylePointerCast(\"class SomeType{};\\n\"\n                                 \"class X : public Base {\\n\"\n                                 \"    X() : Base((SomeType*)0x7000) {}\\n\" // <- it's common in embedded code to cast address\n                                 \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkOldStylePointerCast(\"class SomeType;\\n\"\n                                 \"class X : public Base {\\n\"\n                                 \"    X() : Base((SomeType*)var) {}\\n\"\n                                 \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        checkOldStylePointerCast(\"class SomeType;\\n\"\n                                 \"class X : public Base {\\n\"\n                                 \"    X() : Base((SomeType*)0) {}\\n\"\n                                 \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5560\n        checkOldStylePointerCast(\"class C;\\n\"\n                                 \"\\n\"\n                                 \"class B\\n\"\n                                 \"{ virtual G* createGui(S*, C*) const = 0; };\\n\"\n                                 \"\\n\"\n                                 \"class MS : public M\\n\"\n                                 \"{ virtual void addController(C*) override {} };\", Standards::CPP03);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6164\n        checkOldStylePointerCast(\"class Base {};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void testCC() {\\n\"\n                                 \"  std::vector<Base*> v;\\n\"\n                                 \"  v.push_back((Base*)new Derived);\\n\"\n                                 \"}\");\n        // FIXME write a dangerousTypeCast warning instead\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        // #7709\n        checkOldStylePointerCast(\"typedef struct S S;\\n\"\n                                 \"typedef struct S SS;\\n\"\n                                 \"typedef class C C;\\n\"\n                                 \"typedef long LONG;\\n\"\n                                 \"typedef long* LONGP;\\n\"\n                                 \"struct T {};\\n\"\n                                 \"typedef struct T TT;\\n\"\n                                 \"typedef struct T2 {} TT2;\\n\"\n                                 \"void f(int* i) {\\n\"\n                                 \"    S* s = (S*)i;\\n\"\n                                 \"    SS* ss = (SS*)i;\\n\"\n                                 \"    struct S2* s2 = (struct S2*)i;\\n\"\n                                 \"    C* c = (C*)i;\\n\"\n                                 \"    class C2* c2 = (class C2*)i;\\n\"\n                                 \"    long* l = (long*)i;\\n\"\n                                 \"    LONG* l2 = (LONG*)i;\\n\"\n                                 \"    LONGP l3 = (LONGP)i;\\n\"\n                                 \"    TT* tt = (TT*)i;\\n\"\n                                 \"    TT2* tt2 = (TT2*)i;\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:10:12]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:11:14]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:12:21]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:13:12]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:14:20]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:15:15]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:16:16]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:17:16]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:18:14]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:19:16]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\",\n                      errout_str());\n\n        // #8649\n        checkOldStylePointerCast(\"struct S {};\\n\"\n                                 \"void g(S*& s);\\n\"\n                                 \"void f(uintptr_t i) {\\n\"\n                                 \"    g((S*&)i);\\n\"\n                                 \"    S*& r = (S*&)i;\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) C-style pointer casting [cstyleCast]\\n\"\n                      \"[test.cpp:5:13]: (style) C-style pointer casting [cstyleCast]\\n\",\n                      errout_str());\n\n        checkOldStylePointerCast(\"struct S {};\\n\"\n                                 \"void g(S*& s);\\n\"\n                                 \"void f(uint8_t i) {\\n\"\n                                 \"    g((S*&)i);\\n\"\n                                 \"    S*& r = (S*&)i;\\n\"\n                                 \"}\\n\");\n        // TODO: these conversions are dangerous, but it's a different issue not covered by cstyleCast. A separate checker can be added which is executed for both C and C++ code.\n        // clang says: 1.cpp:5:18: warning: cast to 'unsigned char *' from smaller integer type 'uint8_t' (aka 'unsigned char') [-Wint-to-pointer-cast]\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) C-style pointer casting [cstyleCast]\\n\"\n                      \"[test.cpp:5:13]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        // #10823\n        checkOldStylePointerCast(\"void f(void* p) {\\n\"\n                                 \"    auto h = reinterpret_cast<void (STDAPICALLTYPE*)(int)>(p);\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5210\n        checkOldStylePointerCast(\"class Base {};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void f(Base** b1, Base*** b2) {\\n\"\n                                 \"    Derived** p1 = (Derived**)b1;\\n\"\n                                 \"    Derived*** p2 = (Derived***)b2;\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:5:21]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\",\n                      errout_str());\n\n        // #12446\n        checkOldStylePointerCast(\"namespace N { struct S {}; }\\n\"\n                                 \"union U {\\n\"\n                                 \"    int i;\\n\"\n                                 \"    char c[4];\\n\"\n                                 \"};\\n\"\n                                 \"void f(void* p) {\\n\"\n                                 \"    auto ps = (N::S*)p;\\n\"\n                                 \"    auto pu = (union U*)p;\\n\"\n                                 \"    auto pv = (std::vector<int>*)(p);\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:15]: (style) C-style pointer casting [cstyleCast]\\n\"\n                      \"[test.cpp:8:15]: (style) C-style pointer casting [cstyleCast]\\n\"\n                      \"[test.cpp:9:15]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n\n        // #12447\n        checkOldStylePointerCast(\"class Base {};\\n\"\n                                 \"class Derived: public Base {};\\n\"\n                                 \"void f(const Base& base) {\\n\"\n                                 \"  d = (const Derived&)base;\\n\"\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        // #11430\n        checkOldStylePointerCast(\"struct B {\\n\"\n                                 \"    float* data() const;\\n\"\n                                 \"};\\n\"\n                                 \"namespace N {\\n\"\n                                 \"    bool f(float* v);\\n\"\n                                 \"}\\n\"\n                                 \"bool g(B& b) {\\n\"\n                                 \"    using float_ptr = float*;\\n\"\n                                 \"    return N::f(float_ptr(b.data()));\\n\" // <- the cast is safe\n                                 \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:17]: (style) C-style pointer casting [cstyleCast]\\n\", errout_str());\n    }\n\n#define checkIntToPointerCast(...) checkIntToPointerCast_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkIntToPointerCast_(const char* file, int line, const char (&code)[size]) {\n\n        const Settings settings = settingsBuilder().severity(Severity::portability).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizerCpp(settings, *this);\n        ASSERT_LOC(tokenizerCpp.tokenize(code), file, line);\n\n        CheckOther checkOtherCpp(&tokenizerCpp, &settings, this);\n        checkOtherCpp.warningIntToPointerCast();\n    }\n\n    void intToPointerCast() {\n        // #3630\n        checkIntToPointerCast(\"uint8_t* ptr = (uint8_t*)7;\");\n        ASSERT_EQUALS(\"[test.cpp:1:16]: (portability) Casting non-zero decimal integer literal to pointer. [intToPointerCast]\\n\", errout_str());\n\n        checkIntToPointerCast(\"void* ptr = (void*)7;\");\n        ASSERT_EQUALS(\"[test.cpp:1:13]: (portability) Casting non-zero decimal integer literal to pointer. [intToPointerCast]\\n\", errout_str());\n\n        checkIntToPointerCast(\"uint8_t* ptr = (uint8_t*)0;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkIntToPointerCast(\"uint8_t* ptr = (uint8_t*)0x7000;\"); // <- it's common in embedded code to cast address\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkIntToPointerCast(\"struct S { int i; };\\n\" // #13886, don't crash\n                              \"int f() { return sizeof(((struct S*)0)->i); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n#define checkInvalidPointerCast(...) checkInvalidPointerCast_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkInvalidPointerCast_(const char* file, int line, const char (&code)[size], bool portability = true, bool inconclusive = false) {\n        /*const*/ Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::portability, portability).certainty(Certainty::inconclusive, inconclusive).build();\n        settings.platform.defaultSign = 's';\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CheckOther checkOtherCpp(&tokenizer, &settings, this);\n        checkOtherCpp.invalidPointerCast();\n    }\n\n\n    void invalidPointerCast() {\n        checkInvalidPointerCast(\"void test() {\\n\"\n                                \"    float *f = new float[10];\\n\"\n                                \"    delete [] (double*)f;\\n\"\n                                \"    delete [] (long double const*)(new float[10]);\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (portability) Casting between float * and double * which have an incompatible binary data representation. [invalidPointerCast]\\n\"\n                      \"[test.cpp:4:15]: (portability) Casting between float * and const long double * which have an incompatible binary data representation. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"void test(const float* f) {\\n\"\n                                \"    double *d = (double*)f;\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (portability) Casting between const float * and double * which have an incompatible binary data representation. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"void test(double* d1) {\\n\"\n                                \"    long double *ld = (long double*)d1;\\n\"\n                                \"    double *d2 = (double*)ld;\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (portability) Casting between double * and long double * which have an incompatible binary data representation. [invalidPointerCast]\\n\"\n                      \"[test.cpp:3:18]: (portability) Casting between long double * and double * which have an incompatible binary data representation. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"char* test(int* i) {\\n\"\n                                \"    long double *d = (long double*)(i);\\n\"\n                                \"    double *d = (double*)(i);\\n\"\n                                \"    float *f = reinterpret_cast<float*>(i);\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (portability) Casting between signed int * and long double * which have an incompatible binary data representation. [invalidPointerCast]\\n\"\n                      \"[test.cpp:3:17]: (portability) Casting between signed int * and double * which have an incompatible binary data representation. [invalidPointerCast]\\n\"\n                      \"[test.cpp:4:16]: (portability) Casting between signed int * and float * which have an incompatible binary data representation. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"float* test(unsigned int* i) {\\n\"\n                                \"    return (float*)i;\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (portability) Casting between unsigned int * and float * which have an incompatible binary data representation. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"float* test(unsigned int* i) {\\n\"\n                                \"    return (float*)i[0];\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInvalidPointerCast(\"float* test(double& d) {\\n\"\n                                \"    return (float*)&d;\\n\"\n                                \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (portability) Casting between double * and float * which have an incompatible binary data representation. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"void test(float* data) {\\n\"\n                                \"    f.write((char*)data,sizeof(float));\\n\"\n                                \"}\", true, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInvalidPointerCast(\"void test(float* data) {\\n\"\n                                \"    f.write((char*)data,sizeof(float));\\n\"\n                                \"}\", true, true); // #3639\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (portability, inconclusive) Casting from float * to signed char * is not portable due to different binary data representations on different platforms. [invalidPointerCast]\\n\", errout_str());\n\n\n        checkInvalidPointerCast(\"long long* test(float* f) {\\n\"\n                                \"    return (long long*)f;\\n\"\n                                \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInvalidPointerCast(\"long long* test(float* f, char* c) {\\n\"\n                                \"    foo((long long*)f);\\n\"\n                                \"    return reinterpret_cast<long long*>(c);\\n\"\n                                \"}\", true);\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (portability) Casting from float * to signed long long * is not portable due to different binary data representations on different platforms. [invalidPointerCast]\\n\", errout_str());\n\n        checkInvalidPointerCast(\"Q_DECLARE_METATYPE(int*)\"); // #4135 - don't crash\n    }\n\n\n    void passedByValue() {\n        check(\"void f(const std::string str) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:26]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(std::unique_ptr<std::string> ptr) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::shared_ptr<std::string> ptr) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::function<F> ptr) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            check(\"void f(const std::pair<int,int> x) {}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            check(\"void f(const std::pair<std::string,std::string> x) {}\");\n            TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n        }\n\n        check(\"void f(const std::string::size_type x) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class Foo;\\nvoid f(const Foo foo) {}\"); // Unknown class\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (performance, inconclusive) Function parameter 'foo' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class Foo { std::vector<int> v; };\\nvoid f(const Foo foo) {}\"); // Large class (STL member)\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (performance) Function parameter 'foo' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class Foo { int i; };\\nvoid f(const Foo foo) {}\"); // Small class\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class Foo { int i[6]; };\\nvoid f(const Foo foo) {}\"); // Large class (array)\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (performance) Function parameter 'foo' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class Foo { std::string* s; };\\nvoid f(const Foo foo) {}\"); // Small class (pointer)\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class Foo { static std::string s; };\\nvoid f(const Foo foo) {}\"); // Small class (static member)\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class X { std::string s; }; class Foo : X { };\\nvoid f(const Foo foo) {}\"); // Large class (inherited)\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (performance) Function parameter 'foo' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class X { std::string s; }; class Foo { X x; };\\nvoid f(const Foo foo) {}\"); // Large class (inherited)\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (performance) Function parameter 'foo' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::string &str) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // The idiomatic way of passing a std::string_view is by value\n        check(\"void f(const std::string_view str) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string_view str) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::string_view &str) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<int> v) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:31]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::vector<std::string> v) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:39]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::vector<std::string>::size_type s) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<int> &v) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::map<int,int> &v) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::map<int,int> v) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:32]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::map<std::string,std::string> v) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:48]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::map<int,std::string> v) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:40]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::map<std::string,int> v) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:40]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::streamoff pos) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::initializer_list<int> i) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5824\n        check(\"void log(const std::string& file, int line, const std::string& function, const std::string str, ...) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5534\n        check(\"struct float3 { };\\n\"\n              \"typedef float3 vec;\\n\"\n              \"class Plane {\\n\"\n              \"    vec Refract(vec &vec) const;\\n\"\n              \"    bool IntersectLinePlane(const vec &planeNormal);\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    virtual void func(const std::string str) {}\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:41]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"enum X;\\n\"\n              \"void foo(X x1){}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"enum X { a, b, c };\\n\"\n              \"void foo(X x2){}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"enum X { a, b, c };\\n\"\n              \"enum X;\"\n              \"void foo(X x3){}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"enum X;\\n\"\n              \"enum X { a, b, c };\"\n              \"void foo(X x4){}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"union U {\\n\"\n              \"    char* pc;\\n\"\n              \"    short* ps;\\n\"\n              \"    int* pi;\\n\"\n              \"};\\n\"\n              \"void f(U u) {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { char A[8][8]; };\\n\"\n              \"void f(S s) {}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance) Function parameter 's' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"union U {\\n\" // don't crash\n              \"    int a;\\n\"\n              \"    decltype(nullptr) b;\\n\"\n              \"};\\n\"\n              \"int* f(U u) { return u.b; }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct B { virtual int f(std::string s) = 0; };\\n\" // #11432\n              \"struct D1 : B {\\n\"\n              \"  int f(std::string s) override { s += 'a'; return s.size(); }\\n\"\n              \"}\\n\"\n              \"struct D2 : B {\\n\"\n              \"  int f(std::string s) override { return s.size(); }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int x(int);\\n\"\n              \"void f(std::vector<int> v, int& j) {\\n\"\n              \"    for (int i : v)\\n\"\n              \"        j = i;\\n\"\n              \"}\\n\"\n              \"void fn(std::vector<int> v) {\\n\"\n              \"    for (int& i : v)\\n\"\n              \"        i = x(i);\\n\"\n              \"}\\n\"\n              \"void g(std::vector<int> v, int& j) {\\n\"\n              \"    for (int i = 0; i < v.size(); ++i)\\n\"\n              \"        j = v[i];\\n\"\n              \"}\\n\"\n              \"void gn(std::vector<int> v) {\\n\"\n              \"    for (int i = 0; i < v.size(); ++i)\\n\"\n              \"        v[i] = x(i);\\n\"\n              \"}\\n\"\n              \"void h(std::vector<std::vector<int>> v, int& j) {\\n\"\n              \"    for (int i = 0; i < v.size(); ++i)\\n\"\n              \"        j = v[i][0];\\n\"\n              \"}\\n\"\n              \"void hn(std::vector<std::vector<int>> v) {\\n\"\n              \"    for (int i = 0; i < v.size(); ++i)\\n\"\n              \"        v[i][0] = x(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\"\n                      \"[test.cpp:10:25]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\"\n                      \"[test.cpp:18:38]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\" // #11995\n              \"    explicit S(std::string s) noexcept;\\n\"\n              \"    std::string m;\\n\"\n              \"};\\n\"\n              \"S::S(std::string s) noexcept : m(std::move(s)) {}\\n\"\n              \"struct T {\\n\"\n              \"    explicit S(std::string s) noexcept(true);\\n\"\n              \"    std::string m;\\n\"\n              \"};\\n\"\n              \"T::T(std::string s) noexcept(true) : m(std::move(s)) {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace N {\\n\" // #12086\n              \"    void g(int);\\n\"\n              \"}\\n\"\n              \"void f(std::vector<int> v) {\\n\"\n              \"    N::g(v[0]);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:25]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::string& s, std::string t) {\\n\" // #12083\n              \"    const std::string& v = !s.empty() ? s : t;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:42]: (performance) Function parameter 't' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        /*const*/ Settings settings0 = settingsBuilder(_settings).platform(Platform::Type::Unix64).build();\n        check(\"struct S {\\n\" // #12138\n              \"    union {\\n\"\n              \"        int a = 0;\\n\"\n              \"        int x;\\n\"\n              \"    };\\n\"\n              \"    union {\\n\"\n              \"        int b = 0;\\n\"\n              \"        int y;\\n\"\n              \"    };\\n\"\n              \"    union {\\n\"\n              \"        int c = 0;\\n\"\n              \"        int z;\\n\"\n              \"    };\\n\"\n              \"};\\n\"\n              \"void f(S s) {\\n\"\n              \"    if (s.x > s.y) {}\\n\"\n              \"}\\n\", /*cpp*/ true, /*inconclusive*/ true, /*runSimpleChecks*/ true, /*verbose*/ false, &settings0);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { std::list<int> l; };\\n\" // #12147\n              \"class C { public: std::list<int> l; };\\n\"\n              \"bool f(S s) {\\n\"\n              \"    return s.l.empty();\\n\"\n              \"}\\n\"\n              \"bool f(C c) {\\n\"\n              \"    return c.l.empty();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (performance) Function parameter 's' should be passed by const reference. [passedByValue]\\n\"\n                      \"[test.cpp:6:10]: (performance) Function parameter 'c' should be passed by const reference. [passedByValue]\\n\",\n                      errout_str());\n\n        check(\"struct S { std::list<int> a[1][1]; };\\n\"\n              \"bool f(S s) {\\n\"\n              \"    return s.a[0][0].empty();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (performance) Function parameter 's' should be passed by const reference. [passedByValue]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"    enum class E : std::uint8_t { E0 };\\n\"\n              \"    static void f(S::E e) {\\n\"\n              \"        if (e == S::E::E0) {}\\n\"\n              \"    }\\n\"\n              \"    char a[20];\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<int> v[2]);\\n\" // #13052\n              \"void g(const std::vector<int> v[2]);\\n\"\n              \"void g(const std::vector<int> v[2]) {}\\n\"\n              \"int h(const std::array<std::vector<int>, 2> a) { return a[0][0]; }\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:45]: (performance) Function parameter 'a' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(const std::array<int, 10> a[]) {}\\n\"); // #13524\n        ASSERT_EQUALS(\"\", errout_str());\n\n        /*const*/ Settings settings1 = settingsBuilder().platform(Platform::Type::Win64).build();\n        check(\"using ui64 = unsigned __int64;\\n\"\n              \"ui64 Test(ui64 one, ui64 two) { return one + two; }\\n\",\n              /*cpp*/ true, /*inconclusive*/ true, /*runSimpleChecks*/ true, /*verbose*/ false, &settings1);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void passedByValue_nonConst() {\n        check(\"void f(std::string str) {}\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    return str + x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    std::cout << str;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    std::cin >> str;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    std::string s2 = str;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    std::string& s2 = str;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\"\n                      \"[test.cpp:2:18]: (style) Variable 's2' can be declared as reference to const [constVariableReference]\\n\",\n                      errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    const std::string& s2 = str;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    str = \\\"\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string str) {\\n\"\n              \"    foo(str);\\n\" // It could be that foo takes str as non-const-reference\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const std::string& str);\\n\"\n              \"void f(std::string str) {\\n\"\n              \"    foo(str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void foo(std::string str);\\n\"\n              \"void f(std::string str) {\\n\"\n              \"    foo(str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"void foo(std::string& str);\\n\"\n              \"void f(std::string str) {\\n\"\n              \"    foo(str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(std::string* str);\\n\"\n              \"void f(std::string str) {\\n\"\n              \"    foo(&str);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int& i1, const std::string& str, int& i2);\\n\"\n              \"void f(std::string str) {\\n\"\n              \"    foo((a+b)*c, str, x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"std::string f(std::string str) {\\n\"\n              \"    str += x;\\n\"\n              \"    return str;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    std::string s;\\n\"\n              \"    void func() const;\\n\"\n              \"};\\n\"\n              \"Y f(X x) {\\n\"\n              \"    x.func();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (performance) Function parameter 'x' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    void func();\\n\"\n              \"};\\n\"\n              \"Y f(X x) {\\n\"\n              \"    x.func();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    void func(std::string str) {}\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:2:27]: (performance) Function parameter 'str' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    virtual void func(std::string str) {}\\n\" // Do not warn about virtual functions, if 'str' is not declared as const\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    char a[1024];\\n\"\n              \"};\\n\"\n              \"class Y : X {\\n\"\n              \"    char b;\\n\"\n              \"};\\n\"\n              \"void f(Y y) {\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (performance) Function parameter 'y' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"class X {\\n\"\n              \"    void* a;\\n\"\n              \"    void* b;\\n\"\n              \"};\\n\"\n              \"class Y {\\n\"\n              \"    void* a;\\n\"\n              \"    void* b;\\n\"\n              \"    char c;\\n\"\n              \"};\\n\"\n              \"void f(X x, Y y) {\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:15]: (performance) Function parameter 'y' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        {\n            // 8-byte data should be passed by const reference on 32-bit platform but not on 64-bit platform\n            const char code[] = \"class X {\\n\"\n                                \"    uint64_t a;\\n\"\n                                \"    uint64_t b;\\n\"\n                                \"};\\n\"\n                                \"void f(X x) {}\";\n\n            /*const*/ Settings s32 = settingsBuilder(_settings).platform(Platform::Type::Unix32).build();\n            check(code, &s32);\n            ASSERT_EQUALS(\"[test.cpp:5:10]: (performance) Function parameter 'x' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n            /*const*/ Settings s64 = settingsBuilder(_settings).platform(Platform::Type::Unix64).build();\n            check(code, &s64);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"Writer* getWriter();\\n\"\n              \"\\n\"\n              \"void foo(Buffer& buffer) {\\n\"\n              \"    getWriter()->operator<<(buffer);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void passedByValue_externC() {\n        check(\"struct X { int a[5]; }; void f(X v) { }\");\n        ASSERT_EQUALS(\"[test.cpp:1:34]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"extern \\\"C\\\" { struct X { int a[5]; }; void f(X v) { } }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X { int a[5]; }; extern \\\"C\\\" void f(X v) { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X { int a[5]; }; void f(const X v);\");\n        ASSERT_EQUALS(\"[test.cpp:1:40]: (performance) Function parameter 'v' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"extern \\\"C\\\" { struct X { int a[5]; }; void f(const X v); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X { int a[5]; }; extern \\\"C\\\" void f(const X v) { }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constVariable() {\n        check(\"int f(std::vector<int> x) {\\n\"\n              \"    int& i = x[0];\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:24]: (performance) Function parameter 'x' should be passed by const reference. [passedByValue]\\n\"\n                      \"[test.cpp:2:10]: (style) Variable 'i' can be declared as reference to const [constVariableReference]\\n\",\n                      errout_str());\n\n        check(\"int f(std::vector<int>& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:25]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"int f(std::vector<int> x) {\\n\"\n              \"    const int& i = x[0];\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:24]: (performance) Function parameter 'x' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"int f(std::vector<int> x) {\\n\"\n              \"    static int& i = x[0];\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:24]: (performance) Function parameter 'x' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"int f(std::vector<int> x) {\\n\"\n              \"    int& i = x[0];\\n\"\n              \"    i++;\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int& f(std::vector<int>& x) {\\n\"\n              \"    x.push_back(1);\\n\"\n              \"    int& i = x[0];\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int>& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int& f(std::vector<int>& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const int& f(std::vector<int>& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:32]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"int f(std::vector<int>& x) {\\n\"\n              \"    x[0]++;\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int a; };\\n\"\n              \"A f(std::vector<A>& x) {\\n\"\n              \"    x[0].a = 1;\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int a(); };\\n\"\n              \"A f(std::vector<A>& x) {\\n\"\n              \"    x[0].a();\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g(int& x);\\n\"\n              \"int f(std::vector<int>& x) {\\n\"\n              \"    g(x[0]);\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template<class T>\\n\"\n              \"T f(T& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template<class T>\\n\"\n              \"T f(T&& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template<class T>\\n\"\n              \"T f(T& x) {\\n\"\n              \"    return x[0];\\n\"\n              \"}\\n\"\n              \"void h() { std::vector<int> v; h(v); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int& x) {\\n\"\n              \"    return std::move(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::ostream& os) {\\n\"\n              \"    os << \\\"Hello\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int*);\\n\"\n              \"void f(int& x) {\\n\"\n              \"    g(&x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { A(int*); };\\n\"\n              \"A f(int& x) {\\n\"\n              \"    return A(&x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { A(int*); };\\n\"\n              \"A f(int& x) {\\n\"\n              \"    return A{&x};\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int& x, int& y) {\\n\"\n              \"    y++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:13]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    explicit A(int& y) : x(&y) {}\\n\"\n              \"    int * x = nullptr;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    void swap(A& a) {\\n\"\n              \"        v.swap(a.v);\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    template<class T>\\n\"\n              \"    void f();\\n\"\n              \"    template<class T>\\n\"\n              \"    void f() const;\\n\"\n              \"};\\n\"\n              \"void g(A& a) {\\n\"\n              \"    a.f<int>();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    for(auto&& x:v)\\n\"\n              \"        x = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    for(auto x:v)\\n\"\n              \"        x = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:26]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    for(auto& x:v) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Variable 'x' can be declared as reference to const [constVariableReference]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\" // #10980\n              \"    for (int& i : v)\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    for (const int& i : v)\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    for (auto& i : v)\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    for (const auto& i : v)\\n\"\n              \"        if (i == 0) {}\\n\"\n              \"    v.clear();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Variable 'i' can be declared as reference to const [constVariableReference]\\n\"\n                      \"[test.cpp:6:16]: (style) Variable 'i' can be declared as reference to const [constVariableReference]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    for(const auto& x:v) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:26]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"void f(int& i) {\\n\"\n              \"    int& j = i;\\n\"\n              \"    j++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    int& i = v[0];\\n\"\n              \"    i++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::map<unsigned int, std::map<std::string, unsigned int> >& m, unsigned int i) {\\n\"\n              \"    std::map<std::string, unsigned int>& members = m[i];\\n\"\n              \"    members.clear();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int& x;\\n\"\n              \"    A(int& y) : x(y)\\n\"\n              \"    {}\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    A(int& x);\\n\"\n              \"};\\n\"\n              \"struct B : A {\\n\"\n              \"    B(int& x) : A(x)\\n\"\n              \"    {}\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b, int& x, int& y) {\\n\"\n              \"  auto& z = x;\\n\"\n              \"  auto& w = b ? y : z;\\n\"\n              \"  w = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int i;\\n\"\n              \"};\\n\"\n              \"int& f(S& s) {\\n\"\n              \"  return s.i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int* f(std::list<int>& x, unsigned int y) {\\n\"\n              \"    for (int& m : x) {\\n\"\n              \"        if (m == y)\\n\"\n              \"            return &m;\\n\"\n              \"    }\\n\"\n              \"    return nullptr;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int& f(std::list<int>& x, int& y) {\\n\"\n              \"    for (int& m : x) {\\n\"\n              \"        if (m == y)\\n\"\n              \"            return m;\\n\"\n              \"    }\\n\"\n              \"    return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool from_string(int& t, const std::string& s) {\\n\"\n              \"    std::istringstream iss(s);\\n\"\n              \"    return !(iss >> t).fail();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9710\n        check(\"class a {\\n\"\n              \"    void operator()(int& i) const {\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"void f(int& i) {\\n\"\n              \"    a()(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class a {\\n\"\n              \"    void operator()(int& i) const {\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"void f(int& i) {\\n\"\n              \"    a x;\\n\"\n              \"    x(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class a {\\n\"\n              \"    void operator()(const int& i) const;\\n\"\n              \"};\\n\"\n              \"void f(int& i) {\\n\"\n              \"    a x;\\n\"\n              \"    x(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'i' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        //cast or assignment to a non-const reference should prevent the warning\n        check(\"struct T { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U  { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const T& z = x;\\n\" // Make sure we find all assignments\n              \"    T& y = x;\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U  { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = x\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U  { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U& y = x;\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U  { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    my<fancy>::type& y = x;\\n\" // we don't know if y is const or not\n              \"    y.mutate();\\n\"             // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U  { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = static_cast<const U&>(x);\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U  { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U& y = static_cast<U&>(x);\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = dynamic_cast<const U&>(x)\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = dynamic_cast<U const &>(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = dynamic_cast<U & const>(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U& y = dynamic_cast<U&>(x);\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = dynamic_cast<typename const U&>(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U& y = dynamic_cast<typename U&>(x);\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U* y = dynamic_cast<U*>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U * y = dynamic_cast<const U *>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        TODO_ASSERT_EQUALS(\"can be const\", errout_str(), \"\"); //Currently taking the address is treated as a non-const operation when it should depend on what we do with it\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U const * y = dynamic_cast<U const *>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        TODO_ASSERT_EQUALS(\"can be const\", errout_str(), \"\"); //Currently taking the address is treated as a non-const operation when it should depend on what we do with it\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U const * const * const * const y = dynamic_cast<const U const * const * const * const>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U const * const * const * const y = dynamic_cast<const U const * const * const * const>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        TODO_ASSERT_EQUALS(\"can be const\", errout_str(), \"\"); //Currently taking the address is treated as a non-const operation when it should depend on what we do with it\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U const * const *  * const y = dynamic_cast<const U const * const *  * const>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    my::fancy<typename type const *> const * const  * const y = dynamic_cast<my::fancy<typename type const *> const * const  * const>(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = (const U&)(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\",\n                      errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U& y = (U&)(x);\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    const U& y = (typename const U&)(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:2:11]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\",\n                      errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U& y = (typename U&)(x);\\n\"\n              \"    y.mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n        check(\"struct T : public U { void dostuff() const {}};\\n\"\n              \"void a(T& x) {\\n\"\n              \"    x.dostuff();\\n\"\n              \"    U* y = (U*)(&x);\\n\"\n              \"    y->mutate();\\n\" // to avoid warnings that y can be const\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        check(\"struct C { void f() const; };\\n\" // #9875 - crash\n              \"\\n\"\n              \"void foo(C& x) {\\n\"\n              \"   x.f();\\n\"\n              \"   foo( static_cast<U2>(0) );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Parameter 'x' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"class a {\\n\"\n              \"    void foo(const int& i) const;\\n\"\n              \"    void operator()(int& i) const;\\n\"\n              \"};\\n\"\n              \"void f(int& i) {\\n\"\n              \"    a()(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class a {\\n\"\n              \"    void operator()(const int& i) const;\\n\"\n              \"};\\n\"\n              \"void f(int& i) {\\n\"\n              \"    a()(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'i' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        // #9767\n        check(\"void fct1(MyClass& object) {\\n\"\n              \"   fct2([&](void){}, object);\\n\"\n              \"}\\n\"\n              \"bool fct2(std::function<void()> lambdaExpression, MyClass& object) {\\n\"\n              \"   object.modify();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9778\n        check(\"struct A {};\\n\"\n              \"struct B : A {};\\n\"\n              \"B& f(A& x) {\\n\"\n              \"    return static_cast<B&>(x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10002\n        check(\"using A = int*;\\n\"\n              \"void f(const A& x) {\\n\"\n              \"    ++(*x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10086\n        check(\"struct V {\\n\"\n              \"    V& get(typename std::vector<V>::size_type i) {\\n\"\n              \"        std::vector<V>& arr = v;\\n\"\n              \"        return arr[i];\\n\"\n              \"    }\\n\"\n              \"    std::vector<V> v;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void e();\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void ai(void);\\n\"\n              \"void j(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void l(void);\\n\"\n              \"void m(void);\\n\"\n              \"void n(void);\\n\"\n              \"void o(void);\\n\"\n              \"void q(void);\\n\"\n              \"void r(void);\\n\"\n              \"void t(void);\\n\"\n              \"void u(void);\\n\"\n              \"void v(void);\\n\"\n              \"void w(void);\\n\"\n              \"void z(void);\\n\"\n              \"void aj(void);\\n\"\n              \"void am(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void ao(wchar_t *d);\\n\"\n              \"void ah(void);\\n\"\n              \"void e(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void e(void);\\n\"\n              \"void g(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void k(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void k(void);\\n\"\n              \"void an(void);\\n\"\n              \"void k(void);\\n\"\n              \"void e(void);\\n\"\n              \"void g(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void an(void);\\n\"\n              \"void k(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void g(void);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void k(void);\\n\"\n              \"void k(void);\\n\"\n              \"void e(void);\\n\"\n              \"void g(void);\\n\"\n              \"void g(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void e(void);\\n\"\n              \"void k(void);\\n\"\n              \"void e(void);\\n\"\n              \"void ap(wchar_t *c, int d);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void aq(char *b, size_t d, char *c, int a);\\n\"\n              \"void ar(char *b, size_t d, char *c, va_list a);\\n\"\n              \"void k(void);\\n\"\n              \"void g(void);\\n\"\n              \"void g(void);\\n\"\n              \"void h(void);\\n\"\n              \"void ah(void);\\n\"\n              \"void an(void);\\n\"\n              \"void k(void);\\n\"\n              \"void k(void);\\n\"\n              \"void e(void);\\n\"\n              \"void g(void);\\n\"\n              \"void g(void);\\n\"\n              \"void as(std::string s);\\n\"\n              \"void at(std::ifstream &f);\\n\"\n              \"void au(std::istream &f);\\n\"\n              \"void av(std::string &aa, std::wstring &ab);\\n\"\n              \"void aw(bool b, double x, double y);\\n\"\n              \"void ax(int i);\\n\"\n              \"void ay(std::string c, std::wstring a);\\n\"\n              \"void az(const std::locale &ac);\\n\"\n              \"void an();\\n\"\n              \"void ba(std::ifstream &f);\\n\"\n              \"void bb(std::istream &f) {\\n\"\n              \"f.read(NULL, 0);\\n\"\n              \"}\\n\"\n              \"void h(void) {\\n\"\n              \"struct tm *tm = 0;\\n\"\n              \"(void)std::asctime(tm);\\n\"\n              \"(void)std::asctime(0);\\n\"\n              \"}\\n\"\n              \"void bc(size_t ae) {\\n\"\n              \"wchar_t *ad = 0, *af = 0;\\n\"\n              \"struct tm *ag = 0;\\n\"\n              \"(void)std::wcsftime(ad, ae, af, ag);\\n\"\n              \"(void)std::wcsftime(0, ae, 0, 0);\\n\"\n              \"}\\n\"\n              \"void k(void) {}\\n\"\n              \"void bd(void);\\n\"\n              \"void be(void);\\n\"\n              \"void bf(int b);\\n\"\n              \"void e(void);\\n\"\n              \"void e(void);\\n\"\n              \"void bg(wchar_t *p);\\n\"\n              \"void bh(const std::list<int> &ak, const std::list<int> &al);\\n\"\n              \"void ah();\\n\"\n              \"void an();\\n\"\n              \"void h();\");\n        ASSERT_EQUALS(\"[test.cpp:131:12]: (style) Variable 'tm' can be declared as pointer to const [constVariablePointer]\\n\"\n                      \"[test.cpp:136:19]: (style) Variable 'af' can be declared as pointer to const [constVariablePointer]\\n\"\n                      \"[test.cpp:137:12]: (style) Variable 'ag' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str());\n\n        check(\"class C\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit C(int&);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class D\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit D(int&);\\n\"\n              \"\\n\"\n              \"private:\\n\"\n              \"  C c;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"D::D(int& i)\\n\"\n              \"  : c(i)\\n\"\n              \"{\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit C(int&);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class D\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit D(int&) noexcept;\\n\"\n              \"\\n\"\n              \"private:\\n\"\n              \"  C c;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"D::D(int& i) noexcept\\n\"\n              \"  : c(i)\\n\"\n              \"{}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit C(const int&);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class D\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit D(int&);\\n\"\n              \"\\n\"\n              \"private:\\n\"\n              \"  C c;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"D::D(int& i)\\n\"\n              \"  : c(i)\\n\"\n              \"{\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:16]: (style) Parameter 'i' can be declared as reference to const\\n\", \"\", errout_str());\n\n        check(\"class C\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit C(int);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class D\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit D(int&);\\n\"\n              \"\\n\"\n              \"private:\\n\"\n              \"  C c;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"D::D(int& i)\\n\"\n              \"  : c(i)\\n\"\n              \"{\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:16]: (style) Parameter 'i' can be declared as reference to const\\n\", \"\", errout_str());\n\n        check(\"class C\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit C(int, int);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class D\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"  explicit D(int&);\\n\"\n              \"\\n\"\n              \"private:\\n\"\n              \"  C c;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"D::D(int& i)\\n\"\n              \"  : c(0, i)\\n\"\n              \"{\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:16]: (style) Parameter 'i' can be declared as reference to const\\n\", \"\", errout_str());\n\n        check(\"void f(std::map<int, std::vector<int>> &map) {\\n\" // #10266\n              \"  for (auto &[slave, panels] : map)\\n\"\n              \"    panels.erase(it);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { void f(); int i; };\\n\"\n              \"void call_f(S& s) { (s.*(&S::f))(); }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int a[1]; };\\n\"\n              \"void f(S& s) { int* p = s.a; *p = 0; }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo {\\n\" // #9910\n              \"    int* p{};\\n\"\n              \"    int* get() { return p; }\\n\"\n              \"    const int* get() const { return p; }\\n\"\n              \"};\\n\"\n              \"struct Bar {\\n\"\n              \"    int j{};\\n\"\n              \"    void f(Foo& foo) const { int* q = foo.get(); *q = j; }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #10679\n              \"    void g(long L, const C*& PC) const;\\n\"\n              \"    void g(long L, C*& PC);\\n\"\n              \"};\\n\"\n              \"void f(S& s) {\\n\"\n              \"    C* PC{};\\n\"\n              \"    s.g(0, PC);\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10785\n        check(\"template <class T, class C>\\n\"\n              \"struct d {\\n\"\n              \"    T& g(C& c, T C::*f) { return c.*f; }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::map<int, int>& m) {\\n\"\n              \"    std::cout << m[0] << std::endl;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<std::map<int, int>>& v) {\\n\" // #11607\n              \"    for (auto& m : v)\\n\"\n              \"        std::cout << m[0];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int i; };\\n\" // #11473\n              \"void f(std::vector<std::vector<S>>&m, int*& p) {\\n\"\n              \"    auto& a = m[0];\\n\"\n              \"    for (auto& s : a) {\\n\"\n              \"        p = &s.i;\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int& g(int* p, int& r) {\\n\" // #11625\n              \"    if (p)\\n\"\n              \"        return *p;\\n\"\n              \"    return r;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <typename T> void f(std::vector<T*>& d, const std::vector<T*>& s) {\\n\" // #11632\n              \"    for (const auto& e : s) {\\n\"\n              \"        T* newE = new T(*e);\\n\"\n              \"        d.push_back(newE);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11682\n        check(\"struct b {\\n\"\n              \"    void mutate();\\n\"\n              \"};\\n\"\n              \"struct c {\\n\"\n              \"    const b& get() const;\\n\"\n              \"    b get();\\n\"\n              \"};\\n\"\n              \"struct d {\\n\"\n              \"    void f(c& e) const {\\n\"\n              \"        e.get().mutate();\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct B { virtual void f() const {} };\\n\" // #11528\n              \"struct D : B {};\\n\"\n              \"void g(B* b) {\\n\"\n              \"    D* d = dynamic_cast<D*>(b);\\n\"\n              \"    if (d)\\n\"\n              \"        d->f();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:8]: (style) Variable 'd' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"void g(const int*);\\n\"\n              \"void f(const std::vector<int*>&v) {\\n\"\n              \"    for (int* i : v)\\n\"\n              \"        g(i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:15]: (style) Variable 'i' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\" // #11225\n              \"    A();\\n\"\n              \"    virtual ~A();\\n\"\n              \"};\\n\"\n              \"struct B : A {};\\n\"\n              \"void f(A* a) {\\n\"\n              \"    const B* b = dynamic_cast<const B*>(a);\\n\"\n              \"}\\n\"\n              \"void g(A* a) {\\n\"\n              \"    const B* b = (const B*)a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:10:18]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\"\n                      \"[test.cpp:6:11]: (style) Parameter 'a' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:9:11]: (style) Parameter 'a' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void g(int*);\\n\"\n              \"void f(std::vector<int>& v) {\\n\"\n              \"    g(v.data());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(const int*);\\n\"\n              \"void f(std::vector<int>& v) {\\n\"\n              \"    g(v.data());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"struct a {\\n\"\n              \"    template <class T>\\n\"\n              \"    void mutate();\\n\"\n              \"};\\n\"\n              \"struct b {};\\n\"\n              \"template <class T>\\n\"\n              \"void f(a& x) {\\n\"\n              \"    x.mutate<T>();\\n\"\n              \"}\\n\"\n              \"template <class T>\\n\"\n              \"void f(const b&)\\n\"\n              \"{}\\n\"\n              \"void g(a& c) { f<int>(c); }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    template <typename T>\\n\"\n              \"    T* g() {\\n\"\n              \"        return reinterpret_cast<T*>(m);\\n\"\n              \"    }\\n\"\n              \"    template <typename T>\\n\"\n              \"    const T* g() const {\\n\"\n              \"        return reinterpret_cast<const T*>(m);\\n\"\n              \"    }\\n\"\n              \"    char* m;\\n\"\n              \"};\\n\"\n              \"void f(S& s) {\\n\"\n              \"    const int* p = s.g<int>();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int x; };\\n\" // #11818\n              \"std::istream& f(std::istream& is, S& s) {\\n\"\n              \"    return is >> s.x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(std::string& s1, std::string& s2) {\\n\" // #12203\n              \"    return &s1 == &s2;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:21]: (style) Parameter 's1' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:1:38]: (style) Parameter 's2' can be declared as reference to const [constParameterReference]\\n\",\n                      errout_str());\n\n        check(\"void f(int& r) {\\n\" // #12214\n              \"    (void)(true);\\n\"\n              \"    if (r) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:13]: (style) Parameter 'r' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"struct S { void f(int&); };\\n\" // #12216\n              \"void g(S& s, int& r, void (S::* p2m)(int&)) {\\n\"\n              \"    (s.*p2m)(r);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    void f(int& r) { p = &r; }\\n\"\n              \"    int* p;\\n\"\n              \"};\\n\"\n              \"void g(std::vector<int>& v1, std::vector<int*>& v2) {\\n\"\n              \"    std::transform(v1.begin(), v1.end(), v2.begin(), [](auto& x) { return &x; });\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class T;\\n\" // #11869\n              \"class E {\\n\"\n              \"public:\\n\"\n              \"    class F {\\n\"\n              \"    public:\\n\"\n              \"        explicit F(const T* t);\\n\"\n              \"    };\\n\"\n              \"};\\n\"\n              \"void f(T& t) {\\n\"\n              \"    std::list<E::F> c(1, E::F(&t));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:11]: (style) Parameter 't' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"struct T;\\n\"\n              \"struct U {\\n\"\n              \"    struct V { explicit V(const T* p); };\\n\"\n              \"};\\n\"\n              \"void g(U::V v);\\n\"\n              \"void f(T& t) {\\n\"\n              \"    g(U::V(&t));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:11]: (style) Parameter 't' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"void f1(std::vector<int>& v) {\\n\" // #11207\n              \"    auto it = v.cbegin();\\n\"\n              \"    while (it != v.cend()) {\\n\"\n              \"        if (*it > 12) {}\\n\"\n              \"        ++it;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void f2(std::vector<int>& v) {\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    while (it != v.end()) {\\n\"\n              \"        if (*it > 12) {}\\n\"\n              \"        ++it;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:27]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:8:27]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\",\n                      errout_str());\n\n        check(\"void cb(const std::string&);\\n\" // #12349, #12350, #12351\n              \"void f(std::string& s) {\\n\"\n              \"    const std::string& str(s);\\n\"\n              \"    cb(str);\\n\"\n              \"}\\n\"\n              \"void g(std::string& s) {\\n\"\n              \"    const std::string& str{ s };\\n\"\n              \"    cb(str);\\n\"\n              \"}\\n\"\n              \"void h(std::string* s) {\\n\"\n              \"    const std::string& str(*s);\\n\"\n              \"    cb(str);\\n\"\n              \"}\\n\"\n              \"void k(std::string* s) {\\n\"\n              \"    const std::string& str = *s;\\n\"\n              \"    cb(str);\\n\"\n              \"}\\n\"\n              \"void m(std::string& s) {\\n\"\n              \"    const std::string str(s);\\n\"\n              \"    cb(str);\\n\"\n              \"}\\n\"\n              \"void n(std::string* s) {\\n\"\n              \"    const std::string& str(*s);\\n\"\n              \"    cb(str);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:21]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:6:21]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:18:21]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:10:21]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:14:21]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:22:21]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"    S(std::string& r);\\n\"\n              \"};\\n\"\n              \"void f(std::string& str) {\\n\"\n              \"    const S& s(str);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct C {\\n\" // #10052\n              \"    int& operator()(int);\\n\"\n              \"};\\n\"\n              \"void f(std::vector<C>& c) {\\n\"\n              \"    c[0](5) = 12;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int& t) {\\n\" // #11713\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:12]: (style) Parameter 't' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"void f(std::list<std::string>& v) {\\n\" // #12202\n              \"    v.remove_if([](std::string& s) {\\n\"\n              \"        return true;\\n\"\n              \"    });\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:33]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"struct S {\\n\" // #12762\n              \"    std::vector<int> m;\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void S::f() {\\n\"\n              \"    std::vector<int>& r = m;\\n\"\n              \"    g(r[0] * 2);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:23]: (style) Variable 'r' can be declared as reference to const [constVariableReference]\\n\", errout_str());\n\n        check(\"std::iostream& get();\\n\" // #12940\n              \"std::iostream& Fun() {\\n\"\n              \"    auto lam = []() -> std::iostream& {\\n\"\n              \"        std::iostream& ios = get();\\n\"\n              \"        return ios;\\n\"\n              \"    };\\n\"\n              \"    return lam();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int x[3]; };\\n\" // #13226\n              \"void g(int a, int* b);\\n\"\n              \"void f(int a, S& s) {\\n\"\n              \"    return g(a, s.x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { std::vector<int> v; };\\n\" // #13317\n              \"struct T { S s; };\\n\"\n              \"int f(S& s) {\\n\"\n              \"    for (std::vector<int>::const_iterator it = s.v.cbegin(); it != s.v.cend(); ++it) {}\\n\"\n              \"    return *s.v.cbegin();\\n\"\n              \"}\\n\"\n              \"int f(T& t) {\\n\"\n              \"    return *t.s.v.cbegin();\\n\"\n              \"}\\n\"\n              \"int f(std::vector<int>& v) {\\n\"\n              \"    return *v.cbegin();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:7:10]: (style) Parameter 't' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:10:25]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\",\n                      errout_str());\n\n        check(\"void push(V& v) { v.push_back({ .x = 1 }); }\"); // #14010\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void constParameterCallback() {\n        check(\"int callback(std::vector<int>& x) { return x[0]; }\\n\"\n              \"void f() { dostuff(callback); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:1:32]: (style) Parameter 'x' can be declared as reference to const. However it seems that 'callback' is a callback function, if 'x' is declared with const you might also need to cast function pointer(s). [constParameterCallback]\\n\", errout_str());\n\n        // #9906\n        check(\"class EventEngine : public IEventEngine {\\n\"\n              \"public:\\n\"\n              \"    EventEngine();\\n\"\n              \"\\n\"\n              \"private:\\n\"\n              \"    void signalEvent(ev::sig& signal, int revents);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"EventEngine::EventEngine() {\\n\"\n              \"    mSigWatcher.set<EventEngine, &EventEngine::signalEvent>(this);\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"void EventEngine::signalEvent(ev::sig& signal, int revents) {\\n\"\n              \"    switch (signal.signum) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:48] -> [test.cpp:13:40]: (style) Parameter 'signal' can be declared as reference to const. However it seems that 'signalEvent' is a callback function, if 'signal' is declared with const you might also need to cast function pointer(s). [constParameterCallback]\\n\", errout_str());\n\n        check(\"void f(int* p) {}\\n\" // 12843\n              \"void g(std::map<void(*)(int*), int>&m) {\\n\"\n              \"    m[&f] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:1:13]: (style) Parameter 'p' can be declared as pointer to const. \"\n                      \"However it seems that 'f' is a callback function, if 'p' is declared with const you might also need to cast function pointer(s). [constParameterCallback]\\n\",\n                      errout_str());\n\n        check(\"struct S { explicit S(std::function<void(std::string)>); };\\n\" // #13338\n              \"void cb(std::string s) {\\n\"\n              \"    (void)s.empty();\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    S s2{ cb };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:11] -> [test.cpp:2:21]: (performance) Function parameter 's' should be passed by const reference. However it seems that 'cb' is a callback function. [passedByValueCallback]\\n\", errout_str());\n    }\n\n    void constPointer() {\n        check(\"void foo(int *p) { return *p; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { x = *p; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { int &ref = *p; ref = 12; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int *p) { x = *p + 10; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { return p[10]; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { int &ref = p[0]; ref = 12; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int *p) { x[*p] = 12; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { if (p) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { if (p || x) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { if (p == 0) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { if (!p) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { if (*p > 123) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { return *p + 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(int *p) { return *p > 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(const int* c) { if (c == 0) {}; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct a { void b(); };\\n\"\n              \"struct c {\\n\"\n              \"    a* d;\\n\"\n              \"    a& g() { return *d; }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct a { void b(); };\\n\"\n              \"struct c { a* d; };\\n\"\n              \"void e(c);\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct V {\\n\"\n              \"    V& get(typename std::vector<V>::size_type i, std::vector<V>* arr) {\\n\"\n              \"        return arr->at(i);\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {};\\n\"\n              \"struct B : A {};\\n\"\n              \"B* f(A* x) {\\n\"\n              \"    return static_cast<B*>(x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::vector<int>* x) {\\n\"\n              \"    int& i = (*x)[0];\\n\"\n              \"    i++;\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int a; };\\n\"\n              \"A f(std::vector<A>* x) {\\n\"\n              \"    x->front().a = 1;\\n\"\n              \"    return x->front();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>* v) {\\n\"\n              \"    for(auto&& x:*v)\\n\"\n              \"        x = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int* x;\\n\"\n              \"    A(int* y) : x(y)\\n\"\n              \"    {}\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b, int* x, int* y) {\\n\"\n              \"  int* z = x;\\n\"\n              \"  int* w = b ? y : z;\\n\"\n              \"  *w = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b, int* x, int* y) {\\n\"\n              \"  int& z = *x;\\n\"\n              \"  int& w = b ? *y : z;\\n\"\n              \"  w = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class Base { virtual void dostuff(int *p) = 0; };\\n\" // #10397\n              \"class Derived: public Base { int x; void dostuff(int *p) override { x = *p; } };\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Data { char buf[128]; };\\n\" // #10483\n              \"void encrypt(Data& data) {\\n\"\n              \"    const char a[] = \\\"asfasd\\\";\\n\"\n              \"    memcpy(data.buf, &a, sizeof(a));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10547\n        check(\"void foo(std::istream &istr) {\\n\"\n              \"  unsigned char x[2];\\n\"\n              \"  istr >> x[0];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10744\n        check(\"S& f() {\\n\"\n              \"    static S* p = new S();\\n\"\n              \"    return *p;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10471\n        check(\"void f(std::array<int, 1> const& i) {\\n\"\n              \"    if (i[0] == 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10466\n        check(\"typedef void* HWND;\\n\"\n              \"void f(const std::vector<HWND>&v) {\\n\"\n              \"    for (const auto* h : v)\\n\"\n              \"        if (h) {}\\n\"\n              \"    for (const auto& h : v)\\n\"\n              \"        if (h) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:5:22]: (style) Variable 'h' can be declared as pointer to const [constVariableReference]\\n\",\n            errout_str());\n\n        check(\"void f(const std::vector<int*>& v) {\\n\"\n              \"    for (const auto& p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"    for (const auto* p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:22]: (style) Variable 'p' can be declared as pointer to const [constVariableReference]\\n\",\n            errout_str());\n\n        check(\"void f(std::vector<int*>& v) {\\n\"\n              \"    for (const auto& p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"    for (const auto* p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"    for (const int* const& p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"    for (const int* p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:27]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:2:22]: (style) Variable 'p' can be declared as pointer to const [constVariableReference]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<const int*>& v) {\\n\"\n              \"    for (const auto& p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"    for (const auto* p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:33]: (style) Parameter 'v' can be declared as reference to const [constParameterReference]\\n\", errout_str());\n\n        check(\"void f(const std::vector<const int*>& v) {\\n\"\n              \"    for (const auto& p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"    for (const auto* p : v)\\n\"\n              \"        if (p == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int* const p) {\\n\"\n              \"    if (p == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int*);\\n\"\n              \"void f(int* const* pp) {\\n\"\n              \"    int* p = pp[0];\\n\"\n              \"    g(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <typename T>\\n\"\n              \"struct S {\\n\"\n              \"    static bool f(const T& t) { return t != nullptr; }\\n\"\n              \"};\\n\"\n              \"S<int*> s;\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typedef void* HWND;\\n\" // #11084\n              \"void f(const HWND h) {\\n\"\n              \"    if (h == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"using HWND = void*;\\n\"\n              \"void f(const HWND h) {\\n\"\n              \"    if (h == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typedef int A;\\n\"\n              \"void f(A* x) {\\n\"\n              \"    if (x == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"using A = int;\\n\"\n              \"void f(A* x) {\\n\"\n              \"    if (x == nullptr) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"struct S { void v(); };\\n\" // #11095\n              \"void f(S* s) {\\n\"\n              \"    (s - 1)->v();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int*>& v) {\\n\" // #11085\n              \"    for (int* p : v) {\\n\"\n              \"        if (p) {}\\n\"\n              \"    }\\n\"\n              \"    for (auto* p : v) {\\n\"\n              \"        if (p) {}\\n\"\n              \"    }\\n\"\n              \"    v.clear();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\"\n                      \"[test.cpp:5:16]: (style) Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char a[1][1];\\n\"\n              \"    char* b[1];\\n\"\n              \"    b[0] = a[0];\\n\"\n              \"    **b = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"ptrdiff_t f(int *p0, int *p1) {\\n\" // #11148\n              \"    return p0 - p1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:18]: (style) Parameter 'p0' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:1:27]: (style) Parameter 'p1' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::array<int, 1> a{}, b{};\\n\"\n              \"    const std::array<int, 1>& r = a;\\n\"\n              \"    if (r == b) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {};\\n\" // #11599\n              \"void g(S);\\n\"\n              \"void h(const S&);\\n\"\n              \"void h(int, int, const S&);\\n\"\n              \"void i(S&);\\n\"\n              \"void j(const S*);\\n\"\n              \"void j(int, int, const S*);\\n\"\n              \"void f1(S* s) {\\n\"\n              \"    g(*s);\\n\"\n              \"}\\n\"\n              \"void f2(S* s) {\\n\"\n              \"    h(*s);\\n\"\n              \"}\\n\"\n              \"void f3(S* s) {\\n\"\n              \"    h(1, 2, *s);\\n\"\n              \"}\\n\"\n              \"void f4(S* s) {\\n\"\n              \"    i(*s);\\n\"\n              \"}\\n\"\n              \"void f5(S& s) {\\n\"\n              \"    j(&s);\\n\"\n              \"}\\n\"\n              \"void f6(S& s) {\\n\"\n              \"    j(1, 2, &s);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:20:12]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:23:12]: (style) Parameter 's' can be declared as reference to const [constParameterReference]\\n\"\n                      \"[test.cpp:8:12]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:11:12]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:14:12]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void g(int, const int*);\\n\"\n              \"void h(const int*);\\n\"\n              \"void f(int* p) {\\n\"\n              \"    g(1, p);\\n\"\n              \"    h(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(int, const int*);\\n\"\n              \"void f(int i, int* p) {\\n\"\n              \"    f(i, const_cast<const int*>(p));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int a; };\\n\"\n              \"void f(std::vector<S>& v, int b) {\\n\"\n              \"    size_t n = v.size();\\n\"\n              \"    for (size_t i = 0; i < n; i++) {\\n\"\n              \"        S& s = v[i];\\n\"\n              \"        if (!(b & s.a))\\n\"\n              \"            continue;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (style) Variable 's' can be declared as reference to const [constVariableReference]\\n\", errout_str()); // don't crash\n\n        check(\"void f(int& i) {\\n\"\n              \"    new (&i) int();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n\n        check(\"void f(int& i) {\\n\"\n              \"    int& r = i;\\n\"\n              \"    if (!&r) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Variable 'r' can be declared as reference to const [constVariableReference]\\n\", errout_str()); // don't crash\n\n        check(\"class C;\\n\" // #11646\n              \"void g(const C* const p);\\n\"\n              \"void f(C* c) {\\n\"\n              \"    g(c);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Parameter 'c' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"typedef void (*cb_t)(int*);\\n\" // #11674\n              \"void cb(int* p) {\\n\"\n              \"    if (*p) {}\\n\"\n              \"}\\n\"\n              \"void g(cb_t);\\n\"\n              \"void f() {\\n\"\n              \"    g(cb);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:7] -> [test.cpp:2:14]: (style) Parameter 'p' can be declared as pointer to const. \"\n                      \"However it seems that 'cb' is a callback function, if 'p' is declared with const you might also need to cast function pointer(s). [constParameterCallback]\\n\",\n                      errout_str());\n\n        check(\"typedef void (*cb_t)(int*);\\n\"\n              \"void cb(int* p) {\\n\"\n              \"    if (*p) {}\\n\"\n              \"}\\n\"\n              \"void g(cb_t);\\n\"\n              \"void f() {\\n\"\n              \"    g(::cb);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:9] -> [test.cpp:2:14]: (style) Parameter 'p' can be declared as pointer to const. \"\n                      \"However it seems that 'cb' is a callback function, if 'p' is declared with const you might also need to cast function pointer(s). [constParameterCallback]\\n\",\n                      errout_str());\n\n        check(\"void f1(std::vector<int>* p) {\\n\" // #11681\n              \"    if (p->empty()) {}\\n\" // warn\n              \"}\\n\"\n              \"void f2(std::vector<int>* p) {\\n\"\n              \"    p->resize(0);\\n\"\n              \"}\\n\"\n              \"struct S {\\n\"\n              \"    void h1() const;\\n\"\n              \"    void h2();\\n\"\n              \"    int i;\\n\"\n              \"};\\n\"\n              \"void k(int&);\\n\"\n              \"void g1(S* s) {\\n\"\n              \"    s->h1();\\n\" // warn\n              \"}\\n\"\n              \"void g1(S* s) {\\n\"\n              \"    s->h2();\\n\"\n              \"}\\n\"\n              \"void g1(S* s) {\\n\"\n              \"    if (s->i) {}\\n\" // warn\n              \"}\\n\"\n              \"void g2(S* s) {\\n\"\n              \"    s->i = 0;\\n\"\n              \"}\\n\"\n              \"void g3(S* s) {\\n\"\n              \"    k(s->i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:27]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:13:12]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:19:12]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\" // #11573\n              \"    const char* g() const {\\n\"\n              \"        return m;\\n\"\n              \"    }\\n\"\n              \"    const char* m;\\n\"\n              \"};\\n\"\n              \"struct T { std::vector<S*> v; };\\n\"\n              \"void f(T* t, const char* n) {\\n\"\n              \"    for (const auto* p : t->v)\\n\"\n              \"        if (strcmp(p->g(), n) == 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:11]: (style) Parameter 't' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(int*& p, int* q) {\\n\"\n              \"    p = q;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int a[1]; };\\n\"\n              \"void f(S* s) {\\n\"\n              \"    if (s->a[0]) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"size_t f(char* p) {\\n\" // #11842\n              \"    return strlen(p);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:16]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void f(int* p) {\\n\" // #11862\n              \"    long long j = *(p++);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:13]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(void *p, size_t nmemb, size_t size, int (*cmp)(const void *, const void *)) {\\n\"\n              \"    qsort(p, nmemb, size, cmp);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(bool *r, std::size_t *b) {\\n\" // #12129\n              \"    if (*r && *b >= 5) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:14]: (style) Parameter 'r' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:1:30]: (style) Parameter 'b' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(int i) {\\n\" // #12185\n              \"    void* p = &i;\\n\"\n              \"    std::cout << p << '\\\\n';\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str());\n\n        check(\"struct S { const T* t; };\\n\" // #12206\n              \"void f(S* s) {\\n\"\n              \"    if (s->t.i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(char *a1, char *a2) {\\n\" // #12252\n              \"    char* b = new char[strlen(a1) + strlen(a2) + 2];\\n\"\n              \"    sprintf(b, \\\"%s_%s\\\", a1, a2);\\n\"\n              \"    delete[] b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:14]: (style) Parameter 'a1' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:1:24]: (style) Parameter 'a2' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"int f(int* p) {\\n\" // #11713\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:12]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(int *src, int* dst) {\\n\" // #12518\n              \"    *dst++ = (int)*src++;\\n\"\n              \"    *dst++ = static_cast<int>(*src++);\\n\"\n              \"    *dst = (int)*src;\\n\"\n              \"}\\n\"\n              \"void g(int* dst) {\\n\"\n              \"    (int&)*dst = 5;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:13]: (style) Parameter 'src' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {};\\n\"\n              \"void f(T* t) {\\n\"\n              \"    S* s = (S*)t->p;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (style) C-style pointer casting [cstyleCast]\\n\"\n                      \"[test.cpp:3:8]: (style) Variable 's' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str()); // don't crash\n\n        check(\"struct S { int i; };\\n\" // #12205\n              \"void f(S* s) {\\n\"\n              \"    (void)s->i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void f(int* a, int* b, int i) {\\n\" // #13072\n              \"    a[b[i]] = 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:21]: (style) Parameter 'b' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"int f(int* a, int* b, int i) {\\n\" // #13085\n              \"    a[*(b + i)] = 0;\\n\"\n              \"    return *(b + i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (style) Parameter 'b' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S { int a; };\\n\" // #13286\n              \"void f(struct S* s) {\\n\"\n              \"    if ((--s)->a >= 0) {}\\n\"\n              \"}\\n\"\n              \"void g(struct S* s) {\\n\"\n              \"    --s;\\n\"\n              \"    if (s->a >= 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:5:18]: (style) Parameter 's' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n    }\n\n    void constArray() {\n        check(\"void f(std::array<int, 2>& a) {\\n\"\n              \"    if (a[0]) {}\\n\"\n              \"}\\n\"\n              \"void g(std::array<int, 2>& a) {\\n\"\n              \"    a.fill(0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:28]: (style) Parameter 'a' can be declared as const array [constParameterReference]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    static int i[1] = {};\\n\"\n              \"    return i[0];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Variable 'i' can be declared as const array [constVariable]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    static int i[] = { 0 };\\n\"\n              \"    int j = i[0] + 1;\\n\"\n              \"    return j;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Variable 'i' can be declared as const array [constVariable]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    const char *tmp;\\n\"\n              \"    char* a[] = { \\\"a\\\", \\\"aa\\\" };\\n\"\n              \"    static char* b[] = { \\\"b\\\", \\\"bb\\\" };\\n\"\n              \"    tmp = a[i];\\n\"\n              \"    printf(\\\"%s\\\", tmp);\\n\"\n              \"    tmp = b[i];\\n\"\n              \"    printf(\\\"%s\\\", tmp);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Variable 'a' can be declared as const array [constVariable]\\n\"\n                      \"[test.cpp:4:18]: (style) Variable 'b' can be declared as const array [constVariable]\\n\",\n                      errout_str());\n\n        check(\"int f(int i, int j) {\\n\" // #13069\n              \"    int a[3][4] = {\\n\"\n              \"        { 2,  2, -1, -1 },\\n\"\n              \"        { 2, -1,  2, -1 },\\n\"\n              \"        { 2, -1, -1,  2 },\\n\"\n              \"    };\\n\"\n              \"    return a[j][i];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Variable 'a' can be declared as const array [constVariable]\\n\",\n                      errout_str());\n\n        check(\"void f(int n, int v[42]) {\\n\" // #12796\n              \"    int j = 0;\\n\"\n              \"    for (int i = 0; i < n; ++i) {\\n\"\n              \"        j += 1;\\n\"\n              \"        if (j == 1) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:19]: (style) Parameter 'v' can be declared as const array [constParameter]\\n\",\n                      errout_str());\n    }\n\n    void switchRedundantAssignmentTest() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:11] -> [test.cpp:9:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        y = 2;\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:11] -> [test.cpp:11:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"    case 3:\\n\"\n              \"        if (x)\\n\"\n              \"        {\\n\"\n              \"            y = 3;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        y = 2;\\n\"\n              \"        if (z)\\n\"\n              \"            printf(\\\"%d\\\", y);\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int x = a;\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        x = 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"        break;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    while(xyz()) {\\n\"\n              \"        switch (x)\\n\"\n              \"        {\\n\"\n              \"        case 2:\\n\"\n              \"            y = 2;\\n\"\n              \"            continue;\\n\"\n              \"        case 3:\\n\"\n              \"            y = 3;\\n\"\n              \"        }\\n\"\n              \"        bar(y);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    while(xyz()) {\\n\"\n              \"        switch (x)\\n\"\n              \"        {\\n\"\n              \"        case 2:\\n\"\n              \"            y = 2;\\n\"\n              \"            throw e;\\n\"\n              \"        case 3:\\n\"\n              \"            y = 3;\\n\"\n              \"        }\\n\"\n              \"        bar(y);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"        printf(\\\"%d\\\", y);\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"        bar();\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:11] -> [test.cpp:10:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n\n        check(\"void bar() {}\\n\" // bar isn't noreturn\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"        bar();\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:11] -> [test.cpp:11:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"    char str[10];\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      strcpy(str, \\\"a'\\\");\\n\"\n              \"    case 3:\\n\"\n              \"      strcpy(str, \\\"b'\\\");\\n\"\n              \"    }\\n\"\n              \"}\", true, false, false);\n        TODO_ASSERT_EQUALS(\"[test.cpp:6] -> [test.cpp:8]: (style) Buffer 'str' is being written before its old content has been used. 'break;' missing?\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"    char str[10];\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      strncpy(str, \\\"a'\\\");\\n\"\n              \"    case 3:\\n\"\n              \"      strncpy(str, \\\"b'\\\");\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6] -> [test.cpp:8]: (style) Buffer 'str' is being written before its old content has been used. 'break;' missing?\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"    char str[10];\\n\"\n              \"    int z = 0;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      strcpy(str, \\\"a'\\\");\\n\"\n              \"      z++;\\n\"\n              \"    case 3:\\n\"\n              \"      strcpy(str, \\\"b'\\\");\\n\"\n              \"      z++;\\n\"\n              \"    }\\n\"\n              \"}\", true, false, false);\n        TODO_ASSERT_EQUALS(\"[test.cpp:7] -> [test.cpp:10]: (style) Buffer 'str' is being written before its old content has been used. 'break;' missing?\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"    char str[10];\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      strcpy(str, \\\"a'\\\");\\n\"\n              \"      break;\\n\"\n              \"    case 3:\\n\"\n              \"      strcpy(str, \\\"b'\\\");\\n\"\n              \"      break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a) {\\n\"\n              \"    char str[10];\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      strcpy(str, \\\"a'\\\");\\n\"\n              \"      printf(str);\\n\"\n              \"    case 3:\\n\"\n              \"      strcpy(str, \\\"b'\\\");\\n\"\n              \"    }\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #5158 \"segmentation fault (valid code)\"\n        check(\"typedef struct ct_data_s {\\n\"\n              \"    union {\\n\"\n              \"        char freq;\\n\"\n              \"    } fc;\\n\"\n              \"} ct_data;\\n\"\n              \"typedef struct internal_state {\\n\"\n              \"    struct ct_data_s dyn_ltree[10];\\n\"\n              \"} deflate_state;\\n\"\n              \"void f(deflate_state *s) {\\n\"\n              \"    s->dyn_ltree[0].fc.freq++;\\n\"\n              \"}\\n\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #6132 \"crash: daca: kvirc CheckOther::checkRedundantAssignment()\"\n        check(\"void HttpFileTransfer :: transferTerminated ( bool bSuccess ) {\\n\"\n              \"if ( m_szCompletionCallback . isNull ( ) ) {\\n\"\n              \"KVS_TRIGGER_EVENT ( KviEvent_OnHTTPGetTerminated , out ? out : ( g_pApp . activeConsole ( ) ) , & vParams )\\n\"\n              \"} else {\\n\"\n              \"KviKvsScript :: run ( m_szCompletionCallback , out ? out : ( g_pApp . activeConsole ( ) ) , & vParams ) ;\\n\"\n              \"}\\n\"\n              \"}\\n\", true, false, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int x;\\n\"\n              \"  switch (state) {\\n\"\n              \"  case 1: x = 3; goto a;\\n\"\n              \"  case 1: x = 6; goto a;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void switchRedundantOperationTest() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        ++y;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9] -> [test.cpp:9:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        ++y;\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9] -> [test.cpp:11:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        (void)y;\\n\"\n              \"    case 3:\\n\"\n              \"        ++y;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        ++y;\\n\"\n              \"    case 3:\\n\"\n              \"        ++y;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        --y;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9] -> [test.cpp:9:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        --y;\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9] -> [test.cpp:11:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        (void)y;\\n\"\n              \"    case 3:\\n\"\n              \"        --y;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        --y;\\n\"\n              \"    case 3:\\n\"\n              \"        --y;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y++;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10] -> [test.cpp:9:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        y++;\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:10] -> [test.cpp:11:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y++;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y++;\\n\"\n              \"    case 3:\\n\"\n              \"        y++;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y--;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10] -> [test.cpp:9:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        y--;\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:10] -> [test.cpp:11:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y--;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y--;\\n\"\n              \"    case 3:\\n\"\n              \"        y--;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y++;\\n\"\n              \"    case 3:\\n\"\n              \"        if (x)\\n\"\n              \"        {\\n\"\n              \"            y = 3;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"      {\\n\"\n              \"        y++;\\n\"\n              \"        if (y)\\n\"\n              \"            printf(\\\"%d\\\", y);\\n\"\n              \"      }\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int x = a;\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        x++;\\n\"\n              \"    case 3:\\n\"\n              \"        y++;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y++;\\n\"\n              \"        break;\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    while(xyz()) {\\n\"\n              \"        switch (x)\\n\"\n              \"        {\\n\"\n              \"        case 2:\\n\"\n              \"            y++;\\n\"\n              \"            continue;\\n\"\n              \"        case 3:\\n\"\n              \"            y = 3;\\n\"\n              \"        }\\n\"\n              \"        bar(y);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    while(xyz()) {\\n\"\n              \"        switch (x)\\n\"\n              \"        {\\n\"\n              \"        case 2:\\n\"\n              \"            y++;\\n\"\n              \"            throw e;\\n\"\n              \"        case 3:\\n\"\n              \"            y = 3;\\n\"\n              \"        }\\n\"\n              \"        bar(y);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y++;\\n\"\n              \"        printf(\\\"%d\\\", y);\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (x)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y++;\\n\"\n              \"        bar();\\n\"\n              \"    case 3:\\n\"\n              \"        y = 3;\\n\"\n              \"    }\\n\"\n              \"    bar(y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:10] -> [test.cpp:10:11]: (style) Variable 'y' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]\\n\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    bool ret = false;\\n\"\n              \"    switch (switchCond) {\\n\"\n              \"    case 1:\\n\"\n              \"        ret = true;\\n\"\n              \"        break;\\n\"\n              \"    case 31:\\n\"\n              \"        ret = true;\\n\"\n              \"        break;\\n\"\n              \"    case 54:\\n\"\n              \"        ret = true;\\n\"\n              \"        break;\\n\"\n              \"    };\\n\"\n              \"    ret = true;\\n\"\n              \"    return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13] -> [test.cpp:14:9]: (style) Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:8:13] -> [test.cpp:14:9]: (style) Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:11:13] -> [test.cpp:14:9]: (style) Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]\\n\",\n                      errout_str());\n    }\n\n    void switchRedundantBitwiseOperationTest() {\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 3;\\n\"\n              \"    case 3:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (style) Redundant bitwise operation on 'y' in 'switch' statement. 'break;' missing? [redundantBitwiseOperationInSwitch]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y = y | 3;\\n\"\n              \"    case 3:\\n\"\n              \"        y = y | 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (style) Redundant bitwise operation on 'y' in 'switch' statement. 'break;' missing? [redundantBitwiseOperationInSwitch]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 3;\\n\"\n              \"    default:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (style) Redundant bitwise operation on 'y' in 'switch' statement. 'break;' missing? [redundantBitwiseOperationInSwitch]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 3;\\n\"\n              \"    default:\\n\"\n              \"        if (z)\\n\"\n              \"            y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= z;\\n\"\n              \"        z++;\\n\"\n              \"    default:\\n\"\n              \"        y |= z;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 3;\\n\"\n              \"        bar(y);\\n\"\n              \"    case 3:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 3;\\n\"\n              \"        y = 4;\\n\"\n              \"    case 3:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:11] -> [test.cpp:8:11]: (style) Variable 'y' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y &= 3;\\n\"\n              \"    case 3:\\n\"\n              \"        y &= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (style) Redundant bitwise operation on 'y' in 'switch' statement. 'break;' missing? [redundantBitwiseOperationInSwitch]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    case 3:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y ^= 3;\\n\"\n              \"    case 3:\\n\"\n              \"        y ^= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y |= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y &= 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y &= 3;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"    int y = 1;\\n\"\n              \"    switch (a)\\n\"\n              \"    {\\n\"\n              \"    case 2:\\n\"\n              \"        y |= 2;\\n\"\n              \"    case 3:\\n\"\n              \"        y &= 2;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void unreachableCode() {\n        check(\"void foo(int a) {\\n\"\n              \"    while(1) {\\n\"\n              \"        if (a++ >= 100) {\\n\"\n              \"            break;\\n\"\n              \"            continue;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"int foo(int a) {\\n\"\n              \"    return 0;\\n\"\n              \"    return(a-1);\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"int foo(int a) {\\n\"\n              \"  A:\"\n              \"    return(0);\\n\"\n              \"    goto A;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <function name=\\\"exit\\\">\\n\"\n                                   \"    <noreturn>true</noreturn>\\n\"\n                                   \"    <arg nr=\\\"1\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        /*const*/ Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        check(\"void foo() {\\n\"\n              \"    exit(0);\\n\"\n              \"    break;\\n\"\n              \"}\", true, false, false, false, &settings);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"class NeonSession {\\n\"\n              \"    void exit();\\n\"\n              \"};\\n\"\n              \"void NeonSession::exit()\\n\"\n              \"{\\n\"\n              \"    SAL_INFO(\\\"ucb.ucp.webdav\\\", \\\"neon commands cannot be aborted\\\");\\n\"\n              \"}\", true, false, false, false, &settings);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void NeonSession::exit()\\n\"\n              \"{\\n\"\n              \"    SAL_INFO(\\\"ucb.ucp.webdav\\\", \\\"neon commands cannot be aborted\\\");\\n\"\n              \"}\", true, false, false, false, &settings);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() { xResAccess->exit(); }\", true, false, false, false, &settings);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"        switch(a) {\\n\"\n              \"          case 0:\\n\"\n              \"            printf(\\\"case 0\\\");\\n\"\n              \"            break;\\n\"\n              \"            break;\\n\"\n              \"          case 1:\\n\"\n              \"            c++;\\n\"\n              \"            break;\\n\"\n              \"         }\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:7:13]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"        switch(a) {\\n\"\n              \"          case 0:\\n\"\n              \"            printf(\\\"case 0\\\");\\n\"\n              \"            break;\\n\"\n              \"          case 1:\\n\"\n              \"            c++;\\n\"\n              \"            break;\\n\"\n              \"         }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"        while(true) {\\n\"\n              \"          if (a++ >= 100) {\\n\"\n              \"            break;\\n\"\n              \"            break;\\n\"\n              \"          }\\n\"\n              \"       }\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:6:13]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"        while(true) {\\n\"\n              \"          if (a++ >= 100) {\\n\"\n              \"            continue;\\n\"\n              \"            continue;\\n\"\n              \"          }\\n\"\n              \"          a+=2;\\n\"\n              \"       }\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:6:13]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"void foo(int a)\\n\"\n              \"{\\n\"\n              \"        while(true) {\\n\"\n              \"          if (a++ >= 100) {\\n\"\n              \"            continue;\\n\"\n              \"          }\\n\"\n              \"          a+=2;\\n\"\n              \"       }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    throw 0;\\n\"\n              \"    return 1;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    throw 0;\\n\"\n              \"    return;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    throw = 0;\\n\"\n              \"    return 1;\\n\"\n              \"}\", false, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    return 0;\\n\"\n              \"    return 1;\\n\"\n              \"}\", true, false, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    return 0;\\n\"\n              \"    foo();\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Statements following 'return' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"int foo(int unused) {\\n\"\n              \"    return 0;\\n\"\n              \"    (void)unused;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int unused1, int unused2) {\\n\"\n              \"    return 0;\\n\"\n              \"    (void)unused1;\\n\"\n              \"    (void)unused2;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int unused1, int unused2) {\\n\"\n              \"    return 0;\\n\"\n              \"    (void)unused1;\\n\"\n              \"    (void)unused2;\\n\"\n              \"    foo();\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (style) Statements following 'return' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    if(bar)\\n\"\n              \"        return 0;\\n\"\n              \"    return 124;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    while(bar) {\\n\"\n              \"        return 0;\\n\"\n              \"        return 0;\\n\"\n              \"        return 0;\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"    return 124;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    while(bar) {\\n\"\n              \"        return;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        // #5707\n        check(\"extern int i,j;\\n\"\n              \"int foo() {\\n\"\n              \"    switch(i) {\\n\"\n              \"        default: j=1; break;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"    j=2;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (style) Statements following 'return' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    return 0;\\n\"\n              \"  label:\\n\"\n              \"    throw 0;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:3:3]: (style) Label 'label' is not used. [unusedLabel]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    virtual void foo  (P & Val) throw ();\\n\"\n              \"    virtual void foo1 (P & Val) throw ();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    goto label;\\n\"\n              \"    while (true) {\\n\"\n              \"     bar();\\n\"\n              \"     label:\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // #3457\n\n        check(\"int foo() {\\n\"\n              \"    goto label;\\n\"\n              \"    do {\\n\"\n              \"     bar();\\n\"\n              \"     label:\\n\"\n              \"    } while (true);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // #3457\n\n        check(\"int foo() {\\n\"\n              \"    goto label;\\n\"\n              \"    for (;;) {\\n\"\n              \"     bar();\\n\"\n              \"     label:\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // #3457\n\n        // #3383. TODO: Use preprocessor\n        check(\"int foo() {\\n\"\n              \"\\n\" // #ifdef A\n              \"    return 0;\\n\"\n              \"\\n\" // #endif\n              \"    return 1;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"int foo() {\\n\"\n              \"\\n\" // #ifdef A\n              \"    return 0;\\n\"\n              \"\\n\" // #endif\n              \"    return 1;\\n\"\n              \"}\", true, true, false);\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (style, inconclusive) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\", errout_str());\n\n        // #4711 lambda functions\n        check(\"int f() {\\n\"\n              \"    return g([](int x){(void)x+1; return x;});\\n\"\n              \"}\",\n              true,\n              false,\n              false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4756\n        check(\"template <>\\n\"\n              \"inline uint16_t htobe(uint16_t value) {\\n\"\n              \"     return ( __extension__ ({\\n\"\n              \"         register unsigned short int __v, __x = (unsigned short int) (value);\\n\"\n              \"         if (__builtin_constant_p (__x))\\n\"\n              \"             __v = ((unsigned short int) ((((__x) >> 8) & 0xff) | (((__x) & 0xff) << 8)));\\n\"\n              \"         else\\n\"\n              \"             __asm__ (\\\"rorw $8, %w0\\\" : \\\"=r\\\" (__v) : \\\"0\\\" (__x) : \\\"cc\\\");\\n\"\n              \"         (void)__v;\\n\"\n              \"     }));\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6008\n        check(\"static std::function< int ( int, int ) > GetFunctor() {\\n\"\n              \"    return [](int a_, int b_) -> int {\\n\"\n              \"        int sum = a_ + b_;\\n\"\n              \"        return sum;\\n\"\n              \"    };\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5789\n        check(\"struct per_state_info {\\n\"\n              \"    uint64_t enter, exit;\\n\"\n              \"    uint64_t events;\\n\"\n              \"    per_state_info() : enter(0), exit(0), events(0) {}\\n\"\n              \"};\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6664\n        check(\"void foo() {\\n\"\n              \"    (beat < 100) ? (void)0 : exit(0);\\n\"\n              \"    bar();\\n\"\n              \"}\", true, false, false, false, &settings);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    (beat < 100) ? exit(0) : (void)0;\\n\"\n              \"    bar();\\n\"\n              \"}\", true, false, false, false, &settings);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8261\n        // TODO Do not throw AST validation exception\n        TODO_ASSERT_THROW(check(\"void foo() {\\n\"\n                                \"    (beat < 100) ? (void)0 : throw(0);\\n\"\n                                \"    bar();\\n\"\n                                \"}\", true, false, false, false, &settings), InternalError);\n        //ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo() {\\n\"\n              \"    exit(0);\\n\"\n              \"    return 1;\\n\" // <- clarify for tools that function does not continue..\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum : uint8_t { A, B } var = A;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define INB(x) __extension__ ({ u_int tmp = (x); inb(tmp); })\\n\" // #4739\n               \"static unsigned char cmos_hal_read(unsigned index) {\\n\"\n               \"    unsigned short port_0, port_1;\\n\"\n               \"    assert(!verify_cmos_byte_index(index));\\n\"\n               \"    if (index < 128) {\\n\"\n               \"      port_0 = 0x70;\\n\"\n               \"      port_1 = 0x71;\\n\"\n               \"    }\\n\"\n               \"    else {\\n\"\n               \"      port_0 = 0x72;\\n\"\n               \"      port_1 = 0x73;\\n\"\n               \"    }\\n\"\n               \"    OUTB(index, port_0);\\n\"\n               \"    return INB(port_1);\\n\"\n               \"}\\n\", dinit(CheckPOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"[[noreturn]] void n();\\n\"\n              \"void f() {\\n\"\n              \"    n();\\n\"\n              \"    g();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style) Statements following noreturn function 'n()' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    exit(1);\\n\"\n              \"    g();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Statements following noreturn function 'exit()' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    do {\\n\"\n              \"        break;\\n\"\n              \"        g();\\n\"\n              \"    } while (0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Statements following 'break' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #12244\n              \"    {\\n\"\n              \"        std::cout << \\\"x\\\";\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"    std::cout << \\\"y\\\";\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (style) Statements following 'return' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    {\\n\"\n              \"        std::cout << \\\"x\\\";\\n\"\n              \"        exit(1);\\n\"\n              \"    }\\n\"\n              \"    std::cout << \\\"y\\\";\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (style) Statements following noreturn function 'exit()' will never be executed. [unreachableCode]\\n\", errout_str());\n\n        check(\"int f() {\\n\" // #13475\n              \"    { return 0; };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\" // #13478\n              \"    int x = 0;\\n\"\n              \"    switch (i) {\\n\"\n              \"        { case 0: x = 5; break; }\\n\"\n              \"        { case 1: x = 7; break; }\\n\"\n              \"    }\\n\"\n              \"    return x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int c) {\\n\"\n              \"    switch (c) {\\n\"\n              \"    case '\\\\n':\\n\"\n              \"    { return 1; };\\n\"\n              \"    default:\\n\"\n              \"    { return c; };\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main(int argc, char *argv[]) {\\n\" // #11\n              \"    switch (argc) {\\n\"\n              \"        case 0: {\\n\"\n              \"            return 1;\\n\"\n              \"        }\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (style) Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]\\n\"\n                      \"[test.cpp:1:26]: (style) Parameter 'argv' can be declared as const array [constParameter]\\n\",\n                      errout_str());\n\n        check(\"int f(int i) {\\n\" // #13491\n              \"    switch (i) {\\n\"\n              \"    case 0:\\n\"\n              \"        return 0;\\n\"\n              \"        int j;\\n\"\n              \"    case 1:\\n\"\n              \"    case 2:\\n\"\n              \"        j = 5;\\n\"\n              \"        return j + i;\\n\"\n              \"    }\\n\"\n              \"    return 3;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\"\n              \"    switch (i) {\\n\"\n              \"    {\\n\"\n              \"    case 0:\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"    {\\n\"\n              \"        int j;\\n\"\n              \"    case 1:\\n\"\n              \"    case 2:\\n\"\n              \"        j = 5;\\n\"\n              \"        return j + i;\\n\"\n              \"    }\\n\"\n              \"    }\\n\"\n              \"    return 3;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\"\n              \"    switch (i) {\\n\"\n              \"    case 0:\\n\"\n              \"        return 0;\\n\"\n              \"        int a[1];\\n\"\n              \"    case 1:\\n\"\n              \"    case 2:\\n\"\n              \"        a[0] = 5;\\n\"\n              \"        return a[0] + i;\\n\"\n              \"    }\\n\"\n              \"    return 3;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\"\n              \"    switch (i) {\\n\"\n              \"    case 0:\\n\"\n              \"        return 0;\\n\"\n              \"        int j;\\n\"\n              \"        dostuff();\\n\"\n              \"    case 1:\\n\"\n              \"    case 2:\\n\"\n              \"        j = 5;\\n\"\n              \"        return j + i;\\n\"\n              \"    }\\n\"\n              \"    return 3;\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6:5]: (style) Statements following 'return' will never be executed. [unreachableCode]\\n\", \"\", errout_str());\n\n        check(\"int f() {\\n\" // #13472\n              \"    int var;\\n\"\n              \"    auto int ret();\\n\"\n              \"    int ret() {\\n\"\n              \"        return var;\\n\"\n              \"    }\\n\"\n              \"    var = 42;\\n\"\n              \"    return ret();\\n\"\n              \"}\\n\", /*cpp*/ false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #13516\n              \"    io_uring_for_each_cqe(&ring, head, cqe) {\\n\"\n              \"        if (cqe->res == -EOPNOTSUPP)\\n\"\n              \"            printf(\\\"error\\\");\\n\"\n              \"        goto ok;\\n\"\n              \"    }\\n\"\n              \"    usleep(10000);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantContinue() {\n        check(\"void f() {\\n\" // #11195\n              \"    for (int i = 0; i < 10; ++i) {\\n\"\n              \"        printf(\\\"i = %d\\\\n\\\", i);\\n\"\n              \"        continue;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) 'continue' is redundant since it is the last statement in a loop. [redundantContinue]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int i = 0;\"\n              \"    do {\\n\"\n              \"        ++i;\\n\"\n              \"        printf(\\\"i = %d\\\\n\\\", i);\\n\"\n              \"        continue;\\n\"\n              \"    } while (i < 10);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style) 'continue' is redundant since it is the last statement in a loop. [redundantContinue]\\n\", errout_str());\n\n        check(\"int f() {\\n\" // #13475\n              \"    { return 0; };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\" // #13478\n              \"    int x = 0;\\n\"\n              \"    switch (i) {\\n\"\n              \"        { case 0: x = 5; break; }\\n\"\n              \"        { case 1: x = 7; break; }\\n\"\n              \"    }\\n\"\n              \"    return x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int x, int y) {\\n\" // #13544\n              \"    switch (x) {\\n\"\n              \"    case 1: {\\n\"\n              \"        return y != 0;\\n\"\n              \"        int z = y + 5;\\n\"\n              \"        return z != 7;\\n\"\n              \"    }\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (style) Statements following 'return' will never be executed. [unreachableCode]\\n\", errout_str());\n    }\n\n\n    void suspiciousCase() {\n        check(\"void foo() {\\n\"\n              \"    switch(a) {\\n\"\n              \"        case A&&B:\\n\"\n              \"            foo();\\n\"\n              \"        case (A||B):\\n\"\n              \"            foo();\\n\"\n              \"        case A||B:\\n\"\n              \"            foo();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (warning, inconclusive) Found suspicious case label in switch(). Operator '&&' probably doesn't work as intended. [suspiciousCase]\\n\"\n                      \"[test.cpp:5:16]: (warning, inconclusive) Found suspicious case label in switch(). Operator '||' probably doesn't work as intended. [suspiciousCase]\\n\"\n                      \"[test.cpp:7:15]: (warning, inconclusive) Found suspicious case label in switch(). Operator '||' probably doesn't work as intended. [suspiciousCase]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    switch(a) {\\n\"\n              \"        case 1:\\n\"\n              \"            a=A&&B;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // TODO Do not throw AST validation exception\n        TODO_ASSERT_THROW(check(\"void foo() {\\n\"\n                                \"    switch(a) {\\n\"\n                                \"        case A&&B?B:A:\\n\"\n                                \"            foo();\\n\"\n                                \"    }\\n\"\n                                \"}\"), InternalError);\n        //ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void suspiciousEqualityComparison() {\n        check(\"void foo(int c) {\\n\"\n              \"    if (x) c == 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(const int* c) {\\n\"\n              \"    if (x) *c == 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n\n        check(\"void foo(int c) {\\n\"\n              \"    if (c == 1) {\\n\"\n              \"        c = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    c == 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:7]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    for (int i = 0; i == 10; i ++) {\\n\"\n              \"        a ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    for (i == 0; i < 10; i ++) {\\n\"\n              \"        c ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    for (i == 1; i < 10; i ++) {\\n\"\n              \"        c ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    for (i == 2; i < 10; i ++) {\\n\"\n              \"        c ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    for (int i = 0; i < 10; i == c) {\\n\"\n              \"        c ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:31]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    for (; running == 1;) {\\n\"\n              \"        c ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int c) {\\n\"\n              \"    printf(\\\"%i\\\", ({x==0;}));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int arg) {\\n\"\n              \"    printf(\\\"%i\\\", ({int x = do_something(); x == 0;}));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    printf(\\\"%i\\\", ({x == 0; x > 0 ? 10 : 20}));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (warning, inconclusive) Found suspicious equality comparison. Did you intend to assign a value instead? [constStatement]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    for (const Token* end = tok->link(); tok != end; tok = (tok == end) ? end : tok->next()) {\\n\"\n              \"        x++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    for (int i = (x == 0) ? 0 : 5; i < 10; i ++) {\\n\"\n              \"        x++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"    for (int i = 0; i < 10; i += (x == 5) ? 1 : 2) {\\n\"\n              \"        x++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void suspiciousUnaryPlusMinus() { // #8004\n        check(\"int g() { return 1; }\\n\"\n              \"void f() {\\n\"\n              \"    +g();\\n\"\n              \"    -g();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) Found suspicious operator '+', result is not used. [constStatement]\\n\"\n                      \"[test.cpp:4:5]: (warning, inconclusive) Found suspicious operator '-', result is not used. [constStatement]\\n\",\n                      errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    +i;\\n\"\n              \"    -i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '+', result is not used. [constStatement]\\n\"\n                      \"[test.cpp:3:5]: (warning, inconclusive) Found suspicious operator '-', result is not used. [constStatement]\\n\",\n                      errout_str());\n    }\n\n    void suspiciousFloatingPointCast() {\n        check(\"double f(double a, double b, float c) {\\n\"\n              \"    return a + (float)b + c;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Floating-point cast causes loss of precision. [suspiciousFloatingPointCast]\\n\", errout_str());\n\n        check(\"double f(double a, double b, float c) {\\n\"\n              \"    return a + static_cast<float>(b) + c;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:34]: (style) Floating-point cast causes loss of precision. [suspiciousFloatingPointCast]\\n\", errout_str());\n\n        check(\"long double f(long double a, long double b, float c) {\\n\"\n              \"    return a + (double)b + c;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Floating-point cast causes loss of precision. [suspiciousFloatingPointCast]\\n\", errout_str());\n\n        check(\"void g(int, double);\\n\"\n              \"void h(double);\\n\"\n              \"void f(double d) {\\n\"\n              \"    g(1, (float)d);\\n\"\n              \"    h((float)d);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style) Floating-point cast causes loss of precision. [suspiciousFloatingPointCast]\\n\"\n                      \"[test.cpp:5:7]: (style) Floating-point cast causes loss of precision. [suspiciousFloatingPointCast]\\n\",\n                      errout_str());\n    }\n\n    void selfAssignment() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int x = 1;\\n\"\n              \"    x = x;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int x = x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\", errout_str());\n\n        check(\"struct A { int b; };\\n\"\n              \"void foo(A* a1, A* a2) {\\n\"\n              \"    a1->b = a1->b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Redundant assignment of 'a1->b' to itself. [selfAssignment]\\n\", errout_str());\n\n        check(\"int x;\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    x = x = 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\", errout_str());\n\n        // #4073 (segmentation fault)\n        check(\"void Foo::myFunc( int a )\\n\"\n              \"{\\n\"\n              \"    if (a == 42)\\n\"\n              \"    a = a;\\n\"\n              \"}\");\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    int x = 1;\\n\"\n              \"    x = x + 1;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"        int *x = getx();\\n\"\n              \"        *x = x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    BAR *x = getx();\\n\"\n              \"    x = x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\", errout_str());\n\n        // #2502 - non-primitive type -> there might be some side effects\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    Fred fred; fred = fred;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    x = (x == 0);\"\n              \"    func(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    x = (x != 0);\"\n              \"    func(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #3001 - false positive\n        check(\"void foo(int x) {\\n\"\n              \"    x = x ? x : 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3800 - false negative when variable is extern\n        check(\"extern int i;\\n\"\n              \"void f() {\\n\"\n              \"    i = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (style) Redundant assignment of 'i' to itself. [selfAssignment]\\n\", errout_str());\n\n        // #4291 - id for variables accessed through 'this'\n        check(\"class Foo {\\n\"\n              \"    int var;\\n\"\n              \"    void func();\\n\"\n              \"};\\n\"\n              \"void Foo::func() {\\n\"\n              \"    this->var = var;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:15]: (style) Redundant assignment of 'this->var' to itself. [selfAssignment]\\n\", errout_str());\n\n        check(\"class Foo {\\n\"\n              \"    int var;\\n\"\n              \"    void func(int var);\\n\"\n              \"};\\n\"\n              \"void Foo::func(int var) {\\n\"\n              \"    this->var = var;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6406 - designated initializer doing bogus self assignment\n        check(\"struct callbacks {\\n\"\n              \"    void (*s)(void);\\n\"\n              \"};\\n\"\n              \"void something(void) {}\\n\"\n              \"void f() {\\n\"\n              \"    struct callbacks ops = { .s = ops.s };\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (style) Redundant assignment of 'something' to itself.\\n\", \"\", errout_str());\n\n        check(\"class V\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"    V()\\n\"\n              \"    {\\n\"\n              \"        x = y = z = 0.0;\\n\"\n              \"    }\\n\"\n              \"    V( double x, const double y_, const double &z_)\\n\"\n              \"    {\\n\"\n              \"        x = x; y = y; z = z;\\n\"\n              \"    }\\n\"\n              \"    double x, y, z;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:10:11]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\"\n                      \"[test.cpp:10:18]: (style) Redundant assignment of 'y' to itself. [selfAssignment]\\n\"\n                      \"[test.cpp:10:25]: (style) Redundant assignment of 'z' to itself. [selfAssignment]\\n\", errout_str());\n\n        check(\"void f(int i) { i = !!i; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int x = 1;\\n\"\n              \"    int &ref = x;\\n\"\n              \"    ref = x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Redundant assignment of 'ref' to itself. [selfAssignment]\\n\", errout_str());\n\n        check(\"class Foo {\\n\" // #9850\n              \"    int i{};\\n\"\n              \"    void modify();\\n\"\n              \"    void method() {\\n\"\n              \"        Foo copy = *this;\\n\"\n              \"        modify();\\n\"\n              \"        *this = copy;\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #11383\n              \"    void f() {\\n\"\n              \"        int x = 42;\"\n              \"        auto l2 = [i = i, x, y = 0]() { return i + x + y; };\\n\"\n              \"    }\\n\"\n              \"    int i;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #10337\n              \"    int b[2] = { 1, 2 };\\n\"\n              \"    int idx = 0;\\n\"\n              \"    int& i = b[idx];\\n\"\n              \"    idx++;\\n\"\n              \"    i = b[idx];\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int*);\\n\" // #12390\n              \"void f() {\\n\"\n              \"    int o = s.i;\\n\"\n              \"    g(&s.i);\\n\"\n              \"    s.i = o;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void trac1132() {\n        check(\"class Lock\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"    Lock(int i)\\n\"\n              \"    {\\n\"\n              \"        std::cout << \\\"Lock \\\" << i << std::endl;\\n\"\n              \"    }\\n\"\n              \"    ~Lock()\\n\"\n              \"    {\\n\"\n              \"        std::cout << \\\"~Lock\\\" << std::endl;\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    Lock(123);\\n\"\n              \"    std::cout << \\\"hello\\\" << std::endl;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:15:5]: (style) Instance of 'Lock' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n    }\n\n    void trac3693() {\n        check(\"struct A{\\n\"\n              \"  enum {\\n\"\n              \"    b = 300\\n\"\n              \"  };\\n\"\n              \"};\\n\"\n              \"const int DFLT_TIMEOUT = A::b % 1000000 ;\\n\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickFunction1() {\n        check(\"int main ( )\\n\"\n              \"{\\n\"\n              \"    CouldBeFunction ( 123 ) ;\\n\"\n              \"    return 0 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickFunction2() {\n        check(\"struct error {\\n\"\n              \"    error() {}\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"class parser {\\n\"\n              \"public:\\n\"\n              \"    void error() const {}\\n\"\n              \"\\n\"\n              \"    void foo() const {\\n\"\n              \"        error();\\n\"\n              \"        do_something();\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectPicksClass() {\n        check(\"class NotAFunction ;\\n\"\n              \"int function ( )\\n\"\n              \"{\\n\"\n              \"    NotAFunction ( 123 );\\n\"\n              \"    return 0 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style) Instance of 'NotAFunction' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n    }\n\n    void testMisusedScopeObjectPicksStruct() {\n        check(\"struct NotAClass;\\n\"\n              \"bool func ( )\\n\"\n              \"{\\n\"\n              \"    NotAClass ( 123 ) ;\\n\"\n              \"    return true ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style) Instance of 'NotAClass' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickIf() {\n        check(\"bool func( int a , int b , int c )\\n\"\n              \"{\\n\"\n              \"    if ( a > b ) return c == a ;\\n\"\n              \"    return b == a ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickConstructorDeclaration() {\n        check(\"class Something : public SomethingElse\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"~Something ( ) ;\\n\"\n              \"Something ( ) ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickFunctor() {\n        check(\"class IncrementFunctor\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"    void operator()(int &i)\\n\"\n              \"    {\\n\"\n              \"        ++i;\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    int a = 1;\\n\"\n              \"    IncrementFunctor()(a);\\n\"\n              \"    return a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickLocalClassConstructors() {\n        check(\"void f() {\\n\"\n              \"    class Foo {\\n\"\n              \"        Foo() { }\\n\"\n              \"        Foo(int a) { }\\n\"\n              \"        Foo(int a, int b) { }\\n\"\n              \"    };\\n\"\n              \"    Foo();\\n\"\n              \"    do_something();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (style) Instance of 'Foo' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickUsedObject() {\n        check(\"struct Foo {\\n\"\n              \"    void bar() {\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void fn() {\\n\"\n              \"    Foo().bar();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickPureC() {\n        // Ticket #2352\n        const char code[] = \"struct cb_watch_bool {\\n\"\n                            \"    int a;\\n\"\n                            \"};\\n\"\n                            \"\\n\"\n                            \"void f()\\n\"\n                            \"{\\n\"\n                            \"    cb_watch_bool();\\n\"\n                            \"    do_something();\\n\"\n                            \"}\\n\";\n\n        check(code, true);\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (style) Instance of 'cb_watch_bool' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n\n        check(code, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #2639\n        check(\"struct stat { int a; int b; };\\n\"\n              \"void stat(const char *fn, struct stat *);\\n\"\n              \"\\n\"\n              \"void foo() {\\n\"\n              \"    stat(\\\"file.txt\\\", &st);\\n\"\n              \"    do_something();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\",errout_str());\n\n        check(\"struct AMethodObject {\\n\" // #4336\n              \"    AMethodObject(double, double, double);\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"    static void A(double, double, double);\\n\"\n              \"};\\n\"\n              \"void S::A(double const a1, double const a2, double const a3) {\\n\"\n              \"    AMethodObject(a1, a2, a3);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\",errout_str());\n    }\n\n    void testMisusedScopeObjectDoesNotPickNestedClass() {\n        const char code[] = \"class ios_base {\\n\"\n                            \"public:\\n\"\n                            \"  class Init {\\n\"\n                            \"  public:\\n\"\n                            \"  };\\n\"\n                            \"};\\n\"\n                            \"class foo {\\n\"\n                            \"public:\\n\"\n                            \"  foo();\\n\"\n                            \"  void Init(int);\\n\"\n                            \"};\\n\"\n                            \"foo::foo() {\\n\"\n                            \"  Init(0);\\n\"\n                            \"  do_something();\\n\"\n                            \"}\\n\";\n\n        check(code, true);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectInConstructor() {\n        const char code[] = \"class Foo {\\n\"\n                            \"public:\\n\"\n                            \"  Foo(char x) {\\n\"\n                            \"    Foo(x, 0);\\n\"\n                            \"    do_something();\\n\"\n                            \"  }\\n\"\n                            \"  Foo(char x, int y) { }\\n\"\n                            \"};\\n\";\n        check(code, true);\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (style) Instance of 'Foo' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n    }\n\n    void testMisusedScopeObjectStandardType() {\n        check(\"int g();\\n\"\n              \"void f(int i) {\\n\"\n              \"    int();\\n\"\n              \"    int(0);\\n\"\n              \"    int( g() );\\n\" // don't warn\n              \"    int{};\\n\"\n              \"    int{ 0 };\\n\"\n              \"    int{ i };\\n\"\n              \"    int{ g() };\\n\" // don't warn\n              \"    g();\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Instance of 'int' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:4:5]: (style) Instance of 'int' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:6:5]: (style) Instance of 'int' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:7:5]: (style) Instance of 'int' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:8:5]: (style) Instance of 'int' object is destroyed immediately. [unusedScopedObject]\\n\",\n                      errout_str());\n\n        check(\"void f(int j) {\\n\"\n              \"    for (; bool(j); ) {}\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g() {\\n\"\n              \"    float (f);\\n\"\n              \"    float (*p);\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\"\n              \"    void();\\n\"\n              \"    return i;\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectNamespace() {\n        check(\"namespace M {\\n\" // #4779\n              \"    namespace N {\\n\"\n              \"        struct S {};\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"int f() {\\n\"\n              \"    M::N::S();\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"[test.cpp:7:11]: (style) Instance of 'M::N::S' object is destroyed immediately. [unusedScopedObject]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #10057\n              \"    std::string(\\\"abc\\\");\\n\"\n              \"    std::string{ \\\"abc\\\" };\\n\"\n              \"    std::pair<int, int>(1, 2);\\n\"\n              \"    (void)0;\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Instance of 'std::string' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:3:10]: (style) Instance of 'std::string' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:4:10]: (style) Instance of 'std::pair' object is destroyed immediately. [unusedScopedObject]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\" // #10083\n              \"    void f() {\\n\"\n              \"        std::lock_guard<std::mutex>(m);\\n\"\n              \"    }\\n\"\n              \"    void g() {\\n\"\n              \"        std::scoped_lock<std::mutex>(m);\\n\"\n              \"    }\\n\"\n              \"    void h() {\\n\"\n              \"        std::scoped_lock(m);\\n\"\n              \"    }\\n\"\n              \"    std::mutex m;\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) Instance of 'std::lock_guard' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:6:14]: (style) Instance of 'std::scoped_lock' object is destroyed immediately. [unusedScopedObject]\\n\"\n                      \"[test.cpp:9:14]: (style) Instance of 'std::scoped_lock' object is destroyed immediately. [unusedScopedObject]\\n\",\n                      errout_str());\n\n        check(\"struct S { int i; };\\n\"\n              \"namespace {\\n\"\n              \"    S s() { return ::S{42}; }\\n\"\n              \"}\\n\", true);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testMisusedScopeObjectAssignment() { // #11371\n        check(\"struct S;\\n\"\n              \"S f();\\n\"\n              \"S& g();\\n\"\n              \"S&& h();\\n\"\n              \"S* i();\\n\"\n              \"void t0() { f() = {}; }\\n\"\n              \"void t1() { g() = {}; }\\n\"\n              \"void t2() { h() = {}; }\\n\"\n              \"void t3() { *i() = {}; }\\n\", true);\n        ASSERT_EQUALS(\"[test.cpp:6:19]: (style) Instance of 'S' object is destroyed immediately, assignment has no effect. [unusedScopedObject]\\n\", errout_str());\n    }\n\n    void trac2084() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    struct sigaction sa;\\n\"\n              \"\\n\"\n              \"    { sigaction(SIGHUP, &sa, 0); };\\n\"\n              \"    { sigaction(SIGINT, &sa, 0); };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void trac2071() {\n        check(\"void f() {\\n\"\n              \"    struct AB {\\n\"\n              \"        AB(int a) { }\\n\"\n              \"    };\\n\"\n              \"\\n\"\n              \"    const AB ab[3] = { AB(0), AB(1), AB(2) };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyCalculation() {\n        check(\"int f(char c) {\\n\"\n              \"    return 10 * (c == 0) ? 1 : 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (style) Clarify calculation precedence for '*' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        check(\"void f(char c) {\\n\"\n              \"    printf(\\\"%i\\\", 10 * (c == 0) ? 1 : 2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:32]: (style) Clarify calculation precedence for '*' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    return (2*a)?b:c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char c) {\\n\"\n              \"    printf(\\\"%i\\\", a + b ? 1 : 2);\\n\"\n              \"}\",true,false,false);\n        ASSERT_EQUALS(\"[test.cpp:2:24]: (style) Clarify calculation precedence for '+' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::cout << x << y ? 2 : 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (style) Clarify calculation precedence for '<<' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int ab = a - b ? 2 : 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (style) Clarify calculation precedence for '-' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int ab = a | b ? 2 : 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (style) Clarify calculation precedence for '|' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        // ticket #195\n        check(\"int f(int x, int y) {\\n\"\n              \"    return x >> ! y ? 8 : 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:21]: (style) Clarify calculation precedence for '>>' and '?'. [clarifyCalculation]\\n\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"   return shift < sizeof(int64_t)*8 ? 1 : 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { a = *p ? 1 : 2; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { const char *p = x & 1 ? \\\"1\\\" : \\\"0\\\"; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() { x = a % b ? \\\"1\\\" : \\\"0\\\"; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { return x & 1 ? '1' : '0'; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { return x & 16 ? 1 : 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { return x % 16 ? 1 : 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"enum {X,Y}; void f(int x) { return x & Y ? 1 : 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void clarifyStatement() {\n        check(\"char* f(char* c) {\\n\"\n              \"    *c++;\\n\"\n              \"    return c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:7]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"char* f(char** c) {\\n\"\n              \"    *c[5]--;\\n\"\n              \"    return *c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:10]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"void f(Foo f) {\\n\"\n              \"    *f.a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:9]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"void f(Foo f) {\\n\"\n              \"    *f.a[5].v[3]++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:17]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"void f(Foo f) {\\n\"\n              \"    *f.a(1, 5).v[x + y]++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:24]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"char* f(char* c) {\\n\"\n              \"    (*c)++;\\n\"\n              \"    return c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(char* c) {\\n\"\n              \"    bar(*c++);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char*** f(char*** c) {\\n\"\n              \"    ***c++;\\n\"\n              \"    return c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:9]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"char** f(char*** c) {\\n\"\n              \"    **c[5]--;\\n\"\n              \"    return **c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '*', result is not used. [constStatement]\\n\"\n            \"[test.cpp:2:11]: (warning) In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]\\n\",\n            errout_str());\n\n        check(\"char*** f(char*** c) {\\n\"\n              \"    (***c)++;\\n\"\n              \"    return c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int*** p) {\\n\" // #10923\n              \"    delete[] **p;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void *f(char** c) {\\n\"\n              \"    bar(**c++);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void *f(char* p) {\\n\"\n              \"    for (p = path; *p++;) ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::array<std::array<double,3>,3> array;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<int*>& v) {\\n\" // #12088\n              \"    for (auto it = v.begin(); it != v.end(); delete *it++);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateBranch() {\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a)\\n\"\n              \"        b = 1;\\n\"\n              \"    else\\n\"\n              \"        b = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:2:5]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a) {\\n\"\n              \"        if (a == 1)\\n\"\n              \"            b = 2;\\n\"\n              \"        else\\n\"\n              \"            b = 2;\\n\"\n              \"    } else\\n\"\n              \"        b = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:3:9]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n\n        check(\"void f(int a, int &b) {\\n\"\n              \"    if (a == 1)\\n\"\n              \"        b = 1;\\n\"\n              \"    else {\\n\"\n              \"        if (a)\\n\"\n              \"            b = 2;\\n\"\n              \"        else\\n\"\n              \"            b = 2;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:9] -> [test.cpp:5:9]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n\n        check(\"int f(int signed, unsigned char value) {\\n\"\n              \"    int ret;\\n\"\n              \"    if (signed)\\n\"\n              \"        ret = (signed char)value;\\n\"  // cast must be kept so the simplifications and verification is skipped\n              \"    else\\n\"\n              \"        ret = (unsigned char)value;\\n\"\n              \"    return ret;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (b)\\n\"\n              \"        __asm__(\\\"mov ax, bx\\\");\\n\"\n              \"    else\\n\"\n              \"        __asm__(\\\"mov bx, bx\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // #3407\n\n        check(\"void f() {\\n\"\n              \"    if (b)\\n\"\n              \"        __asm__(\\\"mov ax, bx\\\");\\n\"\n              \"    else\\n\"\n              \"        __asm__(\\\"mov ax, bx\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:2:5]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n    }\n\n    void duplicateBranch1() {\n\n        // tests inspired by http://www.viva64.com/en/b/0149/ ( Comparison between PVS-Studio and cppcheck )\n        // Errors detected in Quake 3: Arena by PVS-Studio: Fragment 2\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  if (front < 0)\\n\"\n              \"    frac = front/(front-back);\\n\"\n              \"  else\\n\"\n              \"    frac = front/(front-back);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:3] -> [test.cpp:3:3]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  if (front < 0)\\n\"\n              \"  { frac = front/(front-back);}\\n\"\n              \"  else\\n\"\n              \"    frac = front/((front-back));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:3] -> [test.cpp:3:3]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n\n        // No message about empty branches (#5354)\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"  if (front < 0)\\n\"\n              \"  {}\\n\"\n              \"  else\\n\"\n              \"  {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateBranch2() {\n        checkP(\"#define DOSTUFF1 ;\\n\"\n               \"#define DOSTUFF2 ;\\n\"\n               \"void f(int x) {\\n\" // #4329\n               \"  if (x)\\n\"\n               \"    DOSTUFF1\\n\"\n               \"  else\\n\"\n               \"    DOSTUFF2\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateBranch3() {\n        check(\"void f(bool b, int i) {\\n\"\n              \"    int j = i;\\n\"\n              \"    if (b) {\\n\"\n              \"        x = i;\\n\"\n              \"    } else {\\n\"\n              \"        x = j;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:5:7] -> [test.cpp:3:5]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\"\n                      \"[test.cpp:2:9]: (style) The scope of the variable 'j' can be reduced. [variableScope]\\n\",\n                      errout_str());\n\n        check(\"void f(bool b, int i) {\\n\"\n              \"    int j = i;\\n\"\n              \"    i++;\\n\"\n              \"    if (b) {\\n\"\n              \"        x = i;\\n\"\n              \"    } else {\\n\"\n              \"        x = j;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateBranch4() {\n        check(\"void* f(bool b) {\\n\"\n              \"    if (b) {\\n\"\n              \"        return new A::Y(true);\\n\"\n              \"    } else {\\n\"\n              \"        return new A::Z(true);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateBranch5() {\n        check(\"void f(bool b) {\\n\"\n              \"    int j;\\n\"\n              \"    if (b) {\\n\"\n              \"        unsigned int i = 0;\\n\"\n              \"        j = i;\\n\"\n              \"    } else {\\n\"\n              \"        unsigned int i = 0;\\n\"\n              \"        j = i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:7] -> [test.cpp:3:5]: (style, inconclusive) Found duplicate branches for 'if' and 'else'. [duplicateBranch]\\n\", errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"    int j;\\n\"\n              \"    if (b) {\\n\"\n              \"        unsigned int i = 0;\\n\"\n              \"        j = i;\\n\"\n              \"    } else {\\n\"\n              \"        unsigned int i = 0;\\n\"\n              \"        j = 1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"    int j;\\n\"\n              \"    if (b) {\\n\"\n              \"        unsigned int i = 0;\\n\"\n              \"    } else {\\n\"\n              \"        int i = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"    int j;\\n\"\n              \"    if (b) {\\n\"\n              \"        unsigned int i = 0;\\n\"\n              \"        j = i;\\n\"\n              \"    } else {\\n\"\n              \"        int i = 0;\\n\"\n              \"        j = i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateBranch6() {\n        check(\"void f(bool b) {\\n\"\n              \"    if (b) {\\n\"\n              \"    } else {\\n\"\n              \"        int i = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"    if (b) {\\n\"\n              \"        int i = 0;\\n\"\n              \"    } else {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression1() {\n        check(\"void foo(int a) {\\n\"\n              \"    if (a == a) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void fun(int b) {\\n\"\n              \"    return  a && a ||\\n\"\n              \"            b == b &&\\n\"\n              \"            d > d &&\\n\"\n              \"            e < e &&\\n\"\n              \"            f ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\"\n                      \"[test.cpp:3:15]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\"\n                      \"[test.cpp:4:15]: (style) Same expression on both sides of '>'. [duplicateExpression]\\n\"\n                      \"[test.cpp:5:15]: (style) Same expression on both sides of '<'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    return a && a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    a = b && b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo(int b) {\\n\"\n              \"    f(a,b == b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo(int b) {\\n\"\n              \"    f(b == b, a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (x!=2 || x!=2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if ((a < b) && (b > a)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Same expression on both sides of '&&' because 'a<b' and 'b>a' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if ((a <= b) && (b >= a)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) Same expression on both sides of '&&' because 'a<=b' and 'b>=a' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (x!=2 || y!=3 || x!=2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (style) Same expression 'x!=2' found multiple times in chain of '||' operators. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (x!=2 && (x=y) && x!=2) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a && b || a && b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a && b || b && c) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a && b | b && c) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Same expression on both sides of '|'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if ((a + b) | (a + b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Same expression on both sides of '|'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if ((a | b) & (a | b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Same expression on both sides of '&'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if ((a | b) == (a | b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a1[a2[c & 0xff] & 0xff]) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void d(const char f, int o, int v)\\n\"\n              \"{\\n\"\n              \"     if (((f=='R') && (o == 1) && ((v < 2) || (v > 99))) ||\\n\"\n              \"         ((f=='R') && (o == 2) && ((v < 2) || (v > 99))) ||\\n\"\n              \"         ((f=='T') && (o == 2) && ((v < 200) || (v > 9999)))) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int x) { return x+x; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { while (x+=x) ; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a && b && b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a || b || b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a / 1000 / 1000) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(int i) {\\n\"\n              \"    return i/i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Same expression on both sides of '/'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (a << 1 << 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() { return !!y; }\"); // No FP\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // make sure there are not \"same expression\" fp when there are different casts\n        check(\"void f(long x) { if ((int32_t)x == (int64_t)x) {} }\",\n              true,  // filename\n              false, // inconclusive\n              false, // runSimpleChecks\n              false, // verbose\n              nullptr   // settings\n              );\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // make sure there are not \"same expression\" fp when there are different ({}) expressions\n        check(\"void f(long x) { if (({ 1+2; }) == ({3+4;})) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5535: Reference named like its type\n        check(\"void foo() { UMSConfig& UMSConfig = GetUMSConfiguration(); }\");\n        ASSERT_EQUALS(\"[test.cpp:1:25]: (style) Variable 'UMSConfig' can be declared as reference to const [constVariableReference]\\n\", errout_str());\n\n        // #3868 - false positive (same expression on both sides of |)\n        check(\"void f(int x) {\\n\"\n              \"    a = x ? A | B | C\\n\"\n              \"          : A | B;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const Bar &bar) {\\n\"\n              \"    bool a = bar.isSet() && bar->isSet();\\n\"\n              \"    bool b = bar.isSet() && bar.isSet();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:26]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\", errout_str());\n\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if ((b + a) | (a + b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) Same expression on both sides of '|' because 'b+a' and 'a+b' represent the same value. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo(const std::string& a, const std::string& b) {\\n\"\n              \"  return a.find(b+\\\"&\\\") || a.find(\\\"&\\\"+b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if ((b > a) | (a > b)) {}\\n\" // > is not commutative\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(double a, double b) {\\n\"\n              \"    if ((b + a) > (a + b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (style) The comparison 'b+a > a+b' is always false because 'b+a' and 'a+b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    if ((x == 1) && (x == 0x00000001))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) Same expression on both sides of '&&' because 'x==1' and 'x==0x00000001' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum { Four = 4 };\\n\"\n              \"    if (Four == 4) {}\"\n              \"}\", true, true, false);\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (style) The comparison 'Four == 4' is always true. [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum { Four = 4 };\\n\"\n              \"    static_assert(Four == 4, \\\"\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum { Four = 4 };\\n\"\n              \"    _Static_assert(Four == 4, \\\"\\\");\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum { Four = 4 };\\n\"\n              \"    static_assert(4 == Four, \\\"\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum { FourInEnumOne = 4 };\\n\"\n              \"    enum { FourInEnumTwo = 4 };\\n\"\n              \"    if (FourInEnumOne == FourInEnumTwo) {}\\n\"\n              \"}\", true, true, false);\n        ASSERT_EQUALS(\"[test.cpp:4:23]: (style) The comparison 'FourInEnumOne == FourInEnumTwo' is always true because 'FourInEnumOne' and 'FourInEnumTwo' represent the same value. [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    enum { FourInEnumOne = 4 };\\n\"\n              \"    enum { FourInEnumTwo = 4 };\\n\"\n              \"    static_assert(FourInEnumOne == FourInEnumTwo, \\\"\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    if (sizeof(a) == sizeof(a)) { }\\n\"\n              \"    if (sizeof(a) == sizeof(b)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        check(\"float bar(int) __attribute__((pure));\\n\"\n              \"char foo(int) __attribute__((pure));\\n\"\n              \"int test(int a, int b) {\\n\"\n              \"    if (bar(a) == bar(a)) { }\\n\"\n              \"    if (unknown(a) == unknown(a)) { }\\n\"\n              \"    if (foo(a) == foo(a)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:16]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n    }\n\n    void duplicateExpression2() { // check if float is NaN or Inf\n        check(\"int f(long double ldbl, double dbl, float flt) {\\n\" // ticket #2730\n              \"    if (ldbl != ldbl) have_nan = 1;\\n\"\n              \"    if (!(dbl == dbl)) have_nan = 1;\\n\"\n              \"    if (flt != flt) have_nan = 1;\\n\"\n              \"    return have_nan;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"float f(float x) { return x-x; }\"); // ticket #4485 (Inf)\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"float f(float x) { return (X double)x == (X double)x; }\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X { float f; };\\n\"\n              \"float f(struct X x) { return x.f == x.f; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X { int i; };\\n\"\n              \"int f(struct X x) { return x.i == x.i; }\");\n        ASSERT_EQUALS(\"[test.cpp:2:32]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        // #5284 - when type is unknown, assume it's float\n        check(\"int f() { return x==x; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression3() {\n        constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                   \"<def>\\n\"\n                                   \"  <function name=\\\"mystrcmp\\\">\\n\"\n                                   \"    <pure/>\\n\"\n                                   \"    <arg nr=\\\"1\\\"/>\\n\"\n                                   \"    <arg nr=\\\"2\\\"/>\\n\"\n                                   \"  </function>\\n\"\n                                   \"</def>\";\n        /*const*/ Settings settings = settingsBuilder().libraryxml(xmldata).build();\n\n        check(\"void foo() {\\n\"\n              \"    if (x() || x()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  void foo() const;\\n\"\n              \"  bool bar() const;\\n\"\n              \"};\\n\"\n              \"void A::foo() const {\\n\"\n              \"    if (bar() && bar()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:15]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  void foo();\\n\"\n              \"  bool bar();\\n\"\n              \"  bool bar() const;\\n\"\n              \"};\\n\"\n              \"void A::foo() {\\n\"\n              \"    if (bar() && bar()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class B {\\n\"\n              \"    void bar(int i);\\n\"\n              \"};\\n\"\n              \"class A {\\n\"\n              \"    void bar(int i) const;\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"    B b;\\n\"\n              \"    A a;\\n\"\n              \"    if (b.bar(1) && b.bar(1)) {}\\n\"\n              \"    if (a.bar(1) && a.bar(1)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:11:18]: (style) Same expression on both sides of '&&'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"class D { void strcmp(); };\\n\"\n              \"void foo() {\\n\"\n              \"    D d;\\n\"\n              \"    if (d.strcmp() && d.strcmp()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if ((mystrcmp(a, b) == 0) || (mystrcmp(a, b) == 0)) {}\\n\"\n              \"}\", true, false, true, false, &settings);\n        ASSERT_EQUALS(\"[test.cpp:2:31]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void GetValue() { return rand(); }\\n\"\n              \"void foo() {\\n\"\n              \"    if ((GetValue() == 0) || (GetValue() == 0)) { dostuff(); }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void __attribute__((const)) GetValue() { return X; }\\n\"\n              \"void foo() {\\n\"\n              \"    if ((GetValue() == 0) || (GetValue() == 0)) { dostuff(); }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:27]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void GetValue() __attribute__((const));\\n\"\n              \"void GetValue() { return X; }\\n\"\n              \"void foo() {\\n\"\n              \"    if ((GetValue() == 0) || (GetValue() == 0)) { dostuff(); }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:27]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (str == \\\"(\\\" || str == \\\"(\\\") {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (bar(a) && !strcmp(a, b) && bar(a) && !strcmp(a, b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5334\n        check(\"void f(C *src) {\\n\"\n              \"    if (x<A*>(src) || x<B*>(src))\\n\"\n              \"        a++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(A *src) {\\n\"\n              \"    if (dynamic_cast<B*>(src) || dynamic_cast<B*>(src)) {}\\n\"\n              \"}\\n\", true, false, false); // don't run simplifications\n        ASSERT_EQUALS(\"[test.cpp:2:31]: (style) Same expression on both sides of '||'. [duplicateExpression]\\n\", errout_str());\n\n        // #5819\n        check(\"Vector func(Vector vec1) {\\n\"\n              \"    return fabs(vec1 & vec1 & vec1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"Vector func(int vec1) {\\n\"\n              \"    return fabs(vec1 & vec1 & vec1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:22]: (style) Same expression on both sides of '&'. [duplicateExpression]\\n\"\n            \"[test.cpp:2:29]: (style) Same expression on both sides of '&'. [duplicateExpression]\\n\",   // duplicate\n            errout_str());\n\n    }\n\n    void duplicateExpression4() {\n        check(\"void foo() {\\n\"\n              \"    if (*a++ != b || *a++ != b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if (*a-- != b || *a-- != b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // assignment\n        check(\"void f() {\\n\"\n              \"  while (*(a+=2)==*(b+=2) && *(a+=2)==*(b+=2)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression5() {  // #3749 - macros with same values\n        check(\"void f() {\\n\"\n              \"    if ($a == $a) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define X 1\\n\"\n               \"#define Y 1\\n\"\n               \"void f() {\\n\"\n               \"    if (X == X) {}\\n\"\n               \"    if (X == Y) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Same expression on both sides of '=='. [duplicateExpression]\\n\", errout_str());\n\n        checkP(\"#define X 1\\n\"\n               \"#define Y X\\n\"\n               \"void f() {\\n\"\n               \"    if (X == Y) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression6() {  // #4639\n        check(\"float IsNan(float value) { return !(value == value); }\\n\"\n              \"double IsNan(double value) { return !(value == value); }\\n\"\n              \"long double IsNan(long double value) { return !(value == value); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression7() {\n        check(\"void f() {\\n\"\n              \"    const int i = sizeof(int);\\n\"\n              \"    if ( i != sizeof (int)){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25] -> [test.cpp:3:12]: (style) The comparison 'i != sizeof(int)' is always false because 'i' and 'sizeof(int)' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const int i = sizeof(int);\\n\"\n              \"    if ( sizeof (int) != i){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25] -> [test.cpp:3:23]: (style) The comparison 'sizeof(int) != i' is always false because 'sizeof(int)' and 'i' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int a = 1) { if ( a != 1){}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:12]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    int b = 1;\\n\"\n              \"    if ( a != b){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:13] -> [test.cpp:4:12]: (style) The comparison 'a != b' is always false because 'a' and 'b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    int b = a;\\n\"\n              \"    if ( a != b){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13] -> [test.cpp:4:12]: (style) The comparison 'a != b' is always false because 'a' and 'b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void use(int);\\n\"\n              \"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    int b = 1;\\n\"\n              \"    use(b);\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13] -> [test.cpp:6:12]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void use(int);\\n\"\n              \"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    use(a);\\n\"\n              \"    a = 2;\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void use(int);\\n\"\n              \"void f() {\\n\"\n              \"    int a = 2;\\n\"\n              \"    use(a);\\n\"\n              \"    a = 1;\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const int a = 1;\\n\"\n              \"void f() {\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:15] -> [test.cpp:3:12]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"int a = 1;\\n\"\n              \"    void f() {\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static const int a = 1;\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:26] -> [test.cpp:3:12]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int a = 1;\\n\"\n              \"    if ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    if ( a != 1){\\n\"\n              \"        a++;\\n\"\n              \"    }}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:12]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(int b) {\\n\"\n              \"    int a = 1;\\n\"\n              \"    while (b) {\\n\"\n              \"        if ( a != 1){}\\n\"\n              \"        a++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(bool a, bool b) {\\n\"\n              \"    const bool c = a;\\n\"\n              \"    return a && b && c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:3:19]: (style) Same expression 'a' found multiple times in chain of '&&' operators because 'a' and 'c' represent the same value. [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        // 6906\n        check(\"void f(const bool b) {\\n\"\n              \"   const bool b1 = !b;\\n\"\n              \"   if(!b && b1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:3:10]: (style) Same expression on both sides of '&&' because '!b' and 'b1' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        // 7284\n        check(\"void f(void) {\\n\"\n              \"   if (a || !!a) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Same expression on both sides of '||' because 'a' and '!!a' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        // 8205\n        check(\"void f(int x) {\\n\"\n              \"   int Diag = 0;\\n\"\n              \"   switch (x) {\\n\"\n              \"   case 12:\\n\"\n              \"       if (Diag==0) {}\\n\"\n              \"       break;\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15] -> [test.cpp:5:16]: (style) The comparison 'Diag == 0' is always true. [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #9744\n        check(\"void f(const std::vector<int>& ints) {\\n\"\n              \"    int i = 0;\\n\"\n              \"    for (int p = 0; i < ints.size(); ++i) {\\n\"\n              \"        if (p == 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:18] -> [test.cpp:4:15]: (style) The comparison 'p == 0' is always true. [knownConditionTrueFalse]\\n\", errout_str());\n\n        // #11820\n        check(\"unsigned f(unsigned x) {\\n\"\n              \"    return x - !!x;\\n\"\n              \"}\\n\"\n              \"unsigned g(unsigned x) {\\n\"\n              \"    return !!x - x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression8() {\n        check(\"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    int b = a;\\n\"\n              \"    a = 2;\\n\"\n              \"    if ( b != a){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int * a, int i) { int b = a[i]; a[i] = 2; if ( b != a[i]){}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int * a, int i) { int b = *a; *a = 2; if ( b != *a){}}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int f() const; };\\n\"\n              \"A g();\\n\"\n              \"void foo() {\\n\"\n              \"    for (A x = A();;) {\\n\"\n              \"        const int a = x.f();\\n\"\n              \"        x = g();\\n\"\n              \"        if (x.f() == a) break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i);\\n\"\n              \"struct A {\\n\"\n              \"    enum E { B, C };\\n\"\n              \"    bool f(E);\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"    A a;\\n\"\n              \"    const bool x = a.f(A::B);\\n\"\n              \"    const bool y = a.f(A::C);\\n\"\n              \"    if(!x && !y) return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    const bool x = a.f(A::B);\\n\"\n              \"    const bool y = a.f(A::C);\\n\"\n              \"    if (!x && !y) return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool * const b);\\n\"\n              \"void foo() {\\n\"\n              \"    bool x = true;\\n\"\n              \"    bool y = true;\\n\"\n              \"    f(&x);\\n\"\n              \"    if (!x && !y) return;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const int a = {};\\n\"\n              \"    if(a == 1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"volatile const int var = 42;\\n\"\n              \"void f() { if(var == 42) {} }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    struct b c;\\n\"\n              \"    c.a = &a;\\n\"\n              \"    g(&c);\\n\"\n              \"    if (a == 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression9() {\n        // #9320\n        check(\"void f() {\\n\"\n              \"  uint16_t x = 1000;\\n\"\n              \"  uint8_t y = x;\\n\"\n              \"  if (x != y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression10() {\n        // #9485\n        check(\"int f() {\\n\"\n              \"   const int a = 1;\\n\"\n              \"   const int b = a-1;\\n\"\n              \"   const int c = a+1;\\n\"\n              \"   return c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression11() {\n        check(\"class Fred {\\n\"\n              \"public:\\n\"\n              \"    double getScale() const { return m_range * m_zoom; }\\n\"\n              \"    void setZoom(double z) { m_zoom = z; }\\n\"\n              \"    void dostuff(int);\\n\"\n              \"private:\\n\"\n              \"    double m_zoom;\\n\"\n              \"    double m_range;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void Fred::dostuff(int x) {\\n\"\n              \"    if (x == 43) {\\n\"\n              \"        double old_scale = getScale();\\n\"\n              \"        setZoom(m_zoom + 1);\\n\"\n              \"        double scale_ratio = getScale() / old_scale;\\n\" // <- FP\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression12() { //#10026\n        check(\"int f(const std::vector<int> &buffer, const uint8_t index)\\n\"\n              \"{\\n\"\n              \"        int var = buffer[index - 1];\\n\"\n              \"        return buffer[index - 1] - var;\\n\"  // <<\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:25] -> [test.cpp:4:34]: (style) Same expression on both sides of '-' because 'buffer[index-1]' and 'var' represent the same value. [duplicateExpression]\\n\", errout_str());\n    }\n\n    void duplicateExpression13() { //#7899\n        check(\"void f() {\\n\"\n              \"    if (sizeof(long) == sizeof(long long)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression14() { //#9871\n        check(\"int f() {\\n\"\n              \"    int k = 7;\\n\"\n              \"    int* f = &k;\\n\"\n              \"    int* g = &k;\\n\"\n              \"    return (f + 4 != g + 4);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:14] -> [test.cpp:4:14] -> [test.cpp:5:19]: (style) The comparison 'f+4 != g+4' is always false because 'f+4' and 'g+4' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n    }\n\n    void duplicateExpression15() { //#10650\n        check(\"bool f() {\\n\"\n              \"    const int i = int(0);\\n\"\n              \"    return i == 0;\\n\"\n              \"}\\n\"\n              \"bool g() {\\n\"\n              \"    const int i = int{ 0 };\\n\"\n              \"    return i == 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:22] -> [test.cpp:3:14]: (style) The comparison 'i == 0' is always true. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:6:22] -> [test.cpp:7:14]: (style) The comparison 'i == 0' is always true. [knownConditionTrueFalse]\\n\",\n                      errout_str());\n    }\n\n    void duplicateExpression16() {\n        check(\"void f(const std::string& a) {\\n\" //#10569\n              \"    if ((a == \\\"x\\\") ||\\n\"\n              \"        (a == \\\"42\\\") ||\\n\"\n              \"        (a == \\\"y\\\") ||\\n\"\n              \"        (a == \\\"42\\\")) {}\\n\"\n              \"}\\n\"\n              \"void g(const std::string& a) {\\n\"\n              \"    if ((a == \\\"42\\\") ||\\n\"\n              \"        (a == \\\"x\\\") ||\\n\"\n              \"        (a == \\\"42\\\") ||\\n\"\n              \"        (a == \\\"y\\\")) {}\\n\"\n              \"}\\n\"\n              \"void h(const std::string& a) {\\n\"\n              \"    if ((a == \\\"42\\\") ||\\n\"\n              \"        (a == \\\"x\\\") ||\\n\"\n              \"        (a == \\\"y\\\") ||\\n\"\n              \"        (a == \\\"42\\\")) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:1:28] -> [test.cpp:4:20]: (style) Same expression 'a==\\\"42\\\"' found multiple times in chain of '||' operators. [duplicateExpression]\\n\"\n                      \"[test.cpp:7:28] -> [test.cpp:9:20]: (style) Same expression 'a==\\\"42\\\"' found multiple times in chain of '||' operators. [duplicateExpression]\\n\"\n                      \"[test.cpp:13:28] -> [test.cpp:16:20]: (style) Same expression 'a==\\\"42\\\"' found multiple times in chain of '||' operators. [duplicateExpression]\\n\",\n                      errout_str());\n\n        check(\"void f(const char* s) {\\n\" // #6371\n              \"    if (*s == '\\x0F') {\\n\"\n              \"        if (!s[1] || !s[2] || !s[1])\\n\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:28]: (style) Same expression '!s[1]' found multiple times in chain of '||' operators. [duplicateExpression]\\n\", errout_str());\n    }\n\n    void duplicateExpression17() {\n        check(\"enum { E0 };\\n\" // #12036\n              \"void f() {\\n\"\n              \"    if (0 > E0) {}\\n\"\n              \"    if (E0 > 0) {}\\n\"\n              \"    if (E0 == 0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) The comparison '0 > E0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:4:12]: (style) The comparison 'E0 > 0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:5:12]: (style) The comparison 'E0 == 0' is always true. [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\" // #12040, #12044\n              \"    static const int I = 0;\\n\"\n              \"    enum { E0 };\\n\"\n              \"    enum F { F0 };\\n\"\n              \"    void f() {\\n\"\n              \"        if (0 > I) {}\\n\"\n              \"        if (0 > S::I) {}\\n\"\n              \"        if (0 > E0) {}\\n\"\n              \"        if (0 > S::E0) {}\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"void g() {\\n\"\n              \"    if (0 > S::I) {}\\n\"\n              \"    if (0 > S::E0) {}\\n\"\n              \"    if (0 > S::F::F0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:26] -> [test.cpp:6:15]: (style) The comparison '0 > I' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:2:26] -> [test.cpp:7:15]: (style) The comparison '0 > S::I' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:8:15]: (style) The comparison '0 > E0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:9:15]: (style) The comparison '0 > S::E0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:2:26] -> [test.cpp:13:11]: (style) The comparison '0 > S::I' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:14:11]: (style) The comparison '0 > S::E0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:15:11]: (style) The comparison '0 > S::F::F0' is always false. [knownConditionTrueFalse]\\n\",\n                      errout_str());\n\n        check(\"template<typename T, typename U>\\n\" // #12122\n              \"void f() {\\n\"\n              \"    static_assert(std::is_same<T, U>::value || std::is_integral<T>::value);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpression18() {\n        checkP(\"#if defined(ABC)\\n\" // #13218\n               \"#define MACRO1 (0x1)\\n\"\n               \"#else\\n\"\n               \"#define MACRO1 (0)\\n\"\n               \"#endif\\n\"\n               \"#if defined(XYZ)\\n\"\n               \"#define MACRO2 (0x2)\\n\"\n               \"#else\\n\"\n               \"#define MACRO2 (0)\\n\"\n               \"#endif\\n\"\n               \"#define MACRO_ALL (MACRO1 | MACRO2)\\n\"\n               \"void f() {\\n\"\n               \"    if (MACRO_ALL == 0) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpressionLoop() {\n        check(\"void f() {\\n\"\n              \"    int a = 1;\\n\"\n              \"    while ( a != 1){}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:15]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() { int a = 1; while ( a != 1){ a++; }}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() { int a = 1; for ( int i=0; i < 3 && a != 1; i++){ a++; }}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int b) { int a = 1; while (b) { if ( a != 1){} b++; } a++; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    for(int i = 0; i < 10;) {\\n\"\n              \"        if( i != 0 ) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:17] -> [test.cpp:3:15]: (style) The comparison 'i != 0' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    for(int i = 0; i < 10;) {\\n\"\n              \"        if( i != 0 ) {}\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    for(int i = 0; i < 10;) {\\n\"\n              \"        if( i != 0 ) { i++; }\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    for(int i = 0; i < 10;) {\\n\"\n              \"        if( i != 0 ) { i++; }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int i = 0;\\n\"\n              \"    while(i < 10) {\\n\"\n              \"        if( i != 0 ) {}\\n\"\n              \"        i++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int b) {\\n\"\n              \"    while (b) {\\n\"\n              \"        int a = 1;\\n\"\n              \"        if ( a != 1){}\\n\"\n              \"        b++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17] -> [test.cpp:4:16]: (style) The comparison 'a != 1' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct T {\\n\" // #11083\n              \"    std::string m;\\n\"\n              \"    const std::string & str() const { return m; }\\n\"\n              \"    T* next();\\n\"\n              \"};\\n\"\n              \"void f(T* t) {\\n\"\n              \"    const std::string& s = t->str();\\n\"\n              \"    while (t && t->str() == s)\\n\"\n              \"        t = t->next();\\n\"\n              \"    do {\\n\"\n              \"        t = t->next();\\n\"\n              \"    } while (t && t->str() == s);\\n\"\n              \"    for (; t && t->str() == s; t = t->next());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string &out, const std::vector<std::string> &list) {\\n\" // #13669\n              \"    for (int i = 0, size = list.size(); i < size; i++) {\\n\"\n              \"        out += list[i];\\n\"\n              \"        if (size > 0 && i < (size - 2))\\n\"\n              \"            out += \\\",\\\";\\n\"\n              \"        else if (i == (size - 1))\\n\"\n              \"            out += \\\".\\\";\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpressionTernary() { // #6391\n        check(\"void f() {\\n\"\n              \"    return A ? x : x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) Same expression in both branches of ternary operator. [duplicateExpressionTernary]\\n\", errout_str());\n\n        check(\"int f(bool b, int a) {\\n\"\n              \"    const int c = a;\\n\"\n              \"    return b ? a : c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:19] -> [test.cpp:3:18]: (style) Same expression in both branches of ternary operator. [duplicateExpressionTernary]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    return A ? x : z;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(unsigned char c) {\\n\"\n              \"  x = y ? (signed char)c : (unsigned char)c;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string stringMerge(std::string const& x, std::string const& y) {\\n\" // #7938\n              \"    return ((x > y) ? (y + x) : (x + y));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6426\n        {\n            const char code[] = \"void foo(bool flag) {\\n\"\n                                \"  bar( (flag) ? ~0u : ~0ul);\\n\"\n                                \"}\";\n            /*const*/ Settings settings = _settings;\n            settings.platform.sizeof_int = 4;\n            settings.platform.int_bit = 32;\n\n            settings.platform.sizeof_long = 4;\n            settings.platform.long_bit = 32;\n            check(code, &settings);\n            ASSERT_EQUALS(\"[test.cpp:2:21]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n            settings.platform.sizeof_long = 8;\n            settings.platform.long_bit = 64;\n            check(code, &settings);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n    }\n\n    void duplicateValueTernary() {\n        check(\"void f() {\\n\"\n              \"    if( a ? (b ? false:false): false ) ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f1(int a) {return (a == 1) ? (int)1 : 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:41]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f2(int a) {return (a == 1) ? (int)1 : (int)1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:41]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f3(int a) {return (a == 1) ? 1 : (int)1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:36]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f4(int a) {return (a == 1) ? 1 : 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:36]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f5(int a) {return (a == (int)1) ? (int)1 : 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:46]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f6(int a) {return (a == (int)1) ? (int)1 : (int)1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:46]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f7(int a) {return (a == (int)1) ? 1 : (int)1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:41]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"int f8(int a) {return (a == (int)1) ? 1 : 1; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:41]: (style) Same value in both branches of ternary operator. [duplicateValueTernary]\\n\", errout_str());\n\n        check(\"struct Foo {\\n\"\n              \"  std::vector<int> bar{1,2,3};\\n\"\n              \"  std::vector<int> baz{4,5,6};\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"  Foo foo;\\n\"\n              \"  it = true ? foo.bar.begin() : foo.baz.begin();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b) {\\n\"\n              \"  std::vector<int> bar{1,2,3};\\n\"\n              \"  std::vector<int> baz{4,5,6};\\n\"\n              \"  std::vector<int> v = b ? bar : baz;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool q) {\\n\" // #9570\n              \"    static int a = 0;\\n\"\n              \"    static int b = 0;\\n\"\n              \"    int& x = q ? a : b;\\n\"\n              \"    ++x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int a, b; };\\n\" // #10107\n              \"S f(bool x, S s) {\\n\"\n              \"    (x) ? f.a = 42 : f.b = 42;\\n\"\n              \"    return f;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"float f(float x) {\\n\" // # 11368\n              \"    return (x >= 0.0) ? 0.0 : -0.0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpressionTemplate() {\n        check(\"template <int I> void f() {\\n\" // #6930\n              \"    if (I >= 0 && I < 3) {}\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"static auto a = f<0>();\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template<typename T>\\n\" // #7754\n              \"void f() {\\n\"\n              \"    if (std::is_same_v<T, char> || std::is_same_v<T, unsigned char>) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"typedef long long int64_t;\"\n              \"template<typename T>\\n\"\n              \"void f() {\\n\"\n              \"    if (std::is_same_v<T, long> || std::is_same_v<T, int64_t>) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define int32_t int\"\n               \"template<typename T>\\n\"\n               \"void f() {\\n\"\n               \"    if (std::is_same_v<T, int> || std::is_same_v<T, int32_t>) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define F(v) (v) != 0\\n\" // #12392\n               \"template<class T>\\n\"\n               \"void f() {\\n\"\n               \"    if (F(0)) {}\\n\"\n               \"}\\n\"\n               \"void g() {\\n\"\n               \"    f<int>();\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateExpressionCompareWithZero() {\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((x && b) || (x != 0 && b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) Same expression on both sides of '||' because 'x&&b' and 'x!=0&&b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((x != 0 && b) || (x && b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (style) Same expression on both sides of '||' because 'x!=0&&b' and 'x&&b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((x && b) || (b && x != 0)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) Same expression on both sides of '||' because 'x&&b' and 'b&&x!=0' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((!x && b) || (x == 0 && b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (style) Same expression on both sides of '||' because '!x&&b' and 'x==0&&b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((x == 0 && b) || (!x && b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (style) Same expression on both sides of '||' because 'x==0&&b' and '!x&&b' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((!x && b) || (b && x == 0)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (style) Same expression on both sides of '||' because '!x&&b' and 'b&&x==0' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int* getX() const;\\n\"\n              \"    bool getB() const;\\n\"\n              \"    void f() {\\n\"\n              \"        if ((getX() && getB()) || (getX() != 0 && getB())) {}\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:32]: (style) Same expression on both sides of '||' because 'getX()&&getB()' and 'getX()!=0&&getB()' represent the same value. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((x && b) || (x == 0 && b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int* x, bool b) {\\n\"\n              \"    if ((!x && b) || (x != 0 && b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void oppositeExpression() {\n        check(\"void f(bool a) { if(a && !a) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (style) Opposite expression on both sides of '&&'. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if(a != !a) {} }\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (style) Opposite expression on both sides of '!='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if( a == !(a) ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:24]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if( a != !(a) ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:24]: (style) Opposite expression on both sides of '!='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if( !(a) == a ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:27]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if( !(a) != a ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:27]: (style) Opposite expression on both sides of '!='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if( !(!a) == !(a) ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:28]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { if( !(!a) != !(a) ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:28]: (style) Opposite expression on both sides of '!='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f1(bool a) {\\n\"\n              \"    const bool b = a;\\n\"\n              \"    if( a == !(b) ) {}\\n\"\n              \"    if( b == !(a) ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:3:11]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\"\n                      \"[test.cpp:2:20] -> [test.cpp:4:11]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f2(const bool *a) {\\n\"\n              \"    const bool b = *a;\\n\"\n              \"    if( *a == !(b) ) {}\\n\"\n              \"    if( b == !(*a) ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:3:12]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\"\n                      \"[test.cpp:2:20] -> [test.cpp:4:11]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(bool a) { a = !a; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a) { if( a < -a ) {}}\");\n        ASSERT_EQUALS(\"[test.cpp:1:23]: (style) Opposite expression on both sides of '<'. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(int a) { a -= -a; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a) { a = a / (-a); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int i){ return !((i - 1) & i); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(unsigned i){ return (x > 0) && (x & (x-1)) == 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void A::f(bool a, bool c)\\n\"\n              \"{\\n\"\n              \"    const bool b = a;\\n\"\n              \"    if(c) { a = false; }\\n\"\n              \"    if(b && !a) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool c) {\\n\"\n              \"    const bool b = a;\\n\"\n              \"    if(c) { a = false; }\\n\"\n              \"    if(b && !a) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    bool x = a;\\n\"\n              \"    dostuff();\\n\"\n              \"    if (x && a) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  const bool b = g();\\n\"\n              \"  if (!b && g()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const bool *a) {\\n\"\n              \"    const bool b = a[42];\\n\"\n              \"    if( b == !(a[42]) ) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:21] -> [test.cpp:3:11]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(const bool *a) {\\n\"\n              \"    const bool b = a[42];\\n\"\n              \"    if( a[42] == !(b) ) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:21] -> [test.cpp:3:15]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(const bool *a) {\\n\"\n              \"    const bool b = *a;\\n\"\n              \"    if( b == !(*a) ) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:3:11]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(const bool *a) {\\n\"\n              \"    const bool b = *a;\\n\"\n              \"    if( *a == !(b) ) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:20] -> [test.cpp:3:12]: (style) Opposite expression on both sides of '=='. [oppositeExpression]\\n\", errout_str());\n\n        check(\"void f(uint16_t u) {\\n\" // #9342\n              \"    if (u != (u & -u))\\n\"\n              \"        return false;\\n\"\n              \"    if (u != (-u & u))\\n\"\n              \"        return false;\\n\"\n              \"    return true;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateVarExpression() {\n        check(\"int f() __attribute__((pure));\\n\"\n              \"int g() __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    int i = f();\\n\"\n              \"    int j = f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct Foo { int f() const; int g() const; };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct Foo { int f() const; int g() const; };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    Foo f2 = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:9] -> [test.cpp:5:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"int f() __attribute__((pure));\\n\"\n              \"int g() __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    int i = 1 + f();\\n\"\n              \"    int j = 1 + f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"int f() __attribute__((pure));\\n\"\n              \"int g() __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    int i = f() + 1;\\n\"\n              \"    int j = 1 + f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() __attribute__((pure));\\n\"\n              \"int g() __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    int x = f();\\n\"\n              \"    int i = x + 1;\\n\"\n              \"    int j = f() + 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() __attribute__((pure));\\n\"\n              \"int g() __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    int i = f() + f();\\n\"\n              \"    int j = f() + f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"int f(int) __attribute__((pure));\\n\"\n              \"int g(int) __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    int i = f(0);\\n\"\n              \"    int j = f(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"int f(int) __attribute__((pure));\\n\"\n              \"int g(int) __attribute__((pure));\\n\"\n              \"void test() {\\n\"\n              \"    const int x = 0;\\n\"\n              \"    int i = f(0);\\n\"\n              \"    int j = f(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(const int * p, const int * q) {\\n\"\n              \"    int i = *p;\\n\"\n              \"    int j = *p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct A { int x; int y; };\"\n              \"void test(A a) {\\n\"\n              \"    int i = a.x;\\n\"\n              \"    int j = a.x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:9]: (style) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"void test() {\\n\"\n              \"    int i = 0;\\n\"\n              \"    int j = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test() {\\n\"\n              \"    int i = -1;\\n\"\n              \"    int j = -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int);\\n\"\n              \"void test() {\\n\"\n              \"    int i = f(0);\\n\"\n              \"    int j = f(1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f();\\n\"\n              \"int g();\\n\"\n              \"void test() {\\n\"\n              \"    int i = f() || f();\\n\"\n              \"    int j = f() && f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo {};\\n\"\n              \"void test() {\\n\"\n              \"    Foo i = Foo();\\n\"\n              \"    Foo j = Foo();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo {};\\n\"\n              \"void test() {\\n\"\n              \"    Foo i = Foo{};\\n\"\n              \"    Foo j = Foo{};\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo { int f() const; float g() const; };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct Foo { int f(); int g(); };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test() {\\n\"\n              \"    int i = f();\\n\"\n              \"    int j = f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(int x) {\\n\"\n              \"    int i = ++x;\\n\"\n              \"    int j = ++x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(int x) {\\n\"\n              \"    int i = x++;\\n\"\n              \"    int j = x++;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(int x) {\\n\"\n              \"    int i = --x;\\n\"\n              \"    int j = --x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(int x) {\\n\"\n              \"    int i = x--;\\n\"\n              \"    int j = x--;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void test(int x) {\\n\"\n              \"    int i = x + 1;\\n\"\n              \"    int j = 1 + x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void duplicateVarExpressionUnique() {\n        check(\"struct SW { int first; };\\n\"\n              \"void foo(SW* x) {\\n\"\n              \"    int start = x->first;\\n\"\n              \"    int end   = x->first;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'start' and 'end'. [duplicateAssignExpression]\\n\"\n                      \"[test.cpp:2:14]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct SW { int first; };\\n\"\n              \"void foo(SW* x, int i, int j) {\\n\"\n              \"    int start = x->first;\\n\"\n              \"    int end   = x->first;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'start' and 'end'. [duplicateAssignExpression]\\n\"\n                      \"[test.cpp:2:14]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct Foo { int f() const; };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"void test(const int * p) {\\n\"\n              \"    int i = *p;\\n\"\n              \"    int j = *p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:2:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct Foo { int f() const; int g(int) const; };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct Foo { int f() const; };\\n\"\n              \"void test() {\\n\"\n              \"    Foo f = Foo{};\\n\"\n              \"    int i = f.f();\\n\"\n              \"    int j = f.f();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:4:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n    }\n\n    void duplicateVarExpressionAssign() {\n        check(\"struct A { int x; int y; };\"\n              \"void use(int);\\n\"\n              \"void test(A a) {\\n\"\n              \"    int i = a.x;\\n\"\n              \"    int j = a.x;\\n\"\n              \"    use(i);\\n\"\n              \"    i = j;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct A { int x; int y; };\"\n              \"void use(int);\\n\"\n              \"void test(A a) {\\n\"\n              \"    int i = a.x;\\n\"\n              \"    int j = a.x;\\n\"\n              \"    use(j);\\n\"\n              \"    j = i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\", errout_str());\n\n        check(\"struct A { int x; int y; };\"\n              \"void use(int);\\n\"\n              \"void test(A a) {\\n\"\n              \"    int i = a.x;\\n\"\n              \"    int j = a.x;\\n\"\n              \"    use(j);\\n\"\n              \"    if (i == j) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\"\n            \"[test.cpp:3:14] -> [test.cpp:4:14] -> [test.cpp:6:11]: (style) The comparison 'i == j' is always true because 'i' and 'j' represent the same value. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"struct A { int x; int y; };\"\n              \"void use(int);\\n\"\n              \"void test(A a) {\\n\"\n              \"    int i = a.x;\\n\"\n              \"    int j = a.x;\\n\"\n              \"    use(j);\\n\"\n              \"    if (i == a.x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\"\n            \"[test.cpp:3:14] -> [test.cpp:6:11]: (style) The comparison 'i == a.x' is always true because 'i' and 'a.x' represent the same value. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"struct A { int x; int y; };\"\n              \"void use(int);\\n\"\n              \"void test(A a) {\\n\"\n              \"    int i = a.x;\\n\"\n              \"    int j = a.x;\\n\"\n              \"    use(i);\\n\"\n              \"    if (j == a.x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:9] -> [test.cpp:3:9]: (style, inconclusive) Same expression used in consecutive assignments of 'i' and 'j'. [duplicateAssignExpression]\\n\"\n            \"[test.cpp:4:14] -> [test.cpp:6:11]: (style) The comparison 'j == a.x' is always true because 'j' and 'a.x' represent the same value. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        // Issue #8612\n        check(\"struct P\\n\"\n              \"{\\n\"\n              \"    void func();\\n\"\n              \"    bool operator==(const P&) const;\\n\"\n              \"};\\n\"\n              \"struct X\\n\"\n              \"{\\n\"\n              \"    P first;\\n\"\n              \"    P second;\\n\"\n              \"};\\n\"\n              \"bool bar();\\n\"\n              \"void baz(const P&);\\n\"\n              \"void foo(const X& x)\\n\"\n              \"{\\n\"\n              \"    P current = x.first;\\n\"\n              \"    P previous = x.first;\\n\"\n              \"    while (true)\\n\"\n              \"    {\\n\"\n              \"        baz(current);\\n\"\n              \"        if (bar() && previous == current)\\n\"\n              \"        {\\n\"\n              \"            current.func();\\n\"\n              \"        }\\n\"\n              \"        previous = current;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:16:7] -> [test.cpp:15:7]: (style, inconclusive) Same expression used in consecutive assignments of 'current' and 'previous'. [duplicateAssignExpression]\\n\", errout_str());\n    }\n\n    void duplicateVarExpressionCrash() {\n        // Issue #8624\n        check(\"struct  X {\\n\"\n              \"    X();\\n\"\n              \"    int f() const;\\n\"\n              \"};\\n\"\n              \"void run() {\\n\"\n              \"        X x;\\n\"\n              \"        int a = x.f();\\n\"\n              \"        int b = x.f();\\n\"\n              \"        (void)a;\\n\"\n              \"        (void)b;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:13] -> [test.cpp:7:13]: (style, inconclusive) Same expression used in consecutive assignments of 'a' and 'b'. [duplicateAssignExpression]\\n\", errout_str());\n\n        // Issue #8712\n        check(\"void f() {\\n\"\n              \"  unsigned char d;\\n\"\n              \"  d = d % 5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <typename T>\\n\"\n              \"T f() {\\n\"\n              \"  T x = T();\\n\"\n              \"}\\n\"\n              \"int &a = f<int&>();\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Issue #8713\n        check(\"class A {\\n\"\n              \"  int64_t B = 32768;\\n\"\n              \"  P<uint8_t> m = MakeP<uint8_t>(B);\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"  uint32_t a = 42;\\n\"\n              \"  uint32_t b = uint32_t(A ::B / 1024);\\n\"\n              \"  int32_t c = int32_t(a / b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Issue #8709\n        check(\"a b;\\n\"\n              \"void c() {\\n\"\n              \"  switch (d) { case b:; }\\n\"\n              \"  double e(b);\\n\"\n              \"  if(e <= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10718\n        // Should probably not be inconclusive\n        check(\"struct a {\\n\"\n              \"  int b() const;\\n\"\n              \"  auto c() -> decltype(0) {\\n\"\n              \"    a d;\\n\"\n              \"    int e = d.b(), f = d.b();\\n\"\n              \"    return e + f;\\n\"\n              \"  }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:20] -> [test.cpp:5:9]: (style, inconclusive) Same expression used in consecutive assignments of 'e' and 'f'. [duplicateAssignExpression]\\n\", errout_str());\n    }\n\n    void multiConditionSameExpression() {\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  if (val < 0) continue;\\n\"\n              \"  if ((val > 0)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:11]: (style) The comparison 'val < 0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:2:13] -> [test.cpp:4:12]: (style) The comparison 'val > 0' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  int *p = &val;n\"\n              \"  val = 1;\\n\"\n              \"  if (*p < 0) continue;\\n\"\n              \"  if ((*p > 0)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:8]: (style) Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  int *p = &val;\\n\"\n              \"  if (*p < 0) continue;\\n\"\n              \"  if ((*p > 0)) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2] -> [test.cpp:3]: (style) The comparison '*p < 0' is always false.\\n\"\n                           \"[test.cpp:2] -> [test.cpp:4]: (style) The comparison '*p > 0' is always false.\\n\",\n                           \"[test.cpp:3:8]: (style) Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\",\n                           errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  if (val < 0) {\\n\"\n              \"    if ((val > 0)) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:11]: (style) The comparison 'val < 0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:2:13] -> [test.cpp:4:14]: (style) The comparison 'val > 0' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int val = 0;\\n\"\n              \"  if (val < 0) {\\n\"\n              \"    if ((val < 0)) {}\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13] -> [test.cpp:3:11]: (style) The comparison 'val < 0' is always false. [knownConditionTrueFalse]\\n\"\n                      \"[test.cpp:2:13] -> [test.cpp:4:14]: (style) The comparison 'val < 0' is always false. [knownConditionTrueFalse]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int activate = 0;\\n\"\n              \"  int foo = 0;\\n\"\n              \"  if (activate) {}\\n\"\n              \"  else if (foo) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkSignOfUnsignedVariable() {\n        check(\"void foo() {\\n\"\n              \"  for(unsigned char i = 10; i >= 0; i--) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:31]: (style) Unsigned expression 'i' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(bool b) {\\n\"\n              \"  for(unsigned int i = 10; b || i >= 0; i--) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:35]: (style) Unsigned expression 'i' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        {\n            const char code[] = \"void foo(unsigned int x) {\\n\"\n                                \"  if (x < 0) {}\\n\"\n                                \"}\";\n            check(code, true, false, true, false);\n            ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n            check(code, true, false, true, true);\n            ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n        }\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (x < 0u) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"  if (x < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            const char code[] = \"void foo(unsigned x) {\\n\"\n                                \"  int y = 0;\\n\"\n                                \"  if (x < y) {}\\n\"\n                                \"}\";\n            check(code, true, false, true, false);\n            ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n            check(code, true, false, true, true);\n            ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n        }\n        check(\"void foo(unsigned x) {\\n\"\n              \"  int y = 0;\\n\"\n              \"  if (b)\\n\"\n              \"    y = 1;\\n\"\n              \"  if (x < y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (0 > x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (0UL > x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"  if (0 > x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (x >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(unsigned int x, unsigned y) {\\n\"\n              \"  if (x - y >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Unsigned expression 'x-y' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (x >= 0ull) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"  if (x >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (0 <= x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(unsigned int x) {\\n\"\n              \"  if (0ll <= x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(int x) {\\n\"\n              \"  if (0 <= x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (x < 0 && y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (x < 0 && y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (0 > x && y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (0 > x && y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (x >= 0 && y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (x >= 0 && y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (y && x < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (y && x < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (y && 0 > x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (y && 0 > x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (y && x >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (y && x >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (x < 0 || y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (x < 0 || y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (0 > x || y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (0 > x || y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(unsigned int x, bool y) {\\n\"\n              \"  if (x >= 0 || y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Unsigned expression 'x' can't be negative so it is unnecessary to test it. [unsignedPositive]\\n\", errout_str());\n\n        check(\"void foo(int x, bool y) {\\n\"\n              \"  if (x >= 0 || y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3233 - FP when template is used (template parameter is numeric constant)\n        {\n            const char code[] = \"template<int n> void foo(unsigned int x) {\\n\"\n                                \"  if (x <= n);\\n\"\n                                \"}\\n\"\n                                \"foo<0>();\";\n            check(code, true, false);\n            ASSERT_EQUALS(\"\", errout_str());\n            check(code, true, true);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            check(\"template<int n> void foo(unsigned int x) {\\n\"\n                  \"if (x <= 0);\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"[test.cpp:2:7]: (style) Checking if unsigned expression 'x' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n        }\n\n        // #8836\n        check(\"uint32_t value = 0xFUL;\\n\"\n              \"void f() {\\n\"\n              \"  if (value < 0u)\\n\"\n              \"  {\\n\"\n              \"    value = 0u;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (style) Checking if unsigned expression 'value' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        // #9040\n        /*const*/ Settings settings1 = settingsBuilder().platform(Platform::Type::Win64).build();\n        check(\"using BOOL = unsigned;\\n\"\n              \"int i;\\n\"\n              \"bool f() {\\n\"\n              \"    return i >= 0;\\n\"\n              \"}\\n\", &settings1);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10612\n        check(\"void f(void) {\\n\"\n              \"   const uint32_t x = 0;\\n\"\n              \"   constexpr const auto y = 0xFFFFU;\\n\"\n              \"   if (y < x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: (style) Checking if unsigned expression 'y' is less than zero. [unsignedLessThanZero]\\n\", errout_str());\n\n        // #12387\n        check(\"template<typename T>\\n\"\n              \"void f(T t) {\\n\"\n              \"    if constexpr (std::numeric_limits<T>::is_signed) {\\n\"\n              \"        if (t < 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    f<uint32_t>(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #13734\n        check(\"void f() {\\n\"\n              \"    uint8_t a[N + 1];\\n\"\n              \"    for (unsigned p = 0; p < (sizeof(a) / sizeof((a)[0])); ++p) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkSignOfPointer() {\n        check(\"void foo(const int* x) {\\n\"\n              \"  if (x >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is not. [pointerPositive]\\n\", errout_str());\n\n        {\n            const char code[] = \"void foo(const int* x) {\\n\"\n                                \"  int y = 0;\\n\"\n                                \"  if (x >= y) {}\\n\"\n                                \"}\";\n            check(code, true, false, true, false);\n            ASSERT_EQUALS(\"[test.cpp:3:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is not. [pointerPositive]\\n\", errout_str());\n            check(code, true, false, true, true);\n            ASSERT_EQUALS(\"[test.cpp:2:11] -> [test.cpp:3:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is not. [pointerPositive]\\n\", errout_str());\n        }\n        check(\"void foo(const int* x) {\\n\"\n              \"  if (*x >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const int* x) {\\n\"\n              \"  if (x < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is. [pointerLessThanZero]\\n\", errout_str());\n\n        {\n            const char code[] = \"void foo(const int* x) {\\n\"\n                                \"  unsigned y = 0u;\\n\"\n                                \"  if (x < y) {}\\n\"\n                                \"}\";\n\n            check(code, true, false, true, false);\n            ASSERT_EQUALS(\"[test.cpp:3:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is. [pointerLessThanZero]\\n\", errout_str());\n            check(code, true, false, true, true);\n            ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:3:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is. [pointerLessThanZero]\\n\", errout_str());\n        }\n\n        check(\"void foo(const int* x) {\\n\"\n              \"  if (*x < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const int* x, const int* y) {\\n\"\n              \"  if (x - y < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const int* x, const int* y) {\\n\"\n              \"  if (x - y <= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const int* x, const int* y) {\\n\"\n              \"  if (x - y > 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const int* x, const int* y) {\\n\"\n              \"  if (x - y >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const Bar* x) {\\n\"\n              \"  if (0 <= x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is not. [pointerPositive]\\n\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first) {\\n\"\n              \"  if (first.ptr >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (style) A pointer can not be negative so it is either pointless or an error to check if it is not. [pointerPositive]\\n\"\n                      \"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if((first.ptr - second.ptr) >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first) {\\n\"\n              \"  if((first.ptr) >= 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:18]: (style) A pointer can not be negative so it is either pointless or an error to check if it is not. [pointerPositive]\\n\"\n                      \"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if(0 <= first.ptr - second.ptr) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if(0 <= (first.ptr - second.ptr)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if(first.ptr - second.ptr < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if((first.ptr - second.ptr) < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if(0 > first.ptr - second.ptr) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct S {\\n\"\n              \"  int* ptr;\\n\"\n              \"};\\n\"\n              \"void foo(S* first, S* second) {\\n\"\n              \"  if(0 > (first.ptr - second.ptr)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Parameter 'first' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:23]: (style) Parameter 'second' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void foo(const int* x) {\\n\"\n              \"  if (0 <= x[0]) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(Bar* x) {\\n\"\n              \"  if (0 <= x.y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(Bar* x) {\\n\"\n              \"  if (0 <= x->y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(Bar* x, Bar* y) {\\n\"\n              \"  if (0 <= x->y - y->y ) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:1:23]: (style) Parameter 'y' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"void foo(const Bar* x) {\\n\"\n              \"  if (0 > x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) A pointer can not be negative so it is either pointless or an error to check if it is. [pointerLessThanZero]\\n\", errout_str());\n\n        check(\"void foo(const int* x) {\\n\"\n              \"  if (0 > x[0]) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(Bar* x) {\\n\"\n              \"  if (0 > x.y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo(Bar* x) {\\n\"\n              \"  if (0 > x->y) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:15]: (style) Parameter 'x' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  int (*t)(void *a, void *b);\\n\"\n              \"  if (t(a, b) < 0) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  int (*t)(void *a, void *b);\\n\"\n              \"  if (0 > t(a, b)) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct object_info { int *typep; };\\n\"\n              \"void packed_object_info(struct object_info *oi) {\\n\"\n              \"  if (oi->typep < 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) A pointer can not be negative so it is either pointless or an error to check if it is. [pointerLessThanZero]\\n\"\n                      \"[test.cpp:2:45]: (style) Parameter 'oi' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct object_info { int typep[10]; };\\n\"\n              \"void packed_object_info(struct object_info *oi) {\\n\"\n              \"  if (oi->typep < 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) A pointer can not be negative so it is either pointless or an error to check if it is. [pointerLessThanZero]\\n\"\n                      \"[test.cpp:2:45]: (style) Parameter 'oi' can be declared as pointer to const [constParameterPointer]\\n\",\n                      errout_str());\n\n        check(\"struct object_info { int *typep; };\\n\"\n              \"void packed_object_info(struct object_info *oi) {\\n\"\n              \"  if (*oi->typep < 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:45]: (style) Parameter 'oi' can be declared as pointer to const [constParameterPointer]\\n\", errout_str());\n    }\n\n    void checkSuspiciousSemicolon1() {\n        check(\"void foo() {\\n\"\n              \"  for(int i = 0; i < 10; ++i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Empty block\n        check(\"void foo() {\\n\"\n              \"  for(int i = 0; i < 10; ++i); {\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (warning) Suspicious use of ; at the end of 'for' statement. [suspiciousSemicolon]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  while (!quit); {\\n\"\n              \"    do_something();\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (warning) Suspicious use of ; at the end of 'while' statement. [suspiciousSemicolon]\\n\", errout_str());\n    }\n\n    void checkSuspiciousSemicolon2() {\n        check(\"void foo() {\\n\"\n              \"  if (i == 1); {\\n\"\n              \"    do_something();\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (warning) Suspicious use of ; at the end of 'if' statement. [suspiciousSemicolon]\\n\", errout_str());\n\n        // Seen this in the wild\n        check(\"void foo() {\\n\"\n              \"  if (Match());\\n\"\n              \"  do_something();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  if (Match());\\n\"\n              \"  else\\n\"\n              \"    do_something();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  if (i == 1)\\n\"\n              \"       ;\\n\"\n              \"  {\\n\"\n              \"    do_something();\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  if (i == 1);\\n\"\n              \"\\n\"\n              \"  {\\n\"\n              \"    do_something();\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkSuspiciousSemicolon3() {\n        checkP(\"#define REQUIRE(code) {code}\\n\"\n               \"void foo() {\\n\"\n               \"  if (x == 123);\\n\"\n               \"  REQUIRE(y=z);\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkSuspiciousComparison() {\n        checkP(\"void f(int a, int b) {\\n\"\n               \"  a > b;\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning, inconclusive) Found suspicious operator '>', result is not used. [constStatement]\\n\", errout_str());\n\n        checkP(\"void f() {\\n\" // #10607\n               \"  for (auto p : m)\\n\"\n               \"    std::vector<std::pair<std::string, std::string>> k;\\n\"\n               \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkInvalidFree() {\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = malloc(1024);\\n\"\n              \"  free(a + 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3]: (error) Mismatching address is freed. The address you get from malloc() must be freed without offset. [invalidFree]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = malloc(1024);\\n\"\n              \"  free(a - 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3]: (error) Mismatching address is freed. The address you get from malloc() must be freed without offset. [invalidFree]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = malloc(1024);\\n\"\n              \"  free(10 + a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:3]: (error) Mismatching address is freed. The address you get from malloc() must be freed without offset. [invalidFree]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = new char[1024];\\n\"\n              \"  delete[] (a + 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:16]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:3:3]: (error) Mismatching address is deleted. The address you get from new must be deleted without offset. [invalidFree]\\n\",\n                      errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = new char;\\n\"\n              \"  delete a + 10;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:16]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:3:3]: (error) Mismatching address is deleted. The address you get from new must be deleted without offset. [invalidFree]\\n\",\n                      errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = new char;\\n\"\n              \"  bar(a);\\n\"\n              \"  delete a + 10;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = new char;\\n\"\n              \"  char *b; b = new char;\\n\"\n              \"  bar(a);\\n\"\n              \"  delete a + 10;\\n\"\n              \"  delete b + 10;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:3]: (error) Mismatching address is deleted. The address you get from new must be deleted without offset. [invalidFree]\\n\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = new char;\\n\"\n              \"  char *b; b = new char;\\n\"\n              \"  bar(a, b);\\n\"\n              \"  delete a + 10;\\n\"\n              \"  delete b + 10;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(char *p) {\\n\"\n              \"  char *a; a = new char;\\n\"\n              \"  bar()\\n\"\n              \"  delete a + 10;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:16]: (style) Parameter 'p' can be declared as pointer to const [constParameterPointer]\\n\"\n                      \"[test.cpp:4:3]: (error) Mismatching address is deleted. The address you get from new must be deleted without offset. [invalidFree]\\n\",\n                      errout_str());\n\n        check(\"void foo(size_t xx) {\\n\"\n              \"  char *ptr; ptr = malloc(42);\\n\"\n              \"  ptr += xx;\\n\"\n              \"  free(ptr + 1 - xx);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:3]: (error) Mismatching address is freed. The address you get from malloc() must be freed without offset. [invalidFree]\\n\", errout_str());\n\n        check(\"void foo(size_t xx) {\\n\"\n              \"  char *ptr; ptr = malloc(42);\\n\"\n              \"  std::cout << ptr;\\n\"\n              \"  ptr = otherPtr;\\n\"\n              \"  free(otherPtr - xx - 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:9]: (style) Variable 'ptr' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n    }\n\n    void checkRedundantCopy() {\n        check(\"const std::string& getA(){static std::string a;return a;}\\n\"\n              \"void foo() {\\n\"\n              \"    const std::string a = getA();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (performance, inconclusive) Use const reference for 'a' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\", errout_str());\n\n        check(\"class A { public: A() {} char x[100]; };\\n\"\n              \"const A& getA(){static A a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    const A a = getA();\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (performance, inconclusive) Use const reference for 'a' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\", errout_str());\n\n        check(\"const int& getA(){static int a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    const int a = getA();\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const int& getA(){static int a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    int getA = 0;\\n\"\n              \"    const int a = getA + 3;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:12] -> [test.cpp:4:9]: (style) Local variable 'getA' shadows outer function [shadowFunction]\\n\", errout_str());\n\n        check(\"class A { public: A() {} char x[100]; };\\n\"\n              \"const A& getA(){static A a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    const A a(getA());\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (performance, inconclusive) Use const reference for 'a' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\", errout_str());\n\n        check(\"const int& getA(){static int a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    const int a(getA());\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A{\\n\"\n              \"public:A(int a=0){_a = a;}\\n\"\n              \"A operator+(const A & a){return A(_a+a._a);}\\n\"\n              \"private:int _a;};\\n\"\n              \"const A& getA(){static A a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    const A a = getA() + 1;\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A{\\n\"\n              \"public:A(int a=0){_a = a;}\\n\"\n              \"A operator+(const A & a){return A(_a+a._a);}\\n\"\n              \"private:int _a;};\\n\"\n              \"const A& getA(){static A a;return a;}\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    const A a(getA()+1);\\n\"\n              \"    return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5190 - FP when creating object with constructor that takes a reference\n        check(\"class A {};\\n\"\n              \"class B { B(const A &a); };\\n\"\n              \"const A &getA();\\n\"\n              \"void f() {\\n\"\n              \"    const B b(getA());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A {};\\n\"\n              \"class B { B(const A& a); };\\n\"\n              \"const A& getA();\\n\"\n              \"void f() {\\n\"\n              \"    const B b{ getA() };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5618\n        const char code5618[] = \"class Token {\\n\"\n                                \"public:\\n\"\n                                \"    const std::string& str();\\n\"\n                                \"};\\n\"\n                                \"void simplifyArrayAccessSyntax() {\\n\"\n                                \"    for (Token *tok = list.front(); tok; tok = tok->next()) {\\n\"\n                                \"        const std::string temp = tok->str();\\n\"\n                                \"        tok->str(tok->strAt(2));\\n\"\n                                \"    }\\n\"\n                                \"}\";\n        check(code5618, true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n        check(code5618, true, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5890 - crash: wesnoth desktop_util.cpp / unicode.hpp\n        check(\"typedef std::vector<char> X;\\n\"\n              \"X f<X>(const X &in) {\\n\"\n              \"    const X s = f<X>(in);\\n\"\n              \"    return f<X>(s);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7981 - False positive redundantCopyLocalConst - const ref argument to ctor\n        check(\"class CD {\\n\"\n              \"        public:\\n\"\n              \"        CD(const CD&);\\n\"\n              \"        static const CD& getOne();\\n\"\n              \"};\\n\"\n              \" \\n\"\n              \"void foo() {\\n\"\n              \"  const CD cd(CD::getOne());\\n\"\n              \"}\", true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #10545\n              \"    int modify();\\n\"\n              \"    const std::string& get() const;\\n\"\n              \"};\\n\"\n              \"std::string f(S& s) {\\n\"\n              \"    const std::string old = s.get();\\n\"\n              \"    int i = s.modify();\\n\"\n              \"    if (i != 0)\\n\"\n              \"        return old;\\n\"\n              \"    return {};\\n\"\n              \"}\", true, /*inconclusive*/ true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct X { int x; };\\n\" // #10191\n              \"struct S {\\n\"\n              \"    X _x;\\n\"\n              \"    X& get() { return _x; }\\n\"\n              \"    void modify() { _x.x += 42; }\\n\"\n              \"    int copy() {\\n\"\n              \"        const X x = get();\\n\"\n              \"        modify();\\n\"\n              \"        return x.x;\\n\"\n              \"    }\\n\"\n              \"    int constref() {\\n\"\n              \"        const X& x = get();\\n\"\n              \"        modify();\\n\"\n              \"        return x.x;\\n\"\n              \"    }\\n\"\n              \"};\\n\", true, /*inconclusive*/ true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10704\n        check(\"struct C {\\n\"\n              \"    std::string str;\\n\"\n              \"    const std::string& get() const { return str; }\\n\"\n              \"};\\n\"\n              \"struct D {\\n\"\n              \"    C c;\\n\"\n              \"    bool f() const {\\n\"\n              \"        std::string s = c.get();\\n\"\n              \"        return s.empty();\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:21]: (performance, inconclusive) Use const reference for 's' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\", errout_str());\n\n        check(\"struct C {\\n\"\n              \"    const std::string & get() const { return m; }\\n\"\n              \"    std::string m;\\n\"\n              \"};\\n\"\n              \"C getC();\\n\"\n              \"void f() {\\n\"\n              \"    const std::string s = getC().get();\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    std::string s = getC().get();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12139\n              \"    int x, y;\\n\"\n              \"};\\n\"\n              \"struct T {\\n\"\n              \"    S s;\\n\"\n              \"    const S& get() const { return s; }\\n\"\n              \"};\\n\"\n              \"void f(const T& t) {\\n\"\n              \"    const S a = t.get();\\n\"\n              \"    if (a.x > a.y) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12740\n              \"    const std::string & get() const { return m; }\\n\"\n              \"    void set(const std::string& v) { m = v; }\\n\"\n              \"    std::string m;\\n\"\n              \"};\\n\"\n              \"struct T {\\n\"\n              \"    void f();\\n\"\n              \"    S* s;\\n\"\n              \"};\\n\"\n              \"void T::f() {\\n\"\n              \"    const std::string o = s->get();\\n\"\n              \"    s->set(\\\"abc\\\");\\n\"\n              \"    s->set(o);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12196\n              \"    std::string s;\\n\"\n              \"    const std::string& get() const { return s; }\\n\"\n              \"};\\n\"\n              \"struct T {\\n\"\n              \"    S* m;\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"struct U {\\n\"\n              \"    explicit U(S* p);\\n\"\n              \"    void g();\\n\"\n              \"    S* n;\\n\"\n              \"};\\n\"\n              \"void T::f() {\\n\"\n              \"    U u(m);\\n\"\n              \"    const std::string c = m->get();\\n\"\n              \"    u.g();\\n\"\n              \"    if (c == m->get()) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"\",\n                           \"[test.cpp:16:33] -> [test.cpp:18:11]: (style) The comparison 'c == m->get()' is always true because 'c' and 'm->get()' represent the same value. [knownConditionTrueFalse]\\n\",\n                           errout_str());\n\n        check(\"struct S {\\n\" // #12925\n              \"    const std::string & f() const { return str; }\\n\"\n              \"    std::string str;\\n\"\n              \"};\\n\"\n              \"void f(const S* s) {\\n\"\n              \"    const std::string v{ s->f() };\\n\"\n              \"    if (v.empty()) {}\\n\"\n              \"}\\n\"\n              \"void g(const S* s) {\\n\"\n              \"    const std::string w(s->f());\\n\"\n              \"    if (w.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:23]: (performance, inconclusive) Use const reference for 'v' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\"\n                      \"[test.cpp:10:23]: (performance, inconclusive) Use const reference for 'w' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\",\n                      errout_str());\n\n        check(\"struct T {\\n\"\n              \"    std::string s;\\n\"\n              \"    const std::string& get() const { return s; }\\n\"\n              \"};\\n\"\n              \"void f(const T& t) {\\n\"\n              \"    const auto s = t.get();\\n\"\n              \"    if (s.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:16]: (performance, inconclusive) Use const reference for 's' to avoid unnecessary data copying. [redundantCopyLocalConst]\\n\", errout_str());\n    }\n\n    void checkNegativeShift() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   int a; a = 123;\\n\"\n              \"   (void)(a << -1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Shifting by a negative value is undefined behaviour [shiftNegative]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   int a; a = 123;\\n\"\n              \"   (void)(a >> -1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Shifting by a negative value is undefined behaviour [shiftNegative]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   int a; a = 123;\\n\"\n              \"   a <<= -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Shifting by a negative value is undefined behaviour [shiftNegative]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   int a; a = 123;\\n\"\n              \"   a >>= -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Shifting by a negative value is undefined behaviour [shiftNegative]\\n\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   std::cout << -1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   std::cout << a << -1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"   std::cout << 3 << -1 ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo() {\\n\"\n              \"   x = (-10+2) << 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:16]: (portability) Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]\\n\", errout_str());\n\n        check(\"x = y ? z << $-1 : 0;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Negative LHS\n        check(\"const int x = -1 >> 2;\");\n        ASSERT_EQUALS(\"[test.cpp:1:18]: (portability) Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]\\n\", errout_str());\n\n        // #6383 - unsigned type\n        check(\"const int x = (unsigned int)(-1) >> 2;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7814 - UB happening in valueflowcode when it tried to compute shifts.\n        check(\"int shift1() { return 1 >> -1 ;}\\n\"\n              \"int shift2() { return 1 << -1 ;}\\n\"\n              \"int shift3() { return -1 >> 1 ;}\\n\"\n              \"int shift4() { return -1 << 1 ;}\");\n        ASSERT_EQUALS(\"[test.cpp:1:25]: (error) Shifting by a negative value is undefined behaviour [shiftNegative]\\n\"\n                      \"[test.cpp:2:25]: (error) Shifting by a negative value is undefined behaviour [shiftNegative]\\n\"\n                      \"[test.cpp:3:26]: (portability) Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]\\n\"\n                      \"[test.cpp:4:26]: (portability) Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\" // #12916\n              \"    if (i < 0) {\\n\"\n              \"        g(\\\"abc\\\" << i);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #13326\n        check(\"template<int b>\\n\"\n              \"int f(int a)\\n\"\n              \"{\\n\"\n              \"    if constexpr (b >= 0) {\\n\"\n              \"        return a << b;\\n\"\n              \"    } else {\\n\"\n              \"        return a << -b;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"int g() {\\n\"\n              \"    return f<1>(2)\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template<int b>\\n\"\n              \"int f(int a)\\n\"\n              \"{\\n\"\n              \"    if constexpr (b >= 0) {\\n\"\n              \"        return a << b;\\n\"\n              \"    } else {\\n\"\n              \"        return a << -b;\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"int g() {\\n\"\n              \"    return f<-1>(2)\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void incompleteArrayFill() {\n        check(\"void f() {\\n\"\n              \"    int a[5];\\n\"\n              \"    memset(a, 123, 5);\\n\"\n              \"    memcpy(a, b, 5);\\n\"\n              \"    memmove(a, b, 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(// TODO \"[test.cpp:4] -> [test.cpp:5]: (performance) Buffer 'a' is being written before its old content has been used.\\n\"\n            \"[test.cpp:3:5]: (warning, inconclusive) Array 'a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\"\n            \"[test.cpp:4:5]: (warning, inconclusive) Array 'a' is filled incompletely. Did you forget to multiply the size given to 'memcpy()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\"\n            \"[test.cpp:5:5]: (warning, inconclusive) Array 'a' is filled incompletely. Did you forget to multiply the size given to 'memmove()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\", errout_str());\n\n        check(\"int a[5];\\n\"\n              \"namespace Z { struct B { int a[5]; } b; }\\n\"\n              \"void f() {\\n\"\n              \"    memset(::a, 123, 5);\\n\"\n              \"    memset(Z::b.a, 123, 5);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:5]: (warning, inconclusive) Array '::a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*::a)'? [incompleteArrayFill]\\n\"\n                           \"[test.cpp:5]: (warning, inconclusive) Array 'Z::b.a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*Z::b.a)'?\\n\",\n                           \"[test.cpp:4:5]: (warning, inconclusive) Array '::a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*::a)'? [incompleteArrayFill]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Foo* a[5];\\n\"\n              \"    memset(a, 'a', 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) Array 'a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\", errout_str());\n\n        check(\"class Foo {int a; int b;};\\n\"\n              \"void f() {\\n\"\n              \"    Foo a[5];\\n\"\n              \"    memset(a, 'a', 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (warning, inconclusive) Array 'a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Foo a[5];\\n\" // Size of foo is unknown\n              \"    memset(a, 'a', 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char a[5];\\n\"\n              \"    memset(a, 'a', 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int a[5];\\n\"\n              \"    memset(a+15, 'a', 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    bool a[5];\\n\"\n              \"    memset(a, false, 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (portability, inconclusive) Array 'a' might be filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const int n = 5;\"\n              \"    int a[n];\\n\"\n              \"    memset(a, 0, n);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning, inconclusive) Array 'a' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*a)'? [incompleteArrayFill]\\n\", errout_str());\n    }\n\n    void redundantVarAssignment() {\n        setMultiline();\n\n        // Simple tests\n        check(\"void f(int i) {\\n\"\n              \"    i = 1;\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:2:7]: note: i is assigned\\n\"\n                      \"[test.cpp:3:7]: note: i is overwritten\\n\", errout_str());\n\n        // non-local variable => only show warning when inconclusive is used\n        check(\"int i;\\n\"\n              \"void f() {\\n\"\n              \"    i = 1;\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:7]: note: i is assigned\\n\"\n                      \"[test.cpp:4:7]: note: i is overwritten\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int i;\\n\"\n              \"    i = 1;\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:7]: note: i is assigned\\n\"\n                      \"[test.cpp:4:7]: note: i is overwritten\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int i;\\n\"\n              \"    i = 1;\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int i[10];\\n\"\n              \"    i[2] = 1;\\n\"\n              \"    i[2] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: style: Variable 'i[2]' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:10]: note: i[2] is assigned\\n\"\n                      \"[test.cpp:4:10]: note: i[2] is overwritten\\n\", errout_str());\n\n        check(\"void f(int x) {\\n\"\n              \"    int i[10];\\n\"\n              \"    i[x] = 1;\\n\"\n              \"    x=1;\\n\"\n              \"    i[x] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const int x) {\\n\"\n              \"    int i[10];\\n\"\n              \"    i[x] = 1;\\n\"\n              \"    i[x] = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: style: Variable 'i[x]' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:10]: note: i[x] is assigned\\n\"\n                      \"[test.cpp:4:10]: note: i[x] is overwritten\\n\", errout_str());\n\n        // Testing different types\n        check(\"void f() {\\n\"\n              \"    Foo& bar = foo();\\n\"\n              \"    bar = x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Foo& bar = foo();\\n\"\n              \"    bar = x;\\n\"\n              \"    bar = y;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Foo& bar = foo();\\n\" // #4425. bar might refer to something global, etc.\n              \"    bar = y();\\n\"\n              \"    foo();\\n\"\n              \"    bar = y();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Tests with function call between assignment\n        check(\"void f(int i) {\\n\"\n              \"    i = 1;\\n\"\n              \"    bar();\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:2:7]: note: i is assigned\\n\"\n                      \"[test.cpp:4:7]: note: i is overwritten\\n\", errout_str());\n\n        check(\"int i;\\n\"\n              \"void f() {\\n\"\n              \"    i = 1;\\n\"\n              \"    bar();\\n\" // Global variable might be accessed in bar()\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int i;\\n\"\n              \"    i = 1;\\n\"\n              \"    bar();\\n\" // bar() might call f() recursively. This could be a false positive in more complex examples (when value of i is used somewhere. See #4229)\n              \"    i = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int i;\\n\"\n              \"    i = 1;\\n\"\n              \"    bar();\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:7]: note: i is assigned\\n\"\n                      \"[test.cpp:5:7]: note: i is overwritten\\n\", errout_str());\n\n        check(\"void bar(int i) {}\\n\"\n              \"void f(int i) {\\n\"\n              \"    i = 1;\\n\"\n              \"    bar(i);\\n\" // Passed as argument\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Foo bar = foo();\\n\"\n              \"    bar();\\n\" // #5568. operator() called\n              \"    bar = y();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Branch tests\n        check(\"void f(int i) {\\n\"\n              \"    i = 1;\\n\"\n              \"    if(x)\\n\"\n              \"        i = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"    if(x)\\n\"\n              \"        i = 0;\\n\"\n              \"    i = 1;\\n\"\n              \"    i = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:4:7]: note: i is assigned\\n\"\n                      \"[test.cpp:5:7]: note: i is overwritten\\n\", errout_str());\n\n        // #4513\n        check(\"int x;\\n\"\n              \"int g() {\\n\"\n              \"    return x*x;\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    x = 2;\\n\"\n              \"    x = g();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g() {\\n\"\n              \"    return x*x;\\n\"\n              \"}\\n\"\n              \"void f(int x) {\\n\"\n              \"    x = 2;\\n\"\n              \"    x = g();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:7]: style: Variable 'x' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:5:7]: note: x is assigned\\n\"\n                      \"[test.cpp:6:7]: note: x is overwritten\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    Foo& bar = foo();\\n\"\n              \"    bar = x;\\n\"\n              \"    bar = y();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C {\\n\"\n              \"    int x;\\n\"\n              \"    void g() { return x * x; }\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void C::f() {\\n\"\n              \"    x = 2;\\n\"\n              \"    x = g();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class C {\\n\"\n              \"    int x;\\n\"\n              \"    void g() { return x*x; }\\n\"\n              \"    void f(Foo z);\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void C::f(Foo z) {\\n\"\n              \"    x = 2;\\n\"\n              \"    x = z.g();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ({ })\n        check(\"void f() {\\n\"\n              \"  int x;\\n\"\n              \"  x = 321;\\n\"\n              \"  x = ({ asm(123); })\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // from #3103 (avoid a false negative)\n        check(\"int foo(){\\n\"\n              \"    int x;\\n\"\n              \"    x = 1;\\n\"\n              \"    x = 1;\\n\"\n              \"    return x + 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: style: Variable 'x' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:7]: note: x is assigned\\n\"\n                      \"[test.cpp:4:7]: note: x is overwritten\\n\", errout_str());\n\n        // from #3103 (avoid a false positive)\n        check(\"int foo(){\\n\"\n              \"    int x;\\n\"\n              \"    x = 1;\\n\"\n              \"    if (y)\\n\" // <-- cppcheck does not know anything about 'y'\n              \"        x = 2;\\n\"\n              \"    return x + 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // initialization, assignment with 0\n        check(\"void f() {\\n\"  // Ticket #4356\n              \"    int x = 0;\\n\"  // <- ignore initialization with 0\n              \"    x = 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  state_t *x = NULL;\\n\"\n              \"  x = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:12]: style: Variable 'x' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"  state_t *x;\\n\"\n              \"  x = NULL;\\n\"\n              \"  x = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:12]: style: Variable 'x' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"int foo() {\\n\" // #4420\n              \"    int x;\\n\"\n              \"    bar(++x);\\n\"\n              \"    x = 5;\\n\"\n              \"    return bar(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // struct member..\n        check(\"struct AB { int a; int b; };\\n\"\n              \"\\n\"\n              \"int f() {\\n\"\n              \"    struct AB ab;\\n\"\n              \"    ab.a = 1;\\n\"\n              \"    ab.a = 2;\\n\"\n              \"    return ab.a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:10]: style: Variable 'ab.a' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:5:10]: note: ab.a is assigned\\n\"\n                      \"[test.cpp:6:10]: note: ab.a is overwritten\\n\", errout_str());\n\n        check(\"struct AB { int a; int b; };\\n\"\n              \"\\n\"\n              \"int f() {\\n\"\n              \"    struct AB ab;\\n\"\n              \"    ab.a = 1;\\n\"\n              \"    ab = do_something();\\n\"\n              \"    return ab.a;\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        check(\"struct AB { int a; int b; };\\n\"\n              \"\\n\"\n              \"int f() {\\n\"\n              \"    struct AB ab;\\n\"\n              \"    ab.a = 1;\\n\"\n              \"    do_something(&ab);\\n\"\n              \"    ab.a = 2;\\n\"\n              \"    return ab.a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AB { int a; int b; };\\n\"\n              \"\\n\"\n              \"int f(DO_SOMETHING do_something) {\\n\"\n              \"    struct AB ab;\\n\"\n              \"    ab.a = 1;\\n\"\n              \"    do_something(&ab);\\n\"\n              \"    ab.a = 2;\\n\"\n              \"    return ab.a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AB { int a; int b; };\\n\"\n              \"\\n\"\n              \"int f(struct AB *ab) {\\n\"\n              \"    ab->a = 1;\\n\"\n              \"    ab->b = 2;\\n\"\n              \"    ab++;\\n\"\n              \"    ab->a = 1;\\n\"\n              \"    ab->b = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct AB { int a; int b; };\\n\"\n              \"\\n\"\n              \"int f(struct AB *ab) {\\n\"\n              \"    ab->a = 1;\\n\"\n              \"    ab->b = 2;\\n\"\n              \"    ab = x;\\n\"\n              \"    ab->a = 1;\\n\"\n              \"    ab->b = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(struct AB *ab) {\\n\" // #\n              \"    ab->data->x = 1;\\n\"\n              \"    ab = &ab1;\\n\"\n              \"    ab->data->x = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5964\n        check(\"void func(char *buffer, const char *format, int precision, unsigned value) {\\n\"\n              \"    (precision < 0) ? sprintf(buffer, format, value) : sprintf(buffer, format, precision, value);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // don't crash\n        check(\"struct data {\\n\"\n              \"  struct { int i; } fc;\\n\"\n              \"};\\n\"\n              \"struct state {\\n\"\n              \"  struct data d[123];\\n\"\n              \"};\\n\"\n              \"void func(struct state *s) {\\n\"\n              \"  s->foo[s->x++] = 2;\\n\"\n              \"  s->d[1].fc.i++;\\n\"\n              \"}\");\n\n        // #6525 - inline assembly\n        check(\"void f(int i) {\\n\"\n              \"    i = 1;\\n\"\n              \"    asm(\\\"foo\\\");\\n\"\n              \"    i = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6555\n        check(\"void foo() {\\n\"\n              \"    char *p = 0;\\n\"\n              \"    try {\\n\"\n              \"        p = fred();\\n\"\n              \"        p = wilma();\\n\"\n              \"    }\\n\"\n              \"    catch (...) {\\n\"\n              \"        barney(p);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char *p = 0;\\n\"\n              \"    try {\\n\"\n              \"        p = fred();\\n\"\n              \"        p = wilma();\\n\"\n              \"    }\\n\"\n              \"    catch (...) {\\n\"\n              \"        barney(x);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: style: The scope of the variable 'p' can be reduced. [variableScope]\\n\"\n                      \"[test.cpp:2:11]: style: Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char *p = 0;\\n\"\n              \"    try {\\n\"\n              \"        if(z) {\\n\"\n              \"            p = fred();\\n\"\n              \"            p = wilma();\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    catch (...) {\\n\"\n              \"        barney(p);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Member variable pointers\n        check(\"void podMemPtrs() {\\n\"\n              \"    int POD::*memptr;\\n\"\n              \"    memptr = &POD::a;\\n\"\n              \"    memptr = &POD::b;\\n\"\n              \"    if (memptr)\\n\"\n              \"        memptr = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: style: Variable 'memptr' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:12]: note: memptr is assigned\\n\"\n                      \"[test.cpp:4:12]: note: memptr is overwritten\\n\", errout_str());\n\n        // Pointer function argument (#3857)\n        check(\"void f(float * var)\\n\"\n              \"{\\n\"\n              \"  var[0] = 0.2f;\\n\"\n              \"  var[0] = 0.2f;\\n\" // <-- is initialized twice\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: style: Variable 'var[0]' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:10]: note: var[0] is assigned\\n\"\n                      \"[test.cpp:4:10]: note: var[0] is overwritten\\n\", errout_str());\n\n        check(\"void f(float * var)\\n\"\n              \"{\\n\"\n              \"  *var = 0.2f;\\n\"\n              \"  *var = 0.2f;\\n\" // <-- is initialized twice\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: style: Variable '*var' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:3:8]: note: *var is assigned\\n\"\n                      \"[test.cpp:4:8]: note: *var is overwritten\\n\", errout_str());\n\n        // Volatile variables\n        check(\"void f() {\\n\"\n              \"  volatile char *reg = (volatile char *)0x12345;\\n\"\n              \"  *reg = 12;\\n\"\n              \"  *reg = 34;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::map<int, int>& m, int key, int value) {\\n\" // #6379\n              \"    m[key] = value;\\n\"\n              \"    m[key] = value;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: style: Variable 'm[key]' is reassigned a value before the old one has been used. [redundantAssignment]\\n\"\n                      \"[test.cpp:2:12]: note: m[key] is assigned\\n\"\n                      \"[test.cpp:3:12]: note: m[key] is overwritten\\n\",\n                      errout_str());\n    }\n\n    void redundantVarAssignment_trivial() {\n        check(\"void f() {\\n\"\n              \"   int a = 0;\\n\"\n              \"   a = 4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   int a;\\n\"\n              \"   a = 0;\\n\"\n              \"   a = 4;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   unsigned a;\\n\"\n              \"   a = 0u;\\n\"\n              \"   a = 2u;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"   void* a;\\n\"\n              \"   a = (void*)0;\\n\"\n              \"   a = p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:10]: (style) Variable 'a' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"   void* a;\\n\"\n              \"   a = (void*)0U;\\n\"\n              \"   a = p;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:10]: (style) Variable 'a' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n    }\n\n    void redundantVarAssignment_struct() {\n        check(\"struct foo {\\n\"\n              \"  int a,b;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"int main() {\\n\"\n              \"  struct foo x;\\n\"\n              \"  x.a = _mm_set1_ps(1.0);\\n\"\n              \"  x.a = _mm_set1_ps(2.0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:7] -> [test.cpp:8:7]: (style) Variable 'x.a' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  struct AB ab;\\n\"\n              \"  ab.x = 23;\\n\"\n              \"  ab.y = 41;\\n\"\n              \"  ab.x = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:8] -> [test.cpp:5:8]: (style) Variable 'ab.x' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  struct AB ab = {0};\\n\"\n              \"  ab = foo();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_union() {\n        // Ticket #5115 \"redundantAssignment when using a union\"\n        check(\"void main(void)\\n\"\n              \"{\\n\"\n              \"    short lTotal = 0;\\n\"\n              \"    union\\n\"\n              \"    {\\n\"\n              \"        short l1;\\n\"\n              \"        struct\\n\"\n              \"        {\\n\"\n              \"            unsigned char b1;\\n\"\n              \"            unsigned char b2;\\n\"\n              \"        } b;\\n\"\n              \"    } u;\\n\"\n              \"    u.l1 = 1;\\n\"\n              \"    lTotal += u.b.b1;\\n\"\n              \"    u.l1 = 2;\\n\" //Should not show RedundantAssignment\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #5115 \"redundantAssignment when using a union\"\n        check(\"void main(void)\\n\"\n              \"{\\n\"\n              \"    short lTotal = 0;\\n\"\n              \"    union\\n\"\n              \"    {\\n\"\n              \"        short l1;\\n\"\n              \"        struct\\n\"\n              \"        {\\n\"\n              \"            unsigned char b1;\\n\"\n              \"            unsigned char b2;\\n\"\n              \"        } b;\\n\"\n              \"    } u;\\n\"\n              \"    u.l1 = 1;\\n\"\n              \"    u.l1 = 2;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"[test.cpp:13:10] -> [test.cpp:14:10]: (style) Variable 'u.l1' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n\n        // Ticket #10093 \"redundantAssignment when using a union\"\n        check(\"typedef union fixed32_union {\\n\"\n              \"    struct {\\n\"\n              \"        unsigned32 abcd;\\n\"\n              \"    } u32;\\n\"\n              \"    struct {\\n\"\n              \"        unsigned16 ab;\\n\"\n              \"        unsigned16 cd;\\n\"\n              \"    } u16;\"\n              \"    struct {\\n\"\n              \"        unsigned8 a;\\n\"\n              \"        unsigned8 b;\\n\"\n              \"        unsigned8 c;\\n\"\n              \"        unsigned8 d;\\n\"\n              \"        } b;\\n\"\n              \"} fixed32;\\n\"\n              \"void func1(void) {\\n\"\n              \"    fixed32 m;\\n\"\n              \"    m.u16.ab = 47;\\n\"\n              \"    m.u16.cd = 0;\\n\"\n              \"    m.u16.ab = m.u32.abcd / 53;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #10093 \"redundantAssignment when using a union\"\n        check(\"typedef union{\\n\"\n              \"    char as_char[4];\\n\"\n              \"    int as_int;\\n\"\n              \"} union_t;\\n\"\n              \"void fn(char *data, int len) {\\n\"\n              \"    int i;\\n\"\n              \"    for (i = 0; i < len; i++)\\n\"\n              \"        data[i] = 'a';\\n\"\n              \"}\\n\"\n              \"int main(int argc, char *argv[]) {\\n\"\n              \"    union_t u;\\n\"\n              \"    u.as_int = 42;\\n\"\n              \"    fn(&u.as_char[0], 4);\\n\"\n              \"    u.as_int = 0;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #5115 \"redundantAssignment when using a union\"\n        check(\"void foo(char *ptr) {\\n\"\n              \"    union {\\n\"\n              \"        char * s8;\\n\"\n              \"        unsigned long long u64;\\n\"\n              \"    } addr;\\n\"\n              \"    addr.s8 = ptr;\\n\"\n              \"    addr.u64 += 8;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12895\n              \"    int x, y;\\n\"\n              \"};\\n\"\n              \"union U {\\n\"\n              \"    S* s;\\n\"\n              \"};\\n\"\n              \"void f(const U& Src, const U& Dst) {\\n\"\n              \"    Dst.s->x = Src.s->x;\\n\"\n              \"    Dst.s->y = Src.s->y;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_7133() {\n        // #7133\n        check(\"sal_Int32 impl_Export() {\\n\"\n              \"   try {\\n\"\n              \"        try  {\\n\"\n              \"          uno::Sequence< uno::Any > aArgs(2);\\n\"\n              \"          beans::NamedValue aValue;\\n\"\n              \"          aValue.Name = \\\"DocumentHandler\\\";\\n\"\n              \"          aValue.Value <<= xDocHandler;\\n\"\n              \"          aArgs[0] <<= aValue;\\n\"\n              \"          aValue.Name = \\\"Model\\\";\\n\"\n              \"          aValue.Value <<= xDocumentComp;\\n\"\n              \"          aArgs[1] <<= aValue;\\n\"\n              \"        }\\n\"\n              \"        catch (const uno::Exception&) {\\n\"\n              \"        }\\n\"\n              \"   }\\n\"\n              \"   catch (const uno::Exception&)  {\\n\"\n              \"   }\\n\"\n              \"}\", true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void ConvertBitmapData(sal_uInt16 nDestBits) {\\n\"\n              \"    BitmapBuffer aSrcBuf;\\n\"\n              \"    aSrcBuf.mnBitCount = nSrcBits;\\n\"\n              \"    BitmapBuffer aDstBuf;\\n\"\n              \"    aSrcBuf.mnBitCount = nDestBits;\\n\"\n              \"    bConverted = ::ImplFastBitmapConversion( aDstBuf, aSrcBuf, aTwoRects );\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"[test.c:3:24] -> [test.c:5:24]: (style) Variable 'aSrcBuf.mnBitCount' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n        check(\"void ConvertBitmapData(sal_uInt16 nDestBits) {\\n\"\n              \"    BitmapBuffer aSrcBuf;\\n\"\n              \"    aSrcBuf.mnBitCount = nSrcBits;\\n\"\n              \"    BitmapBuffer aDstBuf;\\n\"\n              \"    aSrcBuf.mnBitCount = nDestBits;\\n\"\n              \"    bConverted = ::ImplFastBitmapConversion( aDstBuf, aSrcBuf, aTwoRects );\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:24] -> [test.cpp:5:24]: (style) Variable 'aSrcBuf.mnBitCount' is reassigned a value before the old one has been used. [redundantAssignment]\\n\",\n                      errout_str());\n\n        check(\"class C { void operator=(int x); };\\n\" // #8368 - assignment operator might have side effects => inconclusive\n              \"void f() {\\n\"\n              \"    C c;\\n\"\n              \"    c = x;\\n\"\n              \"    c = x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7] -> [test.cpp:5:7]: (style, inconclusive) Variable 'c' is reassigned a value before the old one has been used if variable is no semaphore variable. [redundantAssignment]\\n\", errout_str());\n    }\n\n    void redundantVarAssignment_stackoverflow() {\n        check(\"typedef struct message_node {\\n\"\n              \"  char code;\\n\"\n              \"  size_t size;\\n\"\n              \"  struct message_node *next, *prev;\\n\"\n              \"} *message_list;\\n\"\n              \"static message_list remove_message_from_list(message_list m) {\\n\"\n              \"    m->prev->next = m->next;\\n\"\n              \"    m->next->prev = m->prev;\\n\"\n              \"    return m->next;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_lambda() {\n        // #7152\n        check(\"int foo() {\\n\"\n              \"    int x = 0, y = 0;\\n\"\n              \"    auto f = [&]() { if (x < 5) ++y; };\\n\"\n              \"    x = 2;\\n\"\n              \"    f();\\n\"\n              \"    x = 6;\\n\"\n              \"    f();\\n\"\n              \"    return y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10228\n        check(\"std::tuple<int, int> g();\\n\"\n              \"void h(int);\\n\"\n              \"void f() {\\n\"\n              \"    auto [a, b] = g();\\n\"\n              \"    auto l = [a = a]() { h(i); };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_loop() {\n        check(\"void f() {\\n\"\n              \"    char buf[10];\\n\"\n              \"    int i;\\n\"\n              \"    for (i = 0; i < 4; i++)\\n\"\n              \"        buf[i] = 131;\\n\"\n              \"    buf[i] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void bar() {\\n\" // #9262 do-while with break\n              \"    int x = 0;\\n\"\n              \"    x = 432;\\n\"\n              \"    do {\\n\"\n              \"        if (foo()) break;\\n\"\n              \"        x = 1;\\n\"\n              \"     } while (false);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int num) {\\n\" // #9420 FP\n              \"  int a = num;\\n\"\n              \"  for (int b = 0; b < num; a = b++)\\n\"\n              \"    dostuff(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(int num) {\\n\" // #9420 FN\n              \"  int a = num;\\n\"\n              \"  for (int b = 0; b < num; a = b++);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n    }\n\n    void redundantVarAssignment_after_switch() {\n        check(\"void f(int x) {\\n\" // #7907\n              \"    int ret;\\n\"\n              \"    switch (x) {\\n\"\n              \"    case 123:\\n\"\n              \"        ret = 1;\\n\" // redundant assignment\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"    ret = 3;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13] -> [test.cpp:8:9]: (style) Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n    }\n\n    void redundantVarAssignment_pointer() {\n        check(\"void f(int *ptr) {\\n\"\n              \"    int *x = ptr + 1;\\n\"\n              \"    *x = 23;\\n\"\n              \"    foo(ptr);\\n\"\n              \"    *x = 32;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8997\n        check(\"void f() {\\n\"\n              \"  char x[2];\\n\"\n              \"  char* p = x;\\n\"\n              \"  *p = 1;\\n\"\n              \"  p += 1;\\n\"\n              \"  *p = 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_pointer_parameter() {\n        check(\"void f(int *p) {\\n\"\n              \"    *p = 1;\\n\"\n              \"    if (condition) return;\\n\"\n              \"    *p = 2;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_array() {\n        check(\"void f() {\\n\"\n              \"    int arr[10];\\n\"\n              \"    int i = 0;\\n\"\n              \"    arr[i] = 1;\\n\"\n              \"    i += 2;\\n\"\n              \"    arr[i] = 3;\\n\"\n              \"    dostuff(arr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantVarAssignment_switch_break() {\n        // #10058\n        check(\"void f(int a, int b) {\\n\"\n              \"    int ret = 0;\\n\"\n              \"    switch (a) {\\n\"\n              \"    case 1:\\n\"\n              \"        ret = 543;\\n\"\n              \"        if (b) break;\\n\"\n              \"        ret = 1;\\n\"\n              \"        break;\\n\"\n              \"    }\"\n              \"    return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a, int b) {\\n\"\n              \"    int ret = 0;\\n\"\n              \"    switch (a) {\\n\"\n              \"    case 1:\\n\"\n              \"        ret = 543;\\n\"\n              \"        if (b) break;\\n\"\n              \"        ret = 1;\\n\"\n              \"        break;\\n\"\n              \"    }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13] -> [test.cpp:7:13]: (style) Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]\\n\", errout_str());\n    }\n\n    void redundantInitialization() {\n        setMultiline();\n\n        check(\"void f() {\\n\"\n              \"    int err = -ENOMEM;\\n\"\n              \"    err = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: style: Redundant initialization for 'err'. The initialized value is overwritten before it is read. [redundantInitialization]\\n\"\n                      \"[test.cpp:2:13]: note: err is initialized\\n\"\n                      \"[test.cpp:3:9]: note: err is overwritten\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    struct S s = {1,2,3};\\n\"\n              \"    s = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: style: Redundant initialization for 's'. The initialized value is overwritten before it is read. [redundantInitialization]\\n\"\n                      \"[test.cpp:2:16]: note: s is initialized\\n\"\n                      \"[test.cpp:3:7]: note: s is overwritten\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int *p = NULL;\\n\"\n              \"    p = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:10]: style: Variable 'p' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        // \"trivial\" initialization => do not warn\n        check(\"void f() {\\n\"\n              \"    struct S s = {0};\\n\"\n              \"    s = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace N { enum E {e0,e1}; }\\n\"\n              \"void f() {\\n\"\n              \"    N::E e = N::e0;\\n\" // #9261\n              \"    e = dostuff();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #10143\n              \"    std::shared_ptr<int> i = g();\\n\"\n              \"    h();\\n\"\n              \"    i = nullptr;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\" // #9815\n              \"    int i = g();\\n\"\n              \"    i = std::distance(v.begin(), std::find_if(v.begin(), v.end(), [=](int j) { return i == j; }));\\n\"\n              \"    return i;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // cppcheck-suppress unusedPrivateFunction\n    void redundantMemWrite() {\n        // Simple tests\n        // cppcheck-suppress unreachableCode - remove when code is enabled again\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    memcpy(a, foo, bar);\\n\"\n              \"    memset(a, 0, bar);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:4]: (performance) Buffer 'a' is being written before its old content has been used.\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    strcpy(a, foo);\\n\"\n              \"    strncpy(a, 0, bar);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:4]: (performance) Buffer 'a' is being written before its old content has been used.\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    sprintf(a, \\\"foo\\\");\\n\"\n              \"    memmove(a, 0, bar);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:4]: (performance) Buffer 'a' is being written before its old content has been used.\\n\", errout_str());\n\n        check(\"void f(char *filename) {\\n\"\n              \"    char *p = strrchr(filename,'.');\\n\"\n              \"    strcpy(p, \\\"foo\\\");\\n\"\n              \"    dostuff(filename);\\n\"\n              \"    strcpy(p, \\\"foo\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Writing to different parts of a buffer\n        check(\"void f(void* a) {\\n\"\n              \"    memcpy(a, foo, bar);\\n\"\n              \"    memset(a+5, 0, bar);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Use variable as second argument\n        check(\"void f(void* a, void* b) {\\n\"\n              \"    memset(a, 0, 5);\\n\"\n              \"    memcpy(b, a, 5);\\n\"\n              \"    memset(a, 1, 5);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // strcat is special\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    strcpy(a, foo);\\n\"\n              \"    strcat(a, bar);\\n\" // Not redundant\n              \"    strcpy(a, x);\\n\" // Redundant\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:5]: (performance) Buffer 'a' is being written before its old content has been used.\\n\", errout_str());\n\n        // Tests with function call between copy\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    snprintf(a, foo, bar);\\n\"\n              \"    bar();\\n\"\n              \"    memset(a, 0, size);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:5]: (performance) Buffer 'a' is being written before its old content has been used.\\n\", errout_str());\n\n        check(\"void* a;\\n\"\n              \"void f() {\\n\"\n              \"    memset(a, 0, size);\\n\"\n              \"    bar();\\n\" // Global variable might be accessed in bar()\n              \"    memset(a, 0, size);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char a[10];\\n\"\n              \"    memset(a, 0, size);\\n\"\n              \"    bar();\\n\"\n              \"    memset(a, 0, size);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:5]: (performance) Buffer 'a' is being written before its old content has been used.\\n\", \"\", errout_str());\n\n        check(\"void bar(void* a) {}\\n\"\n              \"void f(void* a) {\\n\"\n              \"    memset(a, 0, size);\\n\"\n              \"    bar(a);\\n\" // Passed as argument\n              \"    memset(a, 0, size);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Branch tests\n        check(\"void f(void* a) {\\n\"\n              \"    memset(a, 0, size);\\n\"\n              \"    if(x)\\n\"\n              \"        memset(a, 0, size);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4455 - initialization of local buffer\n        check(\"void f(void) {\"\n              \"    char buf[10];\\n\"\n              \"    memset(buf, 0, 10);\\n\"\n              \"    strcpy(buf, string);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"    char buf[10] = {0};\\n\"\n              \"    memset(buf, 0, 10);\\n\"\n              \"    strcpy(buf, string);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3] -> [test.cpp:4]: (performance) Buffer 'buf' is being written before its old content has been used.\\n\", errout_str());\n\n        // #5689 - use return value of strcpy\n        check(\"int f(void* a) {\\n\"\n              \"    int i = atoi(strcpy(a, foo));\\n\"\n              \"    strncpy(a, 0, bar);\\n\"\n              \"    return i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7175 - read+write\n        check(\"void f() {\\n\"\n              \"    char buf[100];\\n\"\n              \"    strcpy(buf, x);\\n\"\n              \"    strcpy(buf, dostuff(buf));\\n\" // <- read + write\n              \"    strcpy(buf, x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char buf[100];\\n\"\n              \"    strcpy(buf, x);\\n\"\n              \"    strcpy(buf, dostuff(buf));\\n\"\n              \"    strcpy(buf, x);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n    }\n\n    void redundantAssignmentSameValue() {\n        check(\"int main() {\\n\" // #11642\n              \"    int a = 0;\\n\"\n              \"    int b = a;\\n\"\n              \"    int c = 1;\\n\"\n              \"    a = b;\\n\"\n              \"    return a * b * c;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:5:5]: (style) Variable 'a' is assigned an expression that holds the same value. [redundantAssignment]\\n\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    int b = a;\\n\"\n              \"    int c = 1;\\n\"\n              \"    a = b + 1;\\n\"\n              \"    return a * b * c;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main() {\\n\"\n              \"    int a = 0;\\n\"\n              \"    int b = a;\\n\"\n              \"    int c = 1;\\n\"\n              \"    a = b = 5;\\n\"\n              \"    return a * b * c;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:11] -> [test.cpp:5:11]: (style) Redundant initialization for 'b'. The initialized value is overwritten before it is read. [redundantInitialization]\\n\", errout_str());\n\n        check(\"int f(int i) {\\n\" // #12874\n              \"    int j = i + 1;\\n\"\n              \"    if (i > 5)\\n\"\n              \"        j = i;\\n\"\n              \"    return j;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12894\n              \"    std::string a;\\n\"\n              \"    void f(const S& s);\\n\"\n              \"    void g(const S& s);\\n\"\n              \"};\\n\"\n              \"void S::f(const S& s) {\\n\"\n              \"    std::string x = a;\\n\"\n              \"    this->operator=(s);\\n\"\n              \"    a = x;\\n\"\n              \"}\\n\"\n              \"void S::g(const S& s) {\\n\"\n              \"    std::string x = a;\\n\"\n              \"    operator=(s);\\n\"\n              \"    a = x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void varFuncNullUB() { // #4482\n        check(\"void a(...);\\n\"\n              \"void b() { a(NULL); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (portability) Passing NULL after the last typed argument to a variadic function leads to undefined behaviour. [varFuncNullUB]\\n\", errout_str());\n\n        check(\"void a(char *p, ...);\\n\"\n              \"void b() { a(NULL, 2); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkCastIntToCharAndBack() { // #160\n\n        // check getchar\n        check(\"void f() {\\n\"\n              \"unsigned char c; c = getchar();\\n\"\n              \"  while( c != EOF)\\n\"\n              \"  {\\n\"\n              \"    bar(c);\\n\"\n              \"    c = getchar();\\n\"\n              \"  } ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (warning) Storing getchar() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"unsigned char c = getchar();\\n\"\n              \"  while( EOF != c)\\n\"\n              \"  {\\n\"\n              \"    bar(c);\\n\"\n              \"  } ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (warning) Storing getchar() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  unsigned char c; c = getchar();\\n\"\n              \"  while( EOF != c )\\n\"\n              \"  {\\n\"\n              \"    bar(c);\\n\"\n              \"    c = getchar();\\n\"\n              \"  } ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (warning) Storing getchar() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  unsigned char c;\\n\"\n              \"  while( EOF != ( c = getchar() ) )\\n\"\n              \"  {\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (warning) Storing getchar() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int i; i = getchar();\\n\"\n              \"  while( i != EOF)\\n\"\n              \"  {\\n\"\n              \"    bar(i);\\n\"\n              \"    i = getchar();\\n\"\n              \"  } ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int i; i = getchar();\\n\"\n              \"  while( EOF != i )\\n\"\n              \"  {\\n\"\n              \"    bar(i);\\n\"\n              \"    i = getchar();\\n\"\n              \"  } ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        // check getc\n        check(\"void f (FILE * pFile){\\n\"\n              \"unsigned char c;\\n\"\n              \"do {\\n\"\n              \"  c = getc (pFile);\\n\"\n              \"} while (c != EOF);\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (warning) Storing getc() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"unsigned char c;\\n\"\n              \"do {\\n\"\n              \"  c = getc (pFile);\\n\"\n              \"} while (EOF != c);\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (warning) Storing getc() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"int i;\\n\"\n              \"do {\\n\"\n              \"  i = getc (pFile);\\n\"\n              \"} while (i != EOF);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"int i;\\n\"\n              \"do {\\n\"\n              \"  i = getc (pFile);\\n\"\n              \"} while (EOF != i);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        // check fgetc\n        check(\"void f (FILE * pFile){\\n\"\n              \"unsigned char c;\\n\"\n              \"do {\\n\"\n              \"  c = fgetc (pFile);\\n\"\n              \"} while (c != EOF);\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (warning) Storing fgetc() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"char c;\\n\"\n              \"do {\\n\"\n              \"  c = fgetc (pFile);\\n\"\n              \"} while (EOF != c);\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (warning) Storing fgetc() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"signed char c;\\n\"\n              \"do {\\n\"\n              \"  c = fgetc (pFile);\\n\"\n              \"} while (EOF != c);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"int i;\\n\"\n              \"do {\\n\"\n              \"  i = fgetc (pFile);\\n\"\n              \"} while (i != EOF);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f (FILE * pFile){\\n\"\n              \"int i;\\n\"\n              \"do {\\n\"\n              \"  i = fgetc (pFile);\\n\"\n              \"} while (EOF != i);\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // cin.get()\n        check(\"void f(){\\n\"\n              \"   char ch; ch = std::cin.get();\\n\"\n              \"   while (EOF != ch) {\\n\"\n              \"        std::cout << ch;\\n\"\n              \"        ch = std::cin.get();\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (warning) Storing cin.get() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f(){\\n\"\n              \"   char ch; ch = std::cin.get();\\n\"\n              \"   while (ch != EOF) {\\n\"\n              \"        std::cout << ch;\\n\"\n              \"        ch = std::cin.get();\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (warning) Storing cin.get() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]\\n\", errout_str());\n\n        check(\"void f(){\\n\"\n              \"   int i; i = std::cin.get();\\n\"\n              \"   while ( EOF != i ) {\\n\"\n              \"        std::cout << i;\\n\"\n              \"        i = std::cin.get();\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(){\\n\"\n              \"   int i; i = std::cin.get();\\n\"\n              \"   while ( i != EOF ) {\\n\"\n              \"        std::cout << i;\\n\"\n              \"        i = std::cin.get();\\n\"\n              \"   }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkCommaSeparatedReturn() {\n        check(\"int fun(int a) {\\n\"\n              \"  if (a < 0)\\n\"\n              \"    return a++,\\n\"\n              \"  do_something();\\n\"\n              \"}\", true, false, false);\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Comma is used in return statement. The comma can easily be misread as a ';'.\\n\", \"\", errout_str());\n\n        check(\"int fun(int a) {\\n\"\n              \"  if (a < 0)\\n\"\n              \"    return a++, do_something();\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int fun(int a) {\\n\"\n              \"  if (a < 0)\\n\"\n              \"    return a+5,\\n\"\n              \"  do_something();\\n\"\n              \"}\", true, false, false);\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Comma is used in return statement. The comma can easily be misread as a ';'.\\n\", \"\", errout_str());\n\n        check(\"int fun(int a) {\\n\"\n              \"  if (a < 0)\\n\"\n              \"    return a+5, do_something();\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int fun(int a) {\\n\"\n              \"  if (a < 0)\\n\"\n              \"    return c<int,\\nint>::b;\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4943 take care of C++11 initializer lists\n        check(\"std::vector<Foo> Bar() {\\n\"\n              \"    return\\n\"\n              \"    {\\n\"\n              \"        { \\\"1\\\" },\\n\"\n              \"        { \\\"2\\\" },\\n\"\n              \"        { \\\"3\\\" }\\n\"\n              \"    };\\n\"\n              \"}\", true, false, false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkPassByReference() {\n        // #8570 passByValue when std::move is used\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    std::vector<int> x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"struct B\\n\"\n              \"{\\n\"\n              \"    explicit B(A a) : a(std::move(a)) {}\\n\"\n              \"    void Init(A _a) { a = std::move(_a); }\\n\"\n              \"    A a;\"\n              \"};\", true, false, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    std::vector<int> x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"struct B\\n\"\n              \"{\\n\"\n              \"    explicit B(A a) : a{std::move(a)} {}\\n\"\n              \"    void Init(A _a) { a = std::move(_a); }\\n\"\n              \"    A a;\"\n              \"};\", true, false, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    std::vector<int> x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"struct B\\n\"\n              \"{\\n\"\n              \"    B(A a, A a2) : a{std::move(a)}, a2{std::move(a2)} {}\\n\"\n              \"    void Init(A _a) { a = std::move(_a); }\\n\"\n              \"    A a;\"\n              \"    A a2;\"\n              \"};\", true, false, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    std::vector<int> x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"struct B\\n\"\n              \"{\\n\"\n              \"    B(A a, A a2) : a{std::move(a)}, a2{a2} {}\\n\"\n              \"    void Init(A _a) { a = std::move(_a); }\\n\"\n              \"    A a;\"\n              \"    A a2;\"\n              \"};\", true, false, true);\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (performance) Function parameter 'a2' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"struct A\\n\"\n              \"{\\n\"\n              \"    std::vector<int> x;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"struct B\\n\"\n              \"{\\n\"\n              \"    B(A a, A a2) : a{std::move(a)}, a2(a2) {}\\n\"\n              \"    void Init(A _a) { a = std::move(_a); }\\n\"\n              \"    A a;\"\n              \"    A a2;\"\n              \"};\", true, false, true);\n        ASSERT_EQUALS(\"[test.cpp:8:14]: (performance) Function parameter 'a2' should be passed by const reference. [passedByValue]\\n\", errout_str());\n\n        check(\"std::map<int, int> m;\\n\" // #10817\n              \"void f(const decltype(m)::const_iterator i) {}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int (*pf) (std::vector<int>) = nullptr;\\n\" // #12118\n              \"int f(std::vector<int> v) {\\n\"\n              \"    return v.size();\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    pf = f;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:10] -> [test.cpp:2:24]: (performance) Function parameter 'v' should be passed by const reference. However it seems that 'f' is a callback function. [passedByValueCallback]\\n\",\n                      errout_str());\n\n        check(\"template<typename T> struct A;\\n\" // #12621\n              \"template<typename T>\\n\"\n              \"struct B { A<T> a; };\\n\"\n              \"template<typename T>\\n\"\n              \"struct A { B<T> b; };\\n\"\n              \"template<typename T>\\n\"\n              \"struct C : public virtual A<T>, public virtual B<T> {\\n\"\n              \"    A<T> x;\\n\"\n              \"    B<T> y;\\n\"\n              \"    C(A<T> x_, B<T> y_) : x(x_), y(y_) {}\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n\n        check(\"template <typename T, int N>\\n\" // #13537\n              \"    struct S {\\n\"\n              \"    T a[N];\\n\"\n              \"};\\n\"\n              \"void f(S<char, 3> s) {}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        Settings settingsUnix32 = settingsBuilder().platform(Platform::Type::Unix32).build();\n        check(\"struct S {\\n\" // #13850\n              \"    int i0 : 32;\\n\"\n              \"    int i1 : 16;\\n\"\n              \"    unsigned short u16;\\n\"\n              \"};\\n\"\n              \"void f(S s) {}\\n\", true, true, true, false, &settingsUnix32);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkComparisonFunctionIsAlwaysTrueOrFalse() {\n        // positive test\n        check(\"bool f(int x){\\n\"\n              \"   return isless(x,x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Comparison of two identical variables with isless(x,x) always evaluates to false. [comparisonFunctionIsAlwaysTrueOrFalse]\\n\", errout_str());\n\n        check(\"bool f(int x){\\n\"\n              \"   return isgreater(x,x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Comparison of two identical variables with isgreater(x,x) always evaluates to false. [comparisonFunctionIsAlwaysTrueOrFalse]\\n\", errout_str());\n\n        check(\"bool f(int x){\\n\"\n              \"   return islessgreater(x,x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Comparison of two identical variables with islessgreater(x,x) always evaluates to false. [comparisonFunctionIsAlwaysTrueOrFalse]\\n\", errout_str());\n\n        check(\"bool f(int x){\\n\"\n              \"   return islessequal(x,x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Comparison of two identical variables with islessequal(x,x) always evaluates to true. [comparisonFunctionIsAlwaysTrueOrFalse]\\n\", errout_str());\n\n        check(\"bool f(int x){\\n\"\n              \"   return isgreaterequal(x,x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (warning) Comparison of two identical variables with isgreaterequal(x,x) always evaluates to true. [comparisonFunctionIsAlwaysTrueOrFalse]\\n\", errout_str());\n\n        // no warning should be reported for\n        check(\"bool f(int x, int y){\\n\"\n              \"   return isgreaterequal(x,y) && islessequal(x,y) && islessgreater(x,y) && isgreater(x,y) && isless(x,y);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void integerOverflow() { // 5895\n        // no signed integer overflow should happen\n        check(\"void f(unsigned long long ull) {\\n\"\n              \"    if (ull == 0x89504e470d0a1a0a || ull == 0x8a4d4e470d0a1a0a) ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantPointerOp() {\n        check(\"int *f(int *x) {\\n\"\n              \"    return &*x;\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Redundant pointer operation on 'x' - it's already a pointer. [redundantPointerOp]\\n\", errout_str());\n\n        check(\"int *f(int *y) {\\n\"\n              \"    return &(*y);\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) Redundant pointer operation on 'y' - it's already a pointer. [redundantPointerOp]\\n\", errout_str());\n\n        check(\"int f() {\\n\" // #10991\n              \"    int value = 4;\\n\"\n              \"    int result1 = *(&value);\\n\"\n              \"    int result2 = *&value;\\n\"\n              \"    return result1 + result2;\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (style) Redundant pointer operation on 'value' - it's already a variable. [redundantPointerOp]\\n\"\n                      \"[test.cpp:4:19]: (style) Redundant pointer operation on 'value' - it's already a variable. [redundantPointerOp]\\n\",\n                      errout_str());\n\n        check(\"void f(int& a, int b) {\\n\"\n              \"    *(&a) = b;\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Redundant pointer operation on 'a' - it's already a variable. [redundantPointerOp]\\n\",\n                      errout_str());\n\n        check(\"void f(int**& p) {}\\n\", true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define\tRESTORE(ORIG, COPY) { *ORIG = *COPY; }\\n\"\n               \"void f(int* p, int i) {\\n\"\n               \"    RESTORE(p, &i);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // no warning for bitwise AND\n        check(\"void f(const int *b) {\\n\"\n              \"    int x = 0x20 & *b;\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // No message for double pointers to structs\n        check(\"void f(struct foo **my_struct) {\\n\"\n              \"    char **pass_to_func = &(*my_struct)->buf;\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // another double pointer to struct - with an array\n        check(\"void f(struct foo **my_struct) {\\n\"\n              \"    char **pass_to_func = &(*my_struct)->buf[10];\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // double pointer to array\n        check(\"void f(char **ptr) {\\n\"\n              \"    int *x = &(*ptr)[10];\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (style) Variable 'x' can be declared as pointer to const [constVariablePointer]\\n\", errout_str());\n\n        // function calls\n        check(\"void f(Mutex *mut) {\\n\"\n              \"    pthread_mutex_lock(&*mut);\\n\"\n              \"}\\n\", true, false);\n        ASSERT_EQUALS(\"[test.cpp:2:24]: (style) Redundant pointer operation on 'mut' - it's already a pointer. [redundantPointerOp]\\n\", errout_str());\n\n        // make sure we got the AST match for \"(\" right\n        check(\"void f(char *ptr) {\\n\"\n              \"    if (&*ptr == NULL)\\n\"\n              \"        return;\\n\"\n              \"}\\n\", true, true);\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (style) Redundant pointer operation on 'ptr' - it's already a pointer. [redundantPointerOp]\\n\", errout_str());\n\n        // no warning for macros\n        checkP(\"#define MUTEX_LOCK(m) pthread_mutex_lock(&(m))\\n\"\n               \"void f(struct mutex *mut) {\\n\"\n               \"    MUTEX_LOCK(*mut);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define B(op)        bar(op)\\n\"\n               \"#define C(orf)       B(&orf)\\n\"\n               \"void foo(const int * pkey) {\\n\"\n               \"    C(*pkey);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void test_isSameExpression() { // see #5738\n        check(\"bool isInUnoIncludeFile(StringRef name) {\"\n              \"   return  name.startswith(SRCDIR \\\"/com/\\\") || name.startswith(SRCDIR \\\"/uno/\\\");\\n\"\n              \"};\", true, false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void raceAfterInterlockedDecrement() {\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    whatever();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (counter)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (!counter)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (counter > 0)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 < counter)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (counter == 0)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 == counter)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 != counter)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy()\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (counter != 0)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy()\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (counter <= 0)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 >= counter)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (newCount)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (!newCount)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (newCount > 0)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 < newCount)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (newCount == 0)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 == newCount)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 != newCount)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy()\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (newCount != 0)\\n\"\n                                  \"        return;\\n\"\n                                  \"    destroy()\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (newCount <= 0)\\n\"\n                                  \"        destroy();\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"void f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    int newCount = InterlockedDecrement(&counter);\\n\"\n                                  \"    if (0 >= newCount)\\n\"\n                                  \"        destroy;\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkInterlockedDecrement(\"int f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    if (InterlockedDecrement(&counter) == 0) {\\n\"\n                                  \"        destroy();\\n\"\n                                  \"        return 0;\\n\"\n                                  \"    } else {\\n\"\n                                  \"        return counter;\\n\"\n                                  \"    }\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:16]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"int f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    if (::InterlockedDecrement(&counter) == 0) {\\n\"\n                                  \"        destroy();\\n\"\n                                  \"        return 0;\\n\"\n                                  \"    } else {\\n\"\n                                  \"        return counter;\\n\"\n                                  \"    }\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:16]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n\n        checkInterlockedDecrement(\"int f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    if (InterlockedDecrement(&counter) == 0) {\\n\"\n                                  \"        destroy();\\n\"\n                                  \"        return 0;\\n\"\n                                  \"    }\\n\"\n                                  \"    return counter;\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:12]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"int f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    if (::InterlockedDecrement(&counter) == 0) {\\n\"\n                                  \"        destroy();\\n\"\n                                  \"        return 0;\\n\"\n                                  \"    }\\n\"\n                                  \"    return counter;\\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:12]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"int f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    if (InterlockedDecrement(&counter) == 0) {\\n\"\n                                  \"        destroy();\\n\"\n                                  \"        return 0;\\n\"\n                                  \"    } else\\n\"\n                                  \"        return counter;\\n\"\n                                  \"   \\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:16]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n\n        checkInterlockedDecrement(\"int f() {\\n\"\n                                  \"    int counter = 0;\\n\"\n                                  \"    if (::InterlockedDecrement(&counter) == 0) {\\n\"\n                                  \"        destroy();\\n\"\n                                  \"        return 0;\\n\"\n                                  \"    } else\\n\"\n                                  \"        return counter;\\n\"\n                                  \"   \\n\"\n                                  \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:16]: (error) Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead. [raceAfterInterlockedDecrement]\\n\", errout_str());\n    }\n\n    void testUnusedLabel() {\n        check(\"void f() {\\n\"\n              \"    label:\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Label 'label' is not used. [unusedLabel]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    label:\\n\"\n              \"    foo();\\n\"\n              \"    goto label;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    label:\\n\"\n              \"    foo();\\n\"\n              \"    goto label;\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    label:\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (style) Label 'label' is not used. [unusedLabel]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    switch(a) {\\n\"\n              \"        default:\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    class X {\\n\"\n              \"        protected:\\n\"\n              \"    };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    class X {\\n\"\n              \"        my_protected:\\n\"\n              \"    };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int test(char art) {\\n\"\n              \"    switch (art) {\\n\"\n              \"    caseZERO:\\n\"\n              \"        return 0;\\n\"\n              \"    case1:\\n\"\n              \"        return 1;\\n\"\n              \"    case 2:\\n\"\n              \"        return 2;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (warning) Label 'caseZERO' is not used. Should this be a 'case' of the enclosing switch()? [unusedLabelSwitch]\\n\"\n                      \"[test.cpp:5:5]: (warning) Label 'case1' is not used. Should this be a 'case' of the enclosing switch()? [unusedLabelSwitch]\\n\", errout_str());\n\n        check(\"int test(char art) {\\n\"\n              \"    switch (art) {\\n\"\n              \"    case 2:\\n\"\n              \"        return 2;\\n\"\n              \"    }\\n\"\n              \"    label:\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (style) Label 'label' is not used. [unusedLabel]\\n\", errout_str());\n    }\n\n    #define checkCustomSettings(...) checkCustomSettings_(__FILE__, __LINE__, __VA_ARGS__)\n    void checkCustomSettings_(const char* file, int line, const char code[], bool cpp = true, bool inconclusive = true, bool runSimpleChecks=true, bool verbose=false, Settings* settings = nullptr) {\n        if (!settings) {\n            settings = &_settings;\n        }\n        settings->certainty.setEnabled(Certainty::inconclusive, inconclusive);\n        settings->verbose = verbose;\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(*settings, *this, cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        runChecks<CheckOther>(tokenizer, this);\n\n        (void)runSimpleChecks; // TODO Remove this\n    }\n\n    void checkCustomSettings_(const char* file, int line, const char code[], Settings *s) {\n        checkCustomSettings_(file, line, code, true, true, true, false, s);\n    }\n\n    void testEvaluationOrder() {\n        check(\"void f() {\\n\"\n              \"  int x = dostuff();\\n\"\n              \"  return x + x++;\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"[test.c:3:12]: (error) Expression 'x+x++' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n\n        // #7226\n        check(\"long int f1(const char *exp) {\\n\"\n              \"  return strtol(++exp, (char **)&exp, 10);\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"long int f1(const char *exp) {\\n\"\n              \"  return dostuff(++exp, exp, 10);\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"[test.c:2:23]: (error) Expression '++exp,exp' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int a;\\n\"\n              \"  while (a=x(), a==123) {}\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 8717\n        check(\"void f(int argc, char *const argv[]) {\\n\"\n              \"    char **local_argv = safe_malloc(sizeof (*local_argv));\\n\"\n              \"    int local_argc = 0;\\n\"\n              \"    local_argv[local_argc++] = argv[0];\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  int x = 0;\\n\"\n              \"  return 0 + x++;\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x, int y) {\\n\"\n              \"  int a[10];\\n\"\n              \"  a[x+y] = a[y+x]++;;\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"[test.c:3:10]: (error) Expression 'a[x+y]=a[y+x]++' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"  int n = ++i + i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (error) Expression '++i+i' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n\n        check(\"long int f1(const char *exp) {\\n\"\n              \"  return dostuff(++exp, ++exp, 10);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (portability) Expression '++exp,++exp' depends on order of evaluation of side effects. Behavior is Unspecified according to c++17 [unknownEvaluationOrder]\\n\"\n                      \"[test.cpp:2:23]: (portability) Expression '++exp,++exp' depends on order of evaluation of side effects. Behavior is Unspecified according to c++17 [unknownEvaluationOrder]\\n\", errout_str());\n\n        check(\"void f(int i) {\\n\"\n              \"  int n = (~(-(++i)) + i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (error) Expression '~(-(++i))+i' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n\n        /*const*/ Settings settings11 = settingsBuilder(_settings).cpp(Standards::CPP11).build();\n\n        checkCustomSettings(\"void f(int i) {\\n\"\n                            \"  i = i++ + 2;\\n\"\n                            \"}\", &settings11);\n        ASSERT_EQUALS(\"[test.cpp:2:11]: (error) Expression 'i+++2' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n    }\n\n    void testEvaluationOrderSelfAssignment() {\n        // self assignment\n        check(\"void f() {\\n\"\n              \"  int x = x = y + 1;\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\n            \"[test.c:2:9]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\"\n            \"[test.c:2:9]: (style) Redundant assignment of 'x' to itself. [selfAssignment]\\n\",   // duplicate\n            errout_str());\n    }\n\n    void testEvaluationOrderMacro() {\n        // macro, don't bailout (#7233)\n        checkP(\"#define X x\\n\"\n               \"void f(int x) {\\n\"\n               \"  return x + X++;\\n\"\n               \"}\", dinit(CheckPOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:12]: (error) Expression 'x+x++' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n    }\n\n    void testEvaluationOrderSequencePointsFunctionCall() {\n        // FP\n        check(\"void f(int id) {\\n\"\n              \"  id = dostuff(id += 42);\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // FN\n        check(\"void f(int id) {\\n\"\n              \"  id = id + dostuff(id += 42);\\n\"\n              \"}\", false);\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n    }\n\n    void testEvaluationOrderSequencePointsComma() {\n        check(\"int f(void) {\\n\"\n              \"  int t;\\n\"\n              \"  return (unsigned char)(t=1,t^c);\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"  int t;\\n\"\n              \"  dostuff(t=1,t^c);\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"[test.c:3:14]: (error) Expression 't=1,t^c' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n\n        check(\"void f(void) {\\n\"\n              \"  int t;\\n\"\n              \"  dostuff((t=1,t),2);\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8230\n        check(\"void hprf(const char* fp) {\\n\"\n              \"    do\\n\"\n              \"        ;\\n\"\n              \"    while (++fp, (*fp) <= 0177);\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void hprf(const char* fp) {\\n\"\n              \"    do\\n\"\n              \"        ;\\n\"\n              \"    while (i++, ++fp, (*fp) <= 0177);\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const char* fp) {\\n\"\n              \"    do\\n\"\n              \"        ;\\n\"\n              \"    while (f(++fp, (*fp) <= 7));\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"[test.c:4:18]: (error) Expression '++fp,(*fp)<=7' depends on order of evaluation of side effects [unknownEvaluationOrder]\\n\", errout_str());\n    }\n\n    void testEvaluationOrderSizeof() {\n        check(\"void f(char *buf) {\\n\"\n              \"  dostuff(buf++, sizeof(*buf));\"\n              \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void testUnsignedLessThanZero() {\n        check(\"struct d {\\n\"\n              \"  unsigned n;\\n\"\n              \"};\\n\"\n              \"void f(void) {\\n\"\n              \"  struct d d;\\n\"\n              \"  d.n = 3;\\n\"\n              \"\\n\"\n              \"  if (d.n < 0) {\\n\"\n              \"    return;\\n\"\n              \"  }\\n\"\n              \"\\n\"\n              \"  if (0 > d.n) {\\n\"\n              \"    return;\\n\"\n              \"  }\\n\"\n              \"}\", false);\n        ASSERT_EQUALS(\"[test.c:8:11]: (style) Checking if unsigned expression 'd.n' is less than zero. [unsignedLessThanZero]\\n\"\n                      \"[test.c:12:9]: (style) Checking if unsigned expression 'd.n' is less than zero. [unsignedLessThanZero]\\n\",\n                      errout_str());\n    }\n\n    void doubleMove1() {\n        check(\"void g(A a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    g(std::move(a));\\n\"\n              \"    g(std::move(a));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:17]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void doubleMoveMemberInitialization1() {\n        check(\"class A\\n\"\n              \"{\\n\"\n              \"    A(B && b)\\n\"\n              \"    :b1(std::move(b))\\n\"\n              \"    {\\n\"\n              \"        b2 = std::move(b);\\n\"\n              \"    }\\n\"\n              \"    B b1;\\n\"\n              \"    B b2;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:6:24]: (warning) Access of moved variable 'b'. [accessMoved]\\n\", errout_str());\n    }\n\n    void doubleMoveMemberInitialization2() {\n        check(\"class A\\n\"\n              \"{\\n\"\n              \"    A(B && b)\\n\"\n              \"    :b1(std::move(b)),\\n\"\n              \"     b2(std::move(b))\\n\"\n              \"    {}\\n\"\n              \"    B b1;\\n\"\n              \"    B b2;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:19]: (warning) Access of moved variable 'b'. [accessMoved]\\n\", errout_str());\n    }\n\n    void doubleMoveMemberInitialization3() { // #9974\n        check(\"struct A { int i; };\\n\"\n              \"struct B { A a1; A a2; };\\n\"\n              \"B f() {\\n\"\n              \"    A a1 = { 1 };\\n\"\n              \"    A a2 = { 2 };\\n\"\n              \"    return { .a1 = std::move(a1), .a2 = std::move(a2) };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void doubleMoveMemberInitialization4() { // #11440\n        check(\"struct S { void f(int); };\\n\"\n              \"struct T {\\n\"\n              \"    T(int c, S&& d) : c{ c }, d{ std::move(d) } { d.f(c); }\\n\"\n              \"    int c;\\n\"\n              \"    S d;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:51]: (warning, inconclusive) Access of moved variable 'd'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndAssign1() {\n        check(\"A g(A a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    a = g(std::move(a));\\n\"\n              \"    a = g(std::move(a));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moveAndAssign2() {\n        check(\"A g(A a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    B b = g(std::move(a));\\n\"\n              \"    C c = g(std::move(a));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAssignMoveAssign() {\n        check(\"void h(A a);\\n\"\n              \"void f() {\"\n              \"    A a;\\n\"\n              \"    g(std::move(a));\\n\"\n              \"    h(a);\\n\"\n              \"    a = b;\\n\"\n              \"    h(a);\\n\"\n              \"    g(std::move(a));\\n\"\n              \"    h(a);\\n\"\n              \"    a = b;\\n\"\n              \"    h(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (warning) Access of moved variable 'a'. [accessMoved]\\n\"\n                      \"[test.cpp:8:7]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndReset1() {\n        check(\"A g(A a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    a.reset(g(std::move(a)));\\n\"\n              \"    a.reset(g(std::move(a)));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moveAndReset2() {\n        check(\"A g(A a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    A b;\\n\"\n              \"    A c;\\n\"\n              \"    b.reset(g(std::move(a)));\\n\"\n              \"    c.reset(g(std::move(a)));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:25]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveResetMoveReset() {\n        check(\"void h(A a);\\n\"\n              \"void f() {\"\n              \"    A a;\\n\"\n              \"    g(std::move(a));\\n\"\n              \"    h(a);\\n\"\n              \"    a.reset(b);\\n\"\n              \"    h(a);\\n\"\n              \"    g(std::move(a));\\n\"\n              \"    h(a);\\n\"\n              \"    a.reset(b);\\n\"\n              \"    h(a);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (warning) Access of moved variable 'a'. [accessMoved]\\n\"\n                      \"[test.cpp:8:7]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndFunctionParameter() {\n        check(\"void g(A a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    A b = std::move(a);\\n\"\n              \"    g(a);\\n\"\n              \"    A c = a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (warning) Access of moved variable 'a'. [accessMoved]\\n\"\n                      \"[test.cpp:6:11]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndFunctionParameterReference() {\n        check(\"void g(A & a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    A b = std::move(a);\\n\"\n              \"    g(a);\\n\"\n              \"    A c = a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moveAndFunctionParameterConstReference() {\n        check(\"void g(A const & a);\\n\"\n              \"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    A b = std::move(a);\\n\"\n              \"    g(a);\\n\"\n              \"    A c = a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (warning) Access of moved variable 'a'. [accessMoved]\\n\"\n                      \"[test.cpp:6:11]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndFunctionParameterUnknown() {\n        check(\"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    A b = std::move(a);\\n\"\n              \"    g(a);\\n\"\n              \"    A c = a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (warning, inconclusive) Access of moved variable 'a'. [accessMoved]\\n\"\n                      \"[test.cpp:5:11]: (warning, inconclusive) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndReturn() {\n        check(\"int f(int i) {\\n\"\n              \"    A a;\\n\"\n              \"    A b;\\n\"\n              \"    g(std::move(a));\\n\"\n              \"    if (i)\\n\"\n              \"        return g(std::move(b));\\n\"\n              \"    return h(std::move(a),std::move(b));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:24]: (warning) Access of moved variable 'a'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndClear() {\n        check(\"void f() {\\n\"\n              \"    V v;\\n\"\n              \"    g(std::move(v));\\n\"\n              \"    v.clear();\\n\"\n              \"    if (v.empty()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void movedPointer() {\n        check(\"void f() {\\n\"\n              \"    P p;\\n\"\n              \"    g(std::move(p));\\n\"\n              \"    x = p->x;\\n\"\n              \"    y = p->y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (warning) Access of moved variable 'p'. [accessMoved]\\n\"\n                      \"[test.cpp:5:9]: (warning) Access of moved variable 'p'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveAndAddressOf() {\n        check(\"void f() {\\n\"\n              \"    std::string s1 = x;\\n\"\n              \"    std::string s2 = std::move(s1);\\n\"\n              \"    p = &s1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void partiallyMoved() {\n        check(\"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    gx(std::move(a).x());\\n\"\n              \"    gy(std::move(a).y());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moveAndLambda() {\n        check(\"void f() {\\n\"\n              \"    A a;\\n\"\n              \"    auto h = [a=std::move(a)](){return g(std::move(a));};\"\n              \"    b = a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moveInLoop()\n    {\n        check(\"void g(std::string&& s);\\n\"\n              \"void f() {\\n\"\n              \"    std::string p;\\n\"\n              \"    while(true)\\n\"\n              \"        g(std::move(p));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:21]: (warning) Access of moved variable 'p'. [accessMoved]\\n\", errout_str());\n\n        check(\"std::list<int> g(std::list<int>&&);\\n\"\n              \"void f(std::list<int>l) {\\n\"\n              \"    for(int i = 0; i < 10; ++i) {\\n\"\n              \"        for (auto &j : g(std::move(l))) { (void)j; }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: (style) Variable 'j' can be declared as reference to const [constVariableReference]\\n\"\n                      \"[test.cpp:4:36]: (warning) Access of moved variable 'l'. [accessMoved]\\n\",\n                      errout_str());\n    }\n\n    void moveCallback()\n    {\n        check(\"bool f(std::function<void()>&& callback);\\n\"\n              \"void func(std::function<void()> callback) {\\n\"\n              \"    if(!f(std::move(callback)))\\n\"\n              \"        callback();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (warning) Access of moved variable 'callback'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveClassVariable()\n    {\n        check(\"struct B {\\n\"\n              \"    virtual void f();\\n\"\n              \"};\\n\"\n              \"struct D : B {\\n\"\n              \"    void f() override {\\n\"\n              \"        auto p = std::unique_ptr<D>(new D(std::move(m)));\\n\"\n              \"    }\\n\"\n              \"    D(std::unique_ptr<int> c) : m(std::move(c)) {}\\n\"\n              \"    std::unique_ptr<int> m;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void forwardAndUsed() {\n        check(\"template<typename T>\\n\"\n              \"void f(T && t) {\\n\"\n              \"    g(std::forward<T>(t));\\n\"\n              \"    T s = t;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (warning) Access of forwarded variable 't'. [accessForwarded]\\n\", errout_str());\n    }\n\n    void moveAndReference() { // #9791\n        check(\"void g(std::string&&);\\n\"\n              \"void h(const std::string&);\\n\"\n              \"void f() {\\n\"\n              \"    std::string s;\\n\"\n              \"    const std::string& r = s;\\n\"\n              \"    g(std::move(s));\\n\"\n              \"    h(r);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:7]: (warning) Access of moved variable 'r'. [accessMoved]\\n\", errout_str());\n    }\n\n    void moveForRange()\n    {\n        check(\"struct C {\\n\"\n              \"    void f() {\\n\"\n              \"        for (auto r : mCategory.find(std::move(mWhere))) {}\\n\"\n              \"    }\\n\"\n              \"    cif::category mCategory;\\n\"\n              \"    cif::condition mWhere;\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moveTernary()\n    {\n        check(\"void gA(std::string);\\n\" // #12174\n              \"void gB(std::string);\\n\"\n              \"void f(bool b) {\\n\"\n              \"    std::string s = \\\"abc\\\";\\n\"\n              \"    b ? gA(std::move(s)) : gB(std::move(s));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int gA(std::string);\\n\"\n              \"int gB(std::string);\\n\"\n              \"void h(int);\\n\"\n              \"void f(bool b) {\\n\"\n              \"    std::string s = \\\"abc\\\";\\n\"\n              \"    h(b ? gA(std::move(s)) : gB(std::move(s)));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int gA(int, std::string);\\n\"\n              \"int gB(int, std::string);\\n\"\n              \"int h(int);\\n\"\n              \"void f(bool b) {\\n\"\n              \"    std::string s = \\\"abc\\\";\\n\"\n              \"    h(b ? h(gA(5, std::move(s))) : h(gB(7, std::move(s))));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void movePointerAlias()\n    {\n        check(\"void f() {\\n\"\n              \"    std::string s;\\n\"\n              \"    std::string s1 = std::move(s);\\n\"\n              \"    const std::string* s_p = &s;\\n\"\n              \"    s_p->size();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (warning) Access of moved variable '.'. [accessMoved]\\n\", errout_str());\n    }\n\n    void funcArgNamesDifferent() {\n        check(\"void func1(int a, int b, int c);\\n\"\n              \"void func1(int a, int b, int c) { }\\n\"\n              \"void func2(int a, int b, int c);\\n\"\n              \"void func2(int A, int B, int C) { }\\n\"\n              \"class Fred {\\n\"\n              \"    void func1(int a, int b, int c);\\n\"\n              \"    void func2(int a, int b, int c);\\n\"\n              \"    void func3(int a = 0, int b = 0, int c = 0);\\n\"\n              \"    void func4(int a = 0, int b = 0, int c = 0);\\n\"\n              \"};\\n\"\n              \"void Fred::func1(int a, int b, int c) { }\\n\"\n              \"void Fred::func2(int A, int B, int C) { }\\n\"\n              \"void Fred::func3(int a, int b, int c) { }\\n\"\n              \"void Fred::func4(int A, int B, int C) { }\");\n        ASSERT_EQUALS(\"[test.cpp:3:16] -> [test.cpp:4:16]: (style, inconclusive) Function 'func2' argument 1 names different: declaration 'a' definition 'A'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:3:23] -> [test.cpp:4:23]: (style, inconclusive) Function 'func2' argument 2 names different: declaration 'b' definition 'B'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:3:30] -> [test.cpp:4:30]: (style, inconclusive) Function 'func2' argument 3 names different: declaration 'c' definition 'C'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:7:20] -> [test.cpp:12:22]: (style, inconclusive) Function 'func2' argument 1 names different: declaration 'a' definition 'A'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:7:27] -> [test.cpp:12:29]: (style, inconclusive) Function 'func2' argument 2 names different: declaration 'b' definition 'B'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:7:34] -> [test.cpp:12:36]: (style, inconclusive) Function 'func2' argument 3 names different: declaration 'c' definition 'C'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:9:20] -> [test.cpp:14:22]: (style, inconclusive) Function 'func4' argument 1 names different: declaration 'a' definition 'A'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:9:31] -> [test.cpp:14:29]: (style, inconclusive) Function 'func4' argument 2 names different: declaration 'b' definition 'B'. [funcArgNamesDifferent]\\n\"\n                      \"[test.cpp:9:42] -> [test.cpp:14:36]: (style, inconclusive) Function 'func4' argument 3 names different: declaration 'c' definition 'C'. [funcArgNamesDifferent]\\n\", errout_str());\n    }\n\n    void funcArgOrderDifferent() {\n        check(\"void func1(int a, int b, int c);\\n\"\n              \"void func1(int a, int b, int c) { }\\n\"\n              \"void func2(int a, int b, int c);\\n\"\n              \"void func2(int c, int b, int a) { }\\n\"\n              \"void func3(int, int b, int c);\\n\"\n              \"void func3(int c, int b, int a) { }\\n\"\n              \"class Fred {\\n\"\n              \"    void func1(int a, int b, int c);\\n\"\n              \"    void func2(int a, int b, int c);\\n\"\n              \"    void func3(int a = 0, int b = 0, int c = 0);\\n\"\n              \"    void func4(int, int b = 0, int c = 0);\\n\"\n              \"};\\n\"\n              \"void Fred::func1(int a, int b, int c) { }\\n\"\n              \"void Fred::func2(int c, int b, int a) { }\\n\"\n              \"void Fred::func3(int c, int b, int a) { }\\n\"\n              \"void Fred::func4(int c, int b, int a) { }\\n\",\n              true, false);\n        ASSERT_EQUALS(\"[test.cpp:3:16] -> [test.cpp:4:16]: (warning) Function 'func2' argument order different: declaration 'a, b, c' definition 'c, b, a' [funcArgOrderDifferent]\\n\"\n                      \"[test.cpp:5:12] -> [test.cpp:6:16]: (warning) Function 'func3' argument order different: declaration ', b, c' definition 'c, b, a' [funcArgOrderDifferent]\\n\"\n                      \"[test.cpp:9:20] -> [test.cpp:14:22]: (warning) Function 'func2' argument order different: declaration 'a, b, c' definition 'c, b, a' [funcArgOrderDifferent]\\n\"\n                      \"[test.cpp:10:20] -> [test.cpp:15:22]: (warning) Function 'func3' argument order different: declaration 'a, b, c' definition 'c, b, a' [funcArgOrderDifferent]\\n\"\n                      \"[test.cpp:11:16] -> [test.cpp:16:22]: (warning) Function 'func4' argument order different: declaration ', b, c' definition 'c, b, a' [funcArgOrderDifferent]\\n\", errout_str());\n    }\n\n    // #7846 - Syntax error when using C++11 braced-initializer in default argument\n    void cpp11FunctionArgInit() {\n        // syntax error is not expected\n        ASSERT_NO_THROW(check(\"\\n void foo(int declaration = {}) {\"\n                              \"\\n   for (int i = 0; i < 10; i++) {}\\n\"\n                              \"\\n }\"\n                              \"\\n  \"));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void shadowVariables() {\n        check(\"int x;\\n\"\n              \"void f() { int x; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:5] -> [test.cpp:2:16]: (style) Local variable 'x' shadows outer variable [shadowVariable]\\n\", errout_str());\n\n        check(\"int x();\\n\"\n              \"void f() { int x; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:5] -> [test.cpp:2:16]: (style) Local variable 'x' shadows outer function [shadowFunction]\\n\", errout_str());\n\n        check(\"struct C {\\n\"\n              \"    C(int x) : x(x) {}\\n\" // <- we do not want a FP here\n              \"    int x;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if (cond) {int x;}\\n\" // <- not a shadow variable\n              \"  int x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int size() {\\n\"\n              \"  int size;\\n\" // <- not a shadow variable\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #8954 - lambda\n              \"  int x;\\n\"\n              \"  auto f = [](){ int x; }\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x) { int x; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:12] -> [test.cpp:1:21]: (style) Local variable 'x' shadows outer argument [shadowArgument]\\n\", errout_str());\n\n        check(\"class C { C(); void foo() { static int C = 0; } }\"); // #9195 - shadow constructor\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct C {\\n\" // #10091 - shadow destructor\n              \"    ~C();\\n\"\n              \"    void f() {\\n\"\n              \"        bool C{};\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"C::~C() = default;\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // 10752 - no\n        check(\"struct S {\\n\"\n              \"    int i;\\n\"\n              \"\\n\"\n              \"    static int foo() {\\n\"\n              \"        int i = 0;\\n\"\n              \"        return i;\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    int i{};\\n\"\n              \"    void f() { int i; }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:20]: (style) Local variable 'i' shadows outer variable [shadowVariable]\\n\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    int i{};\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    void f() const { for (const int& i : v) {} }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:4:38]: (style) Local variable 'i' shadows outer variable [shadowVariable]\\n\", errout_str());\n\n        check(\"struct S {\\n\" // #10405\n              \"    F* f{};\\n\"\n              \"    std::list<F> fl;\\n\"\n              \"    void S::f() const;\\n\"\n              \"};\\n\"\n              \"void S::f() const {\\n\"\n              \"    for (const F& f : fl) {}\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:8] -> [test.cpp:7:19]: (style) Local variable 'f' shadows outer variable [shadowVariable]\\n\", errout_str());\n\n        check(\"extern int a;\\n\"\n              \"int a;\\n\"\n              \"static int f(void) {\\n\"\n              \"    int a;\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\", false);\n        ASSERT_EQUALS(\"[test.c:1:12] -> [test.c:4:9]: (style) Local variable 'a' shadows outer variable [shadowVariable]\\n\", errout_str());\n\n        check(\"int f() {\\n\" // #12591\n              \"    int g = 0;\\n\"\n              \"    return g;\\n\"\n              \"}\\n\"\n              \"int g() { return 1; }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #13888\n              \"    int i;\\n\"\n              \"    friend int f() { int i = 5; return i; }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void knownArgument() {\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"   g((x & 0x01) >> 7);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) Argument '(x&0x01)>>7' to function g is always 0. It does not matter what value 'x' has. [knownArgument]\\n\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"   g((int)((x & 0x01) >> 7));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (style) Argument '(int)((x&0x01)>>7)' to function g is always 0. It does not matter what value 'x' has. [knownArgument]\\n\", errout_str());\n\n        check(\"void g(int, int);\\n\"\n              \"void f(int x) {\\n\"\n              \"   g(x, (x & 0x01) >> 7);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:20]: (style) Argument '(x&0x01)>>7' to function g is always 0. It does not matter what value 'x' has. [knownArgument]\\n\",\n            errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"    g(0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void h() { return 1; }\\n\"\n              \"void f(int x) {\\n\"\n              \"    g(h());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"    g(std::strlen(\\\"a\\\"));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"    g((int)0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(Foo *);\\n\"\n              \"void f() {\\n\"\n              \"    g(reinterpret_cast<Foo*>(0));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"    x = 0;\\n\"\n              \"    g(x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f() {\\n\"\n              \"    const int x = 0;\\n\"\n              \"    g(x + 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f() {\\n\"\n              \"    char i = 1;\\n\"\n              \"    g(static_cast<int>(i));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"char *yytext;\\n\"\n              \"void re_init_scanner() {\\n\"\n              \"  int size = 256;\\n\"\n              \"  yytext = xmalloc(size * sizeof *yytext);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const char *c) {\\n\"\n              \"    if (*c == '+' && (operand || !isalnum(*c))) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8986\n        check(\"void f(int);\\n\"\n              \"void g() {\\n\"\n              \"    const int x[] = { 10, 10 };\\n\"\n              \"    f(x[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int);\\n\"\n              \"void g() {\\n\"\n              \"    int x[] = { 10, 10 };\\n\"\n              \"    f(x[0]);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Variable 'x' can be declared as const array [constVariable]\\n\", errout_str());\n\n        check(\"struct A { int x; };\"\n              \"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"    A y;\\n\"\n              \"    y.x = 1;\\n\"\n              \"    g(y.x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // allow known argument value in assert call\n        check(\"void g(int);\\n\"\n              \"void f(int x) {\\n\"\n              \"   ASSERT((int)((x & 0x01) >> 7));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9905 - expression that does not use integer calculation at all\n        check(\"void foo() {\\n\"\n              \"    const std::string heading = \\\"Interval\\\";\\n\"\n              \"    std::cout << std::setw(heading.length());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9909 - struct member with known value\n        check(\"struct LongStack {\\n\"\n              \"    int maxsize;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void growLongStack(LongStack* self) {\\n\"\n              \"    self->maxsize = 32;\\n\"\n              \"    dostuff(self->maxsize * sizeof(intptr_t));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11894\n        check(\"struct S {\\n\"\n              \"    int *p, n;\\n\"\n              \"};\\n\"\n              \"S* g() {\\n\"\n              \"    S* s = static_cast<S*>(calloc(1, sizeof(S)));\\n\"\n              \"    s->n = 100;\\n\"\n              \"    s->p = static_cast<int*>(malloc(s->n * sizeof(int)));\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11679\n        check(\"bool g(int);\\n\"\n              \"void h(int);\\n\"\n              \"int k(int a) { h(a); return 0; }\\n\"\n              \"void f(int i) {\\n\"\n              \"    if (g(k(i))) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11889\n        check(\"struct S {\\n\"\n              \"    int a[5];\\n\"\n              \"    void f(int i);\\n\"\n              \"}\\n\"\n              \"void g(int);\\n\"\n              \"void S::f(int i) {\\n\"\n              \"    if (a[i] == 1) {\\n\"\n              \"        a[i] = 0;\\n\"\n              \"        g(a[i]);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11927\n        check(\"void f(func_t func, int i) {\\n\"\n              \"    (func)(i, 0);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { void operator()(int, int); };\\n\"\n              \"void f(int i) {\\n\"\n              \"    S()(i, 1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int& r) {\\n\"\n              \"    g(static_cast<char>(r = 42));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int i; };\\n\"\n              \"void f(int i) {\\n\"\n              \"    const int a[] = { i - 1 * i, 0 };\\n\"\n              \"    auto s = S{ i - 1 * i };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:25]: (style) Argument 'i-1*i' to init list { is always 0. It does not matter what value 'i' has. [knownArgument]\\n\"\n                      \"[test.cpp:4:19]: (style) Argument 'i-1*i' to constructor S is always 0. It does not matter what value 'i' has. [knownArgument]\\n\",\n                      errout_str());\n\n        checkP(\"#define MACRO(X) std::abs(X ? 0 : a)\\n\"\n               \"int f(int a) {\\n\"\n               \"    return MACRO(true);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void knownArgumentHiddenVariableExpression() {\n        // #9914 - variable expression is explicitly hidden\n        check(\"void f(int x) {\\n\"\n              \"    dostuff(x && false);\\n\"\n              \"    dostuff(false && x);\\n\"\n              \"    dostuff(x || true);\\n\"\n              \"    dostuff(true || x);\\n\"\n              \"    dostuff(x * 0);\\n\"\n              \"    dostuff(0 * x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (style) Argument 'false&&x' to function dostuff is always 0. Constant literal calculation disable/hide variable expression 'x'. [knownArgumentHiddenVariableExpression]\\n\"\n                      \"[test.cpp:5:18]: (style) Argument 'true||x' to function dostuff is always 1. Constant literal calculation disable/hide variable expression 'x'. [knownArgumentHiddenVariableExpression]\\n\"\n                      \"[test.cpp:6:15]: (style) Argument 'x*0' to function dostuff is always 0. Constant literal calculation disable/hide variable expression 'x'. [knownArgumentHiddenVariableExpression]\\n\"\n                      \"[test.cpp:7:15]: (style) Argument '0*x' to function dostuff is always 0. Constant literal calculation disable/hide variable expression 'x'. [knownArgumentHiddenVariableExpression]\\n\", errout_str());\n    }\n\n    void knownArgumentTernaryOperator() { // #10374\n        check(\"void f(bool a, bool b) {\\n\"\n              \"    const T* P = nullptr; \\n\"\n              \"    long N = 0; \\n\"\n              \"    const bool c = foo(); \\n\"\n              \"    bar(P, N); \\n\"\n              \"    if (c ? a : b)\\n\"\n              \"      baz(P, N); \\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkComparePointers() {\n        check(\"int f() {\\n\"\n              \"    const int foo[1] = {0};\\n\"\n              \"    const int bar[1] = {0};\\n\"\n              \"    int diff = 0;\\n\"\n              \"    if(foo > bar) {\\n\"\n              \"       diff = 1;\\n\"\n              \"    }\\n\"\n              \"    return diff;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:15] -> [test.cpp:5:8] -> [test.cpp:3:15] -> [test.cpp:5:14] -> [test.cpp:5:12]: (error) Comparing pointers that point to different objects [comparePointers]\\n\",\n            errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    int y = 0;\\n\"\n              \"    int* xp = &x;\\n\"\n              \"    int* yp = &y;\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:9] -> [test.cpp:4:15] -> [test.cpp:3:9] -> [test.cpp:5:15] -> [test.cpp:6:15]: (error) Comparing pointers that point to different objects [comparePointers]\\n\"\n            \"[test.cpp:4:10]: (style) Variable 'xp' can be declared as pointer to const [constVariablePointer]\\n\"\n            \"[test.cpp:5:10]: (style) Variable 'yp' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    int y = 1;\\n\"\n              \"    return &x > &y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:9] -> [test.cpp:4:12] -> [test.cpp:3:9] -> [test.cpp:4:17] -> [test.cpp:4:15]: (error) Comparing pointers that point to different objects [comparePointers]\\n\",\n            errout_str());\n\n        check(\"struct A {int data;};\\n\"\n              \"bool f() {\\n\"\n              \"    A x;\\n\"\n              \"    A y;\\n\"\n              \"    int* xp = &x.data;\\n\"\n              \"    int* yp = &y.data;\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:7] -> [test.cpp:5:15] -> [test.cpp:4:7] -> [test.cpp:6:15] -> [test.cpp:7:15]: (error) Comparing pointers that point to different objects [comparePointers]\\n\"\n            \"[test.cpp:5:10]: (style) Variable 'xp' can be declared as pointer to const [constVariablePointer]\\n\"\n            \"[test.cpp:6:10]: (style) Variable 'yp' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"struct A {int data;};\\n\"\n              \"bool f(A ix, A iy) {\\n\"\n              \"    A* x = &ix;\\n\"\n              \"    A* y = &iy;\\n\"\n              \"    int* xp = &x->data;\\n\"\n              \"    int* yp = &y->data;\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:10] -> [test.cpp:3:12] -> [test.cpp:5:15] -> [test.cpp:2:16] -> [test.cpp:4:12] -> [test.cpp:6:15] -> [test.cpp:7:15]: (error) Comparing pointers that point to different objects [comparePointers]\\n\"\n            \"[test.cpp:5:10]: (style) Variable 'xp' can be declared as pointer to const [constVariablePointer]\\n\"\n            \"[test.cpp:6:10]: (style) Variable 'yp' can be declared as pointer to const [constVariablePointer]\\n\",\n            errout_str());\n\n        check(\"bool f(int * xp, int* yp) {\\n\"\n              \"    return &xp > &yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:14] -> [test.cpp:2:12] -> [test.cpp:1:23] -> [test.cpp:2:18] -> [test.cpp:2:16]: (error) Comparing pointers that point to different objects [comparePointers]\\n\",\n            errout_str());\n\n        check(\"int f() {\\n\"\n              \"    int x = 0;\\n\"\n              \"    int y = 1;\\n\"\n              \"    return &x - &y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:9] -> [test.cpp:4:12] -> [test.cpp:3:9] -> [test.cpp:4:17] -> [test.cpp:4:15]: (error) Subtracting pointers that point to different objects [subtractPointers]\\n\",\n            errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    int x[2] = {1, 2}m;\\n\"\n              \"    int* xp = &x[0];\\n\"\n              \"    int* yp = &x[1];\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (style) Variable 'xp' can be declared as pointer to const [constVariablePointer]\\n\"\n                      \"[test.cpp:4:10]: (style) Variable 'yp' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str());\n\n        check(\"bool f(const int * xp, const int* yp) {\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(const int & x, const int& y) {\\n\"\n              \"    return &x > &y;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int& g();\\n\"\n              \"bool f() {\\n\"\n              \"    const int& x = g();\\n\"\n              \"    const int& y = g();\\n\"\n              \"    const int* xp = &x;\\n\"\n              \"    const int* yp = &y;\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {int data;};\\n\"\n              \"bool f(A ix) {\\n\"\n              \"    A* x = &ix;\\n\"\n              \"    A* y = x;\\n\"\n              \"    int* xp = &x->data;\\n\"\n              \"    int* yp = &y->data;\\n\"\n              \"    return xp > yp;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (style) Variable 'xp' can be declared as pointer to const [constVariablePointer]\\n\"\n                      \"[test.cpp:6:10]: (style) Variable 'yp' can be declared as pointer to const [constVariablePointer]\\n\",\n                      errout_str());\n\n        check(\"struct S { int i; };\\n\" // #11576\n              \"int f(S s) {\\n\"\n              \"    return &s.i - (int*)&s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (warning) Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]\\n\", errout_str());\n\n        check(\"struct S { int i; };\\n\"\n              \"int f(S s1, S s2) {\\n\"\n              \"    return &s1.i - reinterpret_cast<int*>(&s2);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:12] -> [test.cpp:2:15] -> [test.cpp:3:43] -> [test.cpp:3:18]: (error) Subtracting pointers that point to different objects [subtractPointers]\\n\",\n                      errout_str());\n\n        check(\"struct S { int a; int b; };\\n\" // #12422\n              \"int f() {\\n\"\n              \"    S s;\\n\"\n              \"    return &s.b - &s.a;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void unusedVariableValueTemplate() {\n        check(\"#include <functional>\\n\"\n              \"class A\\n\"\n              \"{\\n\"\n              \"public:\\n\"\n              \"    class Hash\\n\"\n              \"    {\\n\"\n              \"    public:\\n\"\n              \"        std::size_t operator()(const A& a) const\\n\"\n              \"        {\\n\"\n              \"            (void)a;\\n\"\n              \"            return 0;\\n\"\n              \"        }\\n\"\n              \"    };\\n\"\n              \"};\\n\"\n              \"namespace std\\n\"\n              \"{\\n\"\n              \"    template <>\\n\"\n              \"    struct hash<A>\\n\"\n              \"    {\\n\"\n              \"        std::size_t operator()(const A& a) const noexcept\\n\"\n              \"        {\\n\"\n              \"            return A::Hash{}(a);\\n\"\n              \"        }\\n\"\n              \"    };\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void moduloOfOne() {\n        check(\"void f(unsigned int x) {\\n\"\n              \"  int y = x % 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:13]: (style) Modulo of one is always equal to zero [moduloofone]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  for (int x = 1; x < 10; x++) {\\n\"\n              \"    int y = 100 % x;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int i, int j) {\\n\" // #11191\n              \"    const int c = pow(2, i);\\n\"\n              \"    if (j % c) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void sameExpressionPointers() {\n        check(\"int f(int *i);\\n\"\n              \"void g(int *a, const int *b) {\\n\"\n              \"    int c = *a;\\n\"\n              \"    f(a);\\n\"\n              \"    if (b && c != *a) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkOverlappingWrite() {\n        // union\n        check(\"void foo() {\\n\"\n              \"    union { int i; float f; } u;\\n\"\n              \"    u.i = 0;\\n\"\n              \"    u.i = u.f;\\n\" // <- error\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Overlapping read/write of union is undefined behavior [overlappingWriteUnion]\\n\", errout_str());\n\n        check(\"void foo() {\\n\" // #11013\n              \"    union { struct { uint8_t a; uint8_t b; }; uint16_t c; } u;\\n\"\n              \"    u.a = u.b = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // memcpy\n        check(\"void foo() {\\n\"\n              \"    char a[10];\\n\"\n              \"    memcpy(&a[5], &a[4], 2u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char a[10];\\n\"\n              \"    memcpy(a+5, a+4, 2u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char a[10];\\n\"\n              \"    memcpy(a, a+1, 2u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    char a[8];\\n\"\n              \"    memcpy(&a[0], &a[4], 4u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"_Bool a[10];\\n\" // #10350\n              \"void foo() {\\n\"\n              \"    memcpy(&a[5], &a[4], 2u * sizeof(a[0]));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        check(\"int K[2];\\n\" // #12638\n              \"void f(int* p) {\\n\"\n              \"    memcpy(&K[0], &K[1], sizeof(K[0]));\\n\"\n              \"    memcpy(&K[1], &K[0], sizeof(K[0]));\\n\"\n              \"    memcpy(p, p + 1, sizeof(*p));\\n\"\n              \"    memcpy(p + 1, p, sizeof(*p));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int K[2];\\n\"\n              \"void f(int* p) {\\n\"\n              \"    memcpy(&K[0], &K[1], 2 * sizeof(K[0]));\\n\"\n              \"    memcpy(&K[1], &K[0], 2 *sizeof(K[0]));\\n\"\n              \"    memcpy(p, p + 1, 2 * sizeof(*p));\\n\"\n              \"    memcpy(p + 1, p, 2 * sizeof(*p));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\"\n                      \"[test.cpp:4:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\"\n                      \"[test.cpp:5:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\"\n                      \"[test.cpp:6:5]: (error) Overlapping read/write in memcpy() is undefined behavior [overlappingWriteFunction]\\n\",\n                      errout_str());\n\n        // wmemcpy\n        check(\"void foo() {\\n\"\n              \"    wchar_t a[10];\\n\"\n              \"    wmemcpy(&a[5], &a[4], 2u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in wmemcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    wchar_t a[10];\\n\"\n              \"    wmemcpy(a+5, a+4, 2u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in wmemcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    wchar_t a[10];\\n\"\n              \"    wmemcpy(a, a+1, 2u);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Overlapping read/write in wmemcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n\n        // strcpy\n        check(\"void foo(char *ptr) {\\n\"\n              \"    strcpy(ptr, ptr);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (error) Overlapping read/write in strcpy() is undefined behavior [overlappingWriteFunction]\\n\", errout_str());\n    }\n\n    void constVariableArrayMember() { // #10371\n        check(\"class Foo {\\n\"\n              \"public:\\n\"\n              \"    Foo();\\n\"\n              \"    int GetVal() const { return m_Arr[0]; }\\n\"\n              \"    int m_Arr[1];\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void knownPointerToBool()\n    {\n        check(\"void g(bool);\\n\"\n              \"void f() {\\n\"\n              \"    int i = 5;\\n\"\n              \"    int* p = &i;\\n\"\n              \"    g(p);\\n\"\n              \"    g(&i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (style) Pointer expression 'p' converted to bool is always true. [knownPointerToBool]\\n\"\n                      \"[test.cpp:6:7]: (style) Pointer expression '&i' converted to bool is always true. [knownPointerToBool]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const int* x = nullptr;\\n\"\n              \"    std::empty(x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    const int* x = nullptr;\\n\"\n              \"    std::empty(const_cast<int*>(x));\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { bool x; };\\n\"\n              \"bool f(A* a) {\\n\"\n              \"    if (a) {\\n\"\n              \"        return a->x;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A { int* x; };\\n\"\n              \"bool f(A a) {\\n\"\n              \"    if (a.x) {\\n\"\n              \"        return a.x;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:17]: (style) Pointer expression 'a.x' converted to bool is always true. [knownPointerToBool]\\n\", errout_str());\n\n        check(\"void f(bool* b) { if (b) *b = true; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    int* x = nullptr;\\n\"\n              \"    return bool(x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) Pointer expression 'x' converted to bool is always false. [knownPointerToBool]\\n\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    int* x = nullptr;\\n\"\n              \"    return bool{x};\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (style) Pointer expression 'x' converted to bool is always false. [knownPointerToBool]\\n\", errout_str());\n\n        check(\"struct A { A(bool); };\\n\"\n              \"A f() {\\n\"\n              \"    int* x = nullptr;\\n\"\n              \"    return A(x);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (style) Pointer expression 'x' converted to bool is always false. [knownPointerToBool]\\n\", errout_str());\n\n        check(\"struct A { A(bool); };\\n\"\n              \"A f() {\\n\"\n              \"    int* x = nullptr;\\n\"\n              \"    return A{x};\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (style) Pointer expression 'x' converted to bool is always false. [knownPointerToBool]\\n\", errout_str());\n\n        check(\"struct B { virtual void f() {} };\\n\" // #11929\n              \"struct D : B {};\\n\"\n              \"void g(B* b) {\\n\"\n              \"    if (!b)\\n\"\n              \"        return;\\n\"\n              \"    if (dynamic_cast<D*>(b)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool (*ptr)();\\n\" // #12170\n              \"void f() {\\n\"\n              \"    if (!ptr || !ptr()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g(bool b[2]);\\n\" // #12822\n              \"void f() {\\n\"\n              \"    bool b[2] = {};\\n\"\n              \"    g(b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterateByValue() {\n        check(\"void f() {\\n\" // #9684\n              \"    const std::set<std::string> ss = { \\\"a\\\", \\\"b\\\", \\\"c\\\" };\\n\"\n              \"    for (auto s : ss)\\n\"\n              \"        (void)s.size();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (performance) Range variable 's' should be declared as const reference. [iterateByValue]\\n\",\n                      errout_str());\n        check(\"void f() {\\n\" // #13696\n              \"    struct T {\\n\"\n              \"        std::string name;\\n\"\n              \"        UnknownClass member;\\n\"\n              \"    };\\n\"\n              \"\\n\"\n              \"    const std::set<T> ss;\\n\"\n              \"    for (auto s : ss)\\n\"\n              \"        (void)s.name;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:15]: (performance) Range variable 's' should be declared as const reference. [iterateByValue]\\n\",\n                      errout_str());\n    }\n\n    void knownConditionFloating()\n    {\n        check(\"void foo() {\\n\" // #11200\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:16] -> [test.cpp:3:11]: (style) The comparison 'f > 1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float f = 1.0;\\n\"\n              \"    if (f > -1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:2] -> [test.cpp:3]: (style) The comparison 'f > -1.0' is always false.\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13506\n              \"    float f = 1.0;\\n\"\n              \"    if (f > +1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:16] -> [test.cpp:3:11]: (style) The comparison 'f > +1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    float f = 1.0;\\n\"\n              \"    if (f < +1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:16] -> [test.cpp:3:11]: (style) The comparison 'f < 1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #11200\n              \"    float pf = +1.0;\\n\"\n              \"    if (pf > 1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:18] -> [test.cpp:3:12]: (style) The comparison 'pf > 1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float pf = +1.0;\\n\"\n              \"    if (pf > -1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:2] -> [test.cpp:3]: (style) The comparison 'pf > -1.0' is always false.\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13506\n              \"    float pf = +1.0;\\n\"\n              \"    if (pf > +1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:18] -> [test.cpp:3:12]: (style) The comparison 'pf > +1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    float pf = +1.0;\\n\"\n              \"    if (pf < +1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:18] -> [test.cpp:3:12]: (style) The comparison 'pf < 1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #11200\n              \"    float nf = -1.0;\\n\"\n              \"    if (nf > -1.0) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:18] -> [test.cpp:3:12]: (style) The comparison 'nf > -1.0' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float nf = -1.0;\\n\"\n              \"    if (nf > 1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:2] -> [test.cpp:3]: (style) The comparison 'nf > 1.0' is always false.\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float nf = -1.0;\\n\"\n              \"    if (nf > +1.0) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:2] -> [test.cpp:3]: (style) The comparison 'nf > +1.0' is always false.\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1.00f) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:16] -> [test.cpp:3:11]: (style) The comparison 'f > 1.00f' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float f = 1.0f;\\n\"\n              \"    if (f > 1) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:2] -> [test.cpp:3]: (style) The comparison 'f > 1' is always false.\\n\",\n            \"\",\n            errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1.00) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:16] -> [test.cpp:3:11]: (style) The comparison 'f > 1.00' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13508\n              \"    float f = 1.0;\\n\"\n              \"    if (f > 1) {}\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:2] -> [test.cpp:3]: (style) The comparison 'f > 1' is always false.\\n\",\n            \"\",\n            errout_str());\n    }\n\n    void knownConditionPrefixed()\n    {\n        check(\"void foo() {\\n\"\n              \"    int i = 1;\\n\"\n              \"    if (i < +1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:13] -> [test.cpp:3:11]: (style) The comparison 'i < 1' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n\n        check(\"void foo() {\\n\" // #13506\n              \"    int i = 1;\\n\"\n              \"    if (i > +1) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:13] -> [test.cpp:3:11]: (style) The comparison 'i > +1' is always false. [knownConditionTrueFalse]\\n\",\n            errout_str());\n    }\n};\n\nREGISTER_TEST(TestOther)\n"
    }
  ]
}