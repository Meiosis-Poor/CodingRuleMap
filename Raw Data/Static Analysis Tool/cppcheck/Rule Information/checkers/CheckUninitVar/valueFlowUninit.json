{
  "name": "valueFlowUninit",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 76,
  "branches": 26,
  "apis": 84,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        5471
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"check.h\"\n#include \"checkuninitvar.h\"\n#include \"ctu.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n\n#include <list>\n#include <string>\n\nclass TestUninitVar : public TestFixture {\npublic:\n    TestUninitVar() : TestFixture(\"TestUninitVar\") {}\n\nprivate:\n    const Settings settings = settingsBuilder().library(\"std.cfg\").build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(uninitvar1);\n        TEST_CASE(uninitvar_warn_once); // only write 1 warning at a time\n        TEST_CASE(uninitvar_decl);      // handling various types in C and C++ files\n        TEST_CASE(uninitvar_bitop);     // using uninitialized operand in bit operation\n        TEST_CASE(uninitvar_alloc);     // data is allocated but not initialized\n        TEST_CASE(uninitvar_arrays);    // arrays\n        TEST_CASE(uninitvar_class);     // class/struct\n        TEST_CASE(uninitvar_enum);      // enum variables\n        TEST_CASE(uninitvar_if);        // handling if\n        TEST_CASE(uninitvar_loops);     // handling for/while\n        TEST_CASE(uninitvar_switch);    // handling switch\n        TEST_CASE(uninitvar_references); // references\n        TEST_CASE(uninitvar_return);    // return\n        TEST_CASE(uninitvar_assign);    // = {..}\n        TEST_CASE(uninitvar_strncpy);   // strncpy doesn't always null-terminate\n        TEST_CASE(func_uninit_var);     // analyse function calls for: 'int a(int x) { return x+x; }'\n        TEST_CASE(func_uninit_pointer); // analyse function calls for: 'void a(int *p) { *p = 0; }'\n        TEST_CASE(uninitvar_typeof);    // typeof\n        TEST_CASE(uninitvar_ignore);    // ignore cast, *&x, ..\n        TEST_CASE(uninitvar2);\n        TEST_CASE(uninitvar3);          // #3844\n        TEST_CASE(uninitvar4);          // #3869 (reference)\n        TEST_CASE(uninitvar5);          // #3861\n        TEST_CASE(uninitvar6);          // #13227\n        TEST_CASE(uninitvar2_func);     // function calls\n        TEST_CASE(uninitvar2_value);    // value flow\n        TEST_CASE(valueFlowUninit2_value);\n        TEST_CASE(valueFlowUninit_uninitvar2);\n        TEST_CASE(valueFlowUninit_functioncall);\n        TEST_CASE(uninitStructMember);  // struct members\n        TEST_CASE(uninitvar2_while);\n        TEST_CASE(uninitvar2_4494);      // #4494\n        TEST_CASE(uninitvar2_malloc);    // malloc returns uninitialized data\n        TEST_CASE(uninitvar8); // ticket #6230\n        TEST_CASE(uninitvar9); // ticket #6424\n        TEST_CASE(uninitvar10); // ticket #9467\n        TEST_CASE(uninitvar11); // ticket #9123\n        TEST_CASE(uninitvar12); // #10218 - stream read\n        TEST_CASE(uninitvar13); // #9772\n        TEST_CASE(uninitvar14);\n        TEST_CASE(uninitvar_unconditionalTry);\n        TEST_CASE(uninitvar_funcptr); // #6404\n        TEST_CASE(uninitvar_operator); // #6680\n        TEST_CASE(uninitvar_ternaryexpression); // #4683\n        TEST_CASE(uninitvar_pointertoarray);\n        TEST_CASE(uninitvar_cpp11ArrayInit); // #7010\n        TEST_CASE(uninitvar_rangeBasedFor); // #7078\n        TEST_CASE(uninitvar_static); // #8734\n        TEST_CASE(uninitvar_configuration);\n        TEST_CASE(checkExpr);\n        TEST_CASE(trac_4871);\n        TEST_CASE(syntax_error); // Ticket #5073\n        TEST_CASE(trac_5970);\n        TEST_CASE(valueFlowUninitTest);\n        TEST_CASE(valueFlowUninitBreak);\n        TEST_CASE(valueFlowUninitStructMembers);\n        TEST_CASE(valueFlowUninitForLoop);\n        TEST_CASE(uninitvar_ipa);\n        TEST_CASE(uninitvar_memberfunction);\n        TEST_CASE(uninitvar_nonmember); // crash in ycmd test\n        TEST_CASE(uninitvarDesignatedInitializers);\n\n        TEST_CASE(isVariableUsageDeref); // *p\n        TEST_CASE(isVariableUsageDerefValueflow); // *p\n\n        TEST_CASE(uninitvar_memberaccess); // (&(a))->b <=> a.b\n\n        // whole program analysis\n        TEST_CASE(ctuTest);\n    }\n\n    struct CheckUninitVarOptions\n    {\n        CheckUninitVarOptions() = default;\n        bool cpp = true;\n        bool debugwarnings = false;\n        const Settings *s = nullptr;\n    };\n\n#define checkUninitVar(...) checkUninitVar_(__FILE__, __LINE__, __VA_ARGS__)\n    void checkUninitVar_(const char* file, int line, const char code[], const CheckUninitVarOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.s ? *options.s : settings).debugwarnings(options.debugwarnings).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this, options.cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for redundant code..\n        CheckUninitVar checkuninitvar(&tokenizer, &settings1, this);\n        checkuninitvar.check();\n    }\n\n    void uninitvar1() {\n        // extracttests.start: int b; int c;\n\n        // Ticket #2207 - False negative\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int a;\\n\"\n                       \"    b = c - a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int a;\\n\"\n                       \"    b = a - c;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        // Ticket #6455 - some compilers allow const variables to be uninitialized\n        // extracttests.disable\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    const int a;\\n\"\n                       \"    b = c - a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n        // extracttests.enable\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int *p;\\n\"\n                       \"    realloc(p,10);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\" // #5240\n                       \"    char *p = malloc(100);\\n\"\n                       \"    char *tmp = realloc(p,1000);\\n\"\n                       \"    if (!tmp) free(p);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int *p = NULL;\\n\"\n                       \"    realloc(p,10);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // dereferencing uninitialized pointer..\n        // extracttests.start: struct Foo { void abcd(); };\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    Foo *p;\\n\"\n                       \"    p->abcd();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: template<class T> struct Foo { void abcd(); };\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    Foo<int> *p;\\n\"\n                       \"    p->abcd();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: struct Foo { void* a; };\n        checkUninitVar(\"void f(Foo *p)\\n\"\n                       \"{\\n\"\n                       \"    int a;\\n\"\n                       \"    p->a = malloc(4 * a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:23]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *p;\\n\"\n                       \"    delete p;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *p;\\n\"\n                       \"    delete [] p;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *p;\\n\"\n                       \"    *p = 135;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *p;\\n\"\n                       \"    p[0] = 135;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *x;\\n\"\n                       \"    int y = *x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *x;\\n\"\n                       \"    int &y(*x);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    int x;\\n\"\n                       \"    int *y = &x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    int *x;\\n\"\n                       \"    int *&y = x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    int x = xyz::x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int a;\\n\"\n                       \"    a = 5 + a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int a;\\n\"\n                       \"    a++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    extern int a;\\n\"\n                       \"    a++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: void bar(int);\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int a;\\n\"\n                       \"    bar(4 * a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (i);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    for (int x = 0; i < 10; x++);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:21]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    for (int x = 0; x < 10; i++);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:29]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo(int x)\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x)\\n\"\n                       \"        i = 0;\\n\"\n                       \"    i++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int ar[10];\\n\"\n                       \"    int i;\\n\"\n                       \"    ar[i] = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    int x, y;\\n\"\n                       \"    x = (y = 10);\\n\"\n                       \"    int z = y * 2;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void foo() {\\n\"\n                       \"    int x, y;\\n\"\n                       \"    x = ((y) = 10);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #3597\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a;\\n\"\n                       \"    int b = 1;\\n\"\n                       \"    (b += a) = 1;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int a,b,c;\\n\"\n                       \"    a = b = c;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:0]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    Foo p;\\n\"\n                       \"    p.abcd();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void foo()\\n\"\n                       \"{\\n\"\n                       \"    Foo p;\\n\"\n                       \"    int x = p.abcd();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown types\n        // extracttests.disable\n        {\n            checkUninitVar(\"void a()\\n\"\n                           \"{\\n\"\n                           \"    A ret;\\n\"\n                           \"    return ret;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"void a()\\n\"\n                           \"{\\n\"\n                           \"    A ret;\\n\"\n                           \"    return ret;\\n\"\n                           \"}\\n\",\n                           dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"[test.c:4:12]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n        }\n        // extracttests.enable\n\n        // #3916 - avoid false positive\n        checkUninitVar(\"void f(float x) {\\n\"\n                       \"  union lf { long l; float f; } u_lf;\\n\"\n                       \"  float hx = (u_lf.f = (x), u_lf.l);\\n\"\n                       \"}\",\n                       dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a()\\n\"\n                       \"{\\n\"\n                       \"    int x[10];\\n\"\n                       \"    int *y = x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a()\\n\"\n                       \"{\\n\"\n                       \"    int x;\\n\"\n                       \"    int *y = &x;\\n\"\n                       \"    *y = 0;\\n\"\n                       \"    x++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a()\\n\"\n                       \"{\\n\"\n                       \"    char x[10], y[10];\\n\"\n                       \"    char *z = x;\\n\"\n                       \"    memset(z, 0, sizeof(x));\\n\"\n                       \"    memcpy(y, x, sizeof(x));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Handling >> and <<\n        {\n            checkUninitVar(\"int a() {\\n\"\n                           \"    int ret;\\n\"\n                           \"    std::cin >> ret;\\n\"\n                           \"    ret++;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"void f(int b) {\\n\"\n                           \"    int a;\\n\"\n                           \"    std::cin >> b >> a;\\n\"\n                           \"    return a;\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"void f() {\\n\"\n                           \"    int ret[2];\\n\"\n                           \"    std::cin >> ret[0];\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"void f(int i) {\\n\"\n                           \"    int a;\\n\"\n                           \"    i >> a;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:10]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"int a() {\\n\"\n                           \"    int ret;\\n\"\n                           \"    int a = value >> ret;\\n\"\n                           \"}\\n\",\n                           dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"[test.c:3:22]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"void foo() {\\n\"   // #3707\n                           \"    Node node;\\n\"\n                           \"    int x;\\n\"\n                           \"    node[\\\"abcd\\\"] >> x;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"int a(FArchive &arc) {\\n\"   // #3060 (initialization through operator<<)\n                           \"    int *p;\\n\"\n                           \"    arc << p;\\n\" // <- TODO initialization?\n                           \"    return *p;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"void a() {\\n\"\n                           \"    int ret;\\n\"\n                           \"    a = value << ret;\\n\"\n                           \"}\\n\",\n                           dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"[test.c:3:18]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n\n            // #4320 says this is a FP. << is overloaded.\n            checkUninitVar(\"int f() {\\n\"\n                           \"    int a;\\n\"\n                           \"    a << 1;\\n\"  // <- TODO initialization?\n                           \"    return a;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n            // #4673\n            checkUninitVar(\"void f() {\\n\"\n                           \"    int a;\\n\"\n                           \"    std::cout << a;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:18]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"void f(std::ostringstream& os) {\\n\"\n                           \"    int a;\\n\"\n                           \"    os << a;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:11]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"void f() {\\n\"\n                           \"    int a;\\n\"\n                           \"    std::cout << 1 << a;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"void f(std::ostringstream& os) {\\n\"\n                           \"    int a;\\n\"\n                           \"    os << 1 << a;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n            {\n                // #9422\n                checkUninitVar(\"void f() {\\n\"\n                               \"  char *p = new char[10];\\n\"\n                               \"  std::cout << (void *)p << 1;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"\", errout_str());\n\n                checkUninitVar(\"void f() {\\n\"\n                               \"  char p[10];\\n\"\n                               \"  std::cout << (void *)p << 1;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"\", errout_str());\n\n                checkUninitVar(\"void f() {\\n\"\n                               \"  char *p = new char[10];\\n\"\n                               \"  std::cout << p << 1;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n                checkUninitVar(\"void f() {\\n\" // #9696\n                               \"  int *p = new int[10];\\n\"\n                               \"  std::cout << p << 1;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"\", errout_str());\n\n                checkUninitVar(\"void f() {\\n\"\n                               \"  int i[10];\\n\"\n                               \"  std::cout << i;\\n\"\n                               \"  char c[10];\\n\"\n                               \"  std::cout << c;\\n\"\n                               \"  wchar_t w[10];\\n\"\n                               \"  std::cout << w;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"[test.cpp:5:16]: (error) Uninitialized variable: c [legacyUninitvar]\\n\"\n                              \"[test.cpp:7:16]: (error) Uninitialized variable: w [legacyUninitvar]\\n\",\n                              errout_str());\n\n                checkUninitVar(\"void f() {\\n\"\n                               \"  char p[10];\\n\"\n                               \"  std::cout << p << 1;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n                checkUninitVar(\"void f() {\\n\"\n                               \"  char p[10];\\n\"\n                               \"  std::cout << *p << 1;\\n\"\n                               \"}\");\n                ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n            }\n        }\n\n        // #8494 : Overloaded & operator\n        checkUninitVar(\"void f() {\\n\"\n                       \"  int x;\\n\"\n                       \"  a & x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int a) {\\n\"\n                       \"  int x;\\n\"\n                       \"  a & x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  int a,b,c;\\n\"\n                       \"  ar & a & b & c;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a() {\\n\"   // asm\n                       \"    int x;\\n\"\n                       \"    asm();\\n\"\n                       \"    x++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a()\\n\"\n                       \"{\\n\"\n                       \"    int x[10];\\n\"\n                       \"    struct xyz xyz1 = { .x = x };\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a()\\n\"\n                       \"{\\n\"\n                       \"    struct S *s;\\n\"\n                       \"    s->x = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: s [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"   char *buf = malloc(100);\\n\"\n                       \"   struct ABC *abc = buf;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"class Fred {\\n\"\n                       \"public:\\n\"\n                       \"    FILE *f;\\n\"\n                       \"    ~Fred();\\n\"\n                       \"}\\n\"\n                       \"Fred::~Fred()\\n\"\n                       \"{\\n\"\n                       \"    fclose(f);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int c;\\n\"\n                       \"    ab(sizeof(xyz), &c);\\n\"\n                       \"    if (c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int c;\\n\"\n                       \"    a = (f2(&c));\\n\"\n                       \"    c++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int a)\\n\"\n                       \"{\\n\"\n                       \"    if (a) {\\n\"\n                       \"        char *p;\\n\"\n                       \"        *p = 0;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        // +=\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int c;\\n\"\n                       \"    c += 2;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int a[10];\\n\"\n                       \"    a[0] = 10 - a[1];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Uninitialized variable: a[1] [legacyUninitvar]\\n\", errout_str());\n\n        // goto/setjmp/longjmp..\n        checkUninitVar(\"void foo(int x)\\n\"\n                       \"{\\n\"\n                       \"    long b;\\n\"\n                       \"    if (g()) {\\n\"\n                       \"        b =2;\\n\"\n                       \"        goto found;\\n\"\n                       \"    }\\n\"\n                       \"\\n\"\n                       \"    return;\\n\"\n                       \"\\n\"\n                       \"found:\\n\"\n                       \"    int a = b;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"    jmp_buf env;\\n\"\n                       \"    int a;\\n\"\n                       \"    int val = setjmp(env);\\n\"\n                       \"    if(val)\\n\"\n                       \"        return a;\\n\"\n                       \"    a = 1;\\n\"\n                       \"    longjmp(env, 1);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // macro_for..\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"  int retval;\\n\"\n                       \"  if (condition) {\\n\"\n                       \"    for12(1,2) { }\\n\"\n                       \"    retval = 1;\\n\"\n                       \"  }\\n\"\n                       \"  else\\n\"\n                       \"    retval = 2;\\n\"\n                       \"  return retval;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    goto exit;\\n\"\n                       \"    i++;\\n\"\n                       \"exit:\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int x,y=0;\\n\"\n                       \"again:\\n\"\n                       \"    if (y) return x;\\n\"\n                       \"    x = a;\\n\"\n                       \"    y = 1;\\n\"\n                       \"    goto again;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #3873 (false positive)\n        checkUninitVar(\"MachineLoopRange *MachineLoopRanges::getLoopRange(const MachineLoop *Loop) {\\n\"\n                       \"  MachineLoopRange *&Range = Cache[Loop];\\n\"\n                       \"  if (!Range)\\n\"\n                       \"    Range = new MachineLoopRange(Loop, Allocator, *Indexes);\\n\"\n                       \"  return Range;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4040 - False positive\n        checkUninitVar(\"int f(int x)  {\\n\"\n                       \"    int iter;\\n\"\n                       \"    {\\n\"\n                       \"        union\\n\"\n                       \"        {\\n\"\n                       \"            int asInt;\\n\"\n                       \"            double asDouble;\\n\"\n                       \"        };\\n\"\n                       \"\\n\"\n                       \"        iter = x;\\n\"\n                       \"    }\\n\"\n                       \"    return 1 + iter;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // C++11 style initialization\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int i = 0;\\n\"\n                       \"    int j{ i };\\n\"\n                       \"    return j;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #5646\n        checkUninitVar(\"float foo() {\\n\"\n                       \"  float source[2] = {3.1, 3.1};\\n\"\n                       \"  float (*sink)[2] = &source;\\n\"\n                       \"  return (*sink)[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #9296\n        checkUninitVar(\"void f(void)\\n\"\n                       \"{\\n\"\n                       \"    int x;\\n\"\n                       \"    int z = (x) & ~__round_mask(1, 1);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(void)\\n\"\n                       \"{\\n\"\n                       \"    int x;\\n\"\n                       \"    int z = (x) | ~__round_mask(1, 1);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int __round_mask(int, int);\\n\"\n                       \"void f(void)\\n\"\n                       \"{\\n\"\n                       \"    int x;\\n\"\n                       \"    int* z = &x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_warn_once() {\n        // extracttests.start: int a; int b;\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  int x;\\n\"\n                       \"  a = x;\\n\"\n                       \"  b = x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n    }\n\n    // Handling of unknown types. Assume they are POD in C.\n    void uninitvar_decl() {\n        const char code[] = \"void f() {\\n\"\n                            \"    dfs a;\\n\"\n                            \"    return a;\\n\"\n                            \"}\";\n\n        // Assume dfs is a non POD type if file is C++\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Assume dfs is a POD type if file is C\n        checkUninitVar(code, dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:12]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        const char code2[] = \"struct AB { int a,b; };\\n\"\n                             \"void f() {\\n\"\n                             \"    struct AB ab;\\n\"\n                             \"    return ab;\\n\"\n                             \"}\";\n        checkUninitVar(code2);\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\"\n                      \"[test.cpp:4:12]: (error) Uninitialized struct member: ab.b [uninitStructMember]\\n\", errout_str());\n        checkUninitVar(code2, dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:4:12]: (error) Uninitialized variable: ab [legacyUninitvar]\\n\", errout_str());\n\n        // Ticket #3890 - False positive for std::map\n        checkUninitVar(\"void f() {\\n\"\n                       \"    std::map<int,bool> x;\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #3906 - False positive for std::vector pointer\n        checkUninitVar(\"void f() {\\n\"\n                       \"    std::vector<int> *x = NULL;\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            // Ticket #6701 - Variable name is a POD type according to cfg\n            constexpr char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                       \"<def format=\\\"1\\\">\"\n                                       \"  <podtype name=\\\"_tm\\\"/>\"\n                                       \"</def>\";\n            const Settings s = settingsBuilder(settings).libraryxml(xmldata).build();\n            checkUninitVar(\"void f() {\\n\"\n                           \"  Fred _tm;\\n\"\n                           \"  _tm.dostuff();\\n\"\n                           \"}\", dinit(CheckUninitVarOptions, $.s = &s));\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        // Ticket #7822 - Array type\n        checkUninitVar(\"A *f() {\\n\"\n                       \"    A a,b;\\n\"\n                       \"    b[0] = 0;\"\n                       \"    return a;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar3() { // #3844\n        // avoid false positive\n        checkUninitVar(\"namespace std _GLIBCXX_VISIBILITY(default)\\n\"\n                       \"{\\n\"\n                       \"_GLIBCXX_BEGIN_NAMESPACE_CONTAINER\\n\"\n                       \"    typedef unsigned long _Bit_type;\\n\"\n                       \"    struct _Bit_reference\\n\"\n                       \"    {\\n\"\n                       \"        _Bit_type * _M_p;\\n\"\n                       \"        _Bit_type _M_mask;\\n\"\n                       \"        _Bit_reference(_Bit_type * __x, _Bit_type __y)\\n\"\n                       \"         : _M_p(__x), _M_mask(__y) { }\\n\"\n                       \"    };\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_bitop() {\n        // extracttests.start: int a; int c;\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int b;\\n\"\n                       \"    c = a | b;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: b [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int b;\\n\"\n                       \"    c = b | a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: b [legacyUninitvar]\\n\", errout_str());\n    }\n\n    // if..\n    void uninitvar_if() {\n        // extracttests.start: struct Foo { void abcd(); };\n        checkUninitVar(\"static void foo(int x)\\n\"\n                       \"{\\n\"\n                       \"    Foo *p;\\n\"\n                       \"    if (x)\\n\"\n                       \"        p = new Foo;\\n\"\n                       \"    p->abcd();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static void foo(int x)\\n\"\n                       \"{\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x==1);\\n\"\n                       \"    if (x==2);\\n\"\n                       \"    x = a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (1)\\n\"\n                       \"        i = 11;\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int bar(int x) {\\n\"\n                       \"    int n;\\n\"\n                       \"    if ( x == 23)\\n\"\n                       \"      n = 1;\\n\"\n                       \"    else if ( x == 11 )\\n\"\n                       \"      n = 2;\\n\"\n                       \"    return n;\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x)\\n\"\n                       \"        i = 22;\\n\"\n                       \"    else\\n\"\n                       \"        i = 33;\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo(int x)\\n\" // #5503\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x < 2)\\n\"\n                       \"        i = 22;\\n\"\n                       \"    else if (x >= 2)\\n\" // condition is always true\n                       \"        i = 33;\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x)\\n\"\n                       \"        i = 22;\\n\"\n                       \"    else\\n\"\n                       \"    {\\n\"\n                       \"        char *y = {0};\\n\"\n                       \"        i = 33;\\n\"\n                       \"    }\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x)\\n\"\n                       \"    {\\n\"\n                       \"        struct abc abc1 = (struct abc) { .a=0, .b=0, .c=0 };\\n\"\n                       \"        i = 22;\\n\"\n                       \"    }\\n\"\n                       \"    else\\n\"\n                       \"    {\\n\"\n                       \"        i = 33;\\n\"\n                       \"    }\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void foo(int x)\\n\"\n                       \"{\\n\"\n                       \"    Foo *p;\\n\"\n                       \"    if (x)\\n\"\n                       \"        p = new Foo;\\n\"\n                       \"    if (x)\\n\"\n                       \"        p->abcd();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(int a)\\n\"\n                       \"{\\n\"\n                       \"    int n;\\n\"\n                       \"    int condition;\\n\"\n                       \"    if(a == 1) {\\n\"\n                       \"        n=0;\\n\"\n                       \"        condition=0;\\n\"\n                       \"    }\\n\"\n                       \"    else {\\n\"\n                       \"        n=1;\\n\"\n                       \"    }\\n\"\n                       \"\\n\"\n                       \"    if( n == 0) {\\n\"\n                       \"        a=condition;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    C *c;\\n\"\n                       \"    if (fun(&c));\\n\"\n                       \"    c->Release();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    C c;\\n\"\n                       \"    if (fun(&c.d));\\n\"\n                       \"    return c;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"   char a[10];\\n\"\n                       \"   if (a[0] = x){}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo(int x)\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (one())\\n\"\n                       \"        i = 1;\\n\"\n                       \"    else\\n\"\n                       \"        return 3;\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #2207 - False positive\n        checkUninitVar(\"void foo(int x) {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x)\\n\"\n                       \"        a = 1;\\n\"\n                       \"    if (!x)\\n\"\n                       \"        return;\\n\"\n                       \"    b = (c - a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"    int ret;\\n\"\n                       \"    if (one())\\n\"\n                       \"        ret = 1;\\n\"\n                       \"    else\\n\"\n                       \"        throw 3;\\n\"\n                       \"    return ret;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int a)\\n\"\n                       \"{\\n\"\n                       \"    int ret;\\n\"\n                       \"    if (a == 1)\\n\"\n                       \"        ret = 1;\\n\"\n                       \"    else\\n\"\n                       \"        XYZ ret = 2;\\n\"  // XYZ may be an unexpanded macro so bailout the checking of \"ret\".\n                       \"    return ret;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:12]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f(int a, int b)\\n\"\n                       \"{\\n\"\n                       \"   int x;\\n\"\n                       \"   if (a)\\n\"\n                       \"      x = a;\\n\"\n                       \"   else {\\n\"\n                       \"      do { } while (f2());\\n\"\n                       \"      x = b;\\n\"\n                       \"   }\\n\"\n                       \"   return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(long verbose,bool bFlag)\\n\"\n                       \"{\\n\"\n                       \"  double t;\\n\"\n                       \"  if (bFlag)\\n\"\n                       \"  {\\n\"\n                       \"    if (verbose)\\n\"\n                       \"      t = 1;\\n\"\n                       \"    if (verbose)\\n\"\n                       \"      std::cout << (12-t);\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int test(int cond1, int cond2) {\\n\"\n                       \"  int foo;\\n\"\n                       \"  if (cond1 || cond2) {\\n\"\n                       \"     if (cond2)\\n\"\n                       \"        foo = 0;\\n\"\n                       \"  }\\n\"\n                       \"  if (cond2) {\\n\"\n                       \"    int t = foo*foo;\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(int *pix) {\\n\"\n                       \"    int dest_x;\\n\"\n                       \"    {\\n\"\n                       \"        if (pix)\\n\"\n                       \"            dest_x = 123;\\n\"\n                       \"    }\\n\"\n                       \"    if (pix)\\n\"\n                       \"        a = dest_x;\\n\" // <- not uninitialized\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ? :\n        checkUninitVar(\"static void foo(int v) {\\n\"\n                       \"    int x;\\n\"\n                       \"    x = v <= 0 ? -1 : x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    const char *msgid1, *msgid2;\\n\"\n                       \"    int ret = bar(&msgid1);\\n\"\n                       \"    if (ret > 0) {\\n\"\n                       \"        ret = bar(&msgid2);\\n\"\n                       \"    }\\n\"\n                       \"    ret = ret <= 0 ? -1 :\\n\"\n                       \"          strcmp(msgid1, msgid2) == 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(int a, int b)\\n\"\n                       \"{\\n\"\n                       \"    int x; x = (a<b) ? 1 : 0;\\n\"\n                       \"    int y = y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: y [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\" // pidgin-2.11.0/finch/libgnt/gnttree.c\n                       \"  int x = (x = bar()) ? x : 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ; { .. }\n        checkUninitVar(\"int foo()\\n\"\n                       \"{\\n\"\n                       \"  int retval;\\n\"\n                       \"  if (condition) {\\n\"\n                       \"    { }\\n\"\n                       \"    retval = 1; }\\n\"\n                       \"  else\\n\"\n                       \"    retval = 2;\\n\"\n                       \"  return retval;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"  {\\n\"\n                       \"    for (int i = 0; i < 10; ++i)\\n\"\n                       \"    { }\\n\"\n                       \"  }\\n\"\n                       \"\\n\"\n                       \"  { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ({ .. })\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (abc) { x = 123; }\\n\"\n                       \"    else { a = ({b=c;}); x = 456; }\\n\"\n                       \"    ++x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #3098 - False negative uninitialized variable\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char *c1,*c2;\\n\"\n                       \"    if(strcoll(c1,c2))\\n\"\n                       \"    {\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (error) Uninitialized variable: c1 [legacyUninitvar]\\n\"\n                      \"[test.cpp:4:19]: (error) Uninitialized variable: c2 [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(char *c1, char *c2)\\n\"\n                       \"{\\n\"\n                       \"    if(strcoll(c1,c2))\\n\"\n                       \"    {\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char *c1;\\n\"\n                       \"    c1=strcpy(c1,\\\"test\\\");\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (error) Uninitialized variable: c1 [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(char *c1)\\n\"\n                       \"{\\n\"\n                       \"    c1=strcpy(c1,\\\"test\\\");\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  X var;\\n\"\n                       \"  memset(var, 0, sizeof(var));\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\" // #8692\n                       \"    bool b = e();\\n\"\n                       \"    int v;\\n\"\n                       \"    if (b)\\n\"\n                       \"        doStuff(&v);\\n\"\n                       \"    int v2 = (b) ? v / 5 : 0;\\n\"\n                       \"    int v3;\\n\"\n                       \"    if (b)\\n\"\n                       \"        v3 = 50;\\n\"\n                       \"    int v4 = (b) ? v3 + 5 : 0;\\n\"\n                       \"    int v5;\\n\"\n                       \"    int v6 = v5;\\n\"\n                       \"    doStuff(&v5);\\n\"\n                       \"    int v7 = v5;\\n\"\n                       \"    return v2 + v4 + v6 + v7;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:12:14]: (error) Uninitialized variable: v5 [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"bool set(int *p);\\n\"\n                       \"\\n\"\n                       \"void foo(bool a) {\\n\"\n                       \"    bool flag{false};\\n\"\n                       \"    int x;\\n\"\n                       \"    if (!a) {\\n\"\n                       \"        flag = set(&x);\\n\"\n                       \"    }\\n\"\n                       \"    if (!flag || x == 0) {}\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int n, int a) {\\n\" // #12011\n                       \"    double x[10];\\n\"\n                       \"    if (n == 1) {\\n\"\n                       \"        if (a)\\n\"\n                       \"            x[0] = 4;\\n\"\n                       \"    }\\n\"\n                       \"    else\\n\"\n                       \"        for (int i = 0; i < n; i++) {\\n\"\n                       \"            if (a)\\n\"\n                       \"                x[i] = 8;\\n\"\n                       \"        }\\n\"\n                       \"    if (n == 1)\\n\"\n                       \"        if (a)\\n\"\n                       \"            (void)x[0];\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    // handling for/while loops..\n    void uninitvar_loops() {\n        // for..\n        // extracttests.start: void b(int);\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    for (int i = 0; i < 4; ++i) {\\n\"\n                       \"        int a;\\n\"\n                       \"        b(4*a);\\n\"\n                       \"    }\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int k;\\n\"\n                       \"    for (int i = 0; i < 4; ++i) {\\n\"\n                       \"        k = k + 2;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: k [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    gchar sel[10];\\n\"\n                       \"    for (int i = 0; i < 4; ++i) {\\n\"\n                       \"        int sz = sizeof(sel);\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"enum ABCD { A, B, C, D };\\n\"\n                       \"\\n\"\n                       \"static void f(char *str ) {\\n\"\n                       \"    enum ABCD i;\\n\"\n                       \"    for (i = 0; i < D; i++) {\\n\"\n                       \"        str[i] = 0;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void x() {\\n\"\n                       \"    do  {\\n\"\n                       \"        Token * tok;\\n\"\n                       \"        for (tok = a; tok; tok = tok->next())\\n\"\n                       \"        {\\n\"\n                       \"        }\\n\"\n                       \"    } while (tok2);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(void) {\\n\"\n                       \"    int a = 0;\\n\"\n                       \"    int x;\\n\"\n                       \"\\n\"\n                       \"    for (;;) {\\n\"\n                       \"        if (!a || 12 < x) {\\n\" // <- x is not uninitialized\n                       \"            a = 1;\\n\"\n                       \"            x = 2;\\n\"\n                       \"        }\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(void) {\\n\"\n                       \"    int a = 0;\\n\"\n                       \"    int x;\\n\"\n                       \"\\n\"\n                       \"    for (;;) {\\n\"\n                       \"        if (!a || 12 < x) {\\n\" // <- x is uninitialized\n                       \"            a = 1;\\n\"\n                       \"        }\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:24]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo(int n) {\\n\"\n                       \"  int one[10];\\n\"\n                       \"  for (int rank = 0; rank < n; ++rank) {\\n\"\n                       \"    for (int i=0;i<rank;i++)\\n\"\n                       \"      f = one[i];\\n\"\n                       \"    one[rank] = -1;\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #2226: C++0x loop\n        checkUninitVar(\"void f() {\\n\"\n                       \"    container c;\\n\"\n                       \"    for (iterator it : c) {\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #2345: False positive in sub-condition in if inside a loop\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    const PoolItem* pItem;\\n\"\n                       \"    while (x > 0) {\\n\"\n                       \"        if (GetItem(&pItem) && (*pItem != rPool))\\n\"\n                       \"        { }\\n\"\n                       \"        x--;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        // extracttests.start: struct PoolItem { bool operator!=(const PoolItem&) const; };\n        checkUninitVar(\"void f(int x, const PoolItem& rPool) {\\n\"\n                       \"    const PoolItem* pItem;\\n\"\n                       \"    while (x > 0) {\\n\"\n                       \"        if (*pItem != rPool)\\n\"\n                       \"        { }\\n\"\n                       \"        x--;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Uninitialized variable: pItem [legacyUninitvar]\\n\", errout_str());\n\n        // #2231 - conditional initialization in loop..\n        checkUninitVar(\"int foo(char *a) {\\n\"\n                       \"    int x;\\n\"\n                       \"\\n\"\n                       \"    for (int i = 0; i < 10; ++i) {\\n\"\n                       \"        if (a[i] == 'x') {\\n\"\n                       \"            x = i;\\n\"\n                       \"            break;\\n\"\n                       \"        }\\n\"\n                       \"    }\\n\"\n                       \"\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:11]: (error) Uninitialized variable: x\\n\", \"\", errout_str());\n\n        // Ticket #2796\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    while (true) {\\n\"\n                       \"        int x;\\n\"\n                       \"        if (y) x = 0;\\n\"\n                       \"        else break;\\n\"\n                       \"        return x;\\n\"   // <- x is initialized\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Assignment in for. Ticket #3287\n        checkUninitVar(\"int foo(char* in, bool b) {\\n\"\n                       \"    char* c;\\n\"\n                       \"    if (b) for (c = in; *c == 0; ++c) {}\\n\"\n                       \"    else c = in + strlen(in) - 1;\\n\"\n                       \"    *c = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10273 - assignment in conditional code\n        // extracttests.start: extern const int PORT_LEARN_DISABLE;\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int learn;\\n\"\n                       \"    for (int index = 0; index < 10; index++) {\\n\"\n                       \"        if (!(learn & PORT_LEARN_DISABLE))\\n\"\n                       \"            learn = 123;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (error) Uninitialized variable: learn [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: struct Entry { Entry *next; }; Entry *buckets[10];\n        checkUninitVar(\"void foo() {\\n\"\n                       \"  Entry *entry, *nextEntry;\\n\"\n                       \"  for(int i = 0; i < 10; i++) {\\n\"\n                       \"    for(entry = buckets[i]; entry != NULL; entry = nextEntry) {\\n\" // <- nextEntry is not uninitialized\n                       \"      nextEntry = entry->next;\\n\"\n                       \"    }\\n\"\n                       \"  }\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"  Entry *entry, *nextEntry;\\n\"\n                       \"  for(int i = 0; i < 10; i++) {\\n\"\n                       \"    for(entry = buckets[i]; entry != NULL; entry = nextEntry) {\\n\"\n                       \"    }\\n\"\n                       \"  }\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:52]: (error) Uninitialized variable: nextEntry [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    list *f = NULL;\\n\"\n                       \"    list *l;\\n\"\n                       \"\\n\"\n                       \"    while (--x) {\\n\"\n                       \"        if (!f)\\n\"\n                       \"            f = c;\\n\"\n                       \"        else\\n\"\n                       \"            l->next = c;\\n\" // <- not uninitialized\n                       \"        l = c;\\n\"\n                       \"    }\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6952 - do-while-loop\n        checkUninitVar(\"void f(void)\\n\"\n                       \"{\\n\"\n                       \"    int* p;\\n\"\n                       \"    do\\n\"\n                       \"    {\\n\"\n                       \"        if (true) {;}\\n\"\n                       \"        else\\n\"\n                       \"        {\\n\"\n                       \"            return;\\n\"\n                       \"        }\\n\"\n                       \"        *p = 7;\\n\" // <<\n                       \"        p = new int(9);\\n\"\n                       \"    } while (*p != 8);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:11:10]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        // #6952 - while-loop\n        checkUninitVar(\"void f(void)\\n\"\n                       \"{\\n\"\n                       \"    int* p;\\n\"\n                       \"    while (*p != 8) {\\n\" // <<\n                       \"        *p = 7;\\n\"\n                       \"        p = new int(9);\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        // switch in loop\n        checkUninitVar(\"int foo(int *p) {\\n\"\n                       \"  int x;\\n\"\n                       \"  while (true) {\\n\"\n                       \"    switch (*p) {\\n\"\n                       \"    case 1:\\n\"\n                       \"        return x;\\n\"\n                       \"    case 2:\\n\"\n                       \"        x = 123;\\n\"\n                       \"        break;\\n\"\n                       \"    };\\n\"\n                       \"    ++p\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // switch..\n    void uninitvar_switch() {\n        checkUninitVar(\"void f(int x)\\n\"\n                       \"{\\n\"\n                       \"    short c;\\n\"\n                       \"    switch(x) {\\n\"\n                       \"    case 1:\\n\"\n                       \"        c++;\\n\"\n                       \"        break;\\n\"\n                       \"    };\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Uninitialized variable: c [uninitvar]\\n\", \"\", errout_str());\n\n        checkUninitVar(\"char * f()\\n\"\n                       \"{\\n\"\n                       \"    static char ret[200];\\n\"\n                       \"    memset(ret, 0, 200);\\n\"\n                       \"    switch (x)\\n\"\n                       \"    {\\n\"\n                       \"        case 1: return ret;\\n\"\n                       \"        case 2: return ret;\\n\"\n                       \"    }\\n\"\n                       \"    return 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo(const int iVar, unsigned int slot, unsigned int pin)\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    if (iVar == 0)\\n\"\n                       \"    {\\n\"\n                       \"        switch (slot)\\n\"\n                       \"        {\\n\"\n                       \"            case 4:  return 5;\\n\"\n                       \"            default: return -1;\\n\"\n                       \"        }\\n\"\n                       \"    }\\n\"\n                       \"    else\\n\"\n                       \"    {\\n\"\n                       \"        switch (pin)\\n\"\n                       \"        {\\n\"\n                       \"            case 0:   i =  2; break;\\n\"\n                       \"            default:  i = -1; break;\\n\"\n                       \"        }\\n\"\n                       \"    }\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #1855 - switch(foo(&x))\n        checkUninitVar(\"int a()\\n\"\n                       \"{\\n\"\n                       \"    int x;\\n\"\n                       \"    switch (foo(&x))\\n\"\n                       \"    {\\n\"\n                       \"        case 1:\\n\"\n                       \"            return x;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3231 - ({ switch .. })\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a;\\n\"\n                       \"    ({\\n\"\n                       \"    switch(sizeof(int)) {\\n\"\n                       \"    case 4:\\n\"\n                       \"    default:\\n\"\n                       \"        (a)=0;\\n\"\n                       \"        break;\\n\"\n                       \"    };\\n\"\n                       \"    })\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // arrays..\n    void uninitvar_arrays() {\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a[10];\\n\"\n                       \"    a[a[0]] = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Uninitialized variable: a[0] [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f()\\n\"\n                       \"{\\n\"\n                       \"    char a[10];\\n\"\n                       \"    *a = '\\\\0';\\n\"\n                       \"    int i = strlen(a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a, b[10];\\n\"\n                       \"    a = b[0] = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a[10], b[10];\\n\"\n                       \"    a[0] = b[0] = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a[10], *p;\\n\"\n                       \"    *(p = a) = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char a[10], *p;\\n\"\n                       \"    p = &(a[10]);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // array usage in ?: (tests that the isVariableUsed() works)\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char a[10], *p;\\n\"\n                       \"    p = c?a:0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    char a[10], c;\\n\"\n                       \"    c = *(x?a:0);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char a[10], c;\\n\"\n                       \"    strcpy(dest, x?a:\\\"\\\");\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"  int a[2];\\n\"\n                       \"  y *= (x ? 1 : 2);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // passing array to library functions\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char c[50] = \\\"\\\";\\n\"\n                       \"    strcat(c, \\\"test\\\");\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(char *s2) {\\n\"\n                       \"    char s[20];\\n\"\n                       \"    strcpy(s2, s);\\n\"\n                       \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Uninitialized variable: s [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char s[20];\\n\"\n                       \"    strcat(s, \\\"abc\\\");\\n\"\n                       \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: s [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char s[20];\\n\"\n                       \"    strchr(s, ' ');\\n\"\n                       \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: s [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"        int y[2];\\n\"\n                       \"        int s;\\n\"\n                       \"        GetField( y + 0, y + 1 );\\n\"\n                       \"        s = y[0] * y[1];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"        int a[2];\\n\"\n                       \"        init(a - 1);\\n\"\n                       \"        int b = a[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"        Fred a[2];\\n\"\n                       \"        Fred b = a[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"  char buf[1024];\\n\"\n                       \"  char *b = (char *) (((uintptr_t) buf + 63) & ~(uintptr_t) 63);\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"  char buf[1024];\\n\"\n                       \"  char x = *(char *) (((uintptr_t) buf + 63) & ~(uintptr_t) 63);\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:36]: (error) Uninitialized variable: buf [legacyUninitvar]\\n\", errout_str());\n\n        // Passing array to function\n        checkUninitVar(\"void f(int i);\\n\"\n                       \"void foo()\\n\"\n                       \"{\\n\"\n                       \"    int a[10];\\n\"\n                       \"    f(a[0]);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        // Ticket #2320\n        checkUninitVar(\"void foo() {\\n\"\n                       \"        char a[2];\\n\"\n                       \"        unsigned long b = (unsigned long)(a+2) & ~7;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"   // Ticket #3050\n                       \"    char a[2];\\n\"\n                       \"    printf(\\\"%s\\\", a);\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", \"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"   // Ticket #5108 (fp)\n                       \"    const char *a;\\n\"\n                       \"    printf(\\\"%s\\\", a=\\\"abc\\\");\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"    // Ticket #3497\n                       \"    char header[1];\\n\"\n                       \"    *((unsigned char*)(header)) = 0xff;\\n\"\n                       \"    return header[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"    // Ticket #3497\n                       \"    char header[1];\\n\"\n                       \"    *((unsigned char*)((unsigned char *)(header))) = 0xff;\\n\"\n                       \"    return header[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    ABC abc;\\n\"\n                       \"    int a[1];\\n\"\n                       \"\\n\"\n                       \"    abc.a = a;\\n\"\n                       \"    init(&abc);\\n\"\n                       \"    return a[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ticket #3344\n        checkUninitVar(\"void f(){\\n\"\n                       \"   char *strMsg = \\\"This is a message\\\";\\n\"\n                       \"   char *buffer=(char*)malloc(128*sizeof(char));\\n\"\n                       \"   strcpy(strMsg,buffer);\\n\"\n                       \"   free(buffer);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Memory is allocated but not initialized: buffer [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void f(){\\n\"\n                       \"   char *strMsg = \\\"This is a message\\\";\\n\"\n                       \"   char *buffer=static_cast<char*>(malloc(128*sizeof(char)));\\n\"\n                       \"   strcpy(strMsg,buffer);\\n\"\n                       \"   free(buffer);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Memory is allocated but not initialized: buffer [uninitdata]\\n\", errout_str());\n\n        // #3845\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int a[1] = {5};\\n\"\n                       \"    return a[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int a[2][2] = {{3,4}, {5,6}};\\n\"\n                       \"    return a[0][1];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int a[1];\\n\"\n                       \"    return a[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int a[2][2];\\n\"\n                       \"    return a[0][1];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"    int a[10];\\n\"\n                       \"    dostuff(a[0]);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 4740\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int *a[2][19];\\n\"\n                       \"    int **b = a[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6869 - FP when passing uninit array to function\n        checkUninitVar(\"void bar(PSTR x);\\n\"\n                       \"void foo() {\\n\"\n                       \"  char x[10];\\n\"\n                       \"  bar(x);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // struct\n        checkUninitVar(\"struct Fred { int x; int y; };\\n\"\n                       \"\"\n                       \"void f() {\\n\"\n                       \"  struct Fred fred[10];\\n\"\n                       \"  fred[1].x = 0;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"char f() {\\n\"\n                       \"    std::array<char, 1> a;\\n\"\n                       \"    return a[0];\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"std::string f() {\\n\"\n                       \"    std::array<std::string, 1> a;\\n\"\n                       \"    return a[0];\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\" // #12355\n                       \"    const int x[10](1, 2);\\n\"\n                       \"    if (x[0] == 1) {}\\n\"\n                       \"    return x[0];\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_pointertoarray() {\n        checkUninitVar(\"void draw_quad(float z)  {\\n\"\n                       \"    int i;\\n\"\n                       \"    float (*vertices)[2][4];\\n\"\n                       \"    vertices[0][0][0] = z;\\n\"\n                       \"    vertices[0][0][1] = z;\\n\"\n                       \"    vertices[1][0][0] = z;\\n\"\n                       \"    vertices[1][0][1] = z;\\n\"\n                       \"    vertices[2][0][0] = z;\\n\"\n                       \"    vertices[2][0][1] = z;\\n\"\n                       \"    vertices[3][0][0] = z;\\n\"\n                       \"    vertices[3][0][1] = z;\\n\"\n                       \"    for (i = 0; i < 4; i++) {\\n\"\n                       \"        vertices[i][0][2] = z;\\n\"\n                       \"        vertices[i][0][3] = 1.0;\\n\"\n                       \"        vertices[i][1][0] = 2.0;\\n\"\n                       \"        vertices[i][1][1] = 3.0;\\n\"\n                       \"        vertices[i][1][2] = 4.0;\\n\"\n                       \"        vertices[i][1][3] = 5.0;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: vertices [legacyUninitvar]\\n\",\n                      errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    std::array<int, 3> *PArr[2] = { p0, p1 };\\n\"\n                       \"    (*PArr[0])[2] = 0;\\n\"\n                       \"    (*PArr[1])[2] = 0;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_cpp11ArrayInit() { // #7010\n        checkUninitVar(\"double foo(bool flag) {\\n\"\n                       \"    double adIHPoint_local[4][4]{};\\n\"\n                       \"    function(*adIHPoint_local);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // alloc..\n    void uninitvar_alloc() {\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char *s = (char *)malloc(100);\\n\"\n                       \"    strcat(s, \\\"abc\\\");\\n\"\n                       \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Memory is allocated but not initialized: s [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char *s1 = new char[10];\\n\"\n                       \"    char *s2 = new char[strlen(s1)];\\n\"\n                       \"};\");\n        ASSERT_EQUALS(\"[test.cpp:4:32]: (error) Memory is allocated but not initialized: s1 [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char *p = (char*)malloc(64);\\n\"\n                       \"    int x = p[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char *p = (char*)malloc(64);\\n\"\n                       \"    if (p[0]) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (error) Memory is allocated but not initialized: p[0] [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"char f() {\\n\"\n                       \"    char *p = (char*)malloc(64);\\n\"\n                       \"    return p[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    Fred *fred = new Fred;\\n\"\n                       \"    fred->foo();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct Fred { int i; Fred(int, float); };\\n\"\n                       \"void f() {\\n\"\n                       \"    Fred *fred = new Fred(1, 2);\\n\"\n                       \"    fred->foo();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    Fred *fred = malloc(sizeof(Fred));\\n\"\n                       \"    x(&fred->f);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    Fred *fred = malloc(sizeof(Fred));\\n\"\n                       \"    x(fred->f);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo(char *s)\\n\"\n                       \"{\\n\"\n                       \"    char *a = malloc(100);\\n\"\n                       \"    *a = *s;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    char *a;\\n\"\n                       \"    if (a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    char *a = malloc(100);\\n\"\n                       \"    if (a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    ABC *abc = malloc(100);\\n\"\n                       \"    abc->a = 123;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    ABC *abc = malloc(100);\\n\"\n                       \"    abc->a.word = 123;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    ABC *abc = malloc(100);\\n\"\n                       \"    abc->a = 123;\\n\"\n                       \"    abc->a += 123;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    ABC *abc = malloc(100);\\n\"\n                       \"    free(abc);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char *s = (char*)malloc(100);\\n\"\n                       \"    if (!s)\\n\"\n                       \"        return;\\n\"\n                       \"    char c = *s;\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (error) Memory is allocated but not initialized: s\\n\", \"\", errout_str());\n\n        // #3708 - false positive when using ptr typedef\n        checkUninitVar(\"void f() {\\n\"\n                       \"    uintptr_t x = malloc(100);\\n\"\n                       \"    uintptr_t y = x + 10;\\n\"  // <- not bad usage\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  z_stream strm;\\n\"\n                       \"  char* buf = malloc(10);\\n\"\n                       \"  strm.next_out = buf;\\n\"\n                       \"  deflate(&strm, Z_FINISH);\\n\"\n                       \"  memcpy(body, buf, 10);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6451 - allocation in subscope\n        checkUninitVar(\"struct StgStrm {\\n\"\n                       \"    StgIo& rIo;\\n\"\n                       \"    StgStrm(StgIo&);\\n\"\n                       \"    virtual sal_Int32 Write();\\n\"\n                       \"};\\n\"\n                       \"void Tmp2Strm() {\\n\"\n                       \"    StgStrm* pNewStrm;\\n\"\n                       \"    if (someflag)\\n\"\n                       \"        pNewStrm = new StgStrm(rIo);\\n\"\n                       \"    else\\n\"\n                       \"        pNewStrm = new StgStrm(rIo);\\n\"\n                       \"    pNewStrm->Write();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6450 - calling a member function is allowed if memory was allocated by new\n        checkUninitVar(\"struct EMFPFont {\\n\"\n                       \"    bool family;\\n\"\n                       \"    void Initialize();\\n\"\n                       \"};\\n\"\n                       \"void processObjectRecord() {\\n\"\n                       \"    EMFPFont *font = new EMFPFont();\\n\"\n                       \"    font->Initialize();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7623 - new can also initialize the memory, don't warn in this case\n        checkUninitVar(\"void foo(){\\n\"\n                       \"    int* p1 = new int(314);\\n\"\n                       \"    int* p2 = new int();\\n\"\n                       \"    int* arr = new int[5]();\\n\"\n                       \"    std::cout << *p1 << *p2 << arr[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // new in C code does not allocate..\n        checkUninitVar(\"int main() {\\n\"\n                       \"    char * pBuf = new(10);\\n\"\n                       \"    a = *pBuf;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"class A {};\\n\" // #10698\n                       \"void f() {\\n\"\n                       \"    A* a = new A{};\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #1175\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int* p = new int;\\n\"\n                       \"    *((int*)*p) = 42;\\n\"\n                       \"    delete p;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\" // #10596\n                       \"    int* a = new int;\\n\"\n                       \"    int i{};\\n\"\n                       \"    i += *a;\\n\"\n                       \"    delete a;\\n\"\n                       \"    return i;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) Memory is allocated but not initialized: a [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void* f(size_t n, int i) {\\n\" // #11766\n                       \"    char* p = (char*)malloc(n);\\n\"\n                       \"    *(int*)p = i;\\n\"\n                       \"    return p;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void* f(size_t n, int i) {\\n\"\n                       \"    char* p = (char*)malloc(n);\\n\"\n                       \"    *(int*)(void*)p = i;\\n\"\n                       \"    return p;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int n) {\\n\"\n                       \"    int* p = (int*)malloc(n * sizeof(int));\\n\"\n                       \"    for (int i = 0; i < n; ++i)\\n\"\n                       \"        *(p + i) = 0;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // class / struct..\n    void uninitvar_class() {\n        checkUninitVar(\"class Fred\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    int a() { return i; }\\n\"\n                       \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    struct Relative {\\n\"\n                       \"        Surface *surface;\\n\"\n                       \"        void MoveTo(int x, int y) {\\n\"\n                       \"            surface->MoveTo();\\n\"\n                       \"        }\\n\"\n                       \"    };\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    static const struct ab {\\n\"\n                       \"        int a,b;\\n\"\n                       \"        int get_a() { return a; }\"\n                       \"    } x = { 0, 0 };\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int i;\\n\"\n                       \"    {\\n\"\n                       \"        union ab {\\n\"\n                       \"            int a,b;\\n\"\n                       \"        }\\n\"\n                       \"        i = 0;\\n\"\n                       \"    }\\n\"\n                       \"    return i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    x = ab.x = 12;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // enum..\n    void uninitvar_enum() {\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    enum AB { a, b };\\n\"\n                       \"    AB ab;\\n\"\n                       \"    if (ab);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (error) Uninitialized variable: ab [legacyUninitvar]\\n\", errout_str());\n    }\n\n    // references..\n    void uninitvar_references() {\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    int a;\\n\"\n                       \"    int &b = a;\\n\"\n                       \"    b = 0;\\n\"\n                       \"    int x = a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(struct blame_entry *ent)\\n\"\n                       \"{\\n\"\n                       \"    struct origin *suspect = ent->suspect;\\n\"\n                       \"    char hex[41];\\n\"\n                       \"    strcpy(hex, sha1_to_hex(suspect->commit->object.sha1));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo()\\n\"\n                       \"{\\n\"\n                       \"    const std::string s(x());\\n\"\n                       \"    strchr(s.c_str(), ',');\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6717\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct thing { int value; };\\n\"\n                       \"    thing it;\\n\"\n                       \"    int& referenced_int = it.value;\\n\"\n                       \"    referenced_int = 123;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_return() {\n\n        checkUninitVar(\"static int foo() {\\n\"\n                       \"    int ret;\\n\"\n                       \"    return ret;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static int foo() {\\n\"\n                       \"    int ret;\\n\"\n                       \"    return ret+5;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static int foo() {\\n\"\n                       \"    int ret;\\n\"\n                       \"    return ret = 5;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            checkUninitVar(\"static int foo() {\\n\"\n                           \"    int ret;\\n\"\n                           \"    cin >> ret;\\n\"\n                           \"    return ret;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"static int foo() {\\n\"\n                           \"    int ret;\\n\"\n                           \"    return cin >> ret;\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"[test.c:3:19]: (error) Uninitialized variable: ret [legacyUninitvar]\\n\", errout_str());\n        }\n\n        // Ticket #6341- False negative\n        {\n            checkUninitVar(\"wchar_t f() { int i; return btowc(i); }\");\n            ASSERT_EQUALS(\"[test.cpp:1:35]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n            checkUninitVar(\"wchar_t f(int i) { return btowc(i); }\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // Avoid a potential false positive (#6341)\n            checkUninitVar(\n                \"void setvalue(int &x) {\\n\"\n                \"  x = 0;\\n\"\n                \"  return 123;\\n\"\n                \"}\\n\"\n                \"int f() {\\n\"\n                \"  int x;\\n\"\n                \"  return setvalue(x);\\n\"\n                \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        // Ticket #5412 - False negative\n        {\n            checkUninitVar(\"void f(bool b) {\\n\"\n                           \"    double f;\\n\"\n                           \"    if (b)   {  }\\n\"\n                           \"    else  {\\n\"\n                           \"        f = 0.0;\\n\"\n                           \"    }\\n\"\n                           \"    printf (\\\"%f\\\",f);\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:7:18]: (error) Uninitialized variable: f [legacyUninitvar]\\n\", errout_str());\n\n            // Check for potential FP\n            checkUninitVar(\"void f(bool b) {\\n\"\n                           \"    double f;\\n\"\n                           \"    if (b)   { f = 1.0 }\\n\"\n                           \"    else  {\\n\"\n                           \"        f = 0.0;\\n\"\n                           \"    }\\n\"\n                           \"    printf (\\\"%f\\\",f);\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        // Ticket #2146 - False negative\n        checkUninitVar(\"int f(int x) {\\n\"\n                       \"    int y;\\n\"\n                       \"    return x ? 1 : y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Uninitialized variable: y [legacyUninitvar]\\n\", errout_str());\n\n        // Ticket #3106 - False positive\n        {\n            checkUninitVar(\"int f() {\\n\"\n                           \"    int i;\\n\"\n                           \"    return x(&i) ? i : 0;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"int f() {\\n\"\n                           \"    int i;\\n\"\n                           \"    return x() ? i : 0;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n        }\n    }\n\n    void uninitvar_assign() {  // = { .. }\n        // #1533\n        checkUninitVar(\"char a()\\n\"\n                       \"{\\n\"\n                       \"    char key;\\n\"\n                       \"    struct A msg = { .buf = {&key} };\\n\"\n                       \"    init(&msg);\\n\"\n                       \"    key++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #5660 - False positive\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int result;\\n\"\n                       \"    int *res[] = {&result};\\n\"\n                       \"    foo(res);\\n\"\n                       \"    return result;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6873\n        checkUninitVar(\"int f() {\\n\"\n                       \"    char a[10];\\n\"\n                       \"    char *b[] = {a};\\n\"\n                       \"    foo(b);\\n\"\n                       \"    return atoi(a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // = { .. }\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int a;\\n\"\n                       \"    int *p[] = { &a };\\n\"\n                       \"    *p[0] = 0;\\n\"\n                       \"    return a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    // strncpy doesn't always null-terminate..\n    void uninitvar_strncpy() {\n        // TODO: Add this checking\n        // Can it be added without hardcoding?\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a[100];\\n\"\n                       \"    strncpy(a, s, 20);\\n\"\n                       \"    strncat(a, s, 20);\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Dangerous usage of 'a' (strncpy doesn't always null-terminate it).\\n\", \"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a[100];\\n\"\n                       \"    strncpy(a, \\\"hello\\\", 3);\\n\"\n                       \"    strncat(a, \\\"world\\\", 20);\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Dangerous usage of 'a' (strncpy doesn't always null-terminate it).\\n\", \"\", errout_str());\n\n        checkUninitVar(\"void f()\\n\"\n                       \"{\\n\"\n                       \"    char a[100];\\n\"\n                       \"    strncpy(a, \\\"hello\\\", sizeof(a));\\n\"\n                       \"    strncat(a, \\\"world\\\", 20);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3245 - false positive\n        {\n            checkUninitVar(\"void f() {\\n\"\n                           \"    char a[100];\\n\"\n                           \"    strncpy(a,p,10);\\n\"\n                           \"    memcmp(a,q,10);\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"void f() {\\n\"\n                           \"    char a[100];\\n\"\n                           \"    strncpy(a,p,10);\\n\"\n                           \"    if (memcmp(a,q,10)==0);\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        // Using strncpy isn't necessarily dangerous usage\n        checkUninitVar(\"void f(const char dev[], char *str) {\\n\"\n                       \"    char buf[10];\\n\"\n                       \"    strncpy(buf, dev, 10);\\n\"\n                       \"    strncpy(str, buf, 10);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  char dst[4];\\n\"\n                       \"  const char* source = \\\"You\\\";\\n\"\n                       \"  strncpy(dst, source, sizeof(dst));\\n\"\n                       \"  char value = dst[2];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // valid and invalid use of 'int a(int x) { return x + x; }'\n    void func_uninit_var() {\n        const std::string funca(\"int a(int x) { return x + x; }\");\n\n        checkUninitVar((funca +\n                        \"void b() {\\n\"\n                        \"    int x;\\n\"\n                        \"    a(x);\\n\"\n                        \"}\").c_str());\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar((funca +\n                        \"void b() {\\n\"\n                        \"    int *p;\\n\"\n                        \"    a(*p);\\n\"\n                        \"}\").c_str());\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n    }\n\n\n    // valid and invalid use of 'void a(int *p) { *p = 0; }'\n    void func_uninit_pointer() {\n        const std::string funca(\"void a(int *p) { *p = 0; }\");\n\n        // ok - initialized pointer\n        checkUninitVar((funca +\n                        \"void b() {\\n\"\n                        \"    int buf[10];\\n\"\n                        \"    a(buf);\\n\"\n                        \"}\").c_str());\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // not ok - uninitialized pointer\n        checkUninitVar((funca +\n                        \"void b() {\\n\"\n                        \"    int *p;\\n\"\n                        \"    a(p);\\n\"\n                        \"}\").c_str());\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar_typeof() {\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct Fred *fred;\\n\"\n                       \"    typeof(fred->x);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct SData * s;\\n\"\n                       \"    ab(typeof(s->status));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct SData * s;\\n\"\n                       \"    TYPEOF(s->status);\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:3:12]: (error) Uninitialized variable: s [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int *n = ({ typeof(*n) z;  (typeof(*n)*)z; })\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_ignore() {\n        checkUninitVar(\"void foo() {\\n\"\n                       \"  int i;\\n\"\n                       \"  dostuff((int&)i, 0);\\n\" // <- cast is not use\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"  int i;\\n\"\n                       \"  return (int&)i + 2;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"  int i;\\n\"\n                       \"  dostuff(*&i, 0);\\n\" // <- *& is not use\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int foo() {\\n\"\n                       \"  int i;\\n\"\n                       \"  return *&i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar2() {\n        // using uninit var\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    x++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: char str[10];\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    str[x] = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\" // #7736\n                       \"    int buf[12];\\n\"\n                       \"    printf (\\\"%d\\\", buf[0] );\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Uninitialized variable: buf [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    int y = x & 3;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    int y = 3 & x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    x = 3 + x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    x = x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: struct ABC {int a;};\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct ABC *abc;\\n\"\n                       \"    abc->a = 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: abc [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    static int x;\\n\"\n                       \"    return ++x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    extern int x;\\n\"\n                       \"    return ++x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"  // #3926 - weird cast.\n                       \"    int x;\\n\"\n                       \"    *(((char *)&x) + 0) = 0;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\" // #4737 - weird cast.\n                       \"    int x;\\n\"\n                       \"    do_something(&((char*)&x)[0], 1);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    char *p = (char*)&x + 1;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    i=f(), i!=2;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // using uninit var in condition\n        checkUninitVar(\"void f(void) {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (x) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (1 == (3 & x)) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        // ?:\n        checkUninitVar(\"int f(int *ptr) {\\n\"\n                       \"    int a;\\n\"\n                       \"    int *p = ptr ? ptr : &a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int a) {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (a==3) { x=2; }\\n\"\n                       \"    y = (a==3) ? x : a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // = ({ .. })\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x = ({ 1 + 2; });\\n\"\n                       \"    int y = 1 + (x ? y : y);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (error) Uninitialized variable: y [legacyUninitvar]\\n\", errout_str());\n\n        // >> => initialization / usage\n        {\n            const char code[] = \"void f() {\\n\"\n                                \"    int x;\\n\"\n                                \"    if (i >> x) { }\\n\"\n                                \"}\";\n            checkUninitVar(code);\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(code, dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"[test.c:3:14]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n        }\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i, i2;\\n\"\n                       \"    strm >> i >> i2;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // unconditional initialization\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int ret;\\n\"\n                       \"    if (a) { ret = 1; }\\n\"\n                       \"    else { {} ret = 2; }\\n\"\n                       \"    return ret;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int ret;\\n\"\n                       \"    if (a) { ret = 1; }\\n\"\n                       \"    else { s=foo(1,{2,3},4); ret = 2; }\\n\"\n                       \"    return ret;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // conditional initialization\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (y == 1) { x = 1; }\\n\"\n                       \"    else { if (y == 2) { x = 1; } }\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (y == 1) { x = 1; }\\n\"\n                       \"    else { if (y == 2) { x = 1; } }\\n\"\n                       \"    if (y == 3) { }\\n\"   // <- ignore condition\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:12]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        // initialization in condition\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (init(&a)) { }\\n\"\n                       \"    a++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // return, break, continue, goto\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (y == 1) { return; }\\n\"\n                       \"    else { x = 1; }\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (y == 1) { return; }\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f(int x) {\\n\"\n                       \"    int ret;\\n\"\n                       \"    if (!x) {\\n\"\n                       \"        ret = -123;\\n\"\n                       \"        goto out1;\\n\"\n                       \"    }\\n\"\n                       \"    return 0;\\n\"\n                       \"out1:\\n\"\n                       \"out2:\\n\"\n                       \"    return ret;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) {\\n\"\n                       \"        i = 1;\\n\"\n                       \"    } else {\\n\"\n                       \"        goto out;\\n\"\n                       \"    }\\n\"\n                       \"    i++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int i,x;\\n\"\n                       \"    for (i=0;i<9;++i)\\n\"\n                       \"        if (foo) break;\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    while (foo)\\n\"\n                       \"        if (bar) break;\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        // try/catch : don't warn about exception variable\n        checkUninitVar(\"void f() {\\n\"\n                       \"    try {\\n\"\n                       \"    } catch (CException* e) {\\n\"\n                       \"        trace();\\n\"\n                       \"        e->Delete();\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\" // #5347\n                       \"    try {\\n\"\n                       \"    } catch (const char* e) {\\n\"\n                       \"        A a = e;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // exit\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    if (y == 1) { exit(0); }\\n\"\n                       \"    else { x = 1; }\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // strange code.. don't crash (#3415)\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    int i;\\n\"\n                       \"    ({ if (0); });\\n\"\n                       \"    for_each(i) { }\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n\n        // if, if\n        checkUninitVar(\"void f(int a) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (a) i = 0;\\n\"\n                       \"    if (a) i++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a,b=0;\\n\"\n                       \"    if (x) {\\n\"\n                       \"        if (y) {\\n\"\n                       \"            a = 0;\\n\"\n                       \"            b = 1;\\n\"\n                       \"        }\\n\"\n                       \"    }\\n\"\n                       \"    if (b) a++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a=0, b;\\n\"\n                       \"    if (x) { }\\n\"\n                       \"    else { if (y==2) { a=1; b=2; } }\\n\"\n                       \"    if (a) { ++b; }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void f(int x, int y) {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x == 0) { a = y; }\\n\"\n                       \"    if (x == 0 && (a == 1)) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void f() {\\n\"\n                       \"    int a=0, b;\\n\"\n                       \"    if (something) { a = dostuff(&b); }\\n\"\n                       \"    if (!a || b) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void f(int x, int y) {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x == 0 && (a == 1)) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x) { a = 0; }\\n\"\n                       \"    if (x) { if (y) { a++; } }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x) { a = 0; }\\n\"\n                       \"    if (x) { if (y) { } else { a++; } }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    if (x) ab = getAB();\\n\"\n                       \"    else ab.a = 0;\\n\"\n                       \"    if (ab.a == 1) b = ab.b;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(void) {\\n\"\n                       \"    int a;\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) { noreturn(); }\\n\"\n                       \"    else { i = 0; }\\n\"\n                       \"    if (i==1) { a = 0; }\\n\"\n                       \"    else { a = 1; }\\n\"\n                       \"    return a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int a) {\\n\" // #4560\n                       \"    int x = 0, y;\\n\"\n                       \"    if (a) x = 1;\\n\"\n                       \"    else return 0;\\n\"\n                       \"    if (x) y = 123;\\n\" // <- y is always initialized\n                       \"    else {}\\n\"\n                       \"    return y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int a) {\\n\" // #6583\n                       \"    int x;\\n\"\n                       \"    if (a < 2) exit(1);\\n\"\n                       \"    else if (a == 2) x = 0;\\n\"\n                       \"    else exit(2);\\n\"\n                       \"    return x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int a) {\\n\" // #4560\n                       \"    int x = 1, y;\\n\"\n                       \"    if (a) x = 0;\\n\"\n                       \"    else return 0;\\n\"\n                       \"    if (x) {}\\n\"\n                       \"    else y = 123;\\n\" // <- y is always initialized\n                       \"    return y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\" // #3948\n                       \"  int value;\\n\"\n                       \"  if (x !=-1)\\n\"\n                       \"    value = getvalue();\\n\"\n                       \"  if (x == -1 || value > 300) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"enum t_err { ERR_NONE, ERR_BAD_ARGS };\\n\" // #9649\n                       \"struct box_t { int value; };\\n\"\n                       \"int init_box(box_t *p, int v);\\n\"\n                       \"\\n\"\n                       \"void foo(int ret) {\\n\"\n                       \"    box_t box2;\\n\"\n                       \"    if (ret == ERR_NONE)\\n\"\n                       \"        ret = init_box(&box2, 20);\\n\"\n                       \"    if (ret == ERR_NONE)\\n\"\n                       \"        z = x + box2.value;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"  int value;\\n\"\n                       \"  if (x == 32)\\n\"\n                       \"    value = getvalue();\\n\"\n                       \"  if (x == 1)\\n\"\n                       \"    v = value;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (error) Uninitialized variable: value [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"  int value;\\n\"\n                       \"  if (x == 32)\\n\"\n                       \"    value = getvalue();\\n\"\n                       \"  if (x == 32) {}\\n\"\n                       \"  else v = value;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:12]: (error) Uninitialized variable: value [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"static int x;\" // #4773\n                       \"int f() {\\n\"\n                       \"    int y;\\n\"\n                       \"    if (x) g();\\n\"\n                       \"    if (x) y = 123;\\n\"\n                       \"    else y = 456;\\n\"\n                       \"    return y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static int x;\" // #4773\n                       \"int f() {\\n\"\n                       \"    int y;\\n\"\n                       \"    if (!x) g();\\n\"\n                       \"    if (x) y = 123;\\n\"\n                       \"    else y = 456;\\n\"\n                       \"    return y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int a) {\\n\"\n                       \"  int x;\\n\"\n                       \"  if (a) x=123;\\n\"\n                       \"  if (!a) {\\n\"\n                       \"    if (!a) {}\\n\"\n                       \"    else if (x) {}\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // asm\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    asm();\\n\"\n                       \"    x++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // sizeof / typeof / offsetof / etc\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    sizeof(i+1);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (100 == sizeof(i+1));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct ABC *abc;\\n\"\n                       \"    int i = ARRAY_SIZE(abc.a);\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:3:24]: (error) Uninitialized variable: abc [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int *abc;\\n\"\n                       \"    typeof(*abc);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    struct ABC *abc;\\n\"\n                       \"    return do_something(typeof(*abc));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    A *a;\\n\"\n                       \"    a = malloc(sizeof(*a));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // &\n        checkUninitVar(\"void f() {\\n\"  // #4426 - address of uninitialized variable\n                       \"    int a,b;\\n\"\n                       \"    if (&a == &b);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"  // #4439 - cast address of uninitialized variable\n                       \"    int a;\\n\"\n                       \"    x((LPARAM)(RECT*)&a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int main() {\\n\"\n                       \"    int done;\\n\"\n                       \"    dostuff(1, (AuPointer) &done);\\n\" // <- It is not conclusive if the \"&\" is a binary or unary operator. Bailout.\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\" // #4778 - cast address of uninitialized variable\n                       \"    long a;\\n\"\n                       \"    &a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\" // #4717 - ({})\n                       \"    int a = ({ long b = (long)(123); 2 + b; });\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #3869 - reference variable\n    void uninitvar4() {\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int buf[10];\\n\"\n                       \"    int &x = buf[0];\\n\"\n                       \"    buf[0] = 0;\\n\"\n                       \"    x++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // #3861\n    void uninitvar5() {\n        // ensure there is no false positive\n        checkUninitVar(\"void f() {\\n\"\n                       \"    x<char> c;\\n\"\n                       \"    c << 2345;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ensure there is no false negative\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char c;\\n\"\n                       \"    char a = c << 2;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n    }\n\n    // #13227\n    void uninitvar6() {\n        checkUninitVar(\"int foo(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x == 1) {\\n\"\n                       \"        i = 3;\\n\"\n                       \"    } else {\\n\"\n                       \"        do {\\n\"\n                       \"            return 2;\\n\"\n                       \"        } while (0);\\n\"\n                       \"    }\\n\"\n                       \"    return i;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar8() {\n        const char code[] = \"struct Fred {\\n\"\n                            \"    void Sync(dsmp_t& type, int& len, int limit = 123);\\n\"\n                            \"    void Sync(int& syncpos, dsmp_t& type, int& len, int limit = 123);\\n\"\n                            \"    void FindSyncPoint();\\n\"\n                            \"};\\n\"\n                            \"void Fred::FindSyncPoint() {\\n\"\n                            \"    dsmp_t type;\\n\"\n                            \"    int syncpos, len;\\n\"\n                            \"    Sync(syncpos, type, len);\\n\"\n                            \"}\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar9() { // 6424\n        const char code[] = \"namespace Ns { class C; }\\n\"\n                            \"void f1() { char *p; *p = 0; }\\n\"\n                            \"class Ns::C* p;\\n\"\n                            \"void f2() { char *p; *p = 0; }\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"[test.cpp:2:23]: (error) Uninitialized variable: p [legacyUninitvar]\\n\"\n                      \"[test.cpp:4:23]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar10() { // 9467\n        const char code[] = \"class Foo {\\n\"\n                            \"    template <unsigned int i>\\n\"\n                            \"    bool bar() {\\n\"\n                            \"        return true;\\n\"\n                            \"    }\\n\"\n                            \"};\\n\"\n                            \"template <>\\n\"\n                            \"bool Foo::bar<9>() {\\n\"\n                            \"    return true;\\n\"\n                            \"}\\n\"\n                            \"int global() {\\n\"\n                            \"    int bar = 1;\\n\"\n                            \"    return bar;\\n\"\n                            \"}\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar11() { // 9123\n        const char code[] = \"bool get(int &var);\\n\"\n                            \"void foo () {\\n\"\n                            \"    int x;\\n\"\n                            \"    x = get(x) && x;\\n\"\n                            \"}\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar12() { // 10218\n        const char code[] = \"void fp() {\\n\"\n                            \"  std::stringstream ss;\\n\"\n                            \"  for (int i; ss >> i;) {}\\n\"\n                            \"}\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar13() { // #9772 - FP\n        const char code[] = \"int func(void)\\n\"\n                            \"{ int rez;\\n\"\n                            \"  struct sccb* ccb;\\n\"\n                            \" \\n\"\n                            \"  do\\n\"\n                            \"  { if ((ccb = calloc(1, sizeof(*ccb))) == NULL)\\n\"\n                            \"    { rez = 1;\\n\"\n                            \"      break;\\n\"\n                            \"    }\\n\"\n                            \"    rez = 0;\\n\"\n                            \"  } while (0);\\n\"\n                            \" \\n\"\n                            \"  if (rez != 0)\\n\"\n                            \"    free(ccb);\\n\"\n                            \" \\n\"\n                            \"  return rez;\\n\"\n                            \"}\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar14() { // #11832\n        const char code[] = \"void f() {\\n\"\n                            \"    int b;\\n\"\n                            \"    *(&b) = 0;\\n\"\n                            \"}\";\n        checkUninitVar(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_unconditionalTry() {\n        // Unconditional scopes and try{} scopes\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    {\\n\"\n                       \"        return i;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    try {\\n\"\n                       \"        return i;\\n\"\n                       \"    } catch(...) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(bool x) {\\n\"\n                       \"    bool b;\\n\"\n                       \"    {\\n\"\n                       \"        auto g = []{};\\n\"\n                       \"        b = x;\\n\"\n                       \"    }\\n\"\n                       \"    if (b) {}\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(bool x) {\\n\"\n                       \"    bool b;\\n\"\n                       \"    {\\n\"\n                       \"        int i[2]{ 1, 2 };\\n\"\n                       \"        b = x;\\n\"\n                       \"    }\\n\"\n                       \"    if (b) {}\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(bool x) {\\n\"\n                       \"    bool b;\\n\"\n                       \"    {\\n\"\n                       \"        auto g = []{};\\n\"\n                       \"    }\\n\"\n                       \"    if (b) {}\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (error) Uninitialized variable: b [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar_funcptr() {\n        // extracttests.disable\n\n        checkUninitVar(\"void getLibraryContainer() {\\n\"\n                       \"    Reference< XStorageBasedLibraryContainer >(*Factory)(const Reference< XComponentContext >&, const Reference< XStorageBasedDocument >&)\\n\"\n                       \"        = &DocumentDialogLibraryContainer::create;\\n\"\n                       \"    rxContainer.set((*Factory)(m_aContext, xDocument));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void foo() {\\n\"\n                       \"    void* x;\\n\"\n                       \"    int (*f)(int, int) = x;\\n\"\n                       \"    dostuff((*f)(a,b));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:26]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void getLibraryContainer() {\\n\"\n                       \"    Reference< XStorageBasedLibraryContainer >(*Factory)(const Reference< XComponentContext >&, const Reference< XStorageBasedDocument >&);\\n\"\n                       \"    rxContainer.set((*Factory)(m_aContext, xDocument));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Uninitialized variable: Factory [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.enable\n    }\n\n    void uninitvar_operator() { // Ticket #6463, #6680\n        checkUninitVar(\"struct Source { Source& operator>>(int& i) { i = 0; return *this; } };\\n\"\n                       \"struct Sink { int v; };\\n\"\n                       \"Source foo;\\n\"\n                       \"void uninit() {\\n\"\n                       \"  Sink s;\\n\"\n                       \"  int n = 1 >> s.v;\\n\" // Not initialized\n                       \"};\\n\"\n                       \"void notUninit() {\\n\"\n                       \"  Sink s1;\\n\"\n                       \"  foo >> s1.v;\\n\" // Initialized by operator>>\n                       \"  Sink s2;\\n\"\n                       \"  int n;\\n\"\n                       \"  foo >> s2.v >> n;\\n\" // Initialized by operator>>\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:16]: (error) Uninitialized struct member: s.v [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct Fred { int a; };\\n\"\n                       \"void foo() {\\n\"\n                       \"  Fred fred;\\n\"\n                       \"  std::cin >> fred.a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    // Handling of function calls\n    void uninitvar2_func() {\n        // #4716\n        checkUninitVar(\"void bar(const int a, const int * const b);\\n\"\n                       \"int foo(void) {\\n\"\n                       \"   int a;\\n\"\n                       \"   int *b = 0;\\n\"\n                       \"   bar(a,b);\\n\" // <<\n                       \"   return 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        // non-pointer variable\n        checkUninitVar(\"void a(char);\\n\"  // value => error\n                       \"void b() {\\n\"\n                       \"    char c;\\n\"\n                       \"    a(c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void a(char c);\\n\"  // value => error\n                       \"void b() {\\n\"\n                       \"    char c;\\n\"\n                       \"    a(c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void a(const char c);\\n\"  // const value => error\n                       \"void b() {\\n\"\n                       \"    char c;\\n\"\n                       \"    a(c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void a(char *c);\\n\"  // address => no error\n                       \"void b() {\\n\"\n                       \"    char c;\\n\"\n                       \"    a(&c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a(pstr s);\\n\"  // address => no error\n                       \"void b() {\\n\"\n                       \"    char c;\\n\"\n                       \"    a(&c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a(const char *c);\\n\"  // const address => data is not changed\n                       \"void b() {\\n\"\n                       \"    char c;\\n\"\n                       \"    a(&c);\\n\"  // <- no warning\n                       \"    c++;\\n\"  // <- uninitialized variable\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Uninitialized variable: c\\n\", \"\", errout_str());\n\n        // pointer variable\n        checkUninitVar(\"void a(char c);\\n\"  // value => error\n                       \"void b() {\\n\"\n                       \"    char *c;\\n\"\n                       \"    a(*c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:8]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n\n        checkUninitVar(\"void a(char *c);\\n\"  // address => error\n                       \"void b() {\\n\"\n                       \"    char *c;\\n\"\n                       \"    a(c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"typedef struct { int a; int b; } AB;\\n\"\n                       \"void a(AB *ab);\\n\"\n                       \"void b() {\\n\"\n                       \"    AB *ab;\\n\"\n                       \"    a(ab);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7]: (error) Uninitialized variable: ab [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void a(const char *c);\\n\"  // const address => error\n                       \"void b() {\\n\"\n                       \"    char *c;\\n\"\n                       \"    a(c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void a(const char c[]);\\n\"  // const address => error\n                       \"void b() {\\n\"\n                       \"    char *c;\\n\"\n                       \"    a(c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: c [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void a(char **c);\\n\"  // address of pointer => no error\n                       \"void b() {\\n\"\n                       \"    char *c;\\n\"\n                       \"    a(&c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a(char *c);\\n\"  // address of pointer (suspicious cast to pointer) => no error\n                       \"void b() {\\n\"\n                       \"    char *c;\\n\"\n                       \"    a(&c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void a(const char **c);\\n\"  // const address of pointer => no error\n                       \"void b() {\\n\"\n                       \"    const char *c;\\n\"\n                       \"    a(&c);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // array\n        checkUninitVar(\"int calc(const int *p, int n);\\n\"\n                       \"void f() {\\n\"\n                       \"    int x[10];\\n\"\n                       \"    calc(x,10);\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Uninitialized variable: x [legacyUninitvar]\\n\",\n                           \"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x[10];\\n\"\n                       \"    int &x0(*x);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ....\n        checkUninitVar(\"struct ABC { int a; };\\n\"  // struct initialization\n                       \"void clear(struct ABC &abc);\\n\"\n                       \"int f() {\\n\"\n                       \"    struct ABC abc;\\n\"\n                       \"    clear(abc);\\n\"\n                       \"    return abc.a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void write_packet() {\\n\"\n                       \"    time_t now0;\\n\"\n                       \"    time(&now0);\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void write_packet() {\\n\"\n                       \"    time_t* now0;\\n\"\n                       \"    time(now0);\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:10]: (error) Uninitialized variable: now0 [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void write_packet() {\\n\"\n                       \"    char now0;\\n\"\n                       \"    strcmp(&now0, sth);\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:3:13]: (error) Uninitialized variable: now0 [legacyUninitvar]\\n\", errout_str());\n\n        // #2775 - uninitialized struct pointer in subfunction\n        // extracttests.start: struct Fred {int x;};\n        checkUninitVar(\"void a(struct Fred *fred) {\\n\"\n                       \"    fred->x = 0;\\n\"\n                       \"}\\n\"\n                       \"\\n\"\n                       \"void b() {\\n\"\n                       \"    struct Fred *p;\\n\"\n                       \"    a(p);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:7]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        // #2946 - FP array is initialized in subfunction\n        checkUninitVar(\"void a(char *buf) {\\n\"\n                       \"    buf[0] = 0;\\n\"\n                       \"}\\n\"\n                       \"void b() {\\n\"\n                       \"    char buf[10];\\n\"\n                       \"    a(buf);\\n\"\n                       \"    buf[1] = buf[0];\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // unknown macro\n        checkUninitVar(\"void f() {\\n\"\n                       \"  struct listnode *item;\\n\"\n                       \"  list_for_each(item, &key_list) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar2_value() {\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) {\\n\"\n                       \"        int y = -ENOMEM;\\n\"  // assume constant ENOMEM is nonzero since it's negated\n                       \"        if (y != 0) return;\\n\"\n                       \"        i++;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i, y;\\n\"\n                       \"    if (x) {\\n\"\n                       \"        y = -ENOMEM;\\n\"  // assume constant ENOMEM is nonzero since it's negated\n                       \"        if (y != 0) return;\\n\"\n                       \"        i++;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i, y;\\n\"\n                       \"    if (x) y = -ENOMEM;\\n\"  // assume constant ENOMEM is nonzero since it's negated\n                       \"    else y = get_value(i);\\n\"\n                       \"    if (y != 0) return;\\n\" // <- condition is always true if i is uninitialized\n                       \"    i++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) i = 0;\\n\"\n                       \"    if (!x || i>0) {}\\n\" // <- no error\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (!x) { }\\n\"\n                       \"    else i = 0;\\n\"\n                       \"    if (x || i>0) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:14]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) { }\\n\"\n                       \"    else i = 0;\\n\"\n                       \"    if (x || i>0) {}\\n\" // <- no error\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int x) {\\n\"\n                       \"    int y;\\n\"\n                       \"    if (x) y = do_something();\\n\"\n                       \"    if (!x) return 0;\\n\"\n                       \"    return y;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: int y;\n        checkUninitVar(\"int f(int x) {\\n\" // FP with ?:\n                       \"    int a;\\n\"\n                       \"    if (x)\\n\"\n                       \"        a = y;\\n\"\n                       \"    return x ? 2*a : 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(int x) {\\n\"\n                       \"    int a;\\n\"\n                       \"    if (x)\\n\"\n                       \"        a = y;\\n\"\n                       \"    return y ? 2*a : 3*a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:14]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        ASSERT_THROW_INTERNAL(checkUninitVar(\"void f() {\\n\" // Don't crash\n                                             \"    int a;\\n\"\n                                             \"    dostuff(\\\"ab\\\" cd \\\"ef\\\", x?a:z);\\n\" // <- No AST is created for ?\n                                             \"}\"), UNKNOWN_MACRO);\n\n        // Unknown => bail out..\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (a(x)) i = 0;\\n\"\n                       \"    if (b(x)) return;\\n\"\n                       \"    i++;\\n\" // <- no error if b(x) is always true when a(x) is false\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) i = 0;\\n\"\n                       \"    while (condition) {\\n\"\n                       \"        if (x) i++;\\n\" // <- no error\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(int x) {\\n\"\n                       \"    int i;\\n\"\n                       \"    if (x) i = 0;\\n\"\n                       \"    while (condition) {\\n\"\n                       \"        i++;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n    }\n\n#define valueFlowUninit(...) valueFlowUninit_(__FILE__, __LINE__, __VA_ARGS__)\n    void valueFlowUninit2_value()\n    {\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) {\\n\"\n                        \"        int y = -ENOMEM;\\n\" // assume constant ENOMEM is nonzero since it's negated\n                        \"        if (y != 0) return;\\n\"\n                        \"        i++;\\n\"\n                        \"    }\\n\"\n                        \"}\",\n                        true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i, y;\\n\"\n                        \"    if (x) {\\n\"\n                        \"        y = -ENOMEM;\\n\" // assume constant ENOMEM is nonzero since it's negated\n                        \"        if (y != 0) return;\\n\"\n                        \"        i++;\\n\"\n                        \"    }\\n\"\n                        \"}\",\n                        true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i, y;\\n\"\n                        \"    if (x) y = -ENOMEM;\\n\" // assume constant ENOMEM is nonzero since it's negated\n                        \"    else y = get_value(i);\\n\"\n                        \"    if (y != 0) return;\\n\" // <- condition is always true if i is uninitialized\n                        \"    i++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (!x) i = 0;\\n\"\n                        \"    if (!x || i>0) {}\\n\" // <- error\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:4:15]: (warning) Uninitialized variable: i [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) i = 0;\\n\"\n                        \"    if (!x || i>0) {}\\n\" // <- no error\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (!x) { }\\n\"\n                        \"    else i = 0;\\n\"\n                        \"    if (x || i>0) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:5:14]: (warning) Uninitialized variable: i [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) { }\\n\"\n                        \"    else i = 0;\\n\"\n                        \"    if (x || i>0) {}\\n\" // <- no error\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int x) {\\n\"\n                        \"    int y;\\n\"\n                        \"    if (x) y = do_something();\\n\"\n                        \"    if (!x) return 0;\\n\"\n                        \"    return y;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: int y;\n        valueFlowUninit(\"int f(int x) {\\n\" // FP with ?:\n                        \"    int a;\\n\"\n                        \"    if (x)\\n\"\n                        \"        a = y;\\n\"\n                        \"    return x ? 2*a : 0;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int x, int y) {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (x)\\n\"\n                        \"        a = y;\\n\"\n                        \"    return y ? 2*a : 3*a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:5:18]: (warning) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        ASSERT_THROW_INTERNAL(valueFlowUninit(\"void f() {\\n\" // Don't crash\n                                              \"    int a;\\n\"\n                                              \"    dostuff(\\\"ab\\\" cd \\\"ef\\\", x?a:z);\\n\" // <- No AST is created for ?\n                                              \"}\"), UNKNOWN_MACRO);\n\n        // Unknown => bail out..\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (a(x)) i = 0;\\n\"\n                        \"    if (b(x)) return;\\n\"\n                        \"    i++;\\n\" // <- no error if b(x) is always true when a(x) is false\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) i = 0;\\n\"\n                        \"    while (condition) {\\n\"\n                        \"        if (x) i++;\\n\" // <- no error\n                        \"    }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) i = 0;\\n\"\n                        \"    while (condition) {\\n\"\n                        \"        i++;\\n\"\n                        \"    }\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        valueFlowUninit(\"void f ( void ){\\n\" // #9313 - FN\n                        \" int *p;\\n\"\n                        \" int a[ 2 ] = { [ 0 ] = *p++, [ 1 ] = 1 };\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:26]: (error) Uninitialized variable: p [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(int height) {\\n\"\n                        \"    int a[11];\\n\"\n                        \"    int *p = a;\\n\"\n                        \"    int step = 2;\\n\"\n                        \"    for (int i = 0; i < (height * step); i += step)\\n\"\n                        \"        *p++ = 0;\\n\"\n                        \"    for (int i = 0; i < height; i++)\\n\"\n                        \"        if (a[i]) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(void) {\\n\"\n                        \"    char *c;\\n\"\n                        \"    char x;\\n\"\n                        \"    while (true) {\\n\"\n                        \"        c = &x;\\n\"\n                        \"        break;\\n\"\n                        \"    }\\n\"\n                        \"    ++c;\\n\"\n                        \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12030\n        valueFlowUninit(\"int set(int *x);\\n\"\n                        \"void foo(bool a) {\\n\"\n                        \"    bool flag{0};\\n\"\n                        \"    int x;\\n\"\n                        \"    if (!a) {\\n\"\n                        \"        flag = set(&x);\\n\"\n                        \"    }\\n\"\n                        \"    if (!flag || x==3) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int set(int *x);\\n\"\n                        \"void foo(bool a) {\\n\"\n                        \"    bool flag{0};\\n\"\n                        \"    int x;\\n\"\n                        \"    if (!a) {\\n\"\n                        \"        flag = set(&x);\\n\"\n                        \"    }\\n\"\n                        \"    if (!flag && x==3) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9] -> [test.cpp:8:18]: (warning) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int do_something();\\n\" // #11983\n                        \"int set_st(int *x);\\n\"\n                        \"int bar();\\n\"\n                        \"void foo() {\\n\"\n                        \"    int x, y;\\n\"\n                        \"    int status = 1;\\n\"\n                        \"    if (bar() == 1) {\\n\"\n                        \"        status = 0;\\n\"\n                        \"    }\\n\"\n                        \"    if (status == 1) {\\n\"\n                        \"        status = set_st(&x);\\n\"\n                        \"    }\\n\"\n                        \"    for (int i = 0; status == 1 && i < x; i++) {\\n\"\n                        \"        if (do_something() == 0) {\\n\"\n                        \"            status = 0;\\n\"\n                        \"        }\\n\"\n                        \"    }\\n\"\n                        \"    if(status == 1 && x > 0){}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int h(bool, bool*);\\n\" // #11760\n                        \"int f(bool t) {\\n\"\n                        \"    int i = 0;\\n\"\n                        \"    bool b;\\n\"\n                        \"    if (t)\\n\"\n                        \"        g();\\n\"\n                        \"    if (i == 0)\\n\"\n                        \"        i = h(t, &b);\\n\"\n                        \"    if (i == 0 && b)\\n\"\n                        \"        i = h(t, &b);\\n\"\n                        \"    if (i == 0 && b)\\n\"\n                        \"        i = h(t, &b);\\n\"\n                        \"    return i;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void valueFlowUninit_uninitvar2()\n    {\n        // using uninit var\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    x++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        // extracttests.start: char str[10];\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    str[x] = 0;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #7736\n                        \"    int buf[12];\\n\"\n                        \"    printf (\\\"%d\\\", buf[0] );\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Uninitialized variable: buf [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    int y = x & 3;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    int y = 3 & x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    x = 3 + x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    x = x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        // extracttests.start: struct ABC {int a;};\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    struct ABC *abc;\\n\"\n                        \"    abc->a = 0;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: abc [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    static int x;\\n\"\n                        \"    return ++x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    extern int x;\\n\"\n                        \"    return ++x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #3926 - weird cast.\n                        \"    int x;\\n\"\n                        \"    *(((char *)&x) + 0) = 0;\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #4737 - weird cast.\n                        \"    int x;\\n\"\n                        \"    do_something(&((char*)&x)[0], 1);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    char *p = (char*)&x + 1;\\n\"\n                        \"}\",\n                        true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    i=f(), i!=2;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // using uninit var in condition\n        valueFlowUninit(\"void f(void) {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (x) { }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (1 == (3 & x)) { }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        // ?:\n        valueFlowUninit(\"int f(int *ptr) {\\n\"\n                        \"    int a;\\n\"\n                        \"    int *p = ptr ? ptr : &a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int a) {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (a==3) { x=2; }\\n\"\n                        \"    y = (a==3) ? x : a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // = ({ .. })\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x = ({ 1 + 2; });\\n\"\n                        \"    int y = 1 + (x ? y : y);\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Uninitialized variable: y [legacyUninitvar]\\n\", \"\", errout_str());\n\n        // >> => initialization / usage\n        {\n            const char code[] = \"void f() {\\n\"\n                                \"    int x;\\n\"\n                                \"    if (i >> x) { }\\n\"\n                                \"}\";\n            valueFlowUninit(code, true);\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(code, false);\n            ASSERT_EQUALS(\"[test.c:3:14]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n        }\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i, i2;\\n\"\n                        \"    strm >> i >> i2;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // unconditional initialization\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    int ret;\\n\"\n                        \"    if (a) { ret = 1; }\\n\"\n                        \"    else { {} ret = 2; }\\n\"\n                        \"    return ret;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    int ret;\\n\"\n                        \"    if (a) { ret = 1; }\\n\"\n                        \"    else { s=foo(1,{2,3},4); ret = 2; }\\n\"\n                        \"    return ret;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // conditional initialization\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (y == 1) { x = 1; }\\n\"\n                        \"    else { if (y == 2) { x = 1; } }\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", \"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (y == 1) { x = 1; }\\n\"\n                        \"    else { if (y == 2) { x = 1; } }\\n\"\n                        \"    if (y == 3) { }\\n\" // <- ignore condition\n                        \"    return x;\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6:24]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", \"\", errout_str());\n\n        // initialization in condition\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (init(&a)) { }\\n\"\n                        \"    a++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // return, break, continue, goto\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (y == 1) { return; }\\n\"\n                        \"    else { x = 1; }\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (y == 1) { return; }\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int f(int x) {\\n\"\n                        \"    int ret;\\n\"\n                        \"    if (!x) {\\n\"\n                        \"        ret = -123;\\n\"\n                        \"        goto out1;\\n\"\n                        \"    }\\n\"\n                        \"    return 0;\\n\"\n                        \"out1:\\n\"\n                        \"out2:\\n\"\n                        \"    return ret;\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) {\\n\"\n                        \"        i = 1;\\n\"\n                        \"    } else {\\n\"\n                        \"        goto out;\\n\"\n                        \"    }\\n\"\n                        \"    i++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    int i,x;\\n\"\n                        \"    for (i=0;i<9;++i)\\n\"\n                        \"        if (foo) break;\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    while (foo)\\n\"\n                        \"        if (bar) break;\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        // try/catch : don't warn about exception variable\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    try {\\n\"\n                        \"    } catch (CException* e) {\\n\"\n                        \"        trace();\\n\"\n                        \"        e->Delete();\\n\"\n                        \"    }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #5347\n                        \"    try {\\n\"\n                        \"    } catch (const char* e) {\\n\"\n                        \"        A a = e;\\n\"\n                        \"    }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // exit\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    if (y == 1) { exit(0); }\\n\"\n                        \"    else { x = 1; }\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // strange code.. don't crash (#3415)\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    int i;\\n\"\n                        \"    ({ if (0); });\\n\"\n                        \"    for_each(i) { }\\n\"\n                        \"}\",\n                        false);\n\n        // if, if\n        valueFlowUninit(\"void f(int a) {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (a) i = 0;\\n\"\n                        \"    if (a) i++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int a,b=0;\\n\"\n                        \"    if (x) {\\n\"\n                        \"        if (y) {\\n\"\n                        \"            a = 0;\\n\"\n                        \"            b = 1;\\n\"\n                        \"        }\\n\"\n                        \"    }\\n\"\n                        \"    if (b) a++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int a=0, b;\\n\"\n                        \"    if (x) { }\\n\"\n                        \"    else { if (y==2) { a=1; b=2; } }\\n\"\n                        \"    if (a) { ++b; }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void f(int x, int y) {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (x == 0) { a = y; }\\n\"\n                        \"    if (x == 0 && (a == 1)) { }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void f() {\\n\"\n                        \"    int a=0, b;\\n\"\n                        \"    if (something) { a = dostuff(&b); }\\n\"\n                        \"    if (!a || b) { }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void f(int x, int y) {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (x == 0 && (a == 1)) { }\\n\"\n                        \"}\",\n                        true);\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (x) { a = 0; }\\n\"\n                        \"    if (x) { if (y) { a++; } }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (x) { a = 0; }\\n\"\n                        \"    if (x) { if (y) { } else { a++; } }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    if (x) ab = getAB();\\n\"\n                        \"    else ab.a = 0;\\n\"\n                        \"    if (ab.a == 1) b = ab.b;\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(void) {\\n\"\n                        \"    int a;\\n\"\n                        \"    int i;\\n\"\n                        \"    if (x) { noreturn(); }\\n\"\n                        \"    else { i = 0; }\\n\"\n                        \"    if (i==1) { a = 0; }\\n\"\n                        \"    else { a = 1; }\\n\"\n                        \"    return a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int a) {\\n\" // #4560\n                        \"    int x = 0, y;\\n\"\n                        \"    if (a) x = 1;\\n\"\n                        \"    else return 0;\\n\"\n                        \"    if (x) y = 123;\\n\" // <- y is always initialized\n                        \"    else {}\\n\"\n                        \"    return y;\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:5:9] -> [test.cpp:7:12]: (warning) Uninitialized variable: y [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int f(int a) {\\n\" // #6583\n                        \"    int x;\\n\"\n                        \"    if (a < 2) exit(1);\\n\"\n                        \"    else if (a == 2) x = 0;\\n\"\n                        \"    else exit(2);\\n\"\n                        \"    return x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int a) {\\n\" // #4560\n                        \"    int x = 1, y;\\n\"\n                        \"    if (a) x = 0;\\n\"\n                        \"    else return 0;\\n\"\n                        \"    if (x) {}\\n\"\n                        \"    else y = 123;\\n\" // <- y is always initialized\n                        \"    return y;\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:5:9] -> [test.cpp:7:12]: (warning) Uninitialized variable: y [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\" // #3948\n                        \"  int value;\\n\"\n                        \"  if (x !=-1)\\n\"\n                        \"    value = getvalue();\\n\"\n                        \"  if (x == -1 || value > 300) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"enum t_err { ERR_NONE, ERR_BAD_ARGS };\\n\" // #9649\n                        \"struct box_t { int value; };\\n\"\n                        \"int init_box(box_t *p, int v);\\n\"\n                        \"\\n\"\n                        \"void foo(int ret) {\\n\"\n                        \"    box_t box2;\\n\"\n                        \"    if (ret == ERR_NONE)\\n\"\n                        \"        ret = init_box(&box2, 20);\\n\"\n                        \"    if (ret == ERR_NONE)\\n\"\n                        \"        z = x + box2.value;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"  int value;\\n\"\n                        \"  if (x == 32)\\n\"\n                        \"    value = getvalue();\\n\"\n                        \"  if (x == 1)\\n\"\n                        \"    v = value;\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6:9]: (error) Uninitialized variable: value [legacyUninitvar]\\n\", \"\", errout_str());\n\n        valueFlowUninit(\"void f(int x) {\\n\"\n                        \"  int value;\\n\"\n                        \"  if (x == 32)\\n\"\n                        \"    value = getvalue();\\n\"\n                        \"  if (x == 32) {}\\n\"\n                        \"  else v = value;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:6:12]: (warning) Uninitialized variable: value [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"static int x;\" // #4773\n                        \"int f() {\\n\"\n                        \"    int y;\\n\"\n                        \"    if (x) g();\\n\"\n                        \"    if (x) y = 123;\\n\"\n                        \"    else y = 456;\\n\"\n                        \"    return y;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static int x;\" // #4773\n                        \"int f() {\\n\"\n                        \"    int y;\\n\"\n                        \"    if (!x) g();\\n\"\n                        \"    if (x) y = 123;\\n\"\n                        \"    else y = 456;\\n\"\n                        \"    return y;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int a) {\\n\"\n                        \"  int x;\\n\"\n                        \"  if (a) x=123;\\n\"\n                        \"  if (!a) {\\n\"\n                        \"    if (!a) {}\\n\"\n                        \"    else if (x) {}\\n\"\n                        \"  }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // asm\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int x;\\n\"\n                        \"    asm();\\n\"\n                        \"    x++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // sizeof / typeof / offsetof / etc\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    sizeof(i+1);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    if (100 == sizeof(i+1));\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    struct ABC *abc;\\n\"\n                        \"    int i = ARRAY_SIZE(abc.a);\"\n                        \"}\");\n        // FP ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int *abc;\\n\"\n                        \"    typeof(*abc);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    struct ABC *abc;\\n\"\n                        \"    return do_something(typeof(*abc));\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    A *a;\\n\"\n                        \"    a = malloc(sizeof(*a));\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // &\n        valueFlowUninit(\"void f() {\\n\" // #4426 - address of uninitialized variable\n                        \"    int a,b;\\n\"\n                        \"    if (&a == &b);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #4439 - cast address of uninitialized variable\n                        \"    int a;\\n\"\n                        \"    x((LPARAM)(RECT*)&a);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\n            \"int main() {\\n\"\n            \"    int done;\\n\"\n            \"    dostuff(1, (AuPointer) &done);\\n\" // <- It is not conclusive if the \"&\" is a binary or unary operator. Bailout.\n            \"}\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:3:29]: (error) Uninitialized variable: done [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #4778 - cast address of uninitialized variable\n                        \"    long a;\\n\"\n                        \"    &a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #4717 - ({})\n                        \"    int a = ({ long b = (long)(123); 2 + b; });\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void valueFlowUninit_functioncall() {\n\n        // #12462 - pointer data is not read\n        valueFlowUninit(\"struct myst { int a; };\\n\"\n                        \"void bar(const void* p) {}\\n\"\n                        \"void foo() {\\n\"\n                        \"  struct myst item;\\n\"\n                        \"  bar(&item);\\n\"\n                        \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct myst { int a; };\\n\"\n                        \"void bar(const void* p) { a = (p != 0); }\\n\"\n                        \"void foo() {\\n\"\n                        \"  struct myst item;\\n\"\n                        \"  bar(&item);\\n\"\n                        \"  a = item.a;\\n\" // <- item.a is not initialized\n                        \"}\", false);\n        ASSERT_EQUALS(\"[test.c:6:12]: (error) Uninitialized variable: item.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct myst { int a; };\\n\"\n                        \"void bar(struct myst* p) { p->a = 0; }\\n\"\n                        \"void foo() {\\n\"\n                        \"  struct myst item;\\n\"\n                        \"  bar(&item);\\n\"\n                        \"  a = item.a;\\n\"\n                        \"}\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int& r) {}\\n\" // #12536\n                        \"void g() {\\n\"\n                        \"    int i;\\n\"\n                        \"    f(i);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int& i, int j, int k) {\\n\" // #12514\n                        \"    if (k)\\n\"\n                        \"        i = 2;\\n\"\n                        \"    return i + j;\\n\"\n                        \"}\\n\"\n                        \"int main() {\\n\"\n                        \"    int i;\\n\"\n                        \"    return f(i, 1, 0);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:14] -> [test.cpp:4:12]: (warning) Uninitialized variable: i [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int f(int& i, int k) {\\n\"\n                        \"    if (k)\\n\"\n                        \"        i = 2;\\n\"\n                        \"    return i;\\n\"\n                        \"}\\n\"\n                        \"int main() {\\n\"\n                        \"    int i;\\n\"\n                        \"    return f(i, 0);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:14] -> [test.cpp:4:12]: (warning) Uninitialized variable: i [uninitvar]\\n\", errout_str());\n    }\n\n    void uninitStructMember() { // struct members\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    int a = ab.a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    AB ab;\\n\"\n                       \"    int a = ab.a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = ab.a + 1;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void do_something(const struct AB ab);\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 0;\\n\"\n                       \"    do_something(ab);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:6:18]: (error) Uninitialized struct member: ab.b [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\" // #4760\n                       \"void do_something(int a);\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    do_something(ab.a);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:5:18]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void do_something(const struct AB &ab) { a = ab.a; }\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 0;\\n\"\n                       \"    do_something(ab);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    int a = ab.a;\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:4:13]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    AB ab1;\\n\"\n                       \"    AB ab2 = { ab1.a, 0 };\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: (error) Uninitialized struct member: ab1.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    buf[ab.a] = 0;\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:4:9]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 1;\\n\"\n                       \"    x = ab;\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:5:9]: (error) Uninitialized struct member: ab.b [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 1;\\n\"\n                       \"    x = *(&ab);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:5:12]: (error) Uninitialized struct member: ab.b [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    int x;\\n\"\n                       \"    ab.a = (addr)&x;\\n\"\n                       \"    dostuff(&ab,0);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    static void f() { }\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; element->f();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    static void f() { }\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; (*element).f();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    static int v;\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; element->v;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    static int v;\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; (*element).v;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    void f() { }\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; element->f();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    void f() { }\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; (*element).f();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    int v;\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; element->v;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct Element {\\n\"\n                       \"    int v;\\n\"\n                       \"};\\n\"\n                       \"void test() {\\n\"\n                       \"    Element *element; (*element).v;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"  // pass struct member by address\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    assign(&ab.a, 0);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct Cstring { char *text; int size, alloc; };\\n\"\n                       \"int maybe();\\n\"\n                       \"void f() {\\n\"\n                       \"    Cstring res;\\n\"\n                       \"    if ( ! maybe() ) return;\\n\"  // <- fp goes away if this is removed\n                       \"    ( ((res).text = (void*)0), ((res).size = (res).alloc = 0) );\\n\"  // <- fp goes away if parentheses are removed\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            constexpr char argDirectionsTestXmlData[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n                                                        \"<def>\\n\"\n                                                        \"  <function name=\\\"uninitvar_funcArgInTest\\\">\\n\"\n                                                        \"    <arg nr=\\\"1\\\" direction=\\\"in\\\"/>\\n\"\n                                                        \"  </function>\\n\"\n                                                        \"  <function name=\\\"uninitvar_funcArgOutTest\\\">\\n\"\n                                                        \"    <arg nr=\\\"1\\\" direction=\\\"out\\\"/>\\n\"\n                                                        \"  </function>\\n\"\n                                                        \"</def>\";\n            const Settings s = settingsBuilder(settings).libraryxml(argDirectionsTestXmlData).build();\n\n            checkUninitVar(\"struct AB { int a; };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    uninitvar_funcArgInTest(&ab);\\n\"\n                           \"    x = ab;\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false, $.s = &s));\n            ASSERT_EQUALS(\"[test.c:5:9]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n            checkUninitVar(\"struct AB { int a; };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    uninitvar_funcArgOutTest(&ab);\\n\"\n                           \"    x = ab;\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false, $.s = &s));\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void do_something(const struct AB ab);\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 0;\\n\"\n                       \"    ab.b = 0;\\n\"\n                       \"    do_something(ab);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            checkUninitVar(\"struct AB { char a[10]; };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    strcpy(ab.a, STR);\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"struct AB { unsigned char a[10]; };\\n\" // #8999 - cast\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    strcpy((char *)ab.a, STR);\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"struct AB { char a[10]; };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    strcpy(x, ab.a);\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n            TODO_ASSERT_EQUALS(\"[test.c:4:16]: (error) Uninitialized variable: ab.a [uninitvar]\\n\", \"\", errout_str());\n\n            checkUninitVar(\"struct AB { int a; };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    dosomething(ab.a);\\n\"\n                           \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void do_something(const struct AB ab);\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab = getAB();\\n\"\n                       \"    do_something(ab);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            // #6769 - calling method that might assign struct members\n            checkUninitVar(\"struct AB { int a; int b; void set(); };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    ab.set();\\n\"\n                           \"    x = ab;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            checkUninitVar(\"struct AB { int a; int get() const; };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    ab.get();\\n\"\n                           \"    x = ab;\\n\"\n                           \"}\");\n            ASSERT_EQUALS(\"[test.cpp:5:9]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n            checkUninitVar(\"struct AB { int a; void dostuff() {} };\\n\"\n                           \"void f(void) {\\n\"\n                           \"    struct AB ab;\\n\"\n                           \"    ab.dostuff();\\n\"\n                           \"    x = ab;\\n\"\n                           \"}\");\n            TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n        }\n\n        checkUninitVar(\"struct AB { int a; struct { int b; int c; } s; };\\n\"\n                       \"void do_something(const struct AB ab);\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 1;\\n\"\n                       \"    ab.s.b = 2;\\n\"\n                       \"    ab.s.c = 3;\\n\"\n                       \"    do_something(ab);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct conf {\\n\"\n                       \"    char x;\\n\"\n                       \"};\\n\"\n                       \"\\n\"\n                       \"void do_something(struct conf ant_conf);\\n\"\n                       \"\\n\"\n                       \"void f(void) {\\n\"\n                       \"   struct conf c;\\n\"\n                       \"   initdata(&c);\\n\"\n                       \"   do_something(c);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct PIXEL {\\n\"\n                       \"    union  {\\n\"\n                       \"        struct { unsigned char red,green,blue,alpha; };\\n\"\n                       \"        unsigned int color;\\n\"\n                       \"    };\\n\"\n                       \"};\\n\"\n                       \"\\n\"\n                       \"unsigned char f() {\\n\"\n                       \"    struct PIXEL p1;\\n\"\n                       \"    p1.color = 255;\\n\"\n                       \"    return p1.red;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"int f() {\\n\"\n                       \"  struct AB *ab;\\n\"\n                       \"  for (i = 1; i < 10; i++) {\\n\"\n                       \"    if (condition && (ab = getab()) != NULL) {\\n\"\n                       \"      a = ab->a;\\n\"\n                       \"    }\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"int f(int x) {\\n\"\n                       \"  struct AB *ab;\\n\"\n                       \"  if (x == 0) {\\n\"\n                       \"    ab = getab();\\n\"\n                       \"  }\\n\"\n                       \"  if (x == 0 && (ab != NULL || ab->a == 0)) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct A { int *x; };\\n\" // declarationId is 0 for \"delete\"\n                       \"void foo(void *info, void*p);\\n\"\n                       \"void bar(void) {\\n\"\n                       \"  struct A *delete = 0;\\n\"\n                       \"  foo( info, NULL );\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct ABC { int a; int b; int c; };\\n\"\n                       \"void foo(int x, const struct ABC *abc);\\n\"\n                       \"void bar(void) {\\n\"\n                       \"  struct ABC abc;\\n\"\n                       \"  foo(123, &abc);\\n\"\n                       \"  return abc.b;\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (error) Uninitialized struct member: abc.a\\n\"\n                           \"[test.cpp:5]: (error) Uninitialized struct member: abc.b\\n\"\n                           \"[test.cpp:5]: (error) Uninitialized struct member: abc.c\\n\",\n                           \"[test.cpp:6:10]: (error) Uninitialized struct member: abc.b [uninitStructMember]\\n\",\n                           errout_str());\n\n        checkUninitVar(\"struct ABC { int a; int b; int c; };\\n\"\n                       \"void foo() {\\n\"\n                       \"  struct ABC abc;\\n\"\n                       \"  dostuff((uint32_t *)&abc.a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(void) {\\n\"\n                       \"    struct tm t;\\n\"\n                       \"    t.tm_year = 123;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // return\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 0;\\n\"\n                       \"    return ab.b;\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:5:12]: (error) Uninitialized struct member: ab.b [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    ab.a = 0;\\n\"\n                       \"    return ab.a;\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct S { int a; int b; };\\n\" // #8299\n                       \"void f(void) {\\n\"\n                       \"    struct S s;\\n\"\n                       \"    s.a = 0;\\n\"\n                       \"    return s;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized struct member: s.b [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct S { int a; int b; };\\n\" // #9810\n                       \"void f(void) {\\n\"\n                       \"    struct S s;\\n\"\n                       \"    return s.a ? 1 : 2;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Uninitialized struct member: s.a [uninitStructMember]\\n\", errout_str());\n\n        // checkIfForWhileHead\n        checkUninitVar(\"struct FRED {\\n\"\n                       \"    int a;\\n\"\n                       \"    int b;\\n\"\n                       \"};\\n\"\n                       \"\\n\"\n                       \"void f(void) {\\n\"\n                       \"   struct FRED fred;\\n\"\n                       \"   fred.a = do_something();\\n\"\n                       \"   if (fred.a == 0) { }\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct FRED {\\n\"\n                       \"    int a;\\n\"\n                       \"    int b;\\n\"\n                       \"};\\n\"\n                       \"\\n\"\n                       \"void f(void) {\\n\"\n                       \"   struct FRED fred;\\n\"\n                       \"   fred.a = do_something();\\n\"\n                       \"   if (fred.b == 0) { }\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:9:8]: (error) Uninitialized struct member: fred.b [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct Fred { int a; };\\n\"\n                       \"void f() {\\n\"\n                       \"    struct Fred fred;\\n\"\n                       \"    if (fred.a==1) {}\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:4:9]: (error) Uninitialized struct member: fred.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct S { int n; int m; };\\n\"\n                       \"void f(void) {\\n\"\n                       \" struct S s;\\n\"\n                       \" for (s.n = 0; s.n <= 10; s.n++) { }\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void test2() {\\n\"\n                       \"  struct { char type; } s_d;\\n\"\n                       \"  if (foo(&s_d.type)){}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // for\n        checkUninitVar(\"struct AB { int a; };\\n\"\n                       \"void f() {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    while (x) { clear(ab); z = ab.a; }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; };\\n\"\n                       \"void f() {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    while (x) { ab.a = ab.a + 1; }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:24]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; };\\n\"\n                       \"void f() {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    while (x) { init(&ab); z = ab.a; }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // address of member\n        checkUninitVar(\"struct AB { int a[10]; int b; };\\n\"\n                       \"void f() {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    int *p = ab.a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Reference\n        checkUninitVar(\"struct A { int x; };\\n\"\n                       \"void foo() {\\n\"\n                       \"  struct A a;\\n\"\n                       \"  int& x = a.x;\\n\"\n                       \"  x = 0;\\n\"\n                       \"  return a.x;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // non static data-member initialization\n        checkUninitVar(\"struct AB { int a=1; int b; };\\n\"\n                       \"void f(void) {\\n\"\n                       \"    struct AB ab;\\n\"\n                       \"    int a = ab.a;\\n\"\n                       \"    int b = ab.b;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Uninitialized struct member: ab.b [uninitStructMember]\\n\", errout_str());\n\n        // STL class member\n        checkUninitVar(\"struct A {\\n\"\n                       \"    std::map<int, int> m;\\n\"\n                       \"    int i;\\n\"\n                       \"};\\n\"\n                       \"void foo() {\\n\"\n                       \"    A a;\\n\"\n                       \"    x = a.m;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown type (C++)\n        checkUninitVar(\"struct A {\\n\"\n                       \"    C m;\\n\"\n                       \"    int i;\\n\"\n                       \"};\\n\"\n                       \"void foo() {\\n\"\n                       \"    A a;\\n\"\n                       \"    x = a.m;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown type (C)\n        checkUninitVar(\"struct A {\\n\"\n                       \"    C m;\\n\"\n                       \"    int i;\\n\"\n                       \"};\\n\"\n                       \"void foo() {\\n\"\n                       \"    A a;\\n\"\n                       \"    x = a.m;\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:7:9]: (error) Uninitialized struct member: a.m [uninitStructMember]\\n\", errout_str());\n\n        // Type with constructor\n        checkUninitVar(\"class C { C(); }\\n\"\n                       \"struct A {\\n\"\n                       \"    C m;\\n\"\n                       \"    int i;\\n\"\n                       \"};\\n\"\n                       \"void foo() {\\n\"\n                       \"    A a;\\n\"\n                       \"    x = a.m;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11002\n        checkUninitVar(\"struct S { char *p; int len; };\\n\"\n                       \"void f() {\\n\"\n                       \"    S s;\\n\"\n                       \"    s.p = nullptr;\\n\"\n                       \"    char* q = (s).p;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // if with flag\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"int f(int x) {\\n\"\n                       \"  struct AB ab;\\n\"\n                       \"  int flag = 0;\\n\"\n                       \"  if (x == 0) {\\n\"\n                       \"    flag = dostuff(&ab);\\n\"\n                       \"  }\\n\"\n                       \"  if (flag) {\\n\"\n                       \"    a = ab.a;\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct S { int x; };\\n\"\n                       \"S h() {\\n\"\n                       \"    S s;\\n\"\n                       \"    S& r = s;\\n\"\n                       \"    r.x = 0;\\n\"\n                       \"    return s;\\n\"\n                       \"}\\n\"\n                       \"S i() {\\n\"\n                       \"    S s;\\n\"\n                       \"    S& r{ s };\\n\"\n                       \"    r.x = 0;\\n\"\n                       \"    return s;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct S { int i; };\\n\" // #12142\n                       \"int f() {\\n\"\n                       \"    S s;\\n\"\n                       \"    int S::* p = &S::i;\\n\"\n                       \"    s.*p = 123;\\n\"\n                       \"    return s.i;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct S { int a; };\\n\" // #13848\n                       \"int f(std::istream& is) {\\n\"\n                       \"    S s;\\n\"\n                       \"    is >> s;\\n\"\n                       \"    return s.a;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar2_while() {\n        // extracttests.start: int a;\n\n        // for, while\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    while (a) {\\n\"\n                       \"        x = x + 1;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    do {\\n\"\n                       \"        x = x + 1;\\n\"\n                       \"    } while (a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    for (int x = x; x < 10; x++) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: struct Element{Element*Next();};\n        checkUninitVar(\"void f() {\\n\"\n                       \"    for (Element *ptr3 = ptr3->Next(); ptr3; ptr3 = ptr3->Next()) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (error) Uninitialized variable: ptr3 [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: int a;\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    while (a) {\\n\"\n                       \"        init(&x);\\n\"\n                       \"        x++;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    while (a) {\\n\"\n                       \"        if (b) x++;\\n\"\n                       \"        else x = 0;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    for (int i = 0; i < 10; i += x) {\\n\"\n                       \"        x = y;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int x;\\n\"\n                       \"    for (int i = 0; i < 10; i += x) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:34]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    for (i=0;i<9;++i)\\n\"\n                       \"        if (foo()) return i;\\n\"\n                       \"    return 9;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int i;\\n\"\n                       \"    do {} while (!getvalue(&i));\\n\"\n                       \"    i++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int f(void) {\\n\"\n                       \"   int x;\\n\"\n                       \"   while (a()) {\\n\"  // <- condition must always be true or there will be problem\n                       \"       if (b()) {\\n\"\n                       \"           x = 1;\\n\"\n                       \"           break;\"\n                       \"       }\\n\"\n                       \"   }\\n\"\n                       \"   return x;\\n\"\n                       \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n\n        checkUninitVar(\"int f(void) {\\n\"\n                       \"   int x;\\n\"\n                       \"   while (a()) {\\n\"\n                       \"       if (b() && (x=1)) {\\n\"\n                       \"           return x;\\n\"\n                       \"       }\\n\"\n                       \"   }\\n\"\n                       \"   return 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: void do_something(int);\n        checkUninitVar(\"void f(void) {\\n\"\n                       \"   int x;\\n\"\n                       \"   for (;;) {\\n\"\n                       \"       int a = x+1;\\n\"\n                       \"       do_something(a);\\n\"\n                       \"   }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB {int a; int b;};\\n\"\n                       \"void f(void) {\\n\"\n                       \"   struct AB ab;\\n\"\n                       \"   while (true) {\\n\"\n                       \"       int a = 1+ab.a;\\n\"\n                       \"       do_something(a);\\n\"\n                       \"   }\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:5:18]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"void f(int i) {\\n\" // #4569 fp\n                       \"    float *buffer;\\n\"\n                       \"    if(i>10) buffer = f;\\n\"\n                       \"    if(i>10) {\\n\"\n                       \"        for (int i=0;i<10;i++)\\n\"\n                       \"            buffer[i] = 0;\\n\" // <- fp\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(){\\n\" // #4519 - fp: inline assembler in loop\n                       \"    int x;\\n\"\n                       \"    for (int i = 0; i < 10; i++) {\\n\"\n                       \"        asm(\\\"foo\\\");\\n\"\n                       \"        if (x & 0xf1) { }\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"static void f(void) {\\n\"\n                       \"    struct ABC *abc;\\n\"\n                       \"    for (i = 0; i < 10; i++)\\n\"\n                       \"        x += sizeof(*abc);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(void) {\\n\" // #4879\n                       \"    int i;\\n\"\n                       \"    while (x) {\\n\"\n                       \"        for (i = 0; i < 5; i++)\\n\"\n                       \"            a[i] = b[i];\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(void) {\\n\" // #5658\n                       \"    struct Foo *foo;\\n\"\n                       \"    while (true) {\\n\"\n                       \"            foo = malloc(sizeof(*foo));\\n\"\n                       \"            foo->x = 0;\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f(void) {\\n\"\n                       \"  int i;\\n\"\n                       \"  while (x) {\\n\"\n                       \"    for (i=0,y=i;;){}\\n\"\n                       \"  }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  char *p = (char *)malloc(256);\\n\"\n                       \"  while(*p && *p == '_')\\n\"\n                       \"    p++;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Memory is allocated but not initialized: *p [uninitdata]\\n\", errout_str());\n\n        // #6646 - init in for loop\n        checkUninitVar(\"void f() {\\n\" // No FP\n                       \"  for (int i;;i++)\\n\"\n                       \"    dostuff(&i);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // extracttests.start: int a;\n        checkUninitVar(\"void f() {\\n\" // No FN\n                       \"  for (int i;;i++)\\n\"\n                       \"    a=i;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:15]: (error) Uninitialized variable: i [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"namespace N {\\n\" // #7377\n                       \"    template<typename T>\\n\"\n                       \"    class C {};\\n\"\n                       \"    using V = class C<void>;\\n\"\n                       \"}\\n\"\n                       \"int f() {\\n\"\n                       \"    int r = 0;\\n\"\n                       \"    for (int x; x < 4; x++)\\n\"\n                       \"        r += x;\\n\"\n                       \"    return r;\\n\"\n                       \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:17]: (error) Uninitialized variable: x [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar2_4494() {\n        checkUninitVar(\"namespace N1 {\\n\"\n                       \"    class Fred {\\n\"\n                       \"    public:\\n\"\n                       \"        static void f1(char *p) { *p = 0; }\\n\"\n                       \"    };\\n\"\n                       \"    void fa(void) { char *p; Fred::f1(p); }\\n\"\n                       \"    void fb(void) { char *p; Fred::f2(p); }\\n\"\n                       \"    void fc(void) { char *p; ::N1::Fred::f1(p); }\\n\"\n                       \"    void fd(void) { char *p; ::N1::Fred::f2(p); }\\n\"\n                       \"}\\n\"\n                       \"namespace N2 {\\n\"\n                       \"    static void f1(char *p) { *p = 0; }\\n\"\n                       \"    void fa(void) { char *p; f1(p); }\\n\"\n                       \"    void fb(void) { char *p; f2(p); }\\n\"\n                       \"    void fc(void) { char *p; N1::Fred::f1(p); }\\n\"\n                       \"    void fd(void) { char *p; N1::Fred::f2(p); }\\n\"\n                       \"    void fe(void) { char *p; ::N1::Fred::f1(p); }\\n\"\n                       \"    void ff(void) { char *p; ::N1::Fred::f2(p); }\\n\"\n                       \"    void fg(void) { char *p; Foo::f1(p); }\\n\"\n                       \"    void fh(void) { char *p; Foo::f2(p); }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:39]: (error) Uninitialized variable: p [legacyUninitvar]\\n\"\n                      \"[test.cpp:8:45]: (error) Uninitialized variable: p [legacyUninitvar]\\n\"\n                      \"[test.cpp:13:33]: (error) Uninitialized variable: p [legacyUninitvar]\\n\"\n                      \"[test.cpp:15:43]: (error) Uninitialized variable: p [legacyUninitvar]\\n\"\n                      \"[test.cpp:17:45]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"class Fred {\\n\"\n                       \"public:\\n\"\n                       \"    void f1(char *p) { *p = 0; }\\n\"\n                       \"};\\n\"\n                       \"Fred fred;\\n\"\n                       \"void f(void) {\\n\"\n                       \"    char *p;\\n\"\n                       \"    fred.f1(p);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:13]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"class Fred {\\n\"\n                       \"public:\\n\"\n                       \"    class Wilma {\\n\"\n                       \"    public:\\n\"\n                       \"        class Barney {\\n\"\n                       \"        public:\\n\"\n                       \"            class Betty {\\n\"\n                       \"            public:\\n\"\n                       \"                void f1(char *p) { *p = 0; }\\n\"\n                       \"            };\\n\"\n                       \"            Betty betty;\\n\"\n                       \"        };\\n\"\n                       \"        Barney barney;\\n\"\n                       \"    };\\n\"\n                       \"    Wilma wilma;\\n\"\n                       \"};\\n\"\n                       \"Fred fred;\\n\"\n                       \"void f(void) {\\n\"\n                       \"    char *p;\\n\"\n                       \"    fred.wilma.barney.betty.f1(p);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:20:32]: (error) Uninitialized variable: p [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar2_malloc() {\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int *p = (int*)malloc(40);\\n\"\n                       \"    return *p;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int *p = (int*)malloc(40);\\n\"\n                       \"    int var = *p;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"int f() {\\n\"\n                       \"    struct AB *ab = (AB*)malloc(sizeof(struct AB));\\n\"\n                       \"    return ab->a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12]: (error) Memory is allocated but not initialized: ab [uninitdata]\\n\"\n                      \"[test.cpp:4:12]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\",\n                      errout_str());\n\n        checkUninitVar(\"struct t_udf_file {  int dir_left; };\\n\"\n                       \"\\n\"\n                       \"void f() {\\n\"\n                       \"  struct t_udf_file *newf;\\n\"\n                       \"  newf = malloc(sizeof(*newf));\\n\"\n                       \"  if (!newf) {};\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char *s = malloc(100);\\n\"\n                       \"    if (s != NULL) { }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char *p = malloc(100);\\n\"\n                       \"    p || assert_failed();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char *p = malloc(100);\\n\"\n                       \"    x = p;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"int* f() {\\n\"\n                       \"    int *p = (int*)malloc(40);\\n\"\n                       \"    return p;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // function parameter (treat it as initialized until malloc is used)\n        checkUninitVar(\"int f(int *p) {\\n\"\n                       \"    if (*p == 1) {}\\n\" // no error\n                       \"    p = (int*)malloc(256);\\n\"\n                       \"    return *p;\\n\" // error\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Memory is allocated but not initialized: p [uninitdata]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"int f(struct AB *ab) {\\n\"\n                       \"    if (ab->a == 1) {}\\n\" // no error\n                       \"    ab = (AB*)malloc(sizeof(struct AB));\\n\"\n                       \"    return ab->a;\\n\" // error\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized struct member: ab.a [uninitStructMember]\\n\", errout_str());\n\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void do_something(struct AB *ab);\\n\" // unknown function\n                       \"void f() {\\n\"\n                       \"    struct AB *ab = (AB*)malloc(sizeof(struct AB));\\n\"\n                       \"    do_something(ab);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // analysis failed. varid 0.\n        checkUninitVar(\"void *vlc_custom_create (vlc_object_t *parent, size_t length, const char *typename) {\\n\"\n                       \"  assert (length >= sizeof (vlc_object_t));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_ternaryexpression() { // #4683\n        checkUninitVar(\"struct B { int asd; };\\n\"\n                       \"int f() {\\n\"\n                       \"    int a=0;\\n\"\n                       \"    struct B *b;\\n\"\n                       \"    if (x) {\\n\"\n                       \"        a = 1;\\n\"\n                       \"        b = p;\\n\"\n                       \"    }\\n\"\n                       \"    return a ? b->asd : 0;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_rangeBasedFor() {\n        checkUninitVar(\"void function(Entry& entry) {\\n\" // #7078\n                       \"    for (auto* expr : entry.exprs) {\\n\"\n                       \"        expr->operate();\\n\"\n                       \"        expr->operate();\\n\"\n                       \"    }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int *item;\\n\"\n                       \"    for (item: itemList) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    int buf[10];\\n\"\n                       \"    for (int &i: buf) { i = 0; }\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_static() { // #8734\n        checkUninitVar(\"struct X { \"\n                       \"  typedef struct { int p; } P_t; \"\n                       \"  static int arr[]; \"\n                       \"}; \"\n                       \"int X::arr[] = {42}; \"\n                       \"void f() { \"\n                       \"  std::vector<X::P_t> result; \"\n                       \"  X::P_t P; \"\n                       \"  P.p = 0; \"\n                       \"  result.push_back(P); \"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_configuration() {\n        const Settings s = settingsBuilder(settings).checkLibrary().build();\n\n        checkUninitVar(\"int f() {\\n\"\n                       \"    int i, j;\\n\"\n                       \"    do {\\n\"\n                       \"        i = 0;\\n\"\n                       \"        return i;\\n\"\n                       \"    } while (0);\\n\"\n                       \"}\\n\", dinit(CheckUninitVarOptions, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkExpr() {\n        checkUninitVar(\"struct AB { int a; int b; };\\n\"\n                       \"void f() {\\n\"\n                       \"    struct AB *ab = (struct AB*)calloc(1, sizeof(*ab));\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void trac_4871() { // #4871\n        checkUninitVar(\"void pickup(int a) {\\n\"\n                       \"bool using_planner_action;\\n\"\n                       \"if (a)   {\\n\"\n                       \"  using_planner_action = false;\\n\"\n                       \"}\\n\"\n                       \"else {\\n\"\n                       \"  try\\n\"\n                       \"  {}\\n\"\n                       \"  catch (std::exception &ex) {\\n\"\n                       \"    return;\\n\"\n                       \"  }\\n\"\n                       \"  using_planner_action = true;\\n\"\n                       \"}\\n\"\n                       \"if (using_planner_action) {}\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void syntax_error() { // Ticket #5073\n        const char code[] = \"struct flex_array {};\\n\"\n                            \"struct cgroup_taskset {};\\n\"\n                            \"void cgroup_attach_task() {\\n\"\n                            \"  struct flex_array *group;\\n\"\n                            \"  struct cgroup_taskset tset = { };\\n\"\n                            \"  do { } while_each_thread(leader, tsk);\\n\"\n                            \"}\";\n        ASSERT_THROW_INTERNAL(checkUninitVar(code), SYNTAX);\n    }\n\n    void trac_5970() { // Ticket #5970\n        checkUninitVar(\"void DES_ede3_ofb64_encrypt() {\\n\"\n                       \"  DES_cblock d;\\n\"\n                       \"  char *dp;\\n\"\n                       \"  dp=(char *)d;\\n\"\n                       \"  init(dp);\\n\"\n                       \"}\", dinit(CheckUninitVarOptions, $.cpp = false));\n        // Unknown type\n        TODO_ASSERT_EQUALS(\"\", \"[test.c:4:14]: (error) Uninitialized variable: d [legacyUninitvar]\\n\", errout_str());\n    }\n\n    void valueFlowUninit_(const char* file, int line, const char code[], bool cpp = true)\n    {\n        // Tokenize..\n        const Settings s = settingsBuilder(settings).debugwarnings(false).build();\n\n        SimpleTokenizer tokenizer(s, *this, cpp);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check for redundant code..\n        CheckUninitVar checkuninitvar(&tokenizer, &s, this);\n        (checkuninitvar.valueFlowUninit)();\n    }\n\n#define ctu(code) ctu_(__FILE__, __LINE__, code)\n    void valueFlowUninitTest() {\n        // #9735 - FN\n        valueFlowUninit(\"typedef struct\\n\"\n                        \"{\\n\"\n                        \"    int x;\\n\"\n                        \"    unsigned int flag : 1;\\n\" // bit filed gets never initialized\n                        \"} status;\\n\"\n                        \"bool foo(const status * const s)\\n\"\n                        \"{\\n\"\n                        \"    return s->flag;\\n\" // << uninitvar\n                        \"}\\n\"\n                        \"void bar(const status * const s)\\n\"\n                        \"{\\n\"\n                        \"    if( foo(s) == 1) {;}\\n\"\n                        \"}\\n\"\n                        \"void f(void)\\n\"\n                        \"{\\n\"\n                        \"    status s;\\n\"\n                        \"    s.x = 42;\\n\"\n                        \"    bar(&s);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:18:9] -> [test.cpp:12:13] -> [test.cpp:8:15]: (warning) Uninitialized variable: s->flag [uninitvar]\\n\", errout_str());\n\n        // Ticket #2207 - False negative\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    int a;\\n\"\n                        \"    b = c - a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    int a;\\n\"\n                        \"    b = a - c;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        // Ticket #6455 - some compilers allow const variables to be uninitialized\n        // extracttests.disable\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    const int a;\\n\"\n                        \"    b = c - a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n        // extracttests.enable\n\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    int *p;\\n\"\n                        \"    realloc(p,10);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:13]: (error) Uninitialized variable: p [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void foo() {\\n\" // #5240\n                        \"    char *p = malloc(100);\\n\"\n                        \"    char *tmp = realloc(p,1000);\\n\"\n                        \"    if (!tmp) free(p);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    int *p = NULL;\\n\"\n                        \"    realloc(p,10);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"  int x;\\n\"\n                        \"  switch (x) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int f() {\\n\"\n                        \"  int x;\\n\"\n                        \"  init(x);\\n\"\n                        \"  return x;\\n\" // TODO: inconclusive ?\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #8172\n                        \"  char **x;\\n\"\n                        \"  if (2 < sizeof(*x)) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void foo() {\\n\" // #5259 - False negative\n                        \"    int a;\\n\"\n                        \"    int x[] = {a,2};\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void foo()\\n\"\n                        \"{\\n\"\n                        \"    int x;\\n\"\n                        \"    int *y = &x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void foo()\\n\"\n                        \"{\\n\"\n                        \"    int *x;\\n\"\n                        \"    int *&y = x;\\n\"\n                        \"    y = nullptr;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void foo()\\n\"\n                        \"{\\n\"\n                        \"    int x = xyz::x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f()\\n\"\n                        \"{\\n\"\n                        \"    extern int a;\\n\"\n                        \"    a++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void foo()\\n\"\n                        \"{\\n\"\n                        \"    int x, y;\\n\"\n                        \"    x = (y = 10);\\n\"\n                        \"    int z = y * 2;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void foo() {\\n\"\n                        \"    int x, y;\\n\"\n                        \"    x = ((y) = 10);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void foo()\\n\"\n                        \"{\\n\"\n                        \"    Foo p;\\n\"\n                        \"    p.abcd();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void foo()\\n\"\n                        \"{\\n\"\n                        \"    Foo p;\\n\"\n                        \"    int x = p.abcd();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // struct\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"  AB ab;\\n\"\n                        \"  AB *p = &ab;\\n\"\n                        \"  p->a = 1;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"    S& rIo;\\n\"\n                        \"    S(S&);\\n\"\n                        \"    void Write();\\n\"\n                        \"};\\n\"\n                        \"void foo(bool b, struct S &io) {\\n\"\n                        \"    S* p;\\n\"\n                        \"    if (b)\\n\"\n                        \"        p = new S(io);\\n\"\n                        \"    p->Write();\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:8] -> [test.cpp:10]: (warning) Uninitialized variable: p\\n\",\n                           \"[test.cpp:8:9] -> [test.cpp:10:5]: (warning) Uninitialized variable: p.rIo [uninitvar]\\n\",\n                           errout_str());\n\n        // Unknown types\n        {\n            valueFlowUninit(\"void a()\\n\"\n                            \"{\\n\"\n                            \"    A ret;\\n\"\n                            \"    return ret;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // #3916 - avoid false positive\n            valueFlowUninit(\"void f(float x) {\\n\"\n                            \"  union lf { long l; float f; } u_lf;\\n\"\n                            \"  float hx = (u_lf.f = (x), u_lf.l);\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        valueFlowUninit(\"void a()\\n\"\n                        \"{\\n\"\n                        \"    int x[10];\\n\"\n                        \"    int *y = x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void a()\\n\"\n                        \"{\\n\"\n                        \"    int x;\\n\"\n                        \"    int *y = &x;\\n\"\n                        \"    *y = 0;\\n\"\n                        \"    x++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void a()\\n\"\n                        \"{\\n\"\n                        \"    char x[10], y[10];\\n\"\n                        \"    char *z = x;\\n\"\n                        \"    memset(z, 0, sizeof(x));\\n\"\n                        \"    memcpy(y, x, sizeof(x));\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Handling >> and <<\n        {\n            valueFlowUninit(\"int a() {\\n\"\n                            \"    int ret;\\n\"\n                            \"    std::cin >> ret;\\n\"\n                            \"    ret++;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(\"void f(int b) {\\n\"\n                            \"    int a;\\n\"\n                            \"    std::cin >> b >> a;\\n\"\n                            \"    return a;\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(\"void foo() {\\n\"   // #3707\n                            \"    Node node;\\n\"\n                            \"    int x;\\n\"\n                            \"    node[\\\"abcd\\\"] >> x;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(\"int a(FArchive &arc) {\\n\"  // #3060 (initialization through operator<<)\n                            \"    int *p;\\n\"\n                            \"    arc << p;\\n\"  // <- TODO initialization?\n                            \"    return *p;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:12]: (error) Uninitialized variable: p [uninitvar]\\n\", errout_str());\n\n            // #4320\n            valueFlowUninit(\"void f() {\\n\"\n                            \"    int a;\\n\"\n                            \"    a << 1;\\n\"\n                            \"    return a;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n            // #9750\n            valueFlowUninit(\"struct S {\\n\"\n                            \"    int one;\\n\"\n                            \"    int two;\\n\"\n                            \"};\\n\"\n                            \"\\n\"\n                            \"void test(std::istringstream& in) {\\n\"\n                            \"    S p;\\n\"\n                            \"    in >> p.one >> p.two;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        valueFlowUninit(\"struct S { int x; };\\n\" // #9417\n                        \"void f() {\\n\"\n                        \"    S s;\\n\"\n                        \"    return s(1);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void a() {\\n\"   // asm\n                        \"    int x;\\n\"\n                        \"    asm();\\n\"\n                        \"    x++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void a()\\n\"\n                        \"{\\n\"\n                        \"    int x[10];\\n\"\n                        \"    struct xyz xyz1 = { .x = x };\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void foo()\\n\"\n                        \"{\\n\"\n                        \"   char *buf = malloc(100);\\n\"\n                        \"   struct ABC *abc = buf;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"class Fred {\\n\"\n                        \"public:\\n\"\n                        \"    FILE *f;\\n\"\n                        \"    ~Fred();\\n\"\n                        \"}\\n\"\n                        \"Fred::~Fred()\\n\"\n                        \"{\\n\"\n                        \"    fclose(f);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f()\\n\"\n                        \"{\\n\"\n                        \"    int c;\\n\"\n                        \"    ab(sizeof(xyz), &c);\\n\"\n                        \"    if (c);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f()\\n\"\n                        \"{\\n\"\n                        \"    int c;\\n\"\n                        \"    a = (f2(&c));\\n\"\n                        \"    c++;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // goto/setjmp/longjmp..\n        valueFlowUninit(\"void foo(int x)\\n\"\n                        \"{\\n\"\n                        \"    long b;\\n\"\n                        \"    if (g()) {\\n\"\n                        \"        b =2;\\n\"\n                        \"        goto found;\\n\"\n                        \"    }\\n\"\n                        \"\\n\"\n                        \"    return;\\n\"\n                        \"\\n\"\n                        \"found:\\n\"\n                        \"    int a = b;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int foo()\\n\"\n                        \"{\\n\"\n                        \"    jmp_buf env;\\n\"\n                        \"    int a;\\n\"\n                        \"    int val = setjmp(env);\\n\"\n                        \"    if(val)\\n\"\n                        \"        return a;\\n\"\n                        \"    a = 1;\\n\"\n                        \"    longjmp(env, 1);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // range for..\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    X *item;\\n\"\n                        \"    for (item: itemList) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"X f() {\\n\"\n                        \"    if (!itemList.empty()) {\\n\"\n                        \"        X* item;\\n\"\n                        \"        for(item: itemList) {}\\n\"\n                        \"        return *item;\\n\"\n                        \"    }\\n\"\n                        \"    return X{};\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // macro_for..\n        valueFlowUninit(\"int foo()\\n\"\n                        \"{\\n\"\n                        \"  int retval;\\n\"\n                        \"  if (condition) {\\n\"\n                        \"    for12(1,2) { }\\n\"\n                        \"    retval = 1;\\n\"\n                        \"  }\\n\"\n                        \"  else\\n\"\n                        \"    retval = 2;\\n\"\n                        \"  return retval;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void foo(struct qb_list_head *list) {\\n\"\n                        \"    struct qb_list_head *iter;\\n\"\n                        \"    qb_list_for_each(iter, list) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void json_parse_nat_type_flags(json_t *root) {\\n\"\n                        \"    int index;\\n\"\n                        \"    json_array_foreach(root, index, value) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int foo()\\n\"\n                        \"{\\n\"\n                        \"    int i;\\n\"\n                        \"    goto exit;\\n\"\n                        \"    i++;\\n\"\n                        \"exit:\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int foo() {\\n\"\n                        \"    int x,y=0;\\n\"\n                        \"again:\\n\"\n                        \"    if (y) return x;\\n\"\n                        \"    x = a;\\n\"\n                        \"    y = 1;\\n\"\n                        \"    goto again;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4040 - False positive\n        valueFlowUninit(\"int f(int x)  {\\n\"\n                        \"    int iter;\\n\"\n                        \"    {\\n\"\n                        \"        union\\n\"\n                        \"        {\\n\"\n                        \"            int asInt;\\n\"\n                        \"            double asDouble;\\n\"\n                        \"        };\\n\"\n                        \"\\n\"\n                        \"        iter = x;\\n\"\n                        \"    }\\n\"\n                        \"    return 1 + iter;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // C++11 style initialization\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    int i = 0;\\n\"\n                        \"    int j{ i };\\n\"\n                        \"    return j;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #5646\n        valueFlowUninit(\"float foo() {\\n\"\n                        \"  float source[2] = {3.1, 3.1};\\n\"\n                        \"  float (*sink)[2] = &source;\\n\"\n                        \"  return (*sink)[0];\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #8755\n        valueFlowUninit(\"void f(int b) {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (b == 10)\\n\"\n                        \"        a = 1;\\n\"\n                        \"    if (b == 13)\\n\"\n                        \"        a = 1;\\n\"\n                        \"    if (b == 'x') {}\\n\"\n                        \"    if (a) {}\\n\"\n                        \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:8]: (error) Uninitialized variable: a\\n\", \"\", errout_str());\n\n        valueFlowUninit(\"void h() {\\n\"\n                        \"  int i;\\n\"\n                        \"  int* v = &i;\\n\"\n                        \"  sscanf(\\\"0\\\", \\\"%d\\\", v);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void test(int p) {\\n\"\n                        \"    int f;\\n\"\n                        \"    if (p > 0)\\n\"\n                        \"        f = 0;\\n\"\n                        \"    if (p > 1)\\n\"\n                        \"        f += 1;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"unsigned char get();\\n\"\n                        \"char f() {\\n\"\n                        \"    unsigned char c;\\n\"\n                        \"    do {\\n\"\n                        \"        c = get();\\n\"\n                        \"    } while (isalpha(c) == 0);\\n\"\n                        \"    return static_cast<char>(c);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(int x)\\n\"\n                        \"{\\n\"\n                        \"   int i;\\n\"\n                        \"   char value;\\n\"\n                        \"   for(i = 0; i < 1; i++) {\\n\"\n                        \"       if(x > 1)\\n\"\n                        \"           value = 0;\\n\"\n                        \"    }\\n\"\n                        \"    printf(\\\"\\\", value);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:13] -> [test.cpp:9:16]: (warning) Uninitialized variable: value [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(int x)\\n\"\n                        \"{\\n\"\n                        \"   int i;\\n\"\n                        \"   char value;\\n\"\n                        \"   for(i = 0; i < 1; i++) {\\n\"\n                        \"       if(x > 1)\\n\"\n                        \"           value = 0;\\n\"\n                        \"       else\\n\"\n                        \"           value = 1;\\n\"\n                        \"    }\\n\"\n                        \"    printf(\\\"\\\", value);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // function pointers\n        valueFlowUninit(\"int f (const struct FileFuncDefs *ffd) {\\n\" // #10279\n                        \"  int c;\\n\"\n                        \"  (*ffd->zread)(&c, 1);\\n\"\n                        \"  return c;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int foo(unsigned int code) {\\n\" // #10279\n                        \"  int res;\\n\\n\"\n                        \"  (* (utility_table[code])) (&res);\\n\"\n                        \"  return (res);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct Archive {\\n\"\n                        \"    bool isNull;\\n\"\n                        \"    friend void operator&(const Archive &, bool &isNull);\\n\"\n                        \"};\\n\"\n                        \"void load(Archive& ar) {\\n\"\n                        \"    bool isNull;\\n\"\n                        \"    ar & isNull;\\n\"\n                        \"    if (!isNull) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10119\n        valueFlowUninit(\"struct Foo {\\n\"\n                        \"    int i{};\\n\"\n                        \"    static const float cf;\\n\"\n                        \"};\\n\"\n                        \"const float Foo::cf = 0.1f;\\n\"\n                        \"int bar() {\\n\"\n                        \"    Foo f;\\n\"\n                        \"    return f.i;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10326\n        valueFlowUninit(\"void foo() {\\n\"\n                        \"    int cnt;\\n\"\n                        \"    do {\\n\"\n                        \"        cnt = 32 ;\\n\"\n                        \"    }\\n\"\n                        \"    while ( 0 ) ;\\n\"\n                        \"    if (cnt != 0) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10327 - avoid extra warnings for uninitialized variable\n        valueFlowUninit(\"void dowork( int me ) {\\n\"\n                        \"    if ( me == 0 ) {}\\n\" // <- not uninitialized\n                        \"}\\n\"\n                        \"\\n\"\n                        \"int main() {\\n\"\n                        \"    int me;\\n\"\n                        \"     dowork(me);\\n\" // <- me is uninitialized\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:13]: (error) Uninitialized variable: me [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int foo() {\\n\"\n                        \"  int x;\\n\"\n                        \"  int a = x;\\n\" // <- x is uninitialized\n                        \"  return a;\\n\" // <- a has been initialized\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        // #10468\n        valueFlowUninit(\"uint32_t foo(uint32_t in) {\\n\"\n                        \"    uint32_t out, mask = 0x7F;\\n\"\n                        \"    while (mask ^ 0x7FFFFFFF)\\n\"\n                        \"        out = in & ~mask;\\n\"\n                        \"    return out;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6597\n        valueFlowUninit(\"int f(int b) {\\n\"\n                        \"    int a;\\n\"\n                        \"    if (!b)\\n\"\n                        \"        a = 1;\\n\"\n                        \"    if (b)\\n\"\n                        \"        return a;\\n\"\n                        \"    else\\n\"\n                        \"        return -1;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9] -> [test.cpp:6:16]: (warning) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        // #9772\n        valueFlowUninit(\"int func(void) {\\n\"\n                        \"    int rez;\\n\"\n                        \"    struct sccb* ccb;\\n\"\n                        \"    do {\\n\"\n                        \"        if ((ccb = calloc(1, sizeof(*ccb))) == NULL) {\\n\"\n                        \"            rez = 1;\\n\"\n                        \"            break;\\n\"\n                        \"        }\\n\"\n                        \"        rez = 0;\\n\"\n                        \"    } while (0);\\n\"\n                        \"    if (rez != 0)\\n\"\n                        \"        free(ccb);\\n\"\n                        \"    return rez;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10553\n        valueFlowUninit(\"struct CharDataOnly {\\n\"\n                        \"   char data[100];\\n\"\n                        \"};\\n\"\n                        \"CharDataOnly f() {\\n\"\n                        \"   CharDataOnly testData;\\n\"\n                        \"   strcpy(testData.data, \\\"string smaller than size\\\");\\n\"\n                        \"   return testData;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10089\n        valueFlowUninit(\"typedef union {\\n\"\n                        \"    struct { int x; };\\n\"\n                        \"    int v[1];\\n\"\n                        \"} U;\\n\"\n                        \"void init(int* d) {\\n\"\n                        \"    *d = 42;\\n\"\n                        \"}\\n\"\n                        \"void f() {\\n\"\n                        \"    U u;\\n\"\n                        \"    init(u.v);\\n\"\n                        \"    printf(\\\"%d\\\\n\\\", u.x);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10280\n        valueFlowUninit(\"union U {\\n\"\n                        \"    char c[2];\\n\"\n                        \"    uint16_t u16;\\n\"\n                        \"};\\n\"\n                        \"uint16_t f(std::istream& is) {\\n\"\n                        \"    U u;\\n\"\n                        \"    is.read(u.c, 2);\\n\"\n                        \"    return u.u16;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"  char src, dest;\\n\"\n                        \"  std::memcpy(&dest, &src, 1);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (error) Uninitialized variable: &src [uninitvar]\\n\", errout_str());\n\n        // #10988\n        valueFlowUninit(\"void f(const void* ptr, bool* result) {\\n\"\n                        \"  int dummy;\\n\"\n                        \"  *result = (&dummy < ptr);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    int x;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    A a;\\n\"\n                        \"    A* p = &a;\\n\"\n                        \"    p->x = 1;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    int x;\\n\"\n                        \"};\\n\"\n                        \"void g(const int&);\\n\"\n                        \"void f() {\\n\"\n                        \"    A a;\\n\"\n                        \"    g(a.x);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (error) Uninitialized variable: a.x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    int x;\\n\"\n                        \"};\\n\"\n                        \"void g(const int&);\\n\"\n                        \"void f() {\\n\"\n                        \"    A a;\\n\"\n                        \"    A* p = &a;\\n\"\n                        \"    g(p->x);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:10]: (error) Uninitialized variable: p->x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int a;\\n\"\n                        \"    a++;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        // #11006\n        valueFlowUninit(\"int g(int);\\n\"\n                        \"void f() {\\n\"\n                        \"    int received[NSIG];\\n\"\n                        \"    for (int sig = 0; sig < NSIG; sig++)\\n\"\n                        \"        received[sig] = g(sig);\\n\"\n                        \"    for (int sig = 0; sig < NSIG; sig++)\\n\"\n                        \"        if (received[sig]) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void increment(int& i) { ++i; }\\n\" // #6475\n                        \"int f() {\\n\"\n                        \"    int n;\\n\"\n                        \"    increment(n);\\n\"\n                        \"    return n;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:15] -> [test.cpp:1:28]: (warning) Uninitialized variable: i [uninitvar]\\n\", errout_str());\n\n        // #11412\n        valueFlowUninit(\"void f(int n) {\\n\"\n                        \"\tshort* p;\\n\"\n                        \"\tif (n) {\\n\"\n                        \"\t\tp = g(n);\\n\"\n                        \"\t}\\n\"\n                        \"\tfor (int i = 0; i < n; i++)\\n\"\n                        \"\t\t(void)p[i];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11492\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    try {\\n\"\n                        \"        i = 0;\\n\"\n                        \"    }\\n\"\n                        \"    catch (...) {\\n\"\n                        \"        if (i) {}\\n\"\n                        \"    }\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11624\n        valueFlowUninit(\"const int N = 2;\\n\"\n                        \"void g(int a[N]) {\\n\"\n                        \"    for (int i = 0; i < N; ++i)\\n\"\n                        \"        a[i] = 1;\\n\"\n                        \"}\\n\"\n                        \"void f() {\\n\"\n                        \"    int a[N];\\n\"\n                        \"    g(a);\\n\"\n                        \"    if (a[0]) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11673\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    bool b;\\n\"\n                        \"    auto g = [&b]() {\\n\"\n                        \"        b = true;\\n\"\n                        \"    };\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6619\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    int nok, i;\\n\"\n                        \"    for (i = 1; i < 5; i++) {\\n\"\n                        \"        if (i == 8)\\n\"\n                        \"            nok = 8;\\n\"\n                        \"    }\\n\"\n                        \"    printf(\\\"nok = %d\\\\n\\\", nok);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:26]: (error) Uninitialized variable: nok [uninitvar]\\n\", errout_str());\n\n        // #7475\n        valueFlowUninit(\"struct S {\\n\"\n                        \"    int a, b, c;\\n\"\n                        \"} typedef s_t;\\n\"\n                        \"void f() {\\n\"\n                        \"    s_t s;\\n\"\n                        \"    printf(\\\"%d\\\", s.a);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:20]: (error) Uninitialized variable: s.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(char* src) {\\n\" // #11608\n                        \"    char envar[64], *cp, c;\\n\"\n                        \"    for (src += 2, cp = envar; (c = *src) != '\\\\0'; src++)\\n\"\n                        \"        *cp++ = c;\\n\"\n                        \"    if (cp != envar)\\n\"\n                        \"        if ((cp = getenv(envar)) != NULL) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11459\n        valueFlowUninit(\"struct S {\\n\"\n                        \"    enum E { N = 3 };\\n\"\n                        \"    static const int A[N];\\n\"\n                        \"    static void f();\\n\"\n                        \"};\\n\"\n                        \"const int S::A[N] = { 0, 1, 2 };\\n\"\n                        \"void S::f() {\\n\"\n                        \"    int tmp[N];\\n\"\n                        \"    for (int i = 0; i < N; i++)\\n\"\n                        \"        tmp[i] = 0;\\n\"\n                        \"    if (tmp[0]) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11055\n        valueFlowUninit(\"void g(int*);\\n\"\n                        \"void f(bool b) {\\n\"\n                        \"    int i;\\n\"\n                        \"    int* p = b ? &i : nullptr;\\n\"\n                        \"    g(p);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct T {};\\n\" // #11075\n                        \"struct S {\\n\"\n                        \"    int n;\\n\"\n                        \"    struct T t[10];\\n\"\n                        \"};\\n\"\n                        \"void f(struct S* s, char** tokens) {\\n\"\n                        \"    struct T t[10];\\n\"\n                        \"    int n = 0;\\n\"\n                        \"    for (int i = 0; i < s->n; i++)\\n\"\n                        \"        if (tokens[i])\\n\"\n                        \"            t[n++] = s->t[i];\\n\"\n                        \"    for (int i = 0; i < n; i++)\\n\"\n                        \"        t[i];\\n\"\n                        \"}\\n\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"bool g();\\n\"\n                        \"void f() {\\n\"\n                        \"    int a[10];\\n\"\n                        \"    int idx = 0;\\n\"\n                        \"    if (g())\\n\"\n                        \"        a[idx++] = 1;\\n\"\n                        \"    for (int i = 0; i < idx; i++)\\n\"\n                        \"        (void)a[i];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"  int x;\\n\"\n                        \"  int *p = 0 ? 0 : &x;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void g() {\\n\"\n                        \"  int y;\\n\"\n                        \"  int *q = 1 ? &y : 0;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(std::stringstream& ss) {\\n\" // #11805\n                        \"    int x;\\n\"\n                        \"    int* p = &x;\\n\"\n                        \"    ss >> *p;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    int x;\\n\"\n                        \"    int* p = &x;\\n\"\n                        \"    int& r = *p;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(std::stringstream& ss) {\\n\" // #11805\n                        \"    int x;\\n\"\n                        \"    int* p = &x;\\n\"\n                        \"    ss >> *p;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    int x;\\n\"\n                        \"    int* p = &x;\\n\"\n                        \"    int& r = *p;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S1 { char a[10]; };\\n\" // #11804\n                        \"struct S2 { struct S1 s1; };\\n\"\n                        \"void init(char* c);\\n\"\n                        \"void f() {\\n\"\n                        \"    struct S2 s2;\\n\"\n                        \"    init(s2.s1.a);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S { int i; };\\n\" // #11731\n                        \"void f(const S*& p);\\n\"\n                        \"int g() {\\n\"\n                        \"   const S* s;\\n\"\n                        \"   f(s);\\n\"\n                        \"   return s->i;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"int f(int i) {\\n\"\n                        \"    int x;\\n\"\n                        \"    int* p = &x;\\n\"\n                        \"    return i >> *p;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:17]: (error) Uninitialized variable: *p [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(int& x) {\\n\"\n                        \"    int i;\\n\"\n                        \"    x = i;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Uninitialized variable: i [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #11890\n                        \"    int x;\\n\"\n                        \"    int* a[] = { &x };\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11992\n        valueFlowUninit(\"void foo(const int &x) {\\n\"\n                        \"    if(x==42) {;}\\n\"\n                        \"}\\n\"\n                        \"void test(void) {\\n\"\n                        \"    int t;\\n\"\n                        \"    int &p = t;\\n\"\n                        \"    int &s = p;\\n\"\n                        \"    int &q = s;\\n\"\n                        \"    foo(q);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:9]: (error) Uninitialized variable: q [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"int g();\\n\" // #12082\n                        \"void f() {\\n\"\n                        \"    int a[1], b[1];\\n\"\n                        \"    while (a[0] = g()) {}\\n\"\n                        \"    if ((b[0] = g()) == 0) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(const char *x, char *y);\\n\" // #4527\n                        \"void g(char* b) {\\n\"\n                        \"    char a[1000];\\n\"\n                        \"    f(a, b);\\n\"\n                        \"    printf(\\\"%s\\\", a);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void usage(const char *);\\n\" // #10330\n                        \"int main(int argc, char* argv[]) {\\n\"\n                        \"    int user = 0;\\n\"\n                        \"    struct passwd* pwd;\\n\"\n                        \"    while (1) {\\n\"\n                        \"        int c = getc();\\n\"\n                        \"        if (c == -1)\\n\"\n                        \"            break;\\n\"\n                        \"        switch (c) {\\n\"\n                        \"        case 'u': user = 123; break;\\n\"\n                        \"        }\\n\"\n                        \"    }\\n\"\n                        \"    if (argc == 1)\\n\"\n                        \"        usage(argv[0]);\\n\"\n                        \"    if (user)\\n\"\n                        \"        pwd = getpwnam(user);\\n\"\n                        \"    if (pwd == NULL) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:15:9] -> [test.cpp:17:9]: (warning) Uninitialized variable: pwd [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"size_t Read(unsigned char* buffer, size_t len);\\n\" // #11540\n                        \"void f() {\\n\"\n                        \"    const int N = 100;\\n\"\n                        \"    uint8_t data[N];\\n\"\n                        \"    size_t data_size = 0;\\n\"\n                        \"    for (int i = 0; i < 10; i++) {\\n\"\n                        \"        if (!data_size)\\n\"\n                        \"            data_size = Read(data, N);\\n\"\n                        \"        if (!data_size)\\n\"\n                        \"            return;\\n\"\n                        \"        if (data[0] == 0x47) {}\\n\"\n                        \"    }\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12033\n        valueFlowUninit(\"void g(const char*p);\\n\"\n                        \"void f() {\\n\"\n                        \"    char buf[10];\\n\"\n                        \"    g(buf);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: buf [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #12288\n                        \"    char buf[100];\\n\"\n                        \"    char* p = new (buf) char[100];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12355\n        valueFlowUninit(\"int f() {\\n\"\n                        \"    const int x[10](1, 2);\\n\"\n                        \"    if (x[0] == 1) {}\\n\"\n                        \"    return x[0];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(bool* p) {\\n\" // #12287\n                        \"    if (p)\\n\"\n                        \"        *p = true; \\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    bool b;\\n\"\n                        \"    f(&b);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S { int x; };\\n\" // #12394\n                        \"int f() {\\n\"\n                        \"    struct S s[1];\\n\"\n                        \"    s->x = 0;\\n\"\n                        \"    return s[0].x;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S { int* p; };\\n\" // #12473\n                        \"void f() {\\n\"\n                        \"    struct S s;\\n\"\n                        \"    s.p[0] = 0;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Uninitialized variable: s.p [uninitvar]\\n\", errout_str());\n\n        // #12460\n        valueFlowUninit(\"typedef struct {\\n\"\n                        \"  int a;\\n\"\n                        \"} st;\\n\"\n                        \"void foo(int* p, bool success) {\\n\"\n                        \"  st myst;\\n\"\n                        \"  if (success == 1) {\\n\"\n                        \"    myst.a = 5;\\n\"\n                        \"  }\\n\"\n                        \"  if ((success == 1) && (myst.a != 0)) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12606\n        valueFlowUninit(\"void f(int& r) { if (r) {} }\\n\"\n                        \"void g() {\\n\"\n                        \"    int i;\\n\"\n                        \"    f(i);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7] -> [test.cpp:1:22]: (warning) Uninitialized variable: r [uninitvar]\\n\", errout_str());\n\n        // #12197\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    char a[N];\\n\"\n                        \"    for (int i = 0; i < N; i++)\\n\"\n                        \"        a[i] = 1;\\n\"\n                        \"    const int* p = a;\\n\"\n                        \"    for (int i = 0; i < N; i++) {\\n\"\n                        \"        if (p[i]) {}\\n\"\n                        \"    }\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12247\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    char a[10], *p = &a[0];\\n\"\n                        \"    p = getenv(\\\"abc\\\");\\n\"\n                        \"    printf(\\\"%\\\", p);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(char *q) {\\n\"\n                        \"    char a[1];\\n\"\n                        \"    char *p = a;\\n\"\n                        \"    p = q;\\n\"\n                        \"    printf(\\\"%s\\\", p);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"std::string f() {\\n\" // #12922\n                        \"    std::string a[2];\\n\"\n                        \"    std::array<std::string, 2> b;\\n\"\n                        \"    return a[1] + b.at(1);\\n\" // don't warn\n                        \"}\\n\"\n                        \"struct S { int i; };\\n\"\n                        \"struct T { int i = 0; };\\n\"\n                        \"int g() {\\n\"\n                        \"    std::array<int, 2> a;\\n\"\n                        \"    std::array<S, 2> b;\\n\"\n                        \"    std::array<T, 2> c;\\n\" // don't warn\n                        \"    return a.at(1) + b.at(1).i + c.at(1).i;\\n\"\n                        \"}\\n\"\n                        \"int h() {\\n\"\n                        \"    std::array<int, 2> a;\\n\"\n                        \"    return a[1];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:12:12]: (error) Uninitialized variable: a [uninitvar]\\n\"\n                      \"[test.cpp:12:22]: (error) Uninitialized variable: b [uninitvar]\\n\"\n                      \"[test.cpp:16:12]: (error) Uninitialized variable: a [uninitvar]\\n\",\n                      errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // # 12932\n                        \"    std::array<int, 0> a;\\n\"\n                        \"    if (a.begin() == a.end()) {}\\n\"\n                        \"    std::array<int, 1> b;\\n\"\n                        \"    auto it = b.begin();\\n\"\n                        \"    *it = 0;\\n\"\n                        \"    std::array<int, 1> c;\\n\"\n                        \"    return c.front();\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:12]: (error) Uninitialized variable: c [uninitvar]\\n\", errout_str());\n    }\n\n    void valueFlowUninitBreak() { // Do not show duplicate warnings about the same uninitialized value\n        valueFlowUninit(\"struct wcsstruct {\\n\"\n                        \"    int *wcsprm;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void copy_wcs(wcsstruct *wcsin) {\\n\"\n                        \"    wcsstruct *x;\\n\"\n                        \"    memcpy(wcsin, x, sizeof(wcsstruct));\\n\" // <- warning\n                        \"    x->wcsprm = NULL;\\n\" // <- no warning\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:19]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct wcsstruct {\\n\"\n                        \"    int *wcsprm;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void copy_wcs(wcsstruct *wcsin) {\\n\"\n                        \"    wcsstruct *x;\\n\"\n                        \"    sizeof(x);\\n\"\n                        \"    x->wcsprm = NULL;\\n\" // <- Warn\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct wcsstruct {\\n\"\n                        \"    int *wcsprm;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void init_wcs(wcsstruct *x) { if (x->wcsprm != NULL); }\\n\" // <- no warning\n                        \"\\n\"\n                        \"void copy_wcs() {\\n\"\n                        \"    wcsstruct *x;\\n\"\n                        \"    x->wcsprm = NULL;\\n\" // <- warn here\n                        \"    init_wcs(x);\\n\" // <- no warning\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:5]: (error) Uninitialized variable: x [uninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar_ipa() {\n        // #8825\n        valueFlowUninit(\"typedef struct  {\\n\"\n                        \"    int flags;\\n\"\n                        \"} someType_t;\\n\"\n                        \"void bar(const someType_t * const p)  {\\n\"\n                        \"    if( (p->flags & 0xF000) == 0xF000){}\\n\"\n                        \"}\\n\"\n                        \"void f(void) {\\n\"\n                        \"    someType_t gVar;\\n\"\n                        \"    bar(&gVar);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:9]: (error) Uninitialized variable: &gVar [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"typedef struct\\n\"\n                        \"{\\n\"\n                        \"        int flags[3];\\n\"\n                        \"} someType_t;\\n\"\n                        \"void f(void) {\\n\"\n                        \"        someType_t gVar;\\n\"\n                        \"        if(gVar.flags[1] == 42){}\\n\"\n                        \"}\");\n        // TODO : find bugs for member arrays\n        TODO_ASSERT_EQUALS(\"[test.cpp:7]: (error) Uninitialized variable: gVar.flags\\n\", \"\", errout_str());\n\n        valueFlowUninit(\"void foo() {\\n\" // #10293\n                        \"  union {\\n\"\n                        \"    struct hdr cm;\\n\"\n                        \"    char control[123];\\n\"\n                        \"  } u;\\n\"\n                        \"  char *x = u.control;\\n\" // <- no error\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct pc_data {\\n\"\n                        \"    struct {\\n\"\n                        \"        char   * strefa;\\n\"\n                        \"    } wampiryzm;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    struct pc_data *pcdata;\\n\"\n                        \"    if ( *pcdata->wampiryzm.strefa == '\\\\0' ) { }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:11]: (error) Uninitialized variable: pcdata [uninitvar]\\n\", errout_str());\n\n        // # 9293\n        valueFlowUninit(\"struct S {\\n\"\n                        \"  int x;\\n\"\n                        \"  int y;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void f() {\\n\"\n                        \"    struct S s1;\\n\"\n                        \"    int * x = &s1.x;\\n\"\n                        \"    struct S s2 = {*x, 0};\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:20]: (error) Uninitialized variable: *x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"  int x;\\n\"\n                        \"  int y;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void f() {\\n\"\n                        \"    struct S s1;\\n\"\n                        \"    struct S s2;\\n\"\n                        \"    int * x = &s1.x;\\n\"\n                        \"    s2.x = *x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:12]: (error) Uninitialized variable: *x [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(bool * x) {\\n\"\n                        \"    *x = false;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    bool b;\\n\"\n                        \"    f(&b);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(bool * x) {\\n\"\n                        \"    if (x != nullptr)\\n\"\n                        \"        x = 1;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    bool x;\\n\"\n                        \"    f(&x);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    bool b;\\n\"\n                        \"    bool * x = &b;\\n\"\n                        \"    if (x != nullptr)\\n\"\n                        \"        x = 1;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A { bool b; };\"\n                        \"void f(A * x) {\\n\"\n                        \"    x->b = false;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    A b;\\n\"\n                        \"    f(&b);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"std::string f() {\\n\"\n                        \"    std::ostringstream ostr;\\n\"\n                        \"    ostr << \\\"\\\";\\n\"\n                        \"    return ostr.str();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        // #9281\n        valueFlowUninit(\"struct s {\\n\"\n                        \"    char a[20];\\n\"\n                        \"};\\n\"\n                        \"void c(struct s *sarg) {\\n\"\n                        \"    sarg->a[0] = '\\\\0';\\n\"\n                        \"}\\n\"\n                        \"void b(struct s *sarg) {\\n\"\n                        \"    c(sarg);\\n\"\n                        \"}\\n\"\n                        \"void a() {\\n\"\n                        \"    struct s s1;\\n\"\n                        \"    b(&s1);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 9290\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    double x;\\n\"\n                        \"};\\n\"\n                        \"double b() {\\n\"\n                        \"    A * c;\\n\"\n                        \"    c->x = 42;\\n\"\n                        \"    return c->x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Uninitialized variable: c [uninitvar]\\n\",\n                      errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    double x;\\n\"\n                        \"};\\n\"\n                        \"double b() {\\n\"\n                        \"    A c;\\n\"\n                        \"    c.x = 42;\\n\"\n                        \"    return c.x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    double x;\\n\"\n                        \"};\\n\"\n                        \"double d(A * e) {\\n\"\n                        \"    e->x = 42;\\n\"\n                        \"    return e->x;\\n\"\n                        \"}\\n\"\n                        \"double b() {\\n\"\n                        \"    A c;\\n\"\n                        \"    return d(&c);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 9302\n        valueFlowUninit(\"struct VZ   {\\n\"\n                        \"    double typ;\\n\"\n                        \"};\\n\"\n                        \"void read() {\\n\"\n                        \"    struct VZ vz;\\n\"\n                        \"    struct VZ* pvz = &vz;\\n\"\n                        \"    vz.typ      = 42;\\n\"\n                        \"    if (pvz->typ == 0)\\n\"\n                        \"        return;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 9305\n        valueFlowUninit(\"struct kf {\\n\"\n                        \"    double x;\\n\"\n                        \"};\\n\"\n                        \"void set(kf* k) {\\n\"\n                        \"    k->x = 0;\\n\"\n                        \"}\\n\"\n                        \"void cal() {\\n\"\n                        \"    KF b;\\n\"\n                        \"    KF* pb = &b;\\n\"\n                        \"    set( pb);\\n\"\n                        \"    if (pb->x)\\n\"\n                        \"        return;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 9348\n        valueFlowUninit(\"void f(int *a) {\\n\"\n                        \"  int b = 0;\\n\"\n                        \"  memcpy(a, &b, sizeof(b));\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"  int i;\\n\"\n                        \"  f(&i);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 9631\n        valueFlowUninit(\"static void g(bool * result, int num, int num2, size_t * buflen) {\\n\"\n                        \"  if (*result && *buflen >= 5) {}\\n\"\n                        \"}\\n\"\n                        \"void f() {\\n\"\n                        \"  size_t bytesCopied;\\n\"\n                        \"  bool copied_all = true;\\n\"\n                        \"  g(&copied_all, 5, 6, &bytesCopied);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:24] -> [test.cpp:2:18]: (warning) Uninitialized variable: *buflen [uninitvar]\\n\", errout_str());\n\n        // # 9953\n        valueFlowUninit(\"uint32_t f(uint8_t *mem) {\\n\"\n                        \"    uint32_t u32;\\n\"\n                        \"    uint8_t *buf = (uint8_t *)(&u32);\\n\"\n                        \"    buf[0] = mem[0];\\n\"\n                        \"    return(*(uint32_t *)buf);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void valueFlowUninitStructMembers()\n    {\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 1;\\n\"\n                        \"    if (ab.b == 2) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: ab.b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void do_something(const struct AB &ab) { a = ab.a; }\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 0;\\n\"\n                        \"    do_something(ab);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void do_something(const struct AB &ab) { a = ab.b; }\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 0;\\n\"\n                        \"    do_something(ab);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:18] -> [test.cpp:2:49]: (warning) Uninitialized variable: ab.b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    int a = ab.a;\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:4:16]: (error) Uninitialized variable: ab.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    AB ab1;\\n\"\n                        \"    AB ab2 = { ab1.a, 0 };\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: (error) Uninitialized variable: ab1.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    buf[ab.a] = 0;\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:4:12]: (error) Uninitialized variable: ab.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 1;\\n\"\n                        \"    x = ab;\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:5:9]: (error) Uninitialized variable: ab.b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 1;\\n\"\n                        \"    x = *(&ab);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:5:9]: (error) Uninitialized variable: *(&ab).b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    int x;\\n\"\n                        \"    ab.a = (void*)&x;\\n\"\n                        \"    dostuff(&ab,0);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    static void f() { }\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; element->f();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    static void f() { }\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; (*element).f();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    static int v;\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; element->v;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    static int v;\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; (*element).v;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    void f() { }\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; element->f();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    void f() { }\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; (*element).f();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    int v;\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; element->v;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Element {\\n\"\n                        \"    int v;\\n\"\n                        \"};\\n\"\n                        \"void test() {\\n\"\n                        \"    Element *element; (*element).v;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:25]: (error) Uninitialized variable: element [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\" // pass struct member by address\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    assign(&ab.a, 0);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\n            \"struct Cstring { char *text; int size, alloc; };\\n\"\n            \"int maybe();\\n\"\n            \"void f() {\\n\"\n            \"    Cstring res;\\n\"\n            \"    if ( ! maybe() ) return;\\n\"                                     // <- fp goes away if this is removed\n            \"    ( ((res).text = (void*)0), ((res).size = (res).alloc = 0) );\\n\" // <- fp goes away if parentheses are removed\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void do_something(const struct AB ab);\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 0;\\n\"\n                        \"    ab.b = 0;\\n\"\n                        \"    do_something(ab);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            valueFlowUninit(\"struct AB { char a[10]; };\\n\"\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    strcpy(ab.a, STR);\\n\"\n                            \"}\\n\",\n                            false);\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(\"struct AB { unsigned char a[10]; };\\n\" // #8999 - cast\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    strcpy((char *)ab.a, STR);\\n\"\n                            \"}\\n\",\n                            false);\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(\"struct AB { char a[10]; };\\n\"\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    strcpy(x, ab.a);\\n\"\n                            \"}\\n\",\n                            false);\n            TODO_ASSERT_EQUALS(\"[test.c:4:16]: (error) Uninitialized variable: ab.a [uninitvar]\\n\", \"\", errout_str());\n\n            valueFlowUninit(\"struct AB { int a; };\\n\"\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    dosomething(ab.a);\\n\"\n                            \"}\\n\",\n                            false);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void do_something(const struct AB ab);\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab = getAB();\\n\"\n                        \"    do_something(ab);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            // #6769 - calling method that might assign struct members\n            valueFlowUninit(\"struct AB { int a; int b; void set(); };\\n\"\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    ab.set();\\n\"\n                            \"    x = ab;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n\n            valueFlowUninit(\"struct AB { int a; int get() const; };\\n\"\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    ab.get();\\n\"\n                            \"    x = ab;\\n\"\n                            \"}\");\n            ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Uninitialized variable: ab [uninitvar]\\n\", errout_str());\n\n            valueFlowUninit(\"struct AB { int a; void dostuff() {} };\\n\"\n                            \"void f(void) {\\n\"\n                            \"    struct AB ab;\\n\"\n                            \"    ab.dostuff();\\n\"\n                            \"    x = ab;\\n\"\n                            \"}\");\n            TODO_ASSERT_EQUALS(\"error\", \"\", errout_str());\n        }\n\n        valueFlowUninit(\"struct AB { int a; struct { int b; int c; } s; };\\n\"\n                        \"void do_something(const struct AB ab);\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 1;\\n\"\n                        \"    ab.s.b = 2;\\n\"\n                        \"    ab.s.c = 3;\\n\"\n                        \"    do_something(ab);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct conf {\\n\"\n                        \"    char x;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void do_something(struct conf ant_conf);\\n\"\n                        \"\\n\"\n                        \"void f(void) {\\n\"\n                        \"   struct conf c;\\n\"\n                        \"   initdata(&c);\\n\"\n                        \"   do_something(c);\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct PIXEL {\\n\"\n                        \"    union  {\\n\"\n                        \"        struct { unsigned char red,green,blue,alpha; };\\n\"\n                        \"        unsigned int color;\\n\"\n                        \"    };\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"unsigned char f() {\\n\"\n                        \"    struct PIXEL p1;\\n\"\n                        \"    p1.color = 255;\\n\"\n                        \"    return p1.red;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"int f() {\\n\"\n                        \"  struct AB *ab;\\n\"\n                        \"  for (i = 1; i < 10; i++) {\\n\"\n                        \"    if (condition && (ab = getab()) != NULL) {\\n\"\n                        \"      a = ab->a;\\n\"\n                        \"    }\\n\"\n                        \"  }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"int f(int x) {\\n\"\n                        \"  struct AB *ab;\\n\"\n                        \"  if (x == 0) {\\n\"\n                        \"    ab = getab();\\n\"\n                        \"  }\\n\"\n                        \"  if (x == 0 && (ab != NULL || ab->a == 0)) { }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A { int *x; };\\n\" // declarationId is 0 for \"delete\"\n                        \"void foo(void *info, void*p);\\n\"\n                        \"void bar(void) {\\n\"\n                        \"  struct A *delete = 0;\\n\"\n                        \"  foo( info, NULL );\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct ABC { int a; int b; int c; };\\n\"\n                        \"void foo(int x, const struct ABC *abc);\\n\"\n                        \"void bar(void) {\\n\"\n                        \"  struct ABC abc;\\n\"\n                        \"  foo(123, &abc);\\n\"\n                        \"  return abc.b;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: &abc [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct ABC { int a; int b; int c; };\\n\"\n                        \"void foo() {\\n\"\n                        \"  struct ABC abc;\\n\"\n                        \"  dostuff((uint32_t *)&abc.a);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f(void) {\\n\"\n                        \"    struct tm t;\\n\"\n                        \"    t.tm_year = 123;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // return\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 0;\\n\"\n                        \"    return ab.b;\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:5:15]: (error) Uninitialized variable: ab.b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    ab.a = 0;\\n\"\n                        \"    return ab.a;\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S { int a; int b; };\\n\" // #8299\n                        \"void f(void) {\\n\"\n                        \"    struct S s;\\n\"\n                        \"    s.a = 0;\\n\"\n                        \"    return s;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:12]: (error) Uninitialized variable: s.b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S { int a; int b; };\\n\" // #9810\n                        \"void f(void) {\\n\"\n                        \"    struct S s;\\n\"\n                        \"    return s.a ? 1 : 2;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14]: (error) Uninitialized variable: s.a [uninitvar]\\n\", errout_str());\n\n        // checkIfForWhileHead\n        valueFlowUninit(\"struct FRED {\\n\"\n                        \"    int a;\\n\"\n                        \"    int b;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void f(void) {\\n\"\n                        \"   struct FRED fred;\\n\"\n                        \"   fred.a = do_something();\\n\"\n                        \"   if (fred.a == 0) { }\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct FRED {\\n\"\n                        \"    int a;\\n\"\n                        \"    int b;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"void f(void) {\\n\"\n                        \"   struct FRED fred;\\n\"\n                        \"   fred.a = do_something();\\n\"\n                        \"   if (fred.b == 0) { }\\n\"\n                        \"}\\n\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:9:13]: (error) Uninitialized variable: fred.b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct Fred { int a; };\\n\"\n                        \"void f() {\\n\"\n                        \"    struct Fred fred;\\n\"\n                        \"    if (fred.a==1) {}\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:4:14]: (error) Uninitialized variable: fred.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S { int n; int m; };\\n\"\n                        \"void f(void) {\\n\"\n                        \" struct S s;\\n\"\n                        \" for (s.n = 0; s.n <= 10; s.n++) { }\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void test2() {\\n\"\n                        \"  struct { char type; } s_d;\\n\"\n                        \"  if (foo(&s_d.type)){}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // for\n        valueFlowUninit(\"struct AB { int a; };\\n\"\n                        \"void f() {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    while (x) { clear(ab); z = ab.a; }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; };\\n\"\n                        \"void f() {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    while (x) { ab.a = ab.a + 1; }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:27]: (error) Uninitialized variable: ab.a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct AB { int a; };\\n\"\n                        \"void f() {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    while (x) { init(&ab); z = ab.a; }\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // address of member\n        valueFlowUninit(\"struct AB { int a[10]; int b; };\\n\"\n                        \"void f() {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    int *p = ab.a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Reference\n        valueFlowUninit(\"struct A { int x; };\\n\"\n                        \"void foo() {\\n\"\n                        \"  struct A a;\\n\"\n                        \"  int& x = a.x;\\n\"\n                        \"  x = 0;\\n\"\n                        \"  return a.x;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // non static data-member initialization\n        valueFlowUninit(\"struct AB { int a=1; int b; };\\n\"\n                        \"void f(void) {\\n\"\n                        \"    struct AB ab;\\n\"\n                        \"    int a = ab.a;\\n\"\n                        \"    int b = ab.b;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (error) Uninitialized variable: ab.b [uninitvar]\\n\", errout_str());\n\n        // STL class member\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    std::map<int, int> m;\\n\"\n                        \"    int i;\\n\"\n                        \"};\\n\"\n                        \"void foo() {\\n\"\n                        \"    A a;\\n\"\n                        \"    x = a.m;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown type (C++)\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    C m;\\n\"\n                        \"    int i;\\n\"\n                        \"};\\n\"\n                        \"void foo() {\\n\"\n                        \"    A a;\\n\"\n                        \"    x = a.m;\\n\"\n                        \"}\",\n                        true);\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Unknown type (C)\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    C m;\\n\"\n                        \"    int i;\\n\"\n                        \"};\\n\"\n                        \"void foo() {\\n\"\n                        \"    A a;\\n\"\n                        \"    x = a.m;\\n\"\n                        \"}\",\n                        false);\n        ASSERT_EQUALS(\"[test.c:7:11]: (error) Uninitialized variable: a.m [uninitvar]\\n\", errout_str());\n\n        // Type with constructor\n        valueFlowUninit(\"class C { C(); }\\n\"\n                        \"struct A {\\n\"\n                        \"    C m;\\n\"\n                        \"    int i;\\n\"\n                        \"};\\n\"\n                        \"void foo() {\\n\"\n                        \"    A a;\\n\"\n                        \"    x = a.m;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"   int t[1];\\n\"\n                        \"};\\n\"\n                        \"int f(const S* ps) {\\n\"\n                        \"   return ps->t[0];\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"   S s;\\n\"\n                        \"   s.t[0] = 1;\\n\"\n                        \"   f(&s);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"   int t[1];\\n\"\n                        \"   int u;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"int f(const S* ps) {\\n\"\n                        \"   return ps->t[0];\\n\"\n                        \"}\\n\"\n                        \"\\n\"\n                        \"int main(void)\\n\"\n                        \"{\\n\"\n                        \"   S s;\\n\"\n                        \"   s.t[0] = 1;\\n\"\n                        \"   f(&s);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct X {\\n\"\n                        \"   int a, b;\\n\"\n                        \"};\\n\"\n                        \"struct S {\\n\"\n                        \"   X t;\\n\"\n                        \"};\\n\"\n                        \"int f(const S* ps) {\\n\"\n                        \"   return ps->t.a;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"   S s;\\n\"\n                        \"   s.t.a = 1;\\n\"\n                        \"   f(&s);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"typedef struct { int a; int b; int c; } ABC;\\n\" // #5777\n                        \"void setabc(int x, const ABC* const abc) {\\n\"\n                        \"    sum = abc->a + abc->b + abc->c;\\n\"\n                        \"}\\n\"\n                        \"void f(void) {\\n\"\n                        \"    ABC abc;\\n\"\n                        \"    abc.a = 1;\\n\"\n                        \"    setabc(123, &abc);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:17] -> [test.cpp:3:25]: (warning) Uninitialized variable: abc->b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S { int* p; };\\n\" // #10463\n                        \"void f(S* in) {\\n\"\n                        \"    S* s;\\n\"\n                        \"    memcpy(in, s, sizeof(S));\\n\"\n                        \"    s->p = NULL;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:16]: (error) Uninitialized variable: s [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\" // #11321\n                        \"    int a = 0;\\n\"\n                        \"    int b;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    S s1;\\n\"\n                        \"    s1.b = 1;\\n\"\n                        \"    S s2 = s1;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11460\n        valueFlowUninit(\"struct B { int i; };\\n\"\n                        \"    struct H {\\n\"\n                        \"    void e() const;\\n\"\n                        \"    static const B b;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    H h;\\n\"\n                        \"    h.e();\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11597\n        valueFlowUninit(\"void f(size_t f) {\\n\"\n                        \"    struct {\\n\"\n                        \"        int i;\\n\"\n                        \"        enum { offset = 1062 };\\n\"\n                        \"    } s;\\n\"\n                        \"    if (f < s.offset + sizeof(s)) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11776 - function call initialises struct array member\n        valueFlowUninit(\"typedef struct {\\n\"\n                        \"  int arr[1];\\n\"\n                        \"  int count;\\n\"\n                        \"} arr_struct;\\n\"\n                        \"\\n\"\n                        \"void init(int *a, int b);\\n\"\n                        \"\\n\"\n                        \"void foo(arr_struct const *var);\\n\" // <- inconclusive if var->count is used\n                        \"\\n\"\n                        \"void uninitvar_FP7() {\\n\"\n                        \"  arr_struct my_st;\\n\"\n                        \"  init(my_st.arr, 12);\\n\" // <- assume that my_st.arr is written\n                        \"  foo(&my_st);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"typedef struct {\\n\"\n                        \"  int arr[1];\\n\"\n                        \"  int count;\\n\"\n                        \"} arr_struct;\\n\"\n                        \"\\n\"\n                        \"void init(int *a, int b);\\n\"\n                        \"\\n\"\n                        \"void foo(arr_struct const *var) {\\n\"\n                        \"  x = var->arr[0];\\n\"\n                        \"}\\n\"\n                        \"\\n\"\n                        \"void uninitvar_FP7() {\\n\"\n                        \"  arr_struct my_st;\\n\"\n                        \"  init(my_st.arr, 12);\\n\" // <- assume that my_st.arr is written\n                        \"  foo(&my_st);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\" // #12188\n                        \"    int i;\\n\"\n                        \"    struct T { int j; } t;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    S s;\\n\"\n                        \"    ++s.i;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    S s;\\n\"\n                        \"    s.i--;\\n\"\n                        \"}\\n\"\n                        \"void h() {\\n\"\n                        \"    S s;\\n\"\n                        \"    s.i &= 3;\\n\"\n                        \"}\\n\"\n                        \"void k() {\\n\"\n                        \"    S s;\\n\"\n                        \"    if (++s.i < 3) {}\\n\"\n                        \"}\\n\"\n                        \"void m() {\\n\"\n                        \"    S s;\\n\"\n                        \"    ++s.t.j;\\n\"\n                        \"}\\n\"\n                        \"void n() {\\n\"\n                        \"    S s;\\n\"\n                        \"    if (s.t.j-- < 3) {}\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (error) Uninitialized variable: s.i [uninitvar]\\n\"\n                      \"[test.cpp:11:7]: (error) Uninitialized variable: s.i [uninitvar]\\n\"\n                      \"[test.cpp:15:7]: (error) Uninitialized variable: s.i [uninitvar]\\n\"\n                      \"[test.cpp:19:13]: (error) Uninitialized variable: s.i [uninitvar]\\n\"\n                      \"[test.cpp:23:11]: (error) Uninitialized variable: s.t.j [uninitvar]\\n\"\n                      \"[test.cpp:27:13]: (error) Uninitialized variable: s.t.j [uninitvar]\\n\",\n                      errout_str());\n\n        valueFlowUninit(\"struct S { int x; };\\n\" // #6933\n                        \"void f() {\\n\"\n                        \"    int i;\\n\"\n                        \"    S s(i);\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    int i;\\n\"\n                        \"    S t{ i };\\n\"\n                        \"}\\n\"\n                        \"void h() {\\n\"\n                        \"    int i;\\n\"\n                        \"    std::vector<int> v(i);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Uninitialized variable: i [uninitvar]\\n\"\n                      \"[test.cpp:8:10]: (error) Uninitialized variable: i [uninitvar]\\n\"\n                      \"[test.cpp:12:24]: (error) Uninitialized variable: i [uninitvar]\\n\",\n                      errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"    S(char**);\\n\"\n                        \"    int i;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    char* p;\\n\"\n                        \"    S s(&p);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\" // #12354\n                        \"    int i{};\\n\"\n                        \"    void f();\\n\"\n                        \"};\\n\"\n                        \"void f(bool b) {\\n\"\n                        \"    S* p;\\n\"\n                        \"    if (b)\\n\"\n                        \"        p = new S();\\n\"\n                        \"    p->f();\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:9] -> [test.cpp:9:5]: (warning) Uninitialized variable: p [uninitvar]\\n\", errout_str());\n\n        // #12461\n        valueFlowUninit(\"struct stry_type {\\n\"\n                        \"  void *out;\\n\"\n                        \"};\\n\"\n                        \"void bar(str_type *items);\\n\"\n                        \"void foo() {\\n\"\n                        \"  str_type st_arr[1];\\n\"\n                        \"  char arr[5];\\n\"\n                        \"  st_arr[0].out = &arr;\\n\"\n                        \"  bar(st_arr);\\n\"\n                        \"  int len = strlen(arr);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct stry_type {\\n\"\n                        \"  void *out;\\n\"\n                        \"};\\n\"\n                        \"void foo() {\\n\"\n                        \"  str_type st_arr[1];\\n\"\n                        \"  char arr[5];\\n\"\n                        \"  st_arr[0].out = &arr;\\n\"\n                        \"  int len = strlen(arr);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:20]: (error) Uninitialized variable: arr [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"  void *out;\\n\"\n                        \"};\\n\"\n                        \"void bar(S* s);\\n\"\n                        \"void foo() {\\n\"\n                        \"  S s[1][1];\\n\"\n                        \"  char arr[5];\\n\"\n                        \"  s[0][0].out = &arr;\\n\"\n                        \"  bar(s[0]);\\n\"\n                        \"  int len = strlen(arr);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S1 { int x; };\\n\" // #12401\n                        \"struct S2 { struct S1 s1; };\\n\"\n                        \"struct S2 f() {\\n\"\n                        \"    struct S2 s2;\\n\"\n                        \"    struct S1* s1 = &s2.s1;\\n\"\n                        \"    s1->x = 0;\\n\"\n                        \"    return s2;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\" // #12685\n                        \"    explicit S(double v);\\n\"\n                        \"    double m;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    double d;\\n\"\n                        \"    S s(d);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:9]: (error) Uninitialized variable: d [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S {\\n\"\n                        \"    explicit S(double v) : m(v) {}\\n\"\n                        \"    double m;\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    double d;\\n\"\n                        \"    S s{ d };\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (error) Uninitialized variable: d [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S { int x; int y; };\\n\"\n                        \"int f() {\\n\"\n                        \"  S s;\\n\"\n                        \"  s.x = 0;\\n\"\n                        \"  return (&s)->x;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S { int x; int y; };\\n\"\n                        \"int f() {\\n\"\n                        \"  S s;\\n\"\n                        \"  s.x = 0;\\n\"\n                        \"  return (&s)->y;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (error) Uninitialized variable: s.y [uninitvar]\\n\", errout_str());\n    }\n\n    void valueFlowUninitForLoop()\n    {\n        valueFlowUninit(\"void f() {\\n\" // #9924\n                        \"    for (unsigned int a = 0, b; a < 42; a++) {\\n\"\n                        \"        std::cout << ++b << std::endl;\\n\"\n                        \"    }\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:24]: (error) Uninitialized variable: b [uninitvar]\\n\", errout_str());\n    }\n\n    void uninitvar_memberfunction() {\n        // # 8715\n        valueFlowUninit(\"struct C {\\n\"\n                        \"    int x();\\n\"\n                        \"};\\n\"\n                        \"void f() {\\n\"\n                        \"    C *c;\\n\"\n                        \"    if (c->x() == 4) {}\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (error) Uninitialized variable: c [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct A { \\n\"\n                        \"    int i; \\n\"\n                        \"    void f();\\n\"\n                        \"};\\n\"\n                        \"void g() {\\n\"\n                        \"    A a;\\n\"\n                        \"    a.f();\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_nonmember() {\n        valueFlowUninit(\"struct Foo {\\n\"\n                        \"  int bar;\\n\"\n                        \"};\\n\"\n                        \"\\n\"\n                        \"int main() {\\n\"\n                        \"  Foo* foo;\\n\"\n                        \"  foo->bar = 3;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:3]: (error) Uninitialized variable: foo [uninitvar]\\n\", errout_str());\n    }\n\n    void uninitvarDesignatedInitializers() {\n        checkUninitVar(\"struct a { int b; };\\n\"\n                       \"int main() {\\n\"\n                       \"  char *b;\\n\"\n                       \"  extern int f(struct a *);\\n\"\n                       \"  return f(&(struct a){.b = 0});\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"struct a { int b, c; };\\n\"\n                       \"int main() {\\n\"\n                       \"  char *c;\\n\"\n                       \"  extern int f(struct a *);\\n\"\n                       \"  return f(&(struct a){.b = 0, .c = 0});\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void isVariableUsageDeref() {\n        // *p\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char a[10];\\n\"\n                       \"    char c = *a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        // extracttests.start: extern const int SIZE;\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char a[SIZE+10];\\n\"\n                       \"    char c = *a;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    char a[10];\\n\"\n                       \"    *a += 10;\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Uninitialized variable: a [legacyUninitvar]\\n\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"  int a[10][10];\\n\"\n                       \"  dostuff(*a);\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkUninitVar(\"void f() {\\n\"\n                       \"    void (*fp[1]) (void) = {function1};\\n\"\n                       \"    (*fp[0])();\\n\"\n                       \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void isVariableUsageDerefValueflow()\n    {\n        // *p\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    char a[10];\\n\"\n                        \"    char c = *a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Uninitialized variable: *a [uninitvar]\\n\", errout_str());\n\n        // extracttests.start: extern const int SIZE;\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    char a[SIZE+10];\\n\"\n                        \"    char c = *a;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: (error) Uninitialized variable: *a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    char a[10];\\n\"\n                        \"    *a += 10;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Uninitialized variable: *a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"  int a[10][10];\\n\"\n                        \"  dostuff(*a);\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\"\n                        \"    void (*fp[1]) (void) = {function1};\\n\"\n                        \"    (*fp[0])();\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"template <typename T, int value> T Get() {return value;}\\n\"\n                        \"char f() {\\n\"\n                        \"  char buf[10];\\n\"\n                        \"  for(int i = 0; i < Get<int,10>() ; ++i) \\n\"\n                        \"     buf[i] = 0;\\n\"\n                        \"  return buf[0];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"static void Foo(double* p) {\\n\"\n                        \" p[0] = 0;\\n\"\n                        \" p[1] = 0;\\n\"\n                        \" p[2] = 0;\\n\"\n                        \" p[3] = 0;\\n\"\n                        \"}\\n\"\n                        \"double f() {\\n\"\n                        \"  double L[2][2];\\n\"\n                        \"  Foo(*L);\\n\"\n                        \"  return L[0][0];\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"void f() {\\n\" // #11305\n                        \"    type_t a;\\n\"\n                        \"    a[0] = 0;\\n\"\n                        \"}\\n\", false);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uninitvar_memberaccess() {\n        valueFlowUninit(\"struct foo{char *bar;};\\n\"\n                        \"void f(unsigned long long *p) {\\n\"\n                        \"    foo a;\\n\"\n                        \"    ((&a)->bar) =  reinterpret_cast<char*>(*p);\\n\"\n                        \"    if ((&a)->bar) ;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct foo{char *bar;};\\n\"\n                        \"void f(unsigned long long *p) {\\n\"\n                        \"    foo a;\\n\"\n                        \"    ((&(a))->bar) =  reinterpret_cast<char*>(*p);\\n\"\n                        \"    if ((&a)->bar) ;\\n\"\n                        \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\" // #10200\n                        \"    struct B {\\n\"\n                        \"        int i;\\n\"\n                        \"    };\\n\"\n                        \"    int j;\\n\"\n                        \"};\\n\"\n                        \"void f(std::vector<A::B>& x) {\\n\"\n                        \"    A::B b;\\n\"\n                        \"    b.i = 123;\\n\"\n                        \"    x.push_back(b);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    struct B {\\n\"\n                        \"        int i;\\n\"\n                        \"    };\\n\"\n                        \"    int j;\\n\"\n                        \"};\\n\"\n                        \"void f(std::vector<A::B>& x) {\\n\"\n                        \"    A::B b;\\n\"\n                        \"    x.push_back(b);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:17]: (error) Uninitialized variable: b [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    struct B {\\n\"\n                        \"        int i;\\n\"\n                        \"    };\\n\"\n                        \"    int j;\\n\"\n                        \"};\\n\"\n                        \"void f(std::vector<A>&x) {\\n\"\n                        \"    A a;\\n\"\n                        \"    a.j = 123;\\n\"\n                        \"    x.push_back(a);\\n\"\n                        \"}\\n\");\n\n        valueFlowUninit(\"struct A {\\n\"\n                        \"    struct B {\\n\"\n                        \"        int i;\\n\"\n                        \"    };\\n\"\n                        \"    int j;\\n\"\n                        \"};\\n\"\n                        \"void f(std::vector<A>& x) {\\n\"\n                        \"    A a;\\n\"\n                        \"    x.push_back(a);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:17]: (error) Uninitialized variable: a [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S { struct T { int* p; } t[2]; };\\n\" // #11018\n                        \"void f() {\\n\"\n                        \"    S s;\\n\"\n                        \"    *&s.t[0].p = 0;\\n\"\n                        \"}\\n\"\n                        \"void g() {\\n\"\n                        \"    S s;\\n\"\n                        \"    ((*&(*&s.t[0].p))) = 0;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        valueFlowUninit(\"struct S { int i; };\\n\" // #6323\n                        \"void f() {\\n\"\n                        \"    struct S s;\\n\"\n                        \"    int x = -3;\\n\"\n                        \"    int y = x < (1, s.i);\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:23]: (error) Uninitialized variable: s.i [uninitvar]\\n\", errout_str());\n\n        valueFlowUninit(\"struct S { int x; };\\n\" // #11353\n                        \"struct S f() {\\n\"\n                        \"    struct S s;\\n\"\n                        \"    int* p = &s.x;\\n\"\n                        \"    *p = 0;\\n\"\n                        \"    return s;\\n\"\n                        \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void ctu_(const char* file, int line, const char code[]) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        CTU::FileInfo *ctu = CTU::getFileInfo(tokenizer);\n\n        // Check code..\n        std::list<Check::FileInfo*> fileInfo;\n        Check& c = getCheck<CheckUninitVar>();\n        fileInfo.push_back(c.getFileInfo(tokenizer, settings, \"\"));\n        c.analyseWholeProgram(*ctu, fileInfo, settings, *this); // TODO: check result\n        while (!fileInfo.empty()) {\n            delete fileInfo.back();\n            fileInfo.pop_back();\n        }\n        delete ctu;\n    }\n\n    void ctuTest() {\n        ctu(\"void f(int *p) {\\n\"\n            \"    a = *p;\\n\"\n            \"}\\n\"\n            \"int main() {\\n\"\n            \"  int x;\\n\"\n            \"  f(&x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:4] -> [test.cpp:2:10]: (error) Using argument p that points at uninitialized variable x [ctuuninitvar]\\n\", errout_str());\n\n        ctu(\"void use(int *p) { a = *p + 3; }\\n\"\n            \"void call(int x, int *p) { x++; use(p); }\\n\"\n            \"int main() {\\n\"\n            \"  int x;\\n\"\n            \"  call(4,&x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:7] -> [test.cpp:2:33] -> [test.cpp:1:25]: (error) Using argument p that points at uninitialized variable x [ctuuninitvar]\\n\", errout_str());\n\n        ctu(\"void dostuff(int *x, int *y) {\\n\"\n            \"  if (!var)\\n\"\n            \"    return -1;\\n\"  // <- early return\n            \"  *x = *y;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void f() {\\n\"\n            \"  int x;\\n\"\n            \"  dostuff(a, &x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void dostuff(int *x, int *y) {\\n\"\n            \"  if (cond)\\n\"\n            \"    *y = -1;\\n\"  // <- conditionally written\n            \"  *x = *y;\\n\"\n            \"}\\n\"\n            \"\\n\"\n            \"void f() {\\n\"\n            \"  int x;\\n\"\n            \"  dostuff(a, &x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void f(int *p) {\\n\"\n            \"    a = sizeof(*p);\\n\"\n            \"}\\n\"\n            \"int main() {\\n\"\n            \"  int x;\\n\"\n            \"  f(&x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void f(int *v) {\\n\"\n            \"  std::cin >> *v;\\n\"\n            \"}\\n\"\n            \"int main() {\\n\"\n            \"  int x;\\n\"\n            \"  f(&x);\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void increment(int& i) { ++i; }\\n\" // #6475\n            \"int f() {\\n\"\n            \"    int n;\\n\"\n            \"    increment(n);\\n\"\n            \"    return n;\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14] -> [test.cpp:1:28]: (error) Using argument i that points at uninitialized variable n [ctuuninitvar]\\n\", errout_str());\n\n        ctu(\"void increment(int* i) { ++(*i); }\\n\"\n            \"int f() {\\n\"\n            \"    int n;\\n\"\n            \"    increment(&n);\\n\"\n            \"    return n;\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14] -> [test.cpp:1:30]: (error) Using argument i that points at uninitialized variable n [ctuuninitvar]\\n\", errout_str());\n\n        ctu(\"typedef struct { int type; int id; } Stem;\\n\"\n            \"void lookupStem(recodeCtx h, Stem *stem) {\\n\"\n            \"    i = stem->type & STEM_VERT;\\n\"\n            \"}\\n\"\n            \"void foo() {\\n\"\n            \"    Stem stem;\\n\"\n            \"    stem.type = 0;\\n\"\n            \"    lookupStem(h, &stem);\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        ctu(\"void increment(int& i) { ++i; }\\n\" // #6475\n            \"int f() {\\n\"\n            \"    int n;\\n\"\n            \"    increment(n);\\n\"\n            \"    return n;\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:14] -> [test.cpp:1:28]: (error) Using argument i that points at uninitialized variable n [ctuuninitvar]\\n\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestUninitVar)\n"
    }
  ]
}