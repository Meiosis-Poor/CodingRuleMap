{
  "name": "destructors",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 32,
  "branches": 13,
  "apis": 24,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        82
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkexceptionsafety.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n\n#include <cstddef>\n\nclass TestExceptionSafety : public TestFixture {\npublic:\n    TestExceptionSafety() : TestFixture(\"TestExceptionSafety\") {}\n\nprivate:\n    /*const*/ Settings settings;\n\n    void run() override {\n        settings.severity.fill();\n\n        mNewTemplate = true;\n        TEST_CASE(destructors);\n        TEST_CASE(deallocThrow1);\n        TEST_CASE(deallocThrow2);\n        TEST_CASE(deallocThrow3);\n        TEST_CASE(rethrowCopy1);\n        TEST_CASE(rethrowCopy2);\n        TEST_CASE(rethrowCopy3);\n        TEST_CASE(rethrowCopy4);\n        TEST_CASE(rethrowCopy5);\n        TEST_CASE(catchExceptionByValue);\n        TEST_CASE(noexceptThrow);\n        TEST_CASE(nothrowThrow);\n        TEST_CASE(unhandledExceptionSpecification1); // #4800\n        TEST_CASE(unhandledExceptionSpecification2);\n        TEST_CASE(unhandledExceptionSpecification3);\n        TEST_CASE(nothrowAttributeThrow);\n        TEST_CASE(nothrowAttributeThrow2); // #5703\n        TEST_CASE(nothrowDeclspecThrow);\n        TEST_CASE(rethrowNoCurrentException1);\n        TEST_CASE(rethrowNoCurrentException2);\n        TEST_CASE(rethrowNoCurrentException3);\n        TEST_CASE(noFunctionCall);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        bool inconclusive = false;\n        const Settings *s = nullptr;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size],  const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.s ? *options.s : settings).certainty(Certainty::inconclusive, options.inconclusive).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check char variable usage..\n        runChecks<CheckExceptionSafety>(tokenizer, this);\n    }\n\n    void destructors() {\n        check(\"class x {\\n\"\n              \"    ~x() {\\n\"\n              \"        throw e;\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Class x is not safe, destructor throws exception [exceptThrowInDestructor]\\n\"\n                      \"[test.cpp:3:9]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        check(\"class x {\\n\"\n              \"    ~x();\\n\"\n              \"};\\n\"\n              \"x::~x() {\\n\"\n              \"    throw e;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (warning) Class x is not safe, destructor throws exception [exceptThrowInDestructor]\\n\"\n                      \"[test.cpp:5:5]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        // #3858 - throwing exception in try block in destructor.\n        check(\"class x {\\n\"\n              \"    ~x() {\\n\"\n              \"        try {\\n\"\n              \"            throw e;\\n\"\n              \"        } catch (...) {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class x {\\n\"\n              \"    ~x() {\\n\"\n              \"        if(!std::uncaught_exception()) {\\n\"\n              \"            throw e;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        // #11031 should not warn when noexcept false\n        check(\"class A {\\n\"\n              \"public:\\n\"\n              \"    ~A() noexcept(false) {\\n\"\n              \"        throw 30;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocThrow1() {\n        check(\"int * p;\\n\"\n              \"void f(int x) {\\n\"\n              \"    delete p;\\n\"\n              \"    if (x)\\n\"\n              \"        throw 123;\\n\"\n              \"    p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (warning) Exception thrown in invalid state, 'p' points at deallocated memory. [exceptDeallocThrow]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int* p = foo;\\n\"\n              \"    delete p;\\n\"\n              \"    if (foo)\\n\"\n              \"        throw 1;\\n\"\n              \"    p = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (warning) Exception thrown in invalid state, 'p' points at deallocated memory. [exceptDeallocThrow]\\n\", errout_str());\n    }\n\n    void deallocThrow2() {\n        check(\"void f() {\\n\"\n              \"    int* p = 0;\\n\"\n              \"    delete p;\\n\"\n              \"    if (foo)\\n\"\n              \"        throw 1;\\n\"\n              \"    p = new int;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int* p = 0;\\n\"\n              \"    delete p;\\n\"\n              \"    reset(p);\\n\"\n              \"    throw 1;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void deallocThrow3() {\n        check(\"void f() {\\n\"\n              \"    static int* p = 0;\\n\"\n              \"    delete p;\\n\"\n              \"    throw 1;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static int* p = 0;\\n\"\n              \"    delete p;\\n\"\n              \"    throw 1;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (warning) Exception thrown in invalid state, 'p' points at deallocated memory. [exceptDeallocThrow]\\n\", errout_str());\n    }\n\n    void rethrowCopy1() {\n        check(\"void f() {\\n\"\n              \"    try\\n\"\n              \"    {\\n\"\n              \"       foo();\\n\"\n              \"    }\\n\"\n              \"    catch(const exception& err)\\n\"\n              \"    {\\n\"\n              \"        throw err;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9]: (style) Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]\\n\", errout_str());\n    }\n\n    void rethrowCopy2() {\n        check(\"void f() {\\n\"\n              \"    try\\n\"\n              \"    {\\n\"\n              \"       foo();\\n\"\n              \"    }\\n\"\n              \"    catch(exception& err)\\n\"\n              \"    {\\n\"\n              \"        throw err;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:9]: (style) Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]\\n\", errout_str());\n    }\n\n    void rethrowCopy3() {\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"       foo();\\n\"\n              \"    }\\n\"\n              \"    catch(std::runtime_error& err) {\\n\"\n              \"        throw err;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (style) Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]\\n\", errout_str());\n    }\n\n    void rethrowCopy4() {\n        check(\"void f() {\\n\"\n              \"    try\\n\"\n              \"    {\\n\"\n              \"       foo();\\n\"\n              \"    }\\n\"\n              \"    catch(const exception& err)\\n\"\n              \"    {\\n\"\n              \"        exception err2;\\n\"\n              \"        throw err2;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void rethrowCopy5() {\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"       foo();\\n\"\n              \"    }\\n\"\n              \"    catch(const exception& outer) {\\n\"\n              \"        try {\\n\"\n              \"           foo(outer);\\n\"\n              \"        }\\n\"\n              \"        catch(const exception& inner) {\\n\"\n              \"            throw inner;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:13]: (style) Throwing a copy of the caught exception instead of rethrowing the original exception. [exceptRethrowCopy]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"       foo();\\n\"\n              \"    }\\n\"\n              \"    catch(const exception& outer) {\\n\"\n              \"        try {\\n\"\n              \"           foo(outer);\\n\"\n              \"        }\\n\"\n              \"        catch(const exception& inner) {\\n\"\n              \"            throw outer;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void catchExceptionByValue() {\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch( ::std::exception err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (style) Exception should be caught by reference. [catchExceptionByValue]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch(const exception err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (style) Exception should be caught by reference. [catchExceptionByValue]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch( ::std::exception& err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch(exception* err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch(const exception& err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch(int err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    try {\\n\"\n              \"        bar();\\n\"\n              \"    }\\n\"\n              \"    catch(exception* const err) {\\n\"\n              \"        foo(err);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void noexceptThrow() {\n        check(\"void func1() noexcept(false) { try {} catch(...) {;} throw 1; }\\n\"\n              \"void func2() noexcept { throw 1; }\\n\"\n              \"void func3() noexcept(true) { throw 1; }\\n\"\n              \"void func4() noexcept(false) { throw 1; }\\n\"\n              \"void func5() noexcept(true) { func1(); }\\n\"\n              \"void func6() noexcept(false) { func1(); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\"\n                      \"[test.cpp:3:31]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\"\n                      \"[test.cpp:5:31]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        // avoid false positives\n        check(\"const char *func() noexcept { return 0; }\\n\"\n              \"const char *func1() noexcept { try { throw 1; } catch(...) {} return 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nothrowThrow() {\n        check(\"void func1() throw(int) { try {;} catch(...) { throw 1; } ; }\\n\"\n              \"void func2() throw() { throw 1; }\\n\"\n              \"void func3() throw(int) { throw 1; }\\n\"\n              \"void func4() throw() { func1(); }\\n\"\n              \"void func5() throw(int) { func1(); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:24]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\"\n                      \"[test.cpp:4:24]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        // avoid false positives\n        check(\"const char *func() throw() { return 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n\n        // #11691: FP throwInNoexceptFunction with if constexpr in template\n        check(\"template<bool IsNoThrow>\\n\"\n              \"static void foo(size_t Size) noexcept(IsNoThrow) {\\n\"\n              \"    if constexpr (!IsNoThrow) {\\n\"\n              \"        throw std::bad_alloc();\\n\"\n              \"    }\\n\"\n              \"}\\n\"\n              \"foo<true>(123);\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void unhandledExceptionSpecification1() { // #4800\n        check(\"void myThrowingFoo() throw(MyException) {\\n\"\n              \"  throw MyException();\\n\"\n              \"}\\n\"\n              \"void myNonCatchingFoo() {\\n\"\n              \"  myThrowingFoo();\\n\"\n              \"}\\n\"\n              \"void myCatchingFoo() {\\n\"\n              \"  try {\\n\"\n              \"    myThrowingFoo();\\n\"\n              \"  } catch(MyException &) {}\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:3] -> [test.cpp:1:6]: (style, inconclusive) Unhandled exception specification when calling function myThrowingFoo(). [unhandledExceptionSpecification]\\n\", errout_str());\n    }\n\n    void unhandledExceptionSpecification2() {\n        check(\"void f() const throw (std::runtime_error);\\n\"\n              \"int main()\\n\"\n              \"{\\n\"\n              \"    f();\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void unhandledExceptionSpecification3() {\n        const char code[] = \"void f() const throw (std::runtime_error);\\n\"\n                            \"int _init() {\\n\"\n                            \"    f();\\n\"\n                            \"}\\n\"\n                            \"int _fini() {\\n\"\n                            \"    f();\\n\"\n                            \"}\\n\"\n                            \"int main()\\n\"\n                            \"{\\n\"\n                            \"    f();\\n\"\n                            \"}\\n\";\n\n        check(code, dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:1:6]: (style, inconclusive) Unhandled exception specification when calling function f(). [unhandledExceptionSpecification]\\n\"\n                      \"[test.cpp:6:5] -> [test.cpp:1:6]: (style, inconclusive) Unhandled exception specification when calling function f(). [unhandledExceptionSpecification]\\n\", errout_str());\n\n        const Settings s = settingsBuilder().library(\"gnu.cfg\").build();\n        check(code, dinit(CheckOptions, $.inconclusive = true, $.s = &s));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nothrowAttributeThrow() {\n        check(\"void func1() throw(int) { throw 1; }\\n\"\n              \"void func2() __attribute((nothrow)); void func2() { throw 1; }\\n\"\n              \"void func3() __attribute((nothrow)); void func3() { func1(); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:53]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\"\n                      \"[test.cpp:3:53]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        // avoid false positives\n        check(\"const char *func() __attribute((nothrow)); void func1() { return 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nothrowAttributeThrow2() {\n        check(\"class foo {\\n\"\n              \"  void copyMemberValues() throw () {\\n\"\n              \"      copyMemberValues();\\n\"\n              \"   }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void nothrowDeclspecThrow() {\n        check(\"void func1() throw(int) { throw 1; }\\n\"\n              \"void __declspec(nothrow) func2() { throw 1; }\\n\"\n              \"void __declspec(nothrow) func3() { func1(); }\");\n        ASSERT_EQUALS(\"[test.cpp:2:36]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\"\n                      \"[test.cpp:3:36]: (error) Exception thrown in function declared not to throw exceptions. [throwInNoexceptFunction]\\n\", errout_str());\n\n        // avoid false positives\n        check(\"const char *func() __attribute((nothrow)); void func1() { return 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void rethrowNoCurrentException1() {\n        check(\"void func1(const bool flag) { try{ if(!flag) throw; } catch (int&) { ; } }\");\n        ASSERT_EQUALS(\"[test.cpp:1:46]: (error) Rethrowing current exception with 'throw;', it seems there is no current exception to rethrow.\"\n                      \" If there is no current exception this calls std::terminate(). More: https://isocpp.org/wiki/faq/exceptions#throw-without-an-object [rethrowNoCurrentException]\\n\", errout_str());\n    }\n\n    void rethrowNoCurrentException2() {\n        check(\"void func1() { try{ ; } catch (...) { ; } throw; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:43]: (error) Rethrowing current exception with 'throw;', it seems there is no current exception to rethrow.\"\n                      \" If there is no current exception this calls std::terminate(). More: https://isocpp.org/wiki/faq/exceptions#throw-without-an-object [rethrowNoCurrentException]\\n\", errout_str());\n    }\n\n    void rethrowNoCurrentException3() {\n        check(\"void on_error() { try { throw; } catch (const int &) { ; } catch (...) { ; } }\\n\"      // exception dispatcher idiom\n              \"void func2() { try{ ; } catch (const int&) { throw; } ; }\\n\"\n              \"void func3() { throw 0; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void noFunctionCall() {\n        check(\"void f() {\\n\" // #13803\n              \"    throw \\\"error\\\";\\n\"\n              \"}\\n\"\n              \"void g() noexcept {\\n\"\n              \"    auto pF = &f;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestExceptionSafety)\n"
    }
  ]
}