{
  "name": "misMatchingContainerIterator",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 46,
  "branches": 19,
  "apis": 49,
  "test": [
    {
      "description": null,
      "expected-problems": 1,
      "expected-linenumbers": [
        2132
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkstl.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"settings.h\"\n#include \"standards.h\"\n#include \"utils.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestStl : public TestFixture {\npublic:\n    TestStl() : TestFixture(\"TestStl\") {}\n\nprivate:\n    /*const*/ Settings settings = settingsBuilder().severity(Severity::warning).severity(Severity::style).severity(Severity::performance).library(\"std.cfg\").build();\n\n    void run() override {\n        mNewTemplate = true;\n        TEST_CASE(outOfBounds);\n        TEST_CASE(outOfBoundsSymbolic);\n        TEST_CASE(outOfBoundsIndexExpression);\n        TEST_CASE(outOfBoundsIterator);\n\n        TEST_CASE(iterator1);\n        TEST_CASE(iterator2);\n        TEST_CASE(iterator3);\n        TEST_CASE(iterator4);\n        TEST_CASE(iterator5);\n        TEST_CASE(iterator6);\n        TEST_CASE(iterator7);\n        TEST_CASE(iterator8);\n        TEST_CASE(iterator9);\n        TEST_CASE(iterator10);\n        TEST_CASE(iterator11);\n        TEST_CASE(iterator12);\n        TEST_CASE(iterator13);\n        TEST_CASE(iterator14); // #8191\n        TEST_CASE(iterator15); // #8341\n        TEST_CASE(iterator16);\n        TEST_CASE(iterator17);\n        TEST_CASE(iterator18);\n        TEST_CASE(iterator19);\n        TEST_CASE(iterator20);\n        TEST_CASE(iterator21);\n        TEST_CASE(iterator22);\n        TEST_CASE(iterator23);\n        TEST_CASE(iterator24);\n        TEST_CASE(iterator25); // #9742\n        TEST_CASE(iterator26); // #9176\n        TEST_CASE(iterator27); // #10378\n        TEST_CASE(iterator28); // #10450\n        TEST_CASE(iterator29);\n        TEST_CASE(iterator30);\n        TEST_CASE(iterator31);\n        TEST_CASE(iteratorExpression);\n        TEST_CASE(iteratorSameExpression);\n        TEST_CASE(mismatchingContainerIterator);\n        TEST_CASE(eraseIteratorOutOfBounds);\n\n        TEST_CASE(dereference);\n        TEST_CASE(dereference_break);  // #3644 - handle \"break\"\n        TEST_CASE(dereference_member);\n\n        TEST_CASE(STLSize);\n        TEST_CASE(STLSizeNoErr);\n        TEST_CASE(negativeIndex);\n        TEST_CASE(negativeIndexMultiline);\n        TEST_CASE(erase1);\n        TEST_CASE(erase2);\n        TEST_CASE(erase3);\n        TEST_CASE(erase4);\n        TEST_CASE(erase5);\n        TEST_CASE(erase6);\n        TEST_CASE(eraseBreak);\n        TEST_CASE(eraseContinue);\n        TEST_CASE(eraseReturn1);\n        TEST_CASE(eraseReturn2);\n        TEST_CASE(eraseReturn3);\n        TEST_CASE(eraseGoto);\n        TEST_CASE(eraseAssign1);\n        TEST_CASE(eraseAssign2);\n        TEST_CASE(eraseAssign3);\n        TEST_CASE(eraseAssign4);\n        TEST_CASE(eraseAssignByFunctionCall);\n        TEST_CASE(eraseErase);\n        TEST_CASE(eraseByValue);\n        TEST_CASE(eraseIf);\n        TEST_CASE(eraseOnVector);\n\n        TEST_CASE(pushback1);\n        TEST_CASE(pushback2);\n        TEST_CASE(pushback3);\n        TEST_CASE(pushback4);\n        TEST_CASE(pushback5);\n        TEST_CASE(pushback6);\n        TEST_CASE(pushback7);\n        TEST_CASE(pushback8);\n        TEST_CASE(pushback9);\n        TEST_CASE(pushback10);\n        TEST_CASE(pushback11);\n        TEST_CASE(pushback12);\n        TEST_CASE(pushback13);\n        TEST_CASE(insert1);\n        TEST_CASE(insert2);\n        TEST_CASE(popback1);\n\n        TEST_CASE(stlBoundaries1);\n        TEST_CASE(stlBoundaries2);\n        TEST_CASE(stlBoundaries3);\n        TEST_CASE(stlBoundaries4); // #4364\n        TEST_CASE(stlBoundaries5); // #4352\n        TEST_CASE(stlBoundaries6); // #7106\n\n        // if (str.find(\"ab\"))\n        TEST_CASE(if_find);\n        TEST_CASE(if_str_find);\n\n        TEST_CASE(size1);\n        TEST_CASE(size2);\n        TEST_CASE(size3);\n        TEST_CASE(size4); // #2652 - don't warn about vector/deque\n\n        // Redundant conditions..\n        // if (ints.find(123) != ints.end()) ints.remove(123);\n        TEST_CASE(redundantCondition1);\n\n        // missing inner comparison when incrementing iterator inside loop\n        TEST_CASE(missingInnerComparison1);\n        TEST_CASE(missingInnerComparison2);     // no FP when there is comparison\n        TEST_CASE(missingInnerComparison3);     // no FP when there is iterator shadowing\n        TEST_CASE(missingInnerComparison4);     // no FP when \"break;\" is used\n        TEST_CASE(missingInnerComparison5);     // Ticket #2154 - FP\n        TEST_CASE(missingInnerComparison6);     // #2643 - 'it=foo.insert(++it,0);'\n\n        // catch common problems when using the string::c_str() function\n        TEST_CASE(cstr);\n\n        TEST_CASE(uselessCalls);\n        TEST_CASE(stabilityOfChecks); // #4684 cppcheck crash in template function call\n\n        TEST_CASE(dereferenceInvalidIterator);\n        TEST_CASE(dereferenceInvalidIterator2); // #6572\n        TEST_CASE(dereference_auto);\n\n        TEST_CASE(loopAlgoElementAssign);\n        TEST_CASE(loopAlgoAccumulateAssign);\n        TEST_CASE(loopAlgoContainerInsert);\n        TEST_CASE(loopAlgoIncrement);\n        TEST_CASE(loopAlgoConditional);\n        TEST_CASE(loopAlgoMinMax);\n        TEST_CASE(loopAlgoMultipleReturn);\n\n        TEST_CASE(invalidContainer);\n        TEST_CASE(invalidContainerLoop);\n        TEST_CASE(findInsert);\n\n        TEST_CASE(checkKnownEmptyContainer);\n        TEST_CASE(checkMutexes);\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        bool inconclusive = false;\n        Standards::cppstd_t cppstandard = Standards::CPPLatest;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(settings).certainty(Certainty::inconclusive, options.inconclusive).cpp(options.cppstandard).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        runChecks<CheckStl>(tokenizer, this);\n    }\n\n    // TODO: get rid of this\n    void check_(const char* file, int line, const std::string& code) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        runChecks<CheckStl>(tokenizer, this);\n    }\n\n#define checkNormal(code) checkNormal_(code, __FILE__, __LINE__)\n    template<size_t size>\n    void checkNormal_(const char (&code)[size], const char* file, int line) {\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        runChecks<CheckStl>(tokenizer, this);\n    }\n\n    void outOfBounds() {\n        setMultiline();\n\n        checkNormal(\"bool f(const int a, const int b)\\n\" // #8648\n                    \"{\\n\"\n                    \"    std::cout << a << b;\\n\"\n                    \"    return true;\\n\"\n                    \"}\\n\"\n                    \"void f(const std::vector<int> &v)\\n\"\n                    \"{\\n\"\n                    \"    if(v.size() >=2 &&\\n\"\n                    \"            bar(v[2], v[3]) )\\n\"                          // v[3] is accessed\n                    \"    {;}\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:18]: warning: Either the condition 'v.size()>=2' is redundant or size of 'v' can be 2. Expression 'v[2]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:8:17]: note: condition 'v.size()>=2'\\n\"\n                      \"[test.cpp:9:18]: note: Access out of bounds\\n\"\n                      \"[test.cpp:9:24]: warning: Either the condition 'v.size()>=2' is redundant or size of 'v' can be 2. Expression 'v[3]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:8:17]: note: condition 'v.size()>=2'\\n\"\n                      \"[test.cpp:9:24]: note: Access out of bounds\\n\", errout_str());\n\n        checkNormal(\"void f() {\\n\"\n                    \"  std::string s;\\n\"\n                    \"  s[10] = 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4]: error: Out of bounds access in expression 's[10]' because 's' is empty. [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"void f() {\\n\"\n                    \"  std::string s = \\\"abcd\\\";\\n\"\n                    \"  s[10] = 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:4]: error: Out of bounds access in 's[10]', if 's' size is 4 and '10' is 10 [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"void f(std::vector<int> v) {\\n\"\n                    \"    v.front();\\n\"\n                    \"    if (v.empty()) {}\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: warning: Either the condition 'v.empty()' is redundant or expression 'v.front()' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:3:16]: note: condition 'v.empty()'\\n\"\n                      \"[test.cpp:2:12]: note: Access out of bounds\\n\", errout_str());\n\n        checkNormal(\"void f(std::vector<int> v) {\\n\"\n                    \"    if (v.size() == 3) {}\\n\"\n                    \"    v[16] = 0;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: warning: Either the condition 'v.size()==3' is redundant or size of 'v' can be 3. Expression 'v[16]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:2:18]: note: condition 'v.size()==3'\\n\"\n                      \"[test.cpp:3:6]: note: Access out of bounds\\n\", errout_str());\n\n        checkNormal(\"void f(std::vector<int> v) {\\n\"\n                    \"    int i = 16;\\n\"\n                    \"    if (v.size() == 3) {\\n\"\n                    \"        v[i] = 0;\\n\"\n                    \"    }\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: warning: Either the condition 'v.size()==3' is redundant or size of 'v' can be 3. Expression 'v[i]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:3:18]: note: condition 'v.size()==3'\\n\"\n                      \"[test.cpp:4:10]: note: Access out of bounds\\n\", errout_str());\n\n        checkNormal(\"void f(std::vector<int> v, int i) {\\n\"\n                    \"    if (v.size() == 3 || i == 16) {}\\n\"\n                    \"    v[i] = 0;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(std::map<int,int> x) {\\n\"\n                    \"    if (x.empty()) { x[1] = 2; }\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(std::string s) {\\n\"\n                    \"    if (s.size() == 1) {\\n\"\n                    \"        s[2] = 0;\\n\"\n                    \"    }\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: warning: Either the condition 's.size()==1' is redundant or size of 's' can be 1. Expression 's[2]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:2:18]: note: condition 's.size()==1'\\n\"\n                      \"[test.cpp:3:10]: note: Access out of bounds\\n\", errout_str());\n\n        // Do not crash\n        checkNormal(\"void a() {\\n\"\n                    \"  std::string b[];\\n\"\n                    \"  for (auto c : b)\\n\"\n                    \"    c.data();\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"std::string f(std::string x) {\\n\"\n                    \"  if (x.empty()) return {};\\n\"\n                    \"  x[0];\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"std::string f(std::string x) {\\n\"\n                    \"  if (x.empty()) return std::string{};\\n\"\n                    \"  x[0];\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f() {\\n\"\n                    \"  std::string s;\\n\"\n                    \"  x = s.begin() + 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:17]: error: Out of bounds access in expression 's.begin()+1' because 's' is empty. [containerOutOfBounds]\\n\"\n            \"[test.cpp:3:17]: error: Out of bounds access in expression 's.begin()+1' because 's' is empty. [containerOutOfBounds]\\n\",   // duplicate\n            errout_str());\n\n        checkNormal(\"void f(int x) {\\n\"\n                    \"  std::string s;\\n\"\n                    \"  auto it = s.begin() + x;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: error: Out of bounds access in expression 's.begin()+x' because 's' is empty and 'x' may be non-zero. [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"char fstr1(){const std::string s = \\\"<a><b>\\\"; return s[42]; }\\n\"\n                    \"wchar_t fwstr1(){const std::wstring s = L\\\"<a><b>\\\"; return s[42]; }\");\n        ASSERT_EQUALS(\"[test.cpp:1:54]: error: Out of bounds access in 's[42]', if 's' size is 6 and '42' is 42 [containerOutOfBounds]\\n\"\n                      \"[test.cpp:2:60]: error: Out of bounds access in 's[42]', if 's' size is 6 and '42' is 42 [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"char fstr1(){const std::string s = \\\"<a><b>\\\"; return s[1]; }\\n\"\n                    \"wchar_t fwstr1(){const std::wstring s = L\\\"<a><b>\\\"; return s[1]; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"int f() {\\n\"\n                    \"    std::vector<int> v;\\n\"\n                    \"    std::vector<int> * pv = &v;\\n\"\n                    \"    return (*pv)[42];\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:17]: error: Out of bounds access in expression '(*pv)[42]' because '*pv' is empty. [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"void f() {\\n\"\n                    \"  std::string s;\\n\"\n                    \"  ++abc[s];\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 9274\n        checkNormal(\"char f(bool b) {\\n\"\n                    \"    const std::string s = \\\"<a><b>\\\";\\n\"\n                    \"    int x = 6;\\n\"\n                    \"    if(b) ++x;\\n\"\n                    \"    return s[x];\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: error: Out of bounds access in 's[x]', if 's' size is 6 and 'x' is 6 [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"void f() {\\n\"\n                    \"    static const int N = 4;\\n\"\n                    \"    std::array<int, N> x;\\n\"\n                    \"    x[0] = 0;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(bool b) {\\n\"\n                    \"    std::vector<int> x;\\n\"\n                    \"    if (b)\\n\"\n                    \"        x.push_back(1);\\n\"\n                    \"    if (x.size() < 2)\\n\"\n                    \"        return;\\n\"\n                    \"    x[0] = 2;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(bool b) {\\n\"\n                    \"    std::vector<int> v;\\n\"\n                    \"    if(v.at(b?42:0)) {}\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:12]: error: Out of bounds access in expression 'v.at(b?42:0)' because 'v' is empty. [containerOutOfBounds]\\n\",\n            errout_str());\n\n        checkNormal(\"void f(std::vector<int> v, bool b){\\n\"\n                    \"    if (v.size() == 1)\\n\"\n                    \"        if(v.at(b?42:0)) {}\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:3:16]: warning: Either the condition 'v.size()==1' is redundant or size of 'v' can be 1. Expression 'v.at(b?42:0)' causes access out of bounds. [containerOutOfBounds]\\n\"\n            \"[test.cpp:2:18]: note: condition 'v.size()==1'\\n\"\n            \"[test.cpp:3:16]: note: Access out of bounds\\n\",\n            errout_str());\n\n        check(\"struct T {\\n\"\n              \"  std::vector<int>* v;\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"  T t;\\n\"\n              \"};\\n\"\n              \"long g(S& s);\\n\"\n              \"int f() {\\n\"\n              \"  std::vector<int> ArrS;\\n\"\n              \"  S s = { { &ArrS } };\\n\"\n              \"  g(s);\\n\"\n              \"  return ArrS[0];\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T {\\n\"\n              \"  std::vector<int>* v;\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"  std::vector<T> t;\\n\"\n              \"};\\n\"\n              \"long g(S& s);\\n\"\n              \"int f() {\\n\"\n              \"  std::vector<int> ArrS;\\n\"\n              \"  S s = { { { &ArrS } } };\\n\"\n              \"  g(s);\\n\"\n              \"  return ArrS[0];\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T {\\n\"\n              \"  std::vector<int>* v;\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"  std::vector<std::vector<T>> t;\\n\"\n              \"};\\n\"\n              \"long g(S& s);\\n\"\n              \"int f() {\\n\"\n              \"  std::vector<int> ArrS;\\n\"\n              \"  S s = { { { { &ArrS } } } };\\n\"\n              \"  g(s);\\n\"\n              \"  return ArrS[0];\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T {\\n\"\n              \"  std::vector<int>* v;\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"  T t;\\n\"\n              \"};\\n\"\n              \"long g(S& s);\\n\"\n              \"int f() {\\n\"\n              \"  std::vector<int> ArrS;\\n\"\n              \"  S s { { &ArrS } };\\n\"\n              \"  g(s);\\n\"\n              \"  return ArrS[0];\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T {\\n\"\n              \"  std::vector<int>* v;\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"  std::vector<T> t;\\n\"\n              \"};\\n\"\n              \"long g(S& s);\\n\"\n              \"int f() {\\n\"\n              \"  std::vector<int> ArrS;\\n\"\n              \"  S s { { { &ArrS } } };\\n\"\n              \"  g(s);\\n\"\n              \"  return ArrS[0];\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T {\\n\"\n              \"  std::vector<int>* v;\\n\"\n              \"};\\n\"\n              \"struct S {\\n\"\n              \"  std::vector<std::vector<T>> t;\\n\"\n              \"};\\n\"\n              \"long g(S& s);\\n\"\n              \"int f() {\\n\"\n              \"  std::vector<int> ArrS;\\n\"\n              \"  S s { { { { &ArrS } } } };\\n\"\n              \"  g(s);\\n\"\n              \"  return ArrS[0];\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"extern void Bar(const double, const double);\\n\"\n                    \"void f(std::vector<double> &r, const double ) {\\n\"\n                    \"    std::vector<double> result;\\n\"\n                    \"    double d = 0.0;\\n\"\n                    \"    const double inc = 0.1;\\n\"\n                    \"    for(unsigned int i = 0; i < 10; ++i) {\\n\"\n                    \"        result.push_back(d);\\n\"\n                    \"        d = (i + 1) * inc;\\n\"\n                    \"    }\\n\"\n                    \"    Bar(1.0, d);\\n\"\n                    \"    Bar(10U, result.size());\\n\"\n                    \"    Bar(0.0, result[0]);\\n\"\n                    \"    Bar(0.34, result[1]);\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(size_t entries) {\\n\"\n                    \"    std::vector<uint8_t> v;\\n\"\n                    \"    if (v.size() < entries + 2)\\n\"\n                    \"        v.resize(entries + 2);\\n\"\n                    \"    v[0] = 1;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(size_t entries) {\\n\"\n                    \"    std::vector<uint8_t> v;\\n\"\n                    \"    if (v.size() < entries)\\n\"\n                    \"        v.resize(entries);\\n\"\n                    \"    v[0] = 1;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:6]: error: Out of bounds access in expression 'v[0]' because 'v' is empty. [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"void f(size_t entries) {\\n\"\n                    \"    if (entries < 2) return;\\n\"\n                    \"    std::vector<uint8_t> v;\\n\"\n                    \"    if (v.size() < entries)\\n\"\n                    \"        v.resize(entries);\\n\"\n                    \"    v[0] = 1;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(size_t entries) {\\n\"\n                    \"    if (entries == 0) return;\\n\"\n                    \"    std::vector<uint8_t> v;\\n\"\n                    \"    if (v.size() < entries)\\n\"\n                    \"        v.resize(entries);\\n\"\n                    \"    v[0] = 1;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void foo(std::vector<int>* PArr, int n) {\\n\"\n                    \" std::vector<int> Arr;\\n\"\n                    \" if (!PArr)\\n\"\n                    \"   PArr = &Arr;\\n\"\n                    \" PArr->resize(n);\\n\"\n                    \" for (int i = 0; i < n; ++i)\\n\"\n                    \"   (*PArr)[i] = 1;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"int f() {\\n\"\n                    \"    std::vector<int> v;\\n\"\n                    \"    std::vector<int> * pv = &v;\\n\"\n                    \"    return (*pv).at(42);\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: error: Out of bounds access in expression '(*pv).at(42)' because '*pv' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        checkNormal(\"std::string f(const char* DirName) {\\n\"\n                    \"  if (DirName == nullptr)\\n\"\n                    \"      return {};\\n\"\n                    \"  std::string Name{ DirName };\\n\"\n                    \"  if (!Name.empty() && Name.back() != '\\\\\\\\')\\n\"\n                    \"    Name += '\\\\\\\\';\\n\"\n                    \"  return Name;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"bool f(bool b) {\\n\"\n                    \"  std::vector<int> v;\\n\"\n                    \"  if (b)\\n\"\n                    \"    v.push_back(0);\\n\"\n                    \"  for(auto i:v)\\n\"\n                    \"    if (v[i] > 0)\\n\"\n                    \"      return true;\\n\"\n                    \"  return false;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:3]: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        checkNormal(\"std::vector<int> range(int n);\\n\"\n                    \"bool f(bool b) {\\n\"\n                    \"  std::vector<int> v;\\n\"\n                    \"  if (b)\\n\"\n                    \"    v.push_back(1);\\n\"\n                    \"  assert(range(v.size()).size() == v.size());\\n\"\n                    \"  for(auto i:range(v.size()))\\n\"\n                    \"    if (v[i] > 0)\\n\"\n                    \"      return true;\\n\"\n                    \"  return false;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:3]: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        checkNormal(\"bool g();\\n\"\n                    \"int f(int x) {\\n\"\n                    \"    std::vector<int> v;\\n\"\n                    \"    if (g())\\n\"\n                    \"        v.emplace_back(x);\\n\"\n                    \"    const auto n = (int)v.size();\\n\"\n                    \"    for (int i = 0; i < n; ++i)\\n\"\n                    \"        if (v[i] > 0)\\n\"\n                    \"            return i;\\n\"\n                    \"    return 0;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:0]: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        checkNormal(\"bool g();\\n\"\n                    \"int f(int x) {\\n\"\n                    \"    std::vector<int> v;\\n\"\n                    \"    if (g())\\n\"\n                    \"        v.emplace_back(x);\\n\"\n                    \"    const auto n = static_cast<int>(v.size());\\n\"\n                    \"    for (int i = 0; i < n; ++i)\\n\"\n                    \"        if (v[i] > 0)\\n\"\n                    \"            return i;\\n\"\n                    \"    return 0;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:8:0]: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        checkNormal(\"bool g();\\n\"\n                    \"void f(int x) {\\n\"\n                    \"    std::vector<int> v;\\n\"\n                    \"    if (g())\\n\"\n                    \"        v.emplace_back(x);\\n\"\n                    \"    const int n = v.size();\\n\"\n                    \"    h(n);\\n\"\n                    \"    for (int i = 0; i < n; ++i)\\n\"\n                    \"        h(v[i]);\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void foo(const std::vector<int> &v) {\\n\"\n                    \"    if(v.size() >=1 && v[0] == 4 && v[1] == 2){}\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:38]: warning: Either the condition 'v.size()>=1' is redundant or size of 'v' can be 1. Expression 'v[1]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:2:17]: note: condition 'v.size()>=1'\\n\"\n                      \"[test.cpp:2:38]: note: Access out of bounds\\n\", errout_str());\n\n        checkNormal(\"int f(int x, int y) {\\n\"\n                    \"    std::vector<int> a = {0,1,2};\\n\"\n                    \"    if(x<2)\\n\"\n                    \"        y = a[x] + 1;\\n\"\n                    \"    else\\n\"\n                    \"        y = a[x];\\n\"\n                    \"    return y;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:14]: warning: Either the condition 'x<2' is redundant or 'x' can have the value greater or equal to 3. Expression 'a[x]' causes access out of bounds. [containerOutOfBounds]\\n\"\n            \"[test.cpp:3:9]: note: condition 'x<2'\\n\"\n            \"[test.cpp:6:14]: note: Access out of bounds\\n\",\n            errout_str());\n\n        checkNormal(\"int f(std::vector<int> v) {\\n\"\n                    \"    if (v.size() > 3)\\n\"\n                    \"        return v[v.size() - 3];\\n\"\n                    \"    return 0;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(std::vector<int> v) {\\n\"\n                    \"    v[v.size() - 1];\\n\"\n                    \"    if (v.size() == 1) {}\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(int n) {\\n\"\n                    \"    std::vector<int> v = {1, 2, 3, 4};\\n\"\n                    \"    const int i = qMin(n, v.size());\\n\"\n                    \"    if (i > 1)\\n\"\n                    \"        v[i] = 1;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(std::vector<int>& v, int i) {\\n\"\n                    \"    if (i > -1) {\\n\"\n                    \"        v.erase(v.begin() + i);\\n\"\n                    \"        if (v.empty()) {}\\n\"\n                    \"    }\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void g(const char *, ...) { exit(1); }\\n\" // #10025\n                    \"void f(const char c[]) {\\n\"\n                    \"    std::vector<int> v = get();\\n\"\n                    \"    if (v.empty())\\n\"\n                    \"        g(\\\"\\\", c[0]);\\n\"\n                    \"    return h(&v[0], v.size()); \\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(int i, std::vector<int> v) {\\n\" // #9157\n                    \"    if (i <= (int)v.size()) {\\n\"\n                    \"        if (v[i]) {}\\n\"\n                    \"    }\\n\"\n                    \"    if (i <= static_cast<int>(v.size())) {\\n\"\n                    \"        if (v[i]) {}\\n\"\n                    \"    }\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:14]: warning: Either the condition 'i<=(int)v.size()' is redundant or 'i' can have the value v.size(). Expression 'v[i]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:2:11]: note: condition 'i<=(int)v.size()'\\n\"\n                      \"[test.cpp:3:14]: note: Access out of bounds\\n\"\n                      \"[test.cpp:6:14]: warning: Either the condition 'i<=static_cast<int>(v.size())' is redundant or 'i' can have the value v.size(). Expression 'v[i]' causes access out of bounds. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:5:11]: note: condition 'i<=static_cast<int>(v.size())'\\n\"\n                      \"[test.cpp:6:14]: note: Access out of bounds\\n\",\n                      errout_str());\n\n        check(\"template<class Iterator>\\n\"\n              \"void b(Iterator d) {\\n\"\n              \"  std::string c = \\\"a\\\";\\n\"\n              \"  d + c.length();\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"  std::string buf;\\n\"\n              \"  b(buf.begin());\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:5]: error: Out of bounds access in expression 'd+c.length()' because 'buf' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"template<class Iterator>\\n\"\n              \"void b(Iterator d) {\\n\"\n              \"  std::string c = \\\"a\\\";\\n\"\n              \"  sort(d, d + c.length());\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"  std::string buf;\\n\"\n              \"  b(buf.begin());\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int> &v) {\\n\"\n              \"    return !v.empty() ? 42 : v.back();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:2:36]: warning: Either the condition 'v.empty()' is redundant or expression 'v.back()' causes access out of bounds. [containerOutOfBounds]\\n\"\n            \"[test.cpp:2:20]: note: condition 'v.empty()'\\n\"\n            \"[test.cpp:2:36]: note: Access out of bounds\\n\",\n            errout_str());\n\n        check(\"std::vector<int> g() {\\n\" // #10779\n              \"    std::vector<int> v(10);\\n\"\n              \"    for(int i = 0; i <= 10; ++i)\\n\"\n              \"        v[i] = 42;\\n\"\n              \"    return v;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:10]: error: Out of bounds access in 'v[i]', if 'v' size is 10 and 'i' is 10 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int s = 2;\\n\"\n              \"    std::vector <int> v(s);\\n\"\n              \"    v[100] = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: error: Out of bounds access in 'v[100]', if 'v' size is 2 and '100' is 100 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector <int> v({ 1, 2, 3 });\\n\"\n              \"    v[100] = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: error: Out of bounds access in 'v[100]', if 'v' size is 3 and '100' is 100 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[] = { 1, 2, 3 };\\n\"\n              \"    std::vector<char> v(c, sizeof(c) + c);\\n\"\n              \"    v[100] = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: error: Out of bounds access in 'v[100]', if 'v' size is 3 and '100' is 100 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    char c[] = { 1, 2, 3 };\\n\"\n              \"    std::vector<char> v{ c, c + sizeof(c) };\\n\"\n              \"    v[100] = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: error: Out of bounds access in 'v[100]', if 'v' size is 3 and '100' is 100 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    int i[] = { 1, 2, 3 };\\n\"\n              \"    std::vector<int> v(i, i + sizeof(i) / 4);\\n\"\n              \"    v[100] = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: error: Out of bounds access in 'v[100]', if 'v' size is 3 and '100' is 100 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\" // #6615\n              \"    int i[] = { 1, 2, 3 };\\n\"\n              \"    std::vector<int> v(i, i + sizeof(i) / sizeof(int));\\n\"\n              \"    v[100] = 1;\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"test.cpp:4:error:Out of bounds access in 'v[100]', if 'v' size is 3 and '100' is 100\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::array<int, 10> a = {};\\n\"\n              \"    a[10];\\n\"\n              \"    constexpr std::array<int, 10> b = {};\\n\"\n              \"    b[10];\\n\"\n              \"    const std::array<int, 10> c = {};\\n\"\n              \"    c[10];\\n\"\n              \"    static constexpr std::array<int, 10> d = {};\\n\"\n              \"    d[10];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: error: Out of bounds access in 'a[10]', if 'a' size is 10 and '10' is 10 [containerOutOfBounds]\\n\"\n                      \"[test.cpp:5:6]: error: Out of bounds access in 'b[10]', if 'b' size is 10 and '10' is 10 [containerOutOfBounds]\\n\"\n                      \"[test.cpp:7:6]: error: Out of bounds access in 'c[10]', if 'c' size is 10 and '10' is 10 [containerOutOfBounds]\\n\"\n                      \"[test.cpp:9:6]: error: Out of bounds access in 'd[10]', if 'd' size is 10 and '10' is 10 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"struct test_fixed {\\n\"\n              \"    std::array<int, 10> array = {};\\n\"\n              \"    void index(int i) { array[i]; }\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    test_fixed x = test_fixed();\\n\"\n              \"    x.index(10);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:30]: error: Out of bounds access in 'array[i]', if 'array' size is 10 and 'i' is 10 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"struct test_constexpr {\\n\"\n              \"    static constexpr std::array<int, 10> array = {};\\n\"\n              \"    void index(int i) { array[i]; }\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    test_constexpr x = test_constexpr();\\n\"\n              \"    x.index(10);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:30]: error: Out of bounds access in 'array[i]', if 'array' size is 10 and 'i' is 10 [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        checkNormal(\"struct A {\\n\"\n                    \"    const std::vector<int>& v;\\n\"\n                    \"    A(const std::vector<int>& x) : v(x)\\n\"\n                    \"    {}\\n\"\n                    \"    int f() const {\\n\"\n                    \"        return v[0];\\n\"\n                    \"    }\\n\"\n                    \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"struct A {\\n\"\n                    \"    static const std::vector<int> v;\\n\"\n                    \"    int f() const {\\n\"\n                    \"        return v[0];\\n\"\n                    \"    }\\n\"\n                    \"};\\n\"\n                    \"const std::vector<int> A::v = {1, 2};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"struct a {\\n\"\n                    \"    std::vector<int> g() const;\\n\"\n                    \"};\\n\"\n                    \"int f(const a& b) {\\n\"\n                    \"    auto c = b.g();\\n\"\n                    \"    assert(not c.empty());\\n\"\n                    \"    int d = c.front();\\n\"\n                    \"    return d;\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"std::string f() {\\n\"\n                    \"    std::map<int, std::string> m = { { 1, \\\"1\\\" } };\\n\"\n                    \"    return m.at(1);\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"struct A {\\n\"\n                    \"  virtual void init_v(std::vector<int> *v) = 0;\\n\"\n                    \"};\\n\"\n                    \"A* create_a();\\n\"\n                    \"struct B {\\n\"\n                    \"  B() : a(create_a()) {}\\n\"\n                    \"  void init_v(std::vector<int> *v) {\\n\"\n                    \"    a->init_v(v);\\n\"\n                    \"  }\\n\"\n                    \"  A* a;\\n\"\n                    \"};\\n\"\n                    \"void f() {\\n\"\n                    \"  B b;\\n\"\n                    \"  std::vector<int> v;\\n\"\n                    \"  b.init_v(&v);\\n\"\n                    \"  v[0];\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"void f(std::vector<int>* v) {\\n\"\n                    \"  if (v->empty())\\n\"\n                    \"    v->push_back(1);\\n\"\n                    \"  auto x = v->back();\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"template <typename T, uint8_t count>\\n\"\n                    \"struct Foo {\\n\"\n                    \"    std::array<T, count> items = {0};\\n\"\n                    \"    T maxCount = count;\\n\"\n                    \"    explicit Foo(const T& maxValue = (std::numeric_limits<T>::max)()) : maxCount(maxValue) {}\\n\"\n                    \"    bool Set(const uint8_t idx) {\\n\"\n                    \"        if (CheckBounds(idx) && items[idx] < maxCount) {\\n\"\n                    \"            items[idx] += 1;\\n\"\n                    \"            return true;\\n\"\n                    \"        }\\n\"\n                    \"        return false;\\n\"\n                    \"    }\\n\"\n                    \"    static bool CheckBounds(const uint8_t idx) { return idx < count; }\\n\"\n                    \"};\\n\"\n                    \"void f() {\\n\"\n                    \"    Foo<uint8_t, 42U> x;\\n\"\n                    \"    if (x.Set(42U)) {}\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"struct S { void g(std::span<int>& r) const; };\\n\" // #11828\n                    \"int f(const S& s) {\\n\"\n                    \"    std::span<int> t;\\n\"\n                    \"    s.g(t);\\n\"\n                    \"    return t[0];\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkNormal(\"char h() {\\n\"\n                    \"    std::string s;\\n\"\n                    \"    std::string_view sv(s);\\n\"\n                    \"    return s[2];\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: error: Out of bounds access in expression 's[2]' because 's' is empty. [containerOutOfBounds]\\n\", errout_str());\n\n        checkNormal(\"void f() {\\n\" // #12738\n                    \"    std::vector<double> v{ 0, 0.1 };\\n\"\n                    \"    (void)v[0];\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void outOfBoundsSymbolic()\n    {\n        check(\"void foo(std::string textline, int col) {\\n\"\n              \"    if(col > textline.size())\\n\"\n              \"        return false;\\n\"\n              \"    int x = textline[col];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:2:12] -> [test.cpp:4:21]: (warning) Either the condition 'col>textline.size()' is redundant or 'col' can have the value textline.size(). Expression 'textline[col]' causes access out of bounds. [containerOutOfBounds]\\n\",\n            errout_str());\n    }\n\n    void outOfBoundsIndexExpression() {\n        setMultiline();\n\n        checkNormal(\"void f(std::string s) {\\n\"\n                    \"  s[s.size()] = 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: error: Out of bounds access of s, index 's.size()' is out of bounds. [containerOutOfBoundsIndexExpression]\\n\", errout_str());\n\n        checkNormal(\"void f(std::string s) {\\n\"\n                    \"  s[s.size()+1] = 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: error: Out of bounds access of s, index 's.size()+1' is out of bounds. [containerOutOfBoundsIndexExpression]\\n\", errout_str());\n\n        checkNormal(\"void f(std::string s) {\\n\"\n                    \"  s[1+s.size()] = 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: error: Out of bounds access of s, index '1+s.size()' is out of bounds. [containerOutOfBoundsIndexExpression]\\n\", errout_str());\n\n        checkNormal(\"void f(std::string s) {\\n\"\n                    \"  s[x*s.size()] = 1;\\n\"\n                    \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: error: Out of bounds access of s, index 'x*s.size()' is out of bounds. [containerOutOfBoundsIndexExpression]\\n\", errout_str());\n\n        checkNormal(\"bool f(std::string_view& sv) {\\n\" // #10031\n                    \"    return sv[sv.size()] == '\\\\0';\\n\"\n                    \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:12]: error: Out of bounds access of sv, index 'sv.size()' is out of bounds. [containerOutOfBoundsIndexExpression]\\n\", errout_str());\n    }\n    void outOfBoundsIterator() {\n        check(\"int f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (error) Out of bounds access in expression 'it' because 'v' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"int f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.push_back(0);\\n\"\n              \"    auto it = v.begin() + 1;\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Out of bounds access in 'it', if 'v' size is 1 and 'it' is at position 1 from the beginning [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"int f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.push_back(0);\\n\"\n              \"    auto it = v.end() - 1;\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.push_back(0);\\n\"\n              \"    auto it = v.end() - 2;\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:13]: (error) Out of bounds access in 'it', if 'v' size is 1 and 'it' is at position 2 from the end [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void g(int);\\n\"\n              \"void f(std::vector<int> x) {\\n\"\n              \"    std::map<int, int> m;\\n\"\n              \"    if (!m.empty()) {\\n\"\n              \"        g(m.begin()->second);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> vec;\\n\"\n              \"    std::vector<int>::iterator it = vec.begin();\\n\"\n              \"    *it = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Out of bounds access in expression 'it' because 'vec' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> vec;\\n\"\n              \"    auto it = vec.begin();\\n\"\n              \"    *it = 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Out of bounds access in expression 'it' because 'vec' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n    }\n\n    void iterator1() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    for (std::list<int>::iterator it = l1.begin(); it != l2.end(); ++it)\\n\"\n              \"    { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:40]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    for (std::list<int>::iterator it = l1.begin(); l2.end() != it; ++it)\\n\"\n              \"    { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:52]: (error) Iterators of different containers 'l2' and 'l1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"struct C { std::list<int> l1; void func(); };\\n\"\n              \"void C::func() {\\n\"\n              \"    std::list<int>::iterator it;\\n\"\n              \"    for (it = l1.begin(); it != l1.end(); ++it) { }\\n\"\n              \"    C c;\\n\"\n              \"    for (it = c.l1.begin(); it != c.l1.end(); ++it) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Same check with reverse iterator\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    for (std::list<int>::const_reverse_iterator it = l1.rbegin(); it != l2.rend(); ++it)\\n\"\n              \"    { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:54]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iterator2() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    while (it != l2.end())\\n\"\n              \"    {\\n\"\n              \"        ++it;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:35]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    while (l2.end() != it)\\n\"\n              \"    {\\n\"\n              \"        ++it;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:12]: (error) Iterators of different containers 'l2' and 'l1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iterator3() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    l2.insert(it, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Same iterator is used with different containers 'l1' and 'l2'. [iterators1]\\n\"\n                      \"[test.cpp:6:5]: (error) Iterator 'it' referring to container 'l1' is used with container 'l2'. [mismatchingContainerIterator]\\n\",\n                      errout_str());\n\n        check(\"void foo() {\\n\" // #5803\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    l2.insert(it, l1.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\" // #7658\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    std::list<int>::iterator end = l1.end();\\n\"\n              \"    l2.insert(it, end);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // only warn for insert when there are preciself 2 arguments.\n        check(\"void foo() {\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    l2.insert(it);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void foo() {\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it = l1.begin();\\n\"\n              \"    l2.insert(it,0,1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n    }\n\n    void iterator4() {\n        check(\"void foo(std::vector<std::string> &test)\\n\"\n              \"{\\n\"\n              \"    std::set<int> result;\\n\"\n              \"    for (std::vector<std::string>::const_iterator cit = test.begin();\\n\"\n              \"        cit != test.end();\\n\"\n              \"        ++cit)\\n\"\n              \"    {\\n\"\n              \"        result.insert(cit->size());\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator5() {\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::find(ints1.begin(), ints2.end(), 22);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:47]: (error) Iterators of different containers 'ints1' and 'ints2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iterator6() {\n        // Ticket #1357\n        check(\"void foo(const std::set<int> &ints1)\\n\"\n              \"{\\n\"\n              \"    std::set<int> ints2;\\n\"\n              \"    std::set<int>::iterator it1 = ints1.begin();\\n\"\n              \"    std::set<int>::iterator it2 = ints1.end();\\n\"\n              \"    ints2.insert(it1, it2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const std::set<int> &ints1)\\n\"\n              \"{\\n\"\n              \"    std::set<int> ints2;\\n\"\n              \"    std::set<int>::iterator it1 = ints1.begin();\\n\"\n              \"    std::set<int>::iterator it2 = ints2.end();\\n\"\n              \"    ints2.insert(it1, it2);\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (error) Iterators of different containers are used together.\\n\", \"\", errout_str());\n    }\n\n    void iterator7() {\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::inplace_merge(ints1.begin(), std::advance(ints1.rbegin(), 5), ints2.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:56]: (error) Iterators of different containers 'ints1' and 'ints2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::inplace_merge(ints1.begin(), std::advance(ints2.rbegin(), 5), ints1.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator8() {\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::find_first_of(ints1.begin(), ints2.end(), ints1.begin(), ints1.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:56]: (error) Iterators of different containers 'ints1' and 'ints2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::find_first_of(ints1.begin(), ints1.end(), ints2.begin(), ints1.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:84]: (error) Iterators of different containers 'ints2' and 'ints1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::find_first_of(foo.bar.begin(), foo.bar.end()-6, ints2.begin(), ints1.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:90]: (error) Iterators of different containers 'ints2' and 'ints1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo(std::vector<int> ints1, std::vector<int> ints2)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it = std::find_first_of(ints1.begin(), ints1.end(), ints2.begin(), ints2.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6839\n        check(\"void f(const std::wstring& a, const std::wstring& b) {\\n\"\n              \"    const std::string tp1 = std::string(a.begin(), b.end());\\n\"\n              \"    const std::wstring tp2 = std::string(b.begin(), a.end());\\n\"\n              \"    const std::u16string tp3(a.begin(), b.end());\\n\"\n              \"    const std::u32string tp4(b.begin(), a.end());\\n\"\n              \"    const std::string fp1 = std::string(a.begin(), a.end());\\n\"\n              \"    const std::string tp2(a.begin(), a.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS( // TODO \"[test.cpp:2]: (error) Iterators of different containers are used together.\\n\"\n            // TODO \"[test.cpp:3]: (error) Iterators of different containers are used together.\\n\"\n            \"[test.cpp:4:26]: (error) Iterators of different containers 'tp3' and 'a' are used together. [mismatchingContainers]\\n\"\n            \"[test.cpp:5:26]: (error) Iterators of different containers 'tp4' and 'b' are used together. [mismatchingContainers]\\n\",\n            errout_str());\n    }\n\n    void iterator9() {\n        // Ticket #1600\n        check(\"void foo(std::vector<int> &r)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator aI = r.begin();\\n\"\n              \"    while(aI != r.end())\\n\"\n              \"    {\\n\"\n              \"        if (*aI == 0)\\n\"\n              \"        {\\n\"\n              \"            r.insert(aI, 42);\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"        ++aI;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #2481\n        check(\"void foo(std::vector<int> &r)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator aI = r.begin();\\n\"\n              \"    while(aI != r.end())\\n\"\n              \"    {\\n\"\n              \"        if (*aI == 0)\\n\"\n              \"        {\\n\"\n              \"            r.insert(aI, 42);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"        ++aI;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Execution path checking..\n        check(\"void foo(std::vector<int> &r, int c)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator aI = r.begin();\\n\"\n              \"    while(aI != r.end())\\n\"\n              \"    {\\n\"\n              \"        if (*aI == 0)\\n\"\n              \"        {\\n\"\n              \"            r.insert(aI, 42);\\n\"\n              \"            if (c)\\n\"\n              \"            {\\n\"\n              \"                return;\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"        ++aI;\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:14] (error) After insert(), the iterator 'aI' may be invalid.\", \"\", errout_str());\n    }\n\n    void iterator10() {\n        // Ticket #1679\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::set<int> s1;\\n\"\n              \"    std::set<int> s2;\\n\"\n              \"    for (std::set<int>::iterator it = s1.begin(); it != s1.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (true) { }\\n\"\n              \"        if (it != s2.end()) continue;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:39]: (error) Iterators of different containers 's1' and 's2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iterator11() {\n        // Ticket #3433\n        check(\"int main() {\\n\"\n              \"    map<int, int> myMap;\\n\"\n              \"    vector<string> myVector;\\n\"\n              \"    for(vector<int>::iterator x = myVector.begin(); x != myVector.end(); x++)\\n\"\n              \"        myMap.erase(*x);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator12() {\n        // Ticket #3201\n        check(\"void f() {\\n\"\n              \"    std::map<int, int> map1;\\n\"\n              \"    std::map<int, int> map2;\\n\"\n              \"    std::map<int, int>::const_iterator it = map1.find(123);\\n\"\n              \"    if (it == map2.end()) { }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:45]: (error) Iterators of different containers 'map1' and 'map2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::map<int, int> map1;\\n\"\n              \"    std::map<int, int> map2;\\n\"\n              \"    std::map<int, int>::const_iterator it = map1.find(123);\\n\"\n              \"    if (map2.end() == it) { }\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: (error) Iterators of different containers 'map2' and 'map1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void f(std::string &s) {\\n\"\n              \"    int pos = s.find(x);\\n\"\n              \"    s.erase(pos);\\n\"\n              \"    s.erase(pos);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator13() {\n        check(\"void f() {\\n\"\n              \"    std::vector<int> a;\\n\"\n              \"    std::vector<int> t;\\n\"\n              \"    std::vector<int>::const_iterator it;\\n\"\n              \"    it = a.begin();\\n\"\n              \"    while (it!=a.end())\\n\"\n              \"        ++it;\\n\"\n              \"    it = t.begin();\\n\"\n              \"    while (it!=a.end())\\n\"\n              \"        ++it;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:10]: (error) Iterators of different containers 't' and 'a' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        // #4062\n        check(\"void f() {\\n\"\n              \"    std::vector<int> a;\\n\"\n              \"    std::vector<int> t;\\n\"\n              \"    std::vector<int>::const_iterator it;\\n\"\n              \"    it = a.begin();\\n\"\n              \"    while (it!=a.end())\\n\"\n              \"        ++it;\\n\"\n              \"    it = t.begin();\\n\"\n              \"    while (it!=t.end())\\n\"\n              \"        ++it;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> a;\\n\"\n              \"    std::vector<int> t;\\n\"\n              \"    std::vector<int>::const_iterator it;\\n\"\n              \"    if(z)\\n\"\n              \"        it = a.begin();\\n\"\n              \"    else\\n\"\n              \"        it = t.begin();\\n\"\n              \"    while (z && it!=a.end())\\n\"\n              \"        ++it;\\n\"\n              \"    while (!z && it!=t.end())\\n\"\n              \"        ++it;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator14() {\n        check(\"void f() {\\n\"\n              \"    std::map<int,Foo> x;\\n\"\n              \"    std::map<int,Foo>::const_iterator it;\\n\"\n              \"    for (it = x.find(0)->second.begin(); it != x.find(0)->second.end(); ++it) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator15() {\n        check(\"void f(C1* x, std::list<int> a) {\\n\"\n              \"  std::list<int>::iterator pos = a.begin();\\n\"\n              \"  for(pos = x[0]->plist.begin(); pos != x[0]->plist.end(); ++pos) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator16() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l2.end();\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.end();\\n\"\n              \"    std::list<int>::iterator it2 = l2.begin();\\n\"\n              \"    while (it2 != it1)\\n\"\n              \"    {\\n\"\n              \"        ++it2;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:36]: (error) Iterators of different containers 'l2' and 'l1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it2 = l2.end();\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::set<int> l1;\\n\"\n              \"    std::set<int> l2(10, 4);\\n\"\n              \"    std::set<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::set<int>::iterator it2 = l2.find(4);\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:35]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iterator17() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    { it2 = l2.end(); }\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"    it2 = l2.end();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    it1 = l2.end();\\n\"\n              \"    it1 = l1.end();\\n\"\n              \"    if (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    { it2 = l2.end(); }\\n\"\n              \"    it2 = l1.end();\\n\"\n              \"    { it2 = l2.end(); }\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iterator18() {\n        check(\"void foo(std::list<int> l1, std::list<int> l2)\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    while (++it1 != --it2)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(std::list<int> l1, std::list<int> l2)\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    while (it1++ != --it2)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(std::list<int> l1, std::list<int> l2)\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l1.end();\\n\"\n              \"    if (--it2 > it1++)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"\", \"[test.cpp:5:15]: (error) Dangerous comparison using operator< on iterator. [stlBoundaries]\\n\", errout_str());\n    }\n\n    void iterator19() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    {\\n\"\n              \"        std::list<int> l1;\\n\"\n              \"        if (it1 != l1.end())\\n\"\n              \"        {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:7:13] -> [test.cpp:4:36]: (error) Same iterator is used with containers 'l1' that are temporaries or defined in different scopes. [iterators3]\\n\",\n            errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    {\\n\"\n              \"        std::list<int> l1;\\n\"\n              \"        if (l1.end() > it1)\\n\"\n              \"        {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:7] -> [test.cpp:4]: (error) Same iterator is used with containers 'l1' that are defined in different scopes.\\n\",\n            \"[test.cpp:7:19] -> [test.cpp:7:13]: (error) Same iterator is used with containers 'l1' that are temporaries or defined in different scopes. [iterators3]\\n\"\n            \"[test.cpp:7:22]: (error) Dangerous comparison using operator< on iterator. [stlBoundaries]\\n\",\n            errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    {\\n\"\n              \"        std::list<int> l1;\\n\"\n              \"        std::list<int>::iterator it2 = l1.begin();\\n\"\n              \"        if (it1 != it2)\\n\"\n              \"        {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:8:13] -> [test.cpp:4:36]: (error) Same iterator is used with containers 'l1' that are temporaries or defined in different scopes. [iterators3]\\n\",\n            errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    {\\n\"\n              \"        std::list<int> l1;\\n\"\n              \"        std::list<int>::iterator it2 = l1.begin();\\n\"\n              \"        if (it2 != it1)\\n\"\n              \"        {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:8:13] -> [test.cpp:7:40]: (error) Same iterator is used with containers 'l1' that are temporaries or defined in different scopes. [iterators3]\\n\",\n            errout_str());\n\n        check(\"std::set<int> g() {\\n\"\n              \"    static const std::set<int> s = {1};\\n\"\n              \"    return s;\\n\"\n              \"}\\n\"\n              \"void f() {\\n\"\n              \"    if (g().find(2) == g().end()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:17] -> [test.cpp:6:10]: (error) Same iterator is used with containers 'g()' that are temporaries or defined in different scopes. [iterators3]\\n\",\n            errout_str());\n\n        check(\"std::set<long> f() {\\n\" // #5804\n              \"    std::set<long> s;\\n\"\n              \"    return s;\\n\"\n              \"}\\n\"\n              \"void g() {\\n\"\n              \"    for (std::set<long>::iterator it = f().begin(); it != f().end(); ++it) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:53] -> [test.cpp:6:41]: (error) Same iterator is used with containers 'f()' that are temporaries or defined in different scopes. [iterators3]\\n\",\n            errout_str());\n    }\n\n    void iterator20() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l2.begin();\\n\"\n              \"    it1 = it2;\\n\"\n              \"    while (it1 != l1.end())\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:36]: (error) Iterators of different containers 'l2' and 'l1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"std::list<int> l3;\\n\"\n              \"std::list<int>::iterator bar()\\n\"\n              \"{\\n\"\n              \"    return l3.end();\\n\"\n              \"}\\n\"\n              \"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.begin();\\n\"\n              \"    std::list<int>::iterator it2 = l2.begin();\\n\"\n              \"    it1 = bar();\\n\"\n              \"    while (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"        ++it1;\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:13] -> [test.cpp:10] -> [test.cpp:11]: (error) Comparison of iterators from containers 'l1' and 'l2'.\\n\", \"\", errout_str());\n\n    }\n\n    void iterator21() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.end();\\n\"\n              \"    std::list<int>::iterator it2 = l2.begin();\\n\"\n              \"    if (it1 != it2)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"    if (it2 != it1)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\"\n                      \"[test.cpp:6:36]: (error) Iterators of different containers 'l2' and 'l1' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>::iterator it1 = l1.end();\\n\"\n              \"    std::list<int>::iterator it2 = l2.begin();\\n\"\n              \"    if (it1 != it2 && it1 != it2)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\"\n                      \"[test.cpp:5:36]: (error) Iterators of different containers 'l1' and 'l2' are used together. [mismatchingContainers]\\n\", // duplicate\n                      errout_str());\n    }\n\n    void iterator22() { // #7107\n        check(\"void foo() {\\n\"\n              \"    std::list<int> &l = x.l;\\n\"\n              \"    std::list<int>::iterator it = l.find(123);\\n\"\n              \"    x.l.erase(it);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator23() { // #9550\n        check(\"struct A {\\n\"\n              \"    struct B {\\n\"\n              \"        bool operator==(const A::B& b) const;\\n\"\n              \"        int x;\\n\"\n              \"        int y;\\n\"\n              \"        int z;\\n\"\n              \"    };\\n\"\n              \"};\\n\"\n              \"bool A::B::operator==(const A::B& b) const {\\n\"\n              \"    return std::tie(x, y, z) == std::tie(b.x, b.y, b.z);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator24() {\n        // #9556\n        check(\"void f(int a, int b) {\\n\"\n              \"  if (&a == &b) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int a, int b) {\\n\"\n              \"  if (std::for_each(&a, &b + 1, [](auto) {})) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (error) Iterators of different containers 'a' and 'b' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void f(int a, int b) {\\n\"\n              \"  if (std::for_each(&a, &b, [](auto) {})) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (error) Iterators of different containers 'a' and 'b' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"void f(int a) {\\n\"\n              \"  if (std::for_each(&a, &a, [](auto) {})) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:21]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n\n        check(\"void f(int a) {\\n\"\n              \"  if (std::for_each(&a, &a + 1, [](auto) {})) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator25() {\n        // #9742\n        check(\"struct S {\\n\"\n              \"  std::vector<int>& v;\\n\"\n              \"};\\n\"\n              \"struct T {\\n\"\n              \"    bool operator()(const S& lhs, const S& rhs) const {\\n\"\n              \"        return &lhs.v != &rhs.v;\\n\"\n              \"    }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator26() { // #9176\n        check(\n            \"#include <map>\\n\"\n            \"int main()\\n\"\n            \"{\"\n            \"  std::map<char const*, int> m{ {\\\"a\\\", 1} };\\n\"\n            \"  if (auto iter = m.find(\\\"x\\\"); iter != m.end()) {\\n\"\n            \"    return iter->second;\\n\"\n            \"  }\\n\"\n            \"  return 0;\\n\"\n            \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator27() {\n        // #10378\n        check(\"struct A {\\n\"\n              \"    int a;\\n\"\n              \"    int b;\\n\"\n              \"};\\n\"\n              \"int f(std::map<int, A> m) {\\n\"\n              \"    auto it =  m.find( 1 );\\n\"\n              \"    const int a( it == m.cend() ? 0 : it->second.a );\\n\"\n              \"    const int b( it == m.cend() ? 0 : it->second.b );\\n\"\n              \"    return a + b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator28()\n    {\n        // #10450\n        check(\"struct S {\\n\"\n              \"    struct Private {\\n\"\n              \"        std::list<int> l;\\n\"\n              \"    };\\n\"\n              \"    std::unique_ptr<Private> p;\\n\"\n              \"    int foo();\\n\"\n              \"};\\n\"\n              \"int S::foo() {\\n\"\n              \"    for(auto iter = p->l.begin(); iter != p->l.end(); ++iter) {\\n\"\n              \"        if(*iter == 1) {\\n\"\n              \"            p->l.erase(iter);\\n\"\n              \"            return 1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return 0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:10:24]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n    }\n\n    void iterator29()\n    {\n        // #11511\n        check(\"std::vector<int>& g();\\n\"\n              \"void f() {\\n\"\n              \"    auto v = g();\\n\"\n              \"    auto it = g().begin();\\n\"\n              \"    while (it != g().end())\\n\"\n              \"        it = v.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:14]: (error) Iterator 'it' referring to container 'g()' is used with container 'v'. [mismatchingContainerIterator]\\n\", errout_str());\n\n        check(\"std::vector<int>& g(int);\\n\"\n              \"void f(int i, int j) {\\n\"\n              \"    auto& r = g(i);\\n\"\n              \"    auto it = g(j).begin();\\n\"\n              \"    while (it != g(j).end())\\n\"\n              \"        it = r.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:14]: (error) Iterator 'it' referring to container 'g(j)' is used with container 'r'. [mismatchingContainerIterator]\\n\", errout_str());\n\n        check(\"std::vector<int>& g();\\n\"\n              \"void f() {\\n\"\n              \"    auto& r = g();\\n\"\n              \"    auto it = g().begin();\\n\"\n              \"    while (it != g().end())\\n\"\n              \"        it = r.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator30()\n    {\n        check(\"struct S {\\n\" // #12641\n              \"    bool b;\\n\"\n              \"    std::list<int> A, B;\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void S::f() {\\n\"\n              \"    std::list<int>::iterator i = (b ? B : A).begin();\\n\"\n              \"    while (i != (b ? B : A).end()) {\\n\"\n              \"        ++i;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iterator31()\n    {\n        check(\"struct S {\\n\" // #13327\n              \"    std::string a;\\n\"\n              \"};\\n\"\n              \"struct T {\\n\"\n              \"    S s;\\n\"\n              \"};\\n\"\n              \"bool f(const S& s) {\\n\"\n              \"    std::string b;\\n\"\n              \"    return s.a.c_str() == b.c_str();\\n\"\n              \"}\\n\"\n              \"bool g(const T& t) {\\n\"\n              \"    std::string b;\\n\"\n              \"    return t.s.a.c_str() == b.c_str();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:13]: (error) Iterators of different containers 's.a' and 'b' are used together. [mismatchingContainers]\\n\"\n                      \"[test.cpp:13:15]: (error) Iterators of different containers 't.s.a' and 'b' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n    }\n\n    void iteratorExpression() {\n        check(\"std::vector<int>& f();\\n\"\n              \"std::vector<int>& g();\\n\"\n              \"void foo() {\\n\"\n              \"    (void)std::find(f().begin(), g().end(), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:22]: (error) Iterators of different containers 'f()' and 'g()' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"std::vector<int>& g();\\n\"\n              \"void foo() {\\n\"\n              \"    if(f().begin() == g().end()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (error) Iterators of different containers 'f()' and 'g()' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"std::vector<int>& g();\\n\"\n              \"void foo() {\\n\"\n              \"    auto size = f().end() - g().begin();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:18]: (error) Iterators of different containers 'f()' and 'g()' are used together. [mismatchingContainers]\\n\",\n                      errout_str());\n\n        check(\"struct A {\\n\"\n              \"    std::vector<int>& f();\\n\"\n              \"    std::vector<int>& g();\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"    (void)std::find(A().f().begin(), A().g().end(), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:26]: (error) Iterators of different containers 'A().f()' and 'A().g()' are used together. [mismatchingContainers]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\"\n              \"    std::vector<int>& f();\\n\"\n              \"    std::vector<int>& g();\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"    (void)std::find(A{} .f().begin(), A{} .g().end(), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:27]: (error) Iterators of different containers 'A{}.f()' and 'A{}.g()' are used together. [mismatchingContainers]\\n\",\n            errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"std::vector<int>& g();\\n\"\n              \"void foo() {\\n\"\n              \"    (void)std::find(begin(f()), end(g()), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:28]: (warning) Iterators to containers from different expressions 'f()' and 'g()' are used together. [mismatchingContainerExpression]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    std::vector<int>& f();\\n\"\n              \"    std::vector<int>& g();\\n\"\n              \"};\\n\"\n              \"void foo() {\\n\"\n              \"    (void)std::find(A().f().begin(), A().f().end(), 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"std::vector<int>& g();\\n\"\n              \"void foo() {\\n\"\n              \"    if(bar(f().begin()) == g().end()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"void foo() {\\n\"\n              \"    auto it = f().end() - 1;\\n\"\n              \"    f().begin() - it;\\n\"\n              \"    f().begin()+1 - it;\\n\"\n              \"    f().begin() - (it + 1);\\n\"\n              \"    f().begin() - f().end();\\n\"\n              \"    f().begin()+1 - f().end();\\n\"\n              \"    f().begin() - (f().end() + 1);\\n\"\n              \"    (void)std::find(f().begin(), it, 0);\\n\"\n              \"    (void)std::find(f().begin(), it + 1, 0);\\n\"\n              \"    (void)std::find(f().begin() + 1, it + 1, 0);\\n\"\n              \"    (void)std::find(f().begin() + 1, it, 0);\\n\"\n              \"    (void)std::find(f().begin(), f().end(), 0);\\n\"\n              \"    (void)std::find(f().begin() + 1, f().end(), 0);\\n\"\n              \"    (void)std::find(f().begin(), f().end() - 1, 0);\\n\"\n              \"    (void)std::find(f().begin() + 1, f().end() - 1, 0);\\n\"\n              \"    (void)std::find(begin(f()), end(f()));\\n\"\n              \"    (void)std::find(begin(f()) + 1, end(f()), 0);\\n\"\n              \"    (void)std::find(begin(f()), end(f()) - 1, 0);\\n\"\n              \"    (void)std::find(begin(f()) + 1, end(f()) - 1, 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:30]: (error) Dereference of an invalid iterator: f().end()+1 [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"void foo() {\\n\"\n              \"    if(f().begin() == f().end()) {}\\n\"\n              \"    if(f().begin() == f().end()+1) {}\\n\"\n              \"    if(f().begin()+1 == f().end()) {}\\n\"\n              \"    if(f().begin()+1 == f().end()+1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:32]: (error) Dereference of an invalid iterator: f().end()+1 [derefInvalidIterator]\\n\"\n                      \"[test.cpp:6:34]: (error) Dereference of an invalid iterator: f().end()+1 [derefInvalidIterator]\\n\",\n                      errout_str());\n\n        check(\"std::vector<int>& f();\\n\"\n              \"void foo() {\\n\"\n              \"    if(std::begin(f()) == std::end(f())) {}\\n\"\n              \"    if(std::begin(f()) == std::end(f())+1) {}\\n\"\n              \"    if(std::begin(f())+1 == std::end(f())) {}\\n\"\n              \"    if(std::begin(f())+1 == std::end(f())+1) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:40]: (error) Dereference of an invalid iterator: std::end(f())+1 [derefInvalidIterator]\\n\"\n                      \"[test.cpp:6:42]: (error) Dereference of an invalid iterator: std::end(f())+1 [derefInvalidIterator]\\n\",\n                      errout_str());\n\n        check(\"template<int N>\\n\"\n              \"std::vector<int>& f();\\n\"\n              \"void foo() {\\n\"\n              \"    if(f<1>().begin() == f<1>().end()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  if (a.begin().x == b.begin().x) {}\\n\"\n              \"  if (begin(a).x == begin(b).x) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::list<int*> a, std::list<int*> b) {\\n\"\n              \"  if (*a.begin() == *b.begin()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    if(f().begin(1) == f().end()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(const uint8_t* data, const uint32_t dataLength) {\\n\"\n              \"    const uint32_t minimumLength = sizeof(uint16_t) + sizeof(uint16_t);\\n\"\n              \"    if (dataLength >= minimumLength) {\\n\"\n              \"        char* payload = new char[dataLength - minimumLength];\\n\"\n              \"        std::copy(&data[minimumLength], &data[dataLength], payload);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(const std::vector<int>& a, const std::vector<int>& b) {\\n\" // #11469\n              \"    return (a.begin() - a.end()) == (b.begin() - b.end());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #11469\n              \"    const std::vector<int>* vec() const { return &v; }\\n\"\n              \"    const std::vector<int> v;\\n\"\n              \"};\\n\"\n              \"void f(const S& a, const S& b) {\\n\"\n              \"    if (a.vec()->begin() - a.vec()->end() != b.vec()->begin() - b.vec()->end()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void iteratorSameExpression() {\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    std::for_each(v.begin(), v.begin(), [](int){});\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:26]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n\n        check(\"std::vector<int>& g();\\n\"\n              \"void f() {\\n\"\n              \"    std::for_each(g().begin(), g().begin(), [](int){});\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:28]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    std::for_each(v.end(), v.end(), [](int){});\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:24]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n\n        check(\"std::vector<int>& g();\\n\"\n              \"void f() {\\n\"\n              \"    std::for_each(g().end(), g().end(), [](int){});\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:26]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n\n        check(\"std::vector<int>::iterator g();\\n\"\n              \"void f(std::vector<int> v) {\\n\"\n              \"    std::for_each(g(), g(), [](int){});\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:20]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n\n        check(\"void f(std::vector<int>::iterator it) {\\n\"\n              \"    std::for_each(it, it, [](int){});\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:19]: (style) Same iterators expression are used for algorithm. [sameIteratorExpression]\\n\", errout_str());\n    }\n\n    void mismatchingContainerIterator() {\n        check(\"std::vector<int> to_vector(int value) {\\n\"\n              \"    std::vector<int> a, b;\\n\"\n              \"    a.insert(b.end(), value);\\n\"\n              \"    return a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Iterator 'b.end()' referring to container 'b' is used with container 'a'. [mismatchingContainerIterator]\\n\", errout_str());\n\n        check(\"std::vector<int> f(std::vector<int> a, std::vector<int> b) {\\n\"\n              \"    a.erase(b.begin());\\n\"\n              \"    return a;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (error) Iterator 'b.begin()' referring to container 'b' is used with container 'a'. [mismatchingContainerIterator]\\n\", errout_str());\n\n        // #9973\n        check(\"void f() {\\n\"\n              \"    std::list<int> l1;\\n\"\n              \"    std::list<int> l2;\\n\"\n              \"    std::list<int>& l = l2;\\n\"\n              \"    for (auto it = l.begin(); it != l.end(); ++it) {\\n\"\n              \"        if (*it == 1) {\\n\"\n              \"            l.erase(it);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:23]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        // #10012\n        check(\"struct a {\\n\"\n              \"    int b;\\n\"\n              \"    int end() { return b; }\\n\"\n              \"};\\n\"\n              \"void f(a c, a d) {\\n\"\n              \"    if (c.end() == d.end()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10467\n        check(\"void f(std::array<std::vector<int>, N>& A) {\\n\"\n              \"  for (auto& a : A) {\\n\"\n              \"    auto it = std::find_if(a.begin(), a.end(), \\n\"\n              \"                           [](auto i) { return i == 0; });\\n\"\n              \"    if (it != a.end()) {}\\n\"\n              \"  }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10604\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"};\\n\"\n              \"void f(S& s, int m) {\\n\"\n              \"    s.v.erase(s.v.begin() + m);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11093\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v1, v2;\\n\"\n              \"    void f(bool b) {\\n\"\n              \"        std::vector<int>& v = b ? v1 : v2;\\n\"\n              \"        v.erase(v.begin());\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #12377\n        check(\"void f(bool b) {\\n\"\n              \"    std::vector<int> *pv;\\n\"\n              \"    if (b) {\\n\"\n              \"        std::vector<int>& r = get1();\\n\"\n              \"        pv = &r;\\n\"\n              \"    }\\n\"\n              \"    else {\\n\"\n              \"        std::vector<int>& r = get2();\\n\"\n              \"        pv = &r;\\n\"\n              \"    }\\n\"\n              \"    std::vector<int>::iterator it = pv->begin();\\n\"\n              \"    it = pv->erase(it, it + 2);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    void f() {\\n\"\n              \"        std::vector<int>* p = &v;\\n\"\n              \"        p->insert(std::find(p->begin(), p->end(), 0), 1);\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    void f(int i) {\\n\"\n              \"        std::vector<int>* p = &v;\\n\"\n              \"        if (p->size() > i)\\n\"\n              \"            p->erase(p->begin() + i, p->end());\\n\"\n              \"    }\\n\"\n              \"};\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11067\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    std::list<std::vector<int>::const_iterator> li;\\n\"\n              \"    void f();\\n\"\n              \"};\\n\"\n              \"void S::f() {\\n\"\n              \"    v.erase(*li.begin());\\n\"\n              \"    li.pop_front();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::set<std::string>& a, std::stack<std::set<std::string>::iterator>& b) {\\n\"\n              \"    while (!b.empty()) {\\n\"\n              \"        a.erase(b.top());\\n\"\n              \"        b.pop();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& a, std::vector<std::vector<int>::iterator>& b) {\\n\"\n              \"    auto it = b.begin();\\n\"\n              \"    a.erase(*it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace N {\\n\" // #12443\n              \"    std::vector<int> v;\\n\"\n              \"}\\n\"\n              \"using namespace N;\\n\"\n              \"void f() {\\n\"\n              \"    auto it = std::find(v.begin(), v.end(), 0);\\n\"\n              \"    if (it != N::v.end()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(void* p) {\\n\" // #12445\n              \"    std::vector<int>&v = *(std::vector<int>*)(p);\\n\"\n              \"    v.erase(v.begin(), v.end());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #13408\n        check(\"void f(const std::vector<int>& v) {\\n\"\n              \"    for (const auto& i : v) {\\n\"\n              \"        if (std::distance(&*v.cbegin(), &i)) {}\\n\"\n              \"    }   \\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseIteratorOutOfBounds() {\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.erase(v.begin());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Calling function 'erase()' on the iterator 'v.begin()' which is out of bounds. [eraseIteratorOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.erase(v.end());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Calling function 'erase()' on the iterator 'v.end()' which is out of bounds. [eraseIteratorOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    v.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Calling function 'erase()' on the iterator 'it' which is out of bounds. [eraseIteratorOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v{ 1, 2, 3 };\\n\"\n              \"    auto it = v.end();\\n\"\n              \"    v.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Calling function 'erase()' on the iterator 'it' which is out of bounds. [eraseIteratorOutOfBounds]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v{ 1, 2, 3 };\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    v.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v{ 1, 2, 3 };\\n\"\n              \"    v.erase(v.end() - 1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v{ 1, 2, 3 };\\n\"\n              \"    v.erase(v.begin() - 1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (error) Calling function 'erase()' on the iterator 'v.begin()-1' which is out of bounds. [eraseIteratorOutOfBounds]\\n\"\n                      \"[test.cpp:3:23]: (error) Dereference of an invalid iterator: v.begin()-1 [derefInvalidIterator]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v, std::vector<int>::iterator it) {\\n\"\n              \"    if (it == v.end()) {}\\n\"\n              \"    v.erase(it);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:7]: (warning) Either the condition 'it==v.end()' is redundant or function 'erase()' is called on the iterator 'it' which is out of bounds. [eraseIteratorOutOfBoundsCond]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    ((v).erase)(v.begin());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10]: (error) Calling function 'erase()' on the iterator 'v.begin()' which is out of bounds. [eraseIteratorOutOfBounds]\\n\",\n                      errout_str());\n    }\n\n    // Dereferencing invalid pointer\n    void dereference() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints{1,2,3,4,5};\\n\"\n              \"    std::vector<int>::iterator iter;\\n\"\n              \"    iter = ints.begin() + 2;\\n\"\n              \"    ints.erase(iter);\\n\"\n              \"    std::cout << (*iter) << std::endl;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:5] -> [test.cpp:6] -> [test.cpp:3] -> [test.cpp:7]: (error) Using iterator to local container 'ints' that may be invalid.\\n\", \"[test.cpp:5:22] -> [test.cpp:6:10] -> [test.cpp:3:22] -> [test.cpp:7:20]: (error, inconclusive) Using iterator to local container 'ints' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        // #6554 \"False positive eraseDereference - erase in while() loop\"\n        check(\"typedef std::map<Packet> packetMap;\\n\"\n              \"packetMap waitingPackets;\\n\"\n              \"void ProcessRawPacket() {\\n\"\n              \"    packetMap::iterator wpi;\\n\"\n              \"    while ((wpi = waitingPackets.find(lastInOrder + 1)) != waitingPackets.end()) {\\n\"\n              \"        waitingPackets.erase(wpi);\\n\"\n              \"        for (unsigned pos = 0; pos < buf.size(); ) {     }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8509 Uniform initialization ignored for iterator\n        check(\"void f() {\\n\"\n              \"  std::vector<int> ints;\\n\"\n              \"  std::vector<int>::const_iterator iter {ints.cbegin()};\\n\"\n              \"  std::cout << (*iter) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void dereference_break() {  // #3644\n        check(\"void f(std::vector<int> &ints) {\\n\"\n              \"    std::vector<int>::iterator iter;\\n\"\n              \"    for (iter=ints.begin();iter!=ints.end();++iter) {\\n\"\n              \"        if (*iter == 2) {\\n\"\n              \"            ints.erase(iter);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"        if (*iter == 3) {\\n\"\n              \"            ints.erase(iter);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void dereference_member() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::map<int, int> ints;\\n\"\n              \"    std::map<int, int>::iterator iter;\\n\"\n              \"    iter = ints.begin();\\n\"\n              \"    ints.erase(iter);\\n\"\n              \"    std::cout << iter->first << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:18] -> [test.cpp:6:5]: (error) Iterator 'iter' used after element has been erased. [eraseDereference]\\n\"\n                      \"[test.cpp:6:10]: (error) Calling function 'erase()' on the iterator 'iter' which is out of bounds. [eraseIteratorOutOfBounds]\\n\",\n                      errout_str());\n\n        // Reverse iterator\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::map<int, int> ints;\\n\"\n              \"    std::map<int, int>::reverse_iterator iter;\\n\"\n              \"    iter = ints.rbegin();\\n\"\n              \"    ints.erase(iter);\\n\"\n              \"    std::cout << iter->first << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:18] -> [test.cpp:6:5]: (error) Iterator 'iter' used after element has been erased. [eraseDereference]\\n\"\n                      \"[test.cpp:6:10]: (error) Calling function 'erase()' on the iterator 'iter' which is out of bounds. [eraseIteratorOutOfBounds]\\n\",\n                      errout_str());\n    }\n\n    void dereference_auto() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints{1,2,3,4,5};\\n\"\n              \"    auto iter = ints.begin() + 2;\\n\"\n              \"    ints.erase(iter);\\n\"\n              \"    std::cout << (*iter) << std::endl;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:4] -> [test.cpp:5] -> [test.cpp:3] -> [test.cpp:6]: (error) Using iterator to local container 'ints' that may be invalid.\\n\", \"[test.cpp:4:27] -> [test.cpp:5:10] -> [test.cpp:3:22] -> [test.cpp:6:20]: (error, inconclusive) Using iterator to local container 'ints' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    auto x = *myList.begin();\\n\"\n              \"    myList.erase(x);\\n\"\n              \"    auto b = x.first;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const CXXRecordDecl *CXXRecordDecl::getTemplateInstantiationPattern() const {\\n\"\n              \"    if (auto *TD = dyn_cast<ClassTemplateSpecializationDecl>(this)) {\\n\"\n              \"        auto From = TD->getInstantiatedFrom();\\n\"\n              \"    }\\n\"\n              \"    return nullptr;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void STLSize() {\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    for (unsigned int ii = 0; ii <= foo.size(); ++ii)\\n\"\n              \"    {\\n\"\n              \"       foo[ii] = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:6:11]: (error) Out of bounds access in expression 'foo[ii]' because 'foo' is empty. [containerOutOfBounds]\\n\",\n            errout_str());\n\n        check(\"void foo(std::vector<int> foo) {\\n\"\n              \"    for (unsigned int ii = 0; ii <= foo.size(); ++ii) {\\n\"\n              \"       foo.at(ii) = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) When ii==foo.size(), foo.at(ii) is out of bounds. [stlOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo(std::string& foo) {\\n\"\n              \"    for (unsigned int ii = 0; ii <= foo.length(); ++ii) {\\n\"\n              \"       foo[ii] = 'x';\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) When ii==foo.size(), foo[ii] is out of bounds. [stlOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo(std::string& foo, unsigned int ii) {\\n\"\n              \"    if (ii <= foo.length()) {\\n\"\n              \"       foo[ii] = 'x';\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) When ii==foo.size(), foo[ii] is out of bounds. [stlOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo(std::string& foo, unsigned int ii) {\\n\"\n              \"    do {\\n\"\n              \"       foo[ii] = 'x';\\n\"\n              \"       ++i;\\n\"\n              \"    } while(ii <= foo.length());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (error) When ii==foo.size(), foo[ii] is out of bounds. [stlOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo(std::string& foo, unsigned int ii) {\\n\"\n              \"    if (anything()) {\\n\"\n              \"    } else if (ii <= foo.length()) {\\n\"\n              \"       foo[ii] = 'x';\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (error) When ii==foo.size(), foo[ii] is out of bounds. [stlOutOfBounds]\\n\", errout_str());\n\n        check(\"void foo()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    foo.push_back(1);\\n\"\n              \"    for (unsigned int ii = 0; ii <= foo.size(); ++ii)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"    int ii = 0;\\n\"\n              \"    foo[ii] = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for (B b : D()) {}\\n\" // Don't crash on range-based for-loop\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo(std::vector<int> foo) {\\n\"\n              \"    for (unsigned int ii = 0; ii <= foo.size() + 1; ++ii) {\\n\"\n              \"       foo.at(ii) = 0;\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3:11]: (error) When ii==foo.size(), foo.at(ii) is out of bounds. [stlOutOfBounds]\\n\", \"\", errout_str());\n    }\n\n    void STLSizeNoErr() {\n        {\n            check(\"void foo()\\n\"\n                  \"{\\n\"\n                  \"    std::vector<int> foo;\\n\"\n                  \"    for (unsigned int ii = 0; ii < foo.size(); ++ii)\\n\"\n                  \"    {\\n\"\n                  \"       foo[ii] = 0;\\n\"\n                  \"    }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            check(\"void foo()\\n\"\n                  \"{\\n\"\n                  \"    std::vector<int> foo;\\n\"\n                  \"    for (unsigned int ii = 0; ii <= foo.size(); ++ii)\\n\"\n                  \"    {\\n\"\n                  \"    }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            check(\"void foo()\\n\"\n                  \"{\\n\"\n                  \"    std::vector<int> foo;\\n\"\n                  \"    for (unsigned int ii = 0; ii <= foo.size(); ++ii)\\n\"\n                  \"    {\\n\"\n                  \"        if (ii == foo.size())\\n\"\n                  \"        {\\n\"\n                  \"        }\\n\"\n                  \"        else\\n\"\n                  \"        {\\n\"\n                  \"            foo[ii] = 0;\\n\"\n                  \"        }\\n\"\n                  \"    }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\n                \"[test.cpp:11:16]: (error) Out of bounds access in expression 'foo[ii]' because 'foo' is empty. [containerOutOfBounds]\\n\",\n                errout_str());\n        }\n\n        {\n            check(\"void f(const std::map<int,int> &data) {\\n\"\n                  \"    int i = x;\"\n                  \"    for (int i = 5; i <= data.size(); i++)\\n\"\n                  \"        data[i] = 0;\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            check(\"void foo(std::vector<int> foo) {\\n\"\n                  \"    for (unsigned int ii = 0; ii <= foo.size() - 1; ++ii) {\\n\"\n                  \"       foo.at(ii) = 0;\\n\"\n                  \"    }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n    }\n\n    void negativeIndex() {\n        check(\"void f(const std::vector<int> &v) {\\n\"\n              \"  v[-11] = 123;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (error) Array index -11 is out of bounds. [negativeContainerIndex]\\n\", errout_str());\n\n        check(\"int f(int x, const std::vector<int>& a) {\\n\"\n              \"    if (!(x < 5))\\n\"\n              \"        return a[x - 5];\\n\"\n              \"    else\\n\"\n              \"        return a[4 - x];\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::array<int,6> values;\\n\"\n              \"int get_value();\\n\"\n              \"int compute() {\\n\"\n              \"    int i = get_value();\\n\"\n              \"    if( i < 0 || i > 5)\\n\"\n              \"        return -1;\\n\"\n              \"    int sum = 0;\\n\"\n              \"    for( int j = i+1; j < 7; ++j)\\n\"\n              \"        sum += values[j-1];\\n\"\n              \"    return sum;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct B { virtual int g() { return 0; } };\\n\" // #11831\n              \"struct C {\\n\"\n              \"    int h() const { return b->g(); }\\n\"\n              \"    B* b;\\n\"\n              \"};\\n\"\n              \"struct O {\\n\"\n              \"    int f() const;\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    C c;\\n\"\n              \"};\\n\"\n              \"int O::f() const { return v[c.h() - 1]; }\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<int>& v) {\\n\" // #13196\n              \"    if (v.empty())\\n\"\n              \"        return;\\n\"\n              \"    int idx = -1;\\n\"\n              \"    for (int i = 0; i < v.size(); ++i) {\\n\"\n              \"        idx = i;\\n\"\n              \"    }\\n\"\n              \"    (void)v[idx];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        const auto oldSettings = settings; // TODO: get rid of this\n        settings.daca = true;\n\n        check(\"void f() {\\n\"\n              \"    const char a[][5] = { \\\"1\\\", \\\"true\\\", \\\"on\\\", \\\"yes\\\" };\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        settings = oldSettings;\n    }\n\n    void negativeIndexMultiline() {\n        setMultiline();\n        const auto oldSettings = settings; // TODO: get rid of this\n        settings.verbose = true;\n\n        check(\"bool valid(int);\\n\" // #11697\n              \"void f(int i, const std::vector<int>& v) {\\n\"\n              \"    if (!valid(i))\\n\"\n              \"        return;\\n\"\n              \"    if (v[i]) {}\\n\"\n              \"}\\n\"\n              \"void g(const std::vector<int>& w) {\\n\"\n              \"    f(-1, w);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:9]: warning: Array index -1 is out of bounds. [negativeContainerIndex]\\n\"\n                      \"[test.cpp:8:8]: note: Calling function 'f', 1st argument '-1' value is -1\\n\"\n                      \"[test.cpp:3:9]: note: Assuming condition is false\\n\"\n                      \"[test.cpp:5:9]: note: Negative array index\\n\",\n                      errout_str());\n\n        settings = oldSettings;\n    }\n\n    void erase1() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it) {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it) {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:5:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\"\n                      \"[test.cpp:7:5] -> [test.cpp:8:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n        check(\"void f(std::list<int> &ints)\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator i = ints.begin();\\n\"\n              \"    i = ints.erase(i);\\n\"\n              \"    *i = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator i;\\n\"\n              \"    while (i != x.y.end())\\n\"\n              \"        i = x.y.erase(i);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #2101\n        check(\"void f(vector< std::list<int> > &ints, unsigned int i)\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it;\\n\"\n              \"    for(it = ints[i].begin(); it != ints[i].end(); it++) {\\n\"\n              \"        if (*it % 2)\\n\"\n              \"            it = ints[i].erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void erase2() {\n        check(\"static void f()\\n\"\n              \"{\\n\"\n              \"    for (iterator it = foo.begin(); it != foo.end(); it = next)\\n\"\n              \"    {\\n\"\n              \"        next = it;\\n\"\n              \"        next++;\\n\"\n              \"        foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void erase3() {\n        check(\"static void f(std::list<abc> &foo)\\n\"\n              \"{\\n\"\n              \"    std::list<abc>::iterator it = foo.begin();\\n\"\n              \"    foo.erase(it->a);\\n\"\n              \"    if (it->b);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void erase4() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it, it2;\\n\"\n              \"    for (it = foo.begin(); it != i2; ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:6:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it = foo.begin();\\n\"\n              \"    for (; it != i2; ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:6:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it = foo.begin();\\n\"\n              \"    while (it != i2)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:6:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int>::iterator it = foo.begin();\\n\"\n              \"    while (it != i2)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(++it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5] -> [test.cpp:6:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n    }\n\n    void erase5() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int> foo;\\n\"\n              \"    std::list<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (*it == 123)\\n\"\n              \"            foo.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:5] -> [test.cpp:8:22]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n    }\n\n    void erase6() {\n        check(\"void f() {\\n\"\n              \"    std::vector<int> vec(3);\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    std::vector<int>::iterator itEnd = vec.end();\\n\"\n              \"    for (it = vec.begin(); it != itEnd; it = vec.begin(), itEnd = vec.end())\\n\"\n              \"    {\\n\"\n              \"        vec.erase(it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseBreak() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    for (std::vector<int>::iterator it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"        if (x)\"\n              \"            break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:5:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    for (std::vector<int>::iterator it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (x) {\\n\"\n              \"            foo.erase(it);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(int x)\\n\"\n              \"{\\n\"\n              \"    for (std::vector<int>::iterator it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"        if (x)\"\n              \"            return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5] -> [test.cpp:5:18]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n    }\n\n    void eraseContinue() {\n        check(\"void f(std::vector<int> &ints)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    std::vector<int>::iterator jt = ints.begin();\\n\"\n              \"    for (it = ints.begin(); it != ints.end(); it = jt) {\\n\"\n              \"        ++jt;\\n\"\n              \"        if (*it == 1) {\\n\"\n              \"            jt = ints.erase(it);\\n\"\n              \"            continue;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::map<uint32, uint32> my_map) {\\n\" // #7365\n              \"  std::map<uint32, uint32>::iterator itr = my_map.begin();\\n\"\n              \"  switch (itr->first) {\\n\"\n              \"  case 0:\\n\"\n              \"    my_map.erase(itr);\\n\"\n              \"    continue;\\n\"\n              \"  case 1:\\n\"\n              \"    itr->second = 1;\\n\"\n              \"    break;\\n\"\n              \"  }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseReturn1() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"        return;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseReturn2() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (*it == 1) {\\n\"\n              \"            foo.erase(it);\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"        else {\\n\"\n              \"            foo.erase(it);\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseReturn3() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (somecondition) {\\n\"\n              \"            if (*it == 1)\\n\"\n              \"                foo.erase(it);\\n\"\n              \"            else\\n\"\n              \"                *it = 0;\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (a) {\\n\"\n              \"            if (b)\\n\"\n              \"                foo.erase(it);\\n\" // <- TODO: erase shound't cause inconclusive valueflow\n              \"            else\\n\"\n              \"                *it = 0;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:5] -> [test.cpp:7] -> [test.cpp:8] -> [test.cpp:8] -> [test.cpp:7] -> [test.cpp:5] -> [test.cpp:9] -> [test.cpp:3] -> [test.cpp:5]: (error) Using iterator to local container 'foo' that may be invalid.\\n\",\n            \"[test.cpp:5:24] -> [test.cpp:7:13] -> [test.cpp:8:17] -> [test.cpp:8:17] -> [test.cpp:7:13] -> [test.cpp:5:31] -> [test.cpp:9:21] -> [test.cpp:3:22] -> [test.cpp:5:28]: (error, inconclusive) Using iterator to local container 'foo' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n    }\n\n    void eraseGoto() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    for (std::vector<int>::iterator it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"        goto abc;\\n\"\n              \"    }\\n\"\n              \"bar:\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseAssign1() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    for (std::vector<int>::iterator it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(it);\\n\"\n              \"        it = foo.begin();\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseAssign2() {\n        check(\"void f(std::list<int> &ints)\\n\"\n              \"{\\n\"\n              \"    for (std::list<int>::iterator it = ints.begin(); it != ints.end();) {\\n\"\n              \"        if (*it == 123) {\\n\"\n              \"            std::list<int>::iterator copy = it;\\n\"\n              \"            ++copy;\\n\"\n              \"            ints.erase(it);\\n\"\n              \"            it = copy;\\n\"\n              \"        } else {\\n\"\n              \"            it->second = 123;\\n\"\n              \"            ++it;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseAssign3() {\n        check(\"void f(std::list<list<int> >& l) {\\n\"\n              \"    std::list<std::list<int> >::const_iterator i = l.begin();\\n\"\n              \"    std::list<int>::const_iterator j = (*i).begin();\\n\"\n              \"    cout << *j << endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseAssign4() {\n        check(\"void f(std::list<int> data) {\\n\"\n              \"  std::list<int>::const_iterator it = data.begin();\\n\"\n              \"  it = data.erase(it);\\n\"\n              \"  it = data.erase(it);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(Data data) {\\n\"\n              \"  std::list<int>::const_iterator it = data.ints.begin();\\n\"\n              \"  it = data.ints.erase(it);\\n\"\n              \"  it = data.ints.erase(it);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseAssignByFunctionCall() {\n        check(\"void f(std::list<list<int> >& l) {\\n\"\n              \"    std::list<foo>::const_iterator i;\\n\"\n              \"    bar(i);\\n\"\n              \"    cout << *i;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseErase() {\n        check(\"void f(std::vector<ints> &ints)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator iter;\\n\"\n              \"    iter = ints.begin() + 2;\\n\"\n              \"    ints.erase(iter);\\n\"\n              \"    ints.erase(iter);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:1] -> [test.cpp:4] -> [test.cpp:5] -> [test.cpp:1] -> [test.cpp:6]: (error) Using iterator to local container 'ints' that may be invalid.\\n\", \"[test.cpp:1:31] -> [test.cpp:4:22] -> [test.cpp:5:10] -> [test.cpp:1:27] -> [test.cpp:6:16]: (error, inconclusive) Using iterator to local container 'ints' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void eraseByValue() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::set<int> foo;\\n\"\n              \"    for (std::set<int>::iterator it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.erase(*it);\\n\"\n              \"    }\\n\"\n              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:6]: (error) Iterator 'it' becomes invalid when deleted by value from 'foo'\\n\", \"\", errout_str());\n\n        check(\"int f(std::set<int> foo) {\\n\"\n              \"    std::set<int>::iterator it = foo.begin();\\n\"\n              \"    foo.erase(*it);\\n\"\n              \"    return *it;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:12] -> [test.cpp:3:5]: (error) Iterator 'it' used after element has been erased. [eraseDereference]\\n\", errout_str());\n\n        check(\"void f(std::set<int> foo)\\n\"\n              \"{\\n\"\n              \"    std::set<int>::iterator it = foo.begin();\\n\"\n              \"    foo.erase(*it);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #5669\n        check(\"void f() {\\n\"\n              \"    HashSet_Ref::iterator aIt = m_ImplementationMap.find( xEle );\\n\"\n              \"    m_SetLoadedFactories.erase(*aIt);\\n\"\n              \"    m_SetLoadedFactories.erase(aIt);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::list<int>& m_ImplementationMap) {\\n\"\n              \"    std::list<int>::iterator aIt = m_ImplementationMap.begin();\\n\"\n              \"    m_ImplementationMap.erase(*aIt);\\n\"\n              \"    m_ImplementationMap.erase(aIt);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (error) Invalid iterator: aIt [invalidIterator1]\\n\", errout_str());\n\n        check(\"void f(const std::list<int>& m_ImplementationMap) {\\n\"\n              \"    std::list<int>::iterator aIt = m_ImplementationMap.begin();\\n\"\n              \"    std::list<int>::iterator bIt = m_ImplementationMap.begin();\\n\"\n              \"    m_ImplementationMap.erase(*bIt);\\n\"\n              \"    m_ImplementationMap.erase(aIt);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void eraseIf() {\n        // #4816\n        check(\"void func(std::list<std::string> strlist) {\\n\"\n              \"    for (std::list<std::string>::iterator str = strlist.begin(); str != strlist.end(); str++) {\\n\"\n              \"        if (func2(*str)) {\\n\"\n              \"            strlist.erase(str);\\n\"\n              \"            if (strlist.empty())\\n\"\n              \"                 return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5] -> [test.cpp:4:26]: (error) Iterator 'str' used after element has been erased. [eraseDereference]\\n\", errout_str());\n    }\n\n    void eraseOnVector() {\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    std::vector<int>::iterator aIt = v.begin();\\n\"\n              \"    v.erase(something(unknown));\\n\" // All iterators become invalidated when erasing from std::vector\n              \"    v.erase(aIt);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:27] -> [test.cpp:2:45] -> [test.cpp:3:7] -> [test.cpp:1:26] -> [test.cpp:4:13]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    std::vector<int>::iterator aIt = v.begin();\\n\"\n              \"    std::vector<int>::iterator bIt = v.begin();\\n\"\n              \"    v.erase(bIt);\\n\" // All iterators become invalidated when erasing from std::vector\n              \"    aIt = v.erase(aIt);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:27] -> [test.cpp:2:45] -> [test.cpp:4:7] -> [test.cpp:1:26] -> [test.cpp:5:19]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback1() {\n        check(\"void f(const std::vector<int> &foo)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::const_iterator it = foo.begin();\\n\"\n              \"    foo.push_back(123);\\n\"\n              \"    *it;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:35] -> [test.cpp:3:52] -> [test.cpp:4:9] -> [test.cpp:1:32] -> [test.cpp:5:6]: (error) Using iterator to local container 'foo' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback2() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::const_iterator it = foo.begin();\\n\"\n              \"    foo.push_back(123);\\n\"\n              \"    {\\n\"\n              \"        int *it = &foo[0];\\n\"\n              \"        *it = 456;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pushback3() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    foo.push_back(10);\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.push_back(123);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:24] -> [test.cpp:6:31] -> [test.cpp:8:13] -> [test.cpp:3:22] -> [test.cpp:6:28]: (error) Using iterator to local container 'foo' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback4() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"    ints.push_back(1);\\n\"\n              \"    int *first = &ints[0];\\n\"\n              \"    ints.push_back(2);\\n\"\n              \"    *first;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:18] -> [test.cpp:6:10] -> [test.cpp:3:22] -> [test.cpp:7:6]: (error) Using pointer to local variable 'ints' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback5() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::const_iterator i;\\n\"\n              \"\\n\"\n              \"    for (i=v.begin(); i!=v.end(); ++i)\\n\"\n              \"    {\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    for (i=rhs.v.begin(); i!=rhs.v.end(); ++i)\\n\"\n              \"    {\\n\"\n              \"        v.push_back(*i);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pushback6() {\n        // ticket #735\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    v.push_back(2);\\n\"\n              \"    for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (*it == 1)\\n\"\n              \"            v.push_back(10);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:49] -> [test.cpp:8:17] -> [test.cpp:8:17] -> [test.cpp:6:56] -> [test.cpp:9:15] -> [test.cpp:3:22] -> [test.cpp:6:53]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    vector.push_back(1);\\n\"\n              \"    vector.push_back(2);\\n\"\n              \"    for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        if (*it == 1)\\n\"\n              \"            v.push_back(10);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:49] -> [test.cpp:8:17] -> [test.cpp:8:17] -> [test.cpp:6:56] -> [test.cpp:9:15] -> [test.cpp:3:22] -> [test.cpp:6:53]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback7() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    foo.push_back(10);\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); it++)\\n\"\n              \"    {\\n\"\n              \"        foo.push_back(123);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:24] -> [test.cpp:6:31] -> [test.cpp:8:13] -> [test.cpp:3:22] -> [test.cpp:6:28]: (error) Using iterator to local container 'foo' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback8() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"    std::vector<int>::const_iterator end = ints.end();\\n\"\n              \"    ints.push_back(10);\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    unsigned int sum = 0;\\n\"\n              \"    for (it = ints.begin(); it != end; ++it)\\n\"\n              \"    {\\n\"\n              \"        sum += *it;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10:13]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\"\n                      \"[test.cpp:4:52] -> [test.cpp:5:10] -> [test.cpp:3:22] -> [test.cpp:8:35]: (error) Using iterator to local container 'ints' that may be invalid. [invalidContainer]\\n\",\n                      errout_str());\n    }\n\n    void pushback9() {\n        check(\"struct A {\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"};\\n\"\n              \"\\n\"\n              \"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"    A a;\\n\"\n              \"    std::vector<int>::const_iterator i = ints.begin();\\n\"\n              \"    std::vector<int>::const_iterator e = ints.end();\\n\"\n              \"    while (i != e)\\n\"\n              \"    {\\n\"\n              \"        a.ints.push_back(*i);\\n\"\n              \"        ++i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pushback10() {\n        check(\"void f(std::vector<int> &foo)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::const_iterator it = foo.begin();\\n\"\n              \"    foo.reserve(100);\\n\"\n              \"    *it = 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:29] -> [test.cpp:3:52] -> [test.cpp:4:9] -> [test.cpp:1:26] -> [test.cpp:5:6]: (error) Using iterator to local container 'foo' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        // in loop\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> foo;\\n\"\n              \"    foo.push_back(10);\\n\"\n              \"    std::vector<int>::iterator it;\\n\"\n              \"    for (it = foo.begin(); it != foo.end(); ++it)\\n\"\n              \"    {\\n\"\n              \"        foo.reserve(123);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:24] -> [test.cpp:6:31] -> [test.cpp:8:13] -> [test.cpp:3:22] -> [test.cpp:6:28]: (error) Using iterator to local container 'foo' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void pushback11() {\n        // #2798\n        check(\"void f() {\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"    std::vector<int>::iterator it = ints.begin();\\n\"\n              \"    if (it == ints.begin()) {\\n\"\n              \"        ints.push_back(0);\\n\"\n              \"    } else {\\n\"\n              \"        ints.insert(it,0);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void pushback12() {\n        // #4197\n        check(\"void foo(double s)\\n\"\n              \"{\\n\"\n              \"    std::vector<double> vec;\\n\"\n              \"    for( std::vector<double>::iterator it = vec.begin(); it != vec.end(); ++it )\\n\"\n              \"    {\\n\"\n              \"        vec.insert( it, s );\\n\"\n              \"        for(unsigned int i = 0; i < 42; i++)\\n\"\n              \"        {}\\n\"\n              \"        *it;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:54] -> [test.cpp:6:13] -> [test.cpp:3:25] -> [test.cpp:9:10]: (error, inconclusive) Using iterator to local container 'vec' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n    }\n\n    void pushback13() {\n        check(\"bool Preprocessor::ConcatenateIncludeName(SmallString<128> &FilenameBuffer, SourceLocation &End) {\\n\"\n              \"    unsigned PreAppendSize = FilenameBuffer.size();\\n\"\n              \"    FilenameBuffer.resize(PreAppendSize + CurTok.getLength());\\n\"\n              \"    const char *BufPtr = &FilenameBuffer[PreAppendSize];\\n\"\n              \"    return true;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void insert1() {\n        check(\"void f(std::vector<int> &ints)\\n\"\n              \"{\\n\"\n              \"    std::vector<int>::iterator iter = ints.begin() + 5;\\n\"\n              \"    ints.insert(ints.begin(), 1);\\n\"\n              \"    ++iter;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:30] -> [test.cpp:3:49] -> [test.cpp:4:10] -> [test.cpp:1:26] -> [test.cpp:5:7]: (error) Using iterator to local container 'ints' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"    std::vector<int>::iterator iter = ints.begin();\\n\"\n              \"    ints.insert(iter, 1);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<int> ints;\\n\"\n              \"    std::vector<int>::iterator iter = ints.begin();\\n\"\n              \"    ints.insert(iter, 1);\\n\"\n              \"    ints.insert(iter, 2);\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        TODO_ASSERT_EQUALS(\"[test.cpp:4] -> [test.cpp:5] -> [test.cpp:3] -> [test.cpp:6]: (error) Using iterator to local container 'ints' that may be invalid.\\n\", \"[test.cpp:4:49] -> [test.cpp:5:10] -> [test.cpp:3:22] -> [test.cpp:6:17]: (error, inconclusive) Using iterator to local container 'ints' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void* f(const std::vector<Bar>& bars) {\\n\"\n              \"    std::vector<Bar>::iterator i = bars.begin();\\n\"\n              \"    bars.insert(Bar());\\n\"\n              \"    void* v = &i->foo;\\n\"\n              \"    return v;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:37] -> [test.cpp:2:46] -> [test.cpp:3:10] -> [test.cpp:1:33] -> [test.cpp:4:16]: (error) Using iterator to local container 'bars' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"Foo f(const std::vector<Bar>& bars) {\\n\"\n              \"    std::vector<Bar>::iterator i = bars.begin();\\n\"\n              \"    bars.insert(Bar());\\n\"\n              \"    return i->foo;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:35] -> [test.cpp:2:46] -> [test.cpp:3:10] -> [test.cpp:1:31] -> [test.cpp:4:12]: (error) Using iterator to local container 'bars' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void f(const std::vector<Bar>& bars) {\\n\"\n              \"    for(std::vector<Bar>::iterator i = bars.begin(); i != bars.end(); ++i) {\\n\"\n              \"        i = bars.insert(i, bar);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // TODO: This shouldn't be inconclusive\n        check(\"void f(const std::vector<Bar>& bars) {\\n\"\n              \"    for(std::vector<Bar>::iterator i = bars.begin(); i != bars.end(); ++i) {\\n\"\n              \"        bars.insert(i, bar);\\n\"\n              \"        i = bars.insert(i, bar);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:36] -> [test.cpp:2:50] -> [test.cpp:3:14] -> [test.cpp:1:32] -> [test.cpp:4:25]: (error, inconclusive) Using iterator to local container 'bars' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        // TODO: This shouldn't be inconclusive\n        check(\"void* f(const std::vector<Bar>& bars) {\\n\"\n              \"    std::vector<Bar>::iterator i = bars.begin();\\n\"\n              \"    bars.insert(i, Bar());\\n\"\n              \"    i = bars.insert(i, Bar());\\n\"\n              \"    void* v = &i->foo;\\n\"\n              \"    return v;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:1:37] -> [test.cpp:2:46] -> [test.cpp:3:10] -> [test.cpp:1:33] -> [test.cpp:4:21]: (error, inconclusive) Using iterator to local container 'bars' that may be invalid. [invalidContainer]\\n\", errout_str());\n    }\n\n    void insert2() {\n        // Ticket: #2169\n        check(\"void f(std::vector<int> &vec) {\\n\"\n              \"    for(std::vector<int>::iterator iter = vec.begin(); iter != vec.end(); ++iter)\\n\"\n              \"    {\\n\"\n              \"        vec.insert(iter, 0);\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int> &vec) {\\n\"\n              \"    for(std::vector<int>::iterator iter = vec.begin(); iter != vec.end(); ++iter)\\n\"\n              \"    {\\n\"\n              \"        if (*it == 0) {\\n\"\n              \"            vec.insert(iter, 0);\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void popback1() { // #11553\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.pop_back();\\n\"\n              \"    std::list<int> l;\\n\"\n              \"    l.pop_front();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:15]: (error) Out of bounds access in expression 'v.pop_back()' because 'v' is empty. [containerOutOfBounds]\\n\"\n                      \"[test.cpp:5:16]: (error) Out of bounds access in expression 'l.pop_front()' because 'l' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    if (v.empty()) {}\\n\"\n              \"    v.pop_back();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:16] -> [test.cpp:3:15]: (warning) Either the condition 'v.empty()' is redundant or expression 'v.pop_back()' causes access out of bounds. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\"\n              \"    v.pop_back();\\n\"\n              \"    if (v.empty()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void stlBoundaries1() {\n        const std::string stlCont[] = {\n            \"list\", \"set\", \"multiset\", \"map\", \"multimap\"\n        };\n\n        for (size_t i = 0; i < getArrayLength(stlCont); ++i) {\n            check(\"void f()\\n\"\n                  \"{\\n\"\n                  \"    std::\" + stlCont[i] + \"<int>::iterator it;\\n\"\n                  \"    for (it = ab.begin(); it < ab.end(); ++it)\\n\"\n                  \"        ;\\n\"\n                  \"}\");\n\n            ASSERT_EQUALS_MSG(\"[test.cpp:4:25]: (error) Dangerous comparison using operator< on iterator. [stlBoundaries]\\n\", errout_str(), stlCont[i]);\n        }\n\n        check(\"void f() {\\n\"\n              \"    std::forward_list<int>::iterator it;\\n\"\n              \"    for (it = ab.begin(); ab.end() > it; ++it) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:36]: (error) Dangerous comparison using operator< on iterator. [stlBoundaries]\\n\", errout_str());\n\n        // #5926 no FP Dangerous comparison using operator< on iterator on std::deque\n        check(\"void f() {\\n\"\n              \"    std::deque<int>::iterator it;\\n\"\n              \"    for (it = ab.begin(); ab.end() > it; ++it) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void stlBoundaries2() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::vector<std::string> files;\\n\"\n              \"    std::vector<std::string>::const_iterator it;\\n\"\n              \"    for (it = files.begin(); it < files.end(); it++) { }\\n\"\n              \"    for (it = files.begin(); it < files.end(); it++) { };\\n\"\n              \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void stlBoundaries3() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    set<int> files;\\n\"\n              \"    set<int>::const_iterator current;\\n\"\n              \"    for (current = files.begin(); current != files.end(); ++current)\\n\"\n              \"    {\\n\"\n              \"       assert(*current < 100)\\n\"\n              \"    }\\n\"\n              \"}\");\n\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    static set<Foo>::const_iterator current;\\n\"\n              \"    return 25 > current->bar;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Invalid iterator 'current' used. [eraseDereference]\\n\", errout_str());\n    }\n\n    void stlBoundaries4() {\n\n        check(\"void f() {\\n\"\n              \"    std::forward_list<std::vector<std::vector<int>>>::iterator it;\\n\"\n              \"    for (it = ab.begin(); ab.end() > it; ++it) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:36]: (error) Dangerous comparison using operator< on iterator. [stlBoundaries]\\n\", errout_str());\n\n        // don't crash\n        check(\"void f() {\\n\"\n              \"    if (list < 0) ;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    if (list < 0) {\\n\"\n              \"        std::forward_list<std::vector<std::vector<int>>>::iterator it;\\n\"\n              \"        for (it = ab.begin(); ab.end() > it; ++it) {}\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:40]: (error) Dangerous comparison using operator< on iterator. [stlBoundaries]\\n\", errout_str());\n    }\n\n    void stlBoundaries5() {\n        check(\"class iterator { int foo(); };\\n\"\n              \"int foo() {\\n\"\n              \"    iterator i;\\n\"\n              \"    return i.foo();;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class iterator {\\n\"\n              \"    Class operator*();\\n\"\n              \"    iterator& operator++();\\n\"\n              \"    int foo();\\n\"\n              \"};\\n\"\n              \"int foo() {\\n\"\n              \"    iterator i;\\n\"\n              \"    return i.foo();;\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:8:12]: (error, inconclusive) Invalid iterator 'i' used. [eraseDereference]\\n\", errout_str());\n    }\n\n    void stlBoundaries6() { // #7106\n        check(\"void foo(std::vector<int>& vec) {\\n\"\n              \"    for (Function::iterator BB : vec) {\\n\"\n              \"        for (int Inst : *BB)\\n\"\n              \"        {\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void if_find() {\n        // ---------------------------\n        // set::find\n        // ---------------------------\n\n        // error (simple)\n        check(\"void f(std::set<int> s)\\n\"\n              \"{\\n\"\n              \"    if (s.find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (pointer)\n        check(\"void f(std::set<int> *s)\\n\"\n              \"{\\n\"\n              \"    if ((*s).find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (pointer)\n        check(\"void f(std::set<int> *s)\\n\"\n              \"{\\n\"\n              \"    if (s->find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (array-like pointer)\n        check(\"void f(std::set<int> *s)\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (array)\n        check(\"void f(std::set<int> s [10])\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (undefined length array)\n        check(\"void f(std::set<int> s [])\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (vector)\n        check(\"void f(std::vector<std::set<int> > s)\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(12)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // error (assignment)\n        check(\"void f(std::set<int> s)\\n\"\n              \"{\\n\"\n              \"    if (a || (x = s.find(12))) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // ok (simple)\n        check(\"void f(std::set<int> s)\\n\"\n              \"{\\n\"\n              \"    if (s.find(123) != s.end()) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (pointer)\n        check(\"void f(std::set<int> *s)\\n\"\n              \"{\\n\"\n              \"    if ((*s).find(12) != s.end()) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (array-like pointer)\n        check(\"void f(std::set<int> *s)\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(12) != s->end()) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (array)\n        check(\"void f(std::set<int> s [10])\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(123) != s->end()) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (undefined length array)\n        check(\"void f(std::set<int> s [])\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(123) != s->end()) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (assignment)\n        check(\"void f(std::set<int> s)\\n\"\n              \"{\\n\"\n              \"    if (a || (x = s.find(12)) != s.end()) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (dereference, #6402)\n        check(\"void f(std::set<Foo> s) {\\n\"\n              \"    if (s.find(12).member) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::set<int> s) {\\n\"\n              \"    if (auto result = s.find(123); result != s.end()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ---------------------------\n        // std::find\n        // ---------------------------\n\n        // error\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    if (std::find(a,b,c)) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (warning) Suspicious condition. The result of find() is an iterator, but it is not properly checked. [stlIfFind]\\n\", errout_str());\n\n        // ok\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    if (std::find(a,b,c) != c) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // ok (less than comparison, #6217)\n        check(\"void f(std::vector<int> s)\\n\"\n              \"{\\n\"\n              \"    if (std::find(a, b, c) < d) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #3714 - segmentation fault for syntax error\n        ASSERT_THROW_INTERNAL(check(\"void f() {\\n\"\n                                    \"    if (()) { }\\n\"\n                                    \"}\"),\n                              AST);\n\n        // #3865\n        check(\"void f() {\\n\"\n              \"    if ((std::find(a,b,c)) != b) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void if_str_find() {\n        // error (simple)\n        check(\"void f(const std::string &s)\\n\"\n              \"{\\n\"\n              \"    if (s.find(\\\"abc\\\")) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (performance) Inefficient usage of string::find() in condition; string::starts_with() could be faster. [stlIfStrFind]\\n\", errout_str());\n\n        // error (pointer)\n        check(\"void f(const std::string *s)\\n\"\n              \"{\\n\"\n              \"    if ((*s).find(\\\"abc\\\")) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (performance) Inefficient usage of string::find() in condition; string::starts_with() could be faster. [stlIfStrFind]\\n\", errout_str());\n\n        // error (pointer)\n        check(\"void f(const std::string *s)\\n\"\n              \"{\\n\"\n              \"    if (s->find(\\\"abc\\\")) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (performance) Inefficient usage of string::find() in condition; string::starts_with() could be faster. [stlIfStrFind]\\n\", errout_str());\n\n        // error (vector)\n        check(\"void f(const std::vector<std::string> &s)\\n\"\n              \"{\\n\"\n              \"    if (s[0].find(\\\"abc\\\")) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (performance) Inefficient usage of string::find() in condition; string::starts_with() could be faster. [stlIfStrFind]\\n\", errout_str());\n\n        // #3162\n        check(\"void f(const std::string& s1, const std::string& s2)\\n\"\n              \"{\\n\"\n              \"    if ((!s1.empty()) && (0 == s1.find(s2))) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:32]: (performance) Inefficient usage of string::find() in condition; string::starts_with() could be faster. [stlIfStrFind]\\n\", errout_str());\n\n        // #4102\n        check(\"void f(const std::string &define) {\\n\"\n              \"    if (define.find(\\\"=\\\") + 1U == define.size());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string a, std::string b) {\\n\"  // #4480\n              \"    if (a.find(\\\"<\\\") < b.find(\\\">\\\")) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::string &s) {\\n\"\n              \"    if (foo(s.find(\\\"abc\\\"))) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7349 - std::string::find_first_of\n        check(\"void f(const std::string &s) {\\n\"\n              \"    if (s.find_first_of(\\\"abc\\\")==0) { }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // # 10153\n        check(\"int main() {\\n\"\n              \"  for (;;) {\\n\"\n              \"    std::string line = getLine();\\n\"\n              \"    if (line.find(\\\" GL_EXTENSIONS =\\\") < 12)\\n\"\n              \"      return 1;\\n\"\n              \"  }\\n\"\n              \"  return 0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n\n    void size1() {\n        {\n            const char code[] = \"struct Fred {\\n\"\n                                \"    void foo();\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"};\\n\"\n                                \"void Fred::foo()\\n\"\n                                \"{\\n\"\n                                \"    if (x.size() == 0) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:7:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"std::list<int> x;\\n\"\n                                \"void f()\\n\"\n                                \"{\\n\"\n                                \"    if (x.size() == 0) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (x.size() == 0) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (0 == x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (x.size() != 0) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (0 != x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (x.size() > 0) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (0 < x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:13]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] =  \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (x.size() >= 1) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (x.size() < 1) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (1 <= x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (1 > x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:13]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:9]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    if (!x.size()) {}\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:10]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::list<int> x;\\n\"\n              \"    fun(x.size());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        {\n            const char code[] =\"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    fun(!x.size());\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:10]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        {\n            const char code[] = \"void f()\\n\"\n                                \"{\\n\"\n                                \"    std::list<int> x;\\n\"\n                                \"    fun(a && x.size());\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"[test.cpp:4:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\", errout_str());\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"void f() {\\n\" // #4039\n              \"    std::list<int> x;\\n\"\n              \"    fun(width % x.size() != 0);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #4584\n        check(\"void f() {\\n\"\n              \"    std::list<int> x;\\n\"\n              \"    if (foo + 1 > x.size()) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n        check(\"void f() {\\n\"\n              \"    std::list<int> x;\\n\"\n              \"    if (x.size() < 1 + foo) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void size2() {\n        const char code[] = \"struct Fred {\\n\"\n                            \"    std::list<int> x;\\n\"\n                            \"};\\n\"\n                            \"struct Wilma {\\n\"\n                            \"    Fred f;\\n\"\n                            \"    void foo();\\n\"\n                            \"};\\n\"\n                            \"void Wilma::foo()\\n\"\n                            \"{\\n\"\n                            \"    if (f.x.size() == 0) {}\\n\"\n                            \"}\";\n        check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n        ASSERT_EQUALS(\n            \"[test.cpp:10:11]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\"\n            \"[test.cpp:10:11]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\",   // duplicate\n            errout_str());\n\n        check(code);\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void size3() {\n        {\n            const char code[] = \"namespace N {\\n\"\n                                \"    class Zzz {\\n\"\n                                \"    public:\\n\"\n                                \"        std::list<int> x;\\n\"\n                                \"    };\\n\"\n                                \"}\\n\"\n                                \"using namespace N;\\n\"\n                                \"Zzz * zzz;\\n\"\n                                \"int main() {\\n\"\n                                \"    if (zzz->x.size() > 0) { }\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\n                \"[test.cpp:10:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\"\n                \"[test.cpp:10:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\",   // duplicate\n                errout_str());\n        }\n\n        {\n            const char code[] = \"namespace N {\\n\"\n                                \"    class Zzz {\\n\"\n                                \"    public:\\n\"\n                                \"        std::list<int> x;\\n\"\n                                \"    };\\n\"\n                                \"}\\n\"\n                                \"using namespace N;\\n\"\n                                \"int main() {\\n\"\n                                \"    Zzz * zzz;\\n\"\n                                \"    if (zzz->x.size() > 0) { }\\n\"\n                                \"}\";\n            check(code, dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\n                \"[test.cpp:10:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\"\n                \"[test.cpp:10:14]: (performance) Possible inefficient checking for 'x' emptiness. [stlSize]\\n\",   // duplicate\n                errout_str());\n\n            check(code);\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n    }\n\n    void size4() { // #2652 - don't warn about vector/deque\n        check(\"void f(std::vector<int> &v) {\\n\"\n              \"    if (v.size() > 0U) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::deque<int> &v) {\\n\"\n              \"    if (v.size() > 0U) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::array<int,3> &a) {\\n\"\n              \"    if (a.size() > 0U) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void redundantCondition1() {\n        check(\"void f(string haystack)\\n\"\n              \"{\\n\"\n              \"    if (haystack.find(needle) != haystack.end())\\n\"\n              \"        haystack.remove(needle);\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Redundant checking of STL container element existence before removing it. [redundantIfRemove]\\n\", errout_str());\n    }\n\n    void missingInnerComparison1() {\n        check(\"void f(std::set<int> &ints) {\\n\"\n              \"    for (std::set<int>::iterator it = ints.begin(); it != ints.end(); ++it) {\\n\"\n              \"        if (a) {\\n\"\n              \"            it++;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:13] -> [test.cpp:2:71]: (warning) Missing bounds check for extra iterator increment in loop. [StlMissingComparison]\\n\", errout_str());\n\n        check(\"void f(std::map<int,int> &ints) {\\n\"\n              \"    for (std::map<int,int>::iterator it = ints.begin(); it != ints.end(); ++it) {\\n\"\n              \"        ++it->second;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<std::string> &v) {\\n\"\n              \"    for(std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); ++it) {\\n\"\n              \"        if(it+2 != v.end())\\n\"\n              \"        {\\n\"\n              \"            ++it;\\n\"\n              \"            ++it;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void missingInnerComparison2() {\n        check(\"void f(std::set<int> &ints) {\\n\"\n              \"    for (std::set<int>::iterator it = ints.begin(); it != ints.end(); ++it) {\\n\"\n              \"        if (a) {\\n\"\n              \"            it++;\\n\"\n              \"            if (it == ints.end())\\n\"\n              \"                return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void missingInnerComparison3() {\n        check(\"void f(std::set<int> &ints) {\\n\"\n              \"    for (std::set<int>::iterator it = ints.begin(); it != ints.end(); ++it) {\\n\"\n              \"        for (std::set<int>::iterator it = ints2.begin(); it != ints2.end(); ++it)\\n\"\n              \"        { }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void missingInnerComparison4() {\n        check(\"function f1(std::list<int> &l1) {\\n\"\n              \"    for(std::list<int>::iterator i = l1.begin(); i != l1.end(); i++) {\\n\"\n              \"        if (*i == 44) {\\n\"\n              \"            l1.insert(++i, 55);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"function f1(std::list<int> &l1) {\\n\"\n              \"    for(std::list<int>::iterator i = l1.begin(); i != l1.end(); i++) {\\n\"\n              \"        if (*i == 44) {\\n\"\n              \"            l1.insert(++i, 55);\\n\"\n              \"            return;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n    }\n\n    void missingInnerComparison5() {\n        check(\"void f() {\\n\"\n              \"    for(it = map1.begin(); it != map1.end(); it++) {\\n\"\n              \"        str[i++] = (*it).first;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void missingInnerComparison6() {\n        check(\"void f(std::string &s) {\\n\"\n              \"    for(string::iterator it = s.begin(); it != s.end(); it++) {\\n\"\n              \"        it = s.insert(++it, 0);\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void cstr() {\n        check(\"void f() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    throw errmsg.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception. [stlcstrthrow]\\n\", errout_str());\n\n        check(\"const char *get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return errmsg.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"const char *get_msg() {\\n\"\n              \"    std::ostringstream errmsg;\\n\"\n              \"    return errmsg.str().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"const char *get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return std::string(\\\"ERROR: \\\" + errmsg).c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"const char *get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return (\\\"ERROR: \\\" + errmsg).c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"const char *get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return (\\\"ERROR: \\\" + std::string(\\\"crash me\\\")).c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::ostringstream errmsg;\\n\"\n              \"    const char *c = errmsg.str().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"std::string f();\\n\"\n              \"\\n\"\n              \"void foo() {\\n\"\n              \"    const char *c = f().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4:17]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"class Foo {\\n\"\n              \"    const char *f();\\n\"\n              \"};\\n\"\n              \"const char *Foo::f() {\\n\"\n              \"    std::string s;\\n\"\n              \"    return s.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"class Foo {\\n\"\n              \"    std::string GetVal() const;\\n\"\n              \"};\\n\"\n              \"const char *f() {\\n\"\n              \"    Foo f;\\n\"\n              \"    return f.GetVal().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"const char* foo() {\\n\"\n              \"    static std::string text;\\n\"\n              \"    text = \\\"hello world\\\\n\\\";\\n\"\n              \"    return text.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str()); // #3427\n\n        // Implicit conversion back to std::string\n        check(\"std::string get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return errmsg.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (performance) Returning the result of c_str() in a function that returns std::string is slow and redundant. [stlcstrReturn]\\n\", errout_str());\n\n        check(\"const std::string& get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return errmsg.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (performance) Returning the result of c_str() in a function that returns std::string is slow and redundant. [stlcstrReturn]\\n\", errout_str());\n\n        check(\"class Foo {\\n\"\n              \"    std::string GetVal() const;\\n\"\n              \"};\\n\"\n              \"std::string f() {\\n\"\n              \"    Foo f;\\n\"\n              \"    return f.GetVal().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (performance) Returning the result of c_str() in a function that returns std::string is slow and redundant. [stlcstrReturn]\\n\", errout_str());\n\n        check(\"std::string get_msg() {\\n\"\n              \"    std::string errmsg;\\n\"\n              \"    return errmsg;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string get_msg() {\\n\" // #3678\n              \"    MyStringClass errmsg;\\n\"\n              \"    return errmsg.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Foo1(const std::string& str) {}\\n\"\n              \"void Foo2(const char* c, const std::string str) {}\\n\"\n              \"void Foo3(std::string& rstr) {}\\n\"\n              \"void Foo4(std::string str, const std::string& str) {}\\n\"\n              \"void Bar() {\\n\"\n              \"    std::string str = \\\"bar\\\";\\n\"\n              \"    std::stringstream ss(\\\"foo\\\");\\n\"\n              \"    Foo1(str);\\n\"\n              \"    Foo1(str.c_str());\\n\"\n              \"    Foo2(str.c_str(), str);\\n\"\n              \"    Foo2(str.c_str(), str.c_str());\\n\"\n              \"    Foo3(str.c_str());\\n\"\n              \"    Foo4(str, str);\\n\"\n              \"    Foo4(str.c_str(), str);\\n\"\n              \"    Foo4(str, str.c_str());\\n\"\n              \"    Foo4(ss.str(), ss.str().c_str());\\n\"\n              \"    Foo4(str.c_str(), str.c_str());\\n\"\n              \"}\");\n\n        ASSERT_EQUALS(\"[test.cpp:9:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:11:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 2 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:14:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:15:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 2 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:16:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 2 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:17:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:17:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 2 is slow and redundant. [stlcstrParam]\\n\", errout_str());\n\n        check(\"void Foo1(const std::string& str) {}\\n\"\n              \"void Foo2(char* c, const std::string str) {}\\n\"\n              \"void Bar() {\\n\"\n              \"    std::string str = \\\"bar\\\";\\n\"\n              \"    Foo1(str, foo);\\n\" // Don't crash\n              \"    Foo2(str.c_str());\\n\" // Don't crash\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct Foo {\\n\"\n              \"    void func(std::string str) const {}\\n\"\n              \"    static void sfunc(std::string str) {}\\n\"\n              \"};\\n\"\n              \"void func(std::string str) {}\\n\"\n              \"void Bar() {\\n\"\n              \"    std::string str = \\\"bar\\\";\\n\"\n              \"    Foo foo;\\n\"\n              \"    func(str.c_str());\\n\"\n              \"    Foo::sfunc(str.c_str());\\n\"\n              \"    foo.func(str.c_str());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:10:10]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:11:9]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\",\n                      errout_str());\n\n        check(\"void f(const std::string& s);\\n\" // #8336\n              \"struct T {\\n\"\n              \"    std::string g();\\n\"\n              \"    std::string a[1];\\n\"\n              \"    struct U { std::string s; } u;\"\n              \"};\\n\"\n              \"namespace N { namespace O { std::string s; } }\\n\"\n              \"void g(const std::vector<std::string>& v, T& t) {\\n\"\n              \"    for (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); ++it)\\n\"\n              \"        f(it->c_str());\\n\"\n              \"    f(v.begin()->c_str());\\n\"\n              \"    f(t.g().c_str());\\n\"\n              \"    f(t.a[0].c_str());\\n\"\n              \"    f(t.u.s.c_str());\\n\"\n              \"    f(N::O::s.c_str());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:9]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:10:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:11:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:12:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:13:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\"\n                      \"[test.cpp:14:5]: (performance) Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]\\n\",\n                      errout_str());\n\n        check(\"void svgFile(const std::string &content, const std::string &fileName, const double end = 1000., const double start = 0.);\\n\"\n              \"void Bar(std::string filename) {\\n\"\n              \"    std::string str = \\\"bar\\\";\\n\"\n              \"    std::ofstream svgFile(filename.c_str(), std::ios::trunc);\\n\"\n              \"    svgFile << \\\"test\\\";\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void Foo(const char* p) {}\\n\"\n              \"void Foo(const std::string& str) {Foo(str.c_str());}\\n\" // Overloaded\n              \"void Bar() {\\n\"\n              \"    std::string str = \\\"bar\\\";\\n\"\n              \"    Foo(str);\\n\"\n              \"    Foo(str.c_str());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int atoi(const std::string& str) {\\n\" // #3729: Don't suggest recursive call\n              \"    return atoi(str.c_str());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string hello()\\n\"\n              \"{\\n\"\n              \"     return \\\"hello\\\";\\n\"\n              \"}\\n\"\n              \"\\n\"\n              \"const char *f()\\n\"\n              \"{\\n\"\n              \"    return hello().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:8:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"class Fred {\\n\"\n              \"    std::string hello();\\n\"\n              \"    const char *f();\\n\"\n              \"};\\n\"\n              \"std::string Fred::hello()\\n\"\n              \"{\\n\"\n              \"     return \\\"hello\\\";\\n\"\n              \"}\\n\"\n              \"const char *Fred::f()\\n\"\n              \"{\\n\"\n              \"    return hello().c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:11:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        // #4183 - using MyStringClass.c_str()\n        check(\"void a(const std::string &str);\\n\"\n              \"\\n\"\n              \"void b() {\\n\"\n              \"    MyStringClass s;\\n\"\n              \"    a(s.c_str());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string Format(const char * name) {\\n\" // #4938\n              \"    return String::Format(\\\"%s:\\\", name).c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #7480\n        check(\"struct InternalMapInfo {\\n\"\n              \"    std::string author;\\n\"\n              \"};\\n\"\n              \"const char* GetMapAuthor(int index) {\\n\"\n              \"    const InternalMapInfo* mapInfo = &internal_getMapInfo;\\n\"\n              \"    return mapInfo->author.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct InternalMapInfo {\\n\"\n              \"    std::string author;\\n\"\n              \"};\\n\"\n              \"std::string GetMapAuthor(int index) {\\n\"\n              \"    const InternalMapInfo* mapInfo = &internal_getMapInfo;\\n\"\n              \"    return mapInfo->author.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (performance) Returning the result of c_str() in a function that returns std::string is slow and redundant. [stlcstrReturn]\\n\", errout_str());\n\n        check(\"struct InternalMapInfo {\\n\"\n              \"    std::string author;\\n\"\n              \"};\\n\"\n              \"const char* GetMapAuthor(int index) {\\n\"\n              \"    const InternalMapInfo mapInfo = internal_getMapInfo;\\n\"\n              \"    return mapInfo.author.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"struct S {\\n\" // #7656\n              \"    std::string data;\\n\"\n              \"};\\n\"\n              \"const S& getS();\\n\"\n              \"const char* test() {\\n\"\n              \"    const struct S &s = getS();\\n\"\n              \"    return s.data.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #7930\n              \"    std::string data;\\n\"\n              \"};\\n\"\n              \"const char* test() {\\n\"\n              \"    S s;\\n\"\n              \"    std::string &ref = s.data;\\n\"\n              \"    return ref.c_str();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7:5]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"void f(const wchar_t* w, int i = 0, ...);\\n\" // #10357\n              \"void f(const std::string& s, int i = 0);\\n\"\n              \"void g(const std::wstring& p) {\\n\"\n              \"    f(p.c_str());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" //#9161\n              \"    const char* f() const noexcept {\\n\"\n              \"        return (\\\"\\\" + m).c_str();\\n\"\n              \"    }\\n\"\n              \"    std::string m;\\n\"\n              \"};\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (error) Dangerous usage of c_str(). The value returned by c_str() is invalid after this call. [stlcstr]\\n\", errout_str());\n\n        check(\"struct S {\\n\" // #10493\n              \"    void f(const char** pp);\\n\"\n              \"    std::string s;\\n\"\n              \"};\\n\"\n              \"void S::f(const char** pp) {\\n\"\n              \"    try {\\n\"\n              \"        *pp = member.c_str();\\n\"\n              \"    }\\n\"\n              \"    catch (...) {\\n\"\n              \"        s = \\\"xyz\\\";\\n\"\n              \"        *pp = member.c_str();\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string f(const std::string& a) {\\n\"\n              \"    std::string b(a.c_str());\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (performance) Constructing a std::string from the result of c_str() is slow and redundant. [stlcstrConstructor]\\n\", errout_str());\n\n        check(\"std::string f(const std::string& a) {\\n\"\n              \"    std::string b{ a.c_str() };\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (performance) Constructing a std::string from the result of c_str() is slow and redundant. [stlcstrConstructor]\\n\", errout_str());\n\n        check(\"std::string f(const std::string& a) {\\n\"\n              \"    std::string b = a.c_str();\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:17]: (performance) Assigning the result of c_str() to a std::string is slow and redundant. [stlcstrAssignment]\\n\", errout_str());\n\n        check(\"std::string g(const std::string& a, const std::string& b) {\\n\"\n              \"    return a + b.c_str();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:14]: (performance) Concatenating the result of c_str() and a std::string is slow and redundant. [stlcstrConcat]\\n\", errout_str());\n\n        check(\"std::string g(const std::string& a, const std::string& b) {\\n\"\n              \"    return a.c_str() + b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (performance) Concatenating the result of c_str() and a std::string is slow and redundant. [stlcstrConcat]\\n\", errout_str());\n\n        check(\"std::vector<double> v;\\n\" // don't crash\n              \"int i;\\n\"\n              \"void f() {\\n\"\n              \"    const double* const QM_R__ buf(v.data() + i);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct T {\\n\" // #7515\n              \"    std::string g();\\n\"\n              \"    std::string a[1];\\n\"\n              \"    std::vector<std::string> v;\\n\"\n              \"};\\n\"\n              \"void f(std::stringstream& strm, const std::string& s, T& t) {\\n\"\n              \"    strm << s.c_str();\\n\"\n              \"    strm << \\\"abc\\\" << s.c_str();\\n\"\n              \"    strm << \\\"abc\\\" << s.c_str() << \\\"def\\\";\\n\"\n              \"    strm << \\\"abc\\\" << t.g().c_str() << \\\"def\\\";\\n\"\n              \"    strm << t.a[0].c_str();\\n\"\n              \"    strm << t.v.begin()->c_str();\\n\"\n              \"    auto it = t.v.begin()\\n\"\n              \"    strm << it->c_str();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:7:10]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\"\n                      \"[test.cpp:8:19]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\"\n                      \"[test.cpp:9:19]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\"\n                      \"[test.cpp:10:19]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\"\n                      \"[test.cpp:11:10]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\"\n                      \"[test.cpp:12:10]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\"\n                      \"[test.cpp:14:10]: (performance) Passing the result of c_str() to a stream is slow and redundant. [stlcstrStream]\\n\",\n                      errout_str());\n\n        check(\"struct S { std::string str; };\\n\"\n              \"struct T { S s; };\\n\"\n              \"struct U { T t[1]; };\\n\"\n              \"void f(const T& t, const U& u, std::string& str) {\\n\"\n              \"    if (str.empty())\\n\"\n              \"        str = t.s.str.c_str();\\n\"\n              \"    else\\n\"\n              \"        str = u.t[0].s.str.c_str();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6:9]: (performance) Assigning the result of c_str() to a std::string is slow and redundant. [stlcstrAssignment]\\n\"\n                      \"[test.cpp:8:9]: (performance) Assigning the result of c_str() to a std::string is slow and redundant. [stlcstrAssignment]\\n\",\n                      errout_str());\n\n        check(\"void f(std::string_view);\\n\" // #11547\n              \"void g(const std::string & s) {\\n\"\n              \"    f(s.c_str());\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (performance) Passing the result of c_str() to a function that takes std::string_view as argument no. 1 is slow and redundant. [stlcstrParam]\\n\",\n                      errout_str());\n\n        check(\"std::string_view f(const std::string& s) {\\n\"\n              \"    std::string_view sv = s.c_str();\\n\"\n              \"    return sv;\\n\"\n              \"}\\n\"\n              \"std::string_view g(const std::string& s) {\\n\"\n              \"    std::string_view sv{ s.c_str() };\\n\"\n              \"    return sv;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (performance) Assigning the result of c_str() to a std::string_view is slow and redundant. [stlcstrAssignment]\\n\"\n                      \"[test.cpp:6:22]: (performance) Constructing a std::string_view from the result of c_str() is slow and redundant. [stlcstrConstructor]\\n\",\n                      errout_str());\n\n        check(\"void f(const std::string& s) {\\n\" // #11819\n              \"    std::string_view sv(s.data(), 13);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { std::string x; };\\n\" // #11802\n              \"std::vector<std::shared_ptr<S>> global;\\n\"\n              \"const char* f() {\\n\"\n              \"    auto s = std::make_shared<S>();\\n\"\n              \"    global.push_back(s);\\n\"\n              \"    return s->x.c_str();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void uselessCalls() {\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    string s1, s2;\\n\"\n              \"    s1.swap(s2);\\n\"\n              \"    s2.swap(s2);\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::string s1, s2;\\n\"\n              \"    s1.swap(s2);\\n\"\n              \"    s2.swap(s2);\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (performance) It is inefficient to swap a object with itself by calling 's2.swap(s2)' [uselessCallsSwap]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    std::string s1, s2;\\n\"\n              \"    s1.compare(s2);\\n\"\n              \"    s2.compare(s2);\\n\"\n              \"    s1.compare(s2.c_str());\\n\"\n              \"    s1.compare(0, s1.size(), s1);\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:16]: (warning) It is inefficient to call 's2.compare(s2)' as it always returns 0. [uselessCallsCompare]\\n\", errout_str());\n\n        // #7370 False positive uselessCallsCompare on unknown type\n        check(\"class ReplayIteratorImpl{\\n\"\n              \"  int Compare(ReplayIteratorImpl* other) {\\n\"\n              \"    int cmp;\\n\"\n              \"    int ret = cursor_->compare(cursor_, other->cursor_, &cmp);\\n\"\n              \"    return (cmp);\\n\"\n              \"  }\\n\"\n              \"  WT_CURSOR *cursor_;\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int x=1;\\n\"\n              \"    std::string s1, s2;\\n\"\n              \"    s1 = s1.substr();\\n\"\n              \"    s2 = s1.substr(x);\\n\"\n              \"    s1 = s2.substr(0, x);\\n\"\n              \"    s1 = s2.substr(0,std::string::npos);\\n\"\n              \"    s1 = s2.substr(x+5-n, 0);\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"[test.cpp:5:10]: (performance) Ineffective call of function \\'substr\\' because it returns a copy of \"\n                      \"the object. Use operator= instead. [uselessCallsSubstr]\\n\"\n                      \"[test.cpp:8:10]: (performance) Ineffective call of function \\'substr\\' because it returns a copy of \"\n                      \"the object. Use operator= instead. [uselessCallsSubstr]\\n\"\n                      \"[test.cpp:9:10]: (performance) Ineffective call of function \\'substr\\' because it returns an empty string. [uselessCallsSubstr]\\n\", errout_str());\n\n        check(\"void f()\\n\"\n              \"{\\n\"\n              \"    int x=1;\\n\"\n              \"    string s1, s2;\\n\"\n              \"    s1 = s1.substr();\\n\"\n              \"    s2 = s1.substr(x);\\n\"\n              \"    s1 = s2.substr(0, x);\\n\"\n              \"    s1 = s2.substr(0,std::string::npos);\\n\"\n              \"    s1 = s2.substr(x+5-n, 0);\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int main()\\n\"\n              \"{\\n\"\n              \"    std::string str = \\\"a1b1\\\";\\n\"\n              \"    return str.find(str[1], 2);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool foo(std::vector<int>& v) {\\n\"\n              \"    v.empty();\\n\"\n              \"    return v.empty();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning) Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead? [uselessCallsEmpty]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #4938\n              \"    OdString str;\\n\"\n              \"    str.empty();\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\" // #4032\n              \"    const std::string greeting(\\\"Hello World !!!\\\");\\n\"\n              \"    const std::string::size_type npos = greeting.rfind(\\\" \\\");\\n\"\n              \"    if (npos != std::string::npos)\\n\"\n              \"        std::cout << greeting.substr(0, npos) << std::endl;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int> a) {\\n\"\n              \"    std::remove(a.begin(), a.end(), val);\\n\"\n              \"    std::remove_if(a.begin(), a.end(), val);\\n\"\n              \"    std::unique(a.begin(), a.end(), val);\\n\"\n              \"    x = std::remove(a.begin(), a.end(), val);\\n\"\n              \"    a.erase(std::remove(a.begin(), a.end(), val));\\n\"\n              \"    std::remove(\\\"foo.txt\\\");\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (warning) Return value of std::remove() ignored. Elements remain in container. [uselessCallsRemove]\\n\"\n                      \"[test.cpp:3:5]: (warning) Return value of std::remove_if() ignored. Elements remain in container. [uselessCallsRemove]\\n\"\n                      \"[test.cpp:4:5]: (warning) Return value of std::unique() ignored. Elements remain in container. [uselessCallsRemove]\\n\", errout_str());\n\n        // #4431 - fp\n        check(\"bool f() {\\n\"\n              \"    return x ? true : (y.empty());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8360\n        check(\"void f(std::string s) {\\n\"\n              \"    for (;s.empty();) {}\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11166\n        check(\"std::string f(std::string s) {\\n\"\n              \"    s = s.substr(0, s.size() - 1);\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (performance) Ineffective call of function 'substr' because a prefix of the string is assigned to itself. Use resize() or pop_back() instead. [uselessCallsSubstr]\\n\",\n                      errout_str());\n\n        check(\"std::string f(std::string s, std::size_t start, std::size_t end, const std::string& i) {\\n\"\n              \"    s = s.substr(0, start) + i + s.substr(end + 1);\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:9]: (performance) Ineffective call of function 'substr' because a prefix of the string is assigned to itself. Use replace() instead. [uselessCallsSubstr]\\n\",\n                      errout_str());\n\n        check(\"std::string f(std::string s, std::size_t end) {\\n\"\n              \"    s = { s.begin(), s.begin() + end };\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (performance) Inefficient constructor call: container 's' is assigned a partial copy of itself. Use erase() or resize() instead. [uselessCallsConstructor]\\n\",\n                      errout_str());\n\n        check(\"std::list<int> f(std::list<int> l, std::size_t end) {\\n\"\n              \"    l = { l.begin(), l.begin() + end };\\n\"\n              \"    return l;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (performance) Inefficient constructor call: container 'l' is assigned a partial copy of itself. Use erase() or resize() instead. [uselessCallsConstructor]\\n\",\n                      errout_str());\n\n        check(\"std::string f(std::string s, std::size_t end) {\\n\"\n              \"    s = std::string{ s.begin(), s.begin() + end };\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (performance) Inefficient constructor call: container 's' is assigned a partial copy of itself. Use erase() or resize() instead. [uselessCallsConstructor]\\n\",\n                      errout_str());\n\n        check(\"std::string f(std::string s, std::size_t end) {\\n\"\n              \"    s = std::string(s.begin(), s.begin() + end);\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (performance) Inefficient constructor call: container 's' is assigned a partial copy of itself. Use erase() or resize() instead. [uselessCallsConstructor]\\n\",\n                      errout_str());\n\n        check(\"std::vector<int> f(std::vector<int> v, std::size_t end) {\\n\"\n              \"    v = std::vector<int>(v.begin(), v.begin() + end);\\n\"\n              \"    return v;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (performance) Inefficient constructor call: container 'v' is assigned a partial copy of itself. Use erase() or resize() instead. [uselessCallsConstructor]\\n\",\n                      errout_str());\n    }\n\n    void stabilityOfChecks() {\n        // Stability test: 4684 cppcheck crash in template function call.\n        check(\"template<class T>\\n\"\n              \"class EffectivityRangeData {};\\n\"\n              \"template<class T>\\n\"\n              \"class EffectivityRange {\\n\"\n              \"    void unite() {\\n\"\n              \"        x < vector < EffectivityRangeData<int >> >();\\n\"\n              \"        EffectivityRange<int> er;\\n\"\n              \"    }\\n\"\n              \"    void shift() { EffectivityRangeData<int>::iterator it;  }\\n\"\n              \"};\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void dereferenceInvalidIterator() {\n        // Test simplest \"if\" with && case\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    if (std::isalpha(*i) && i != str.end()) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:22]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    if(foo) { bar(); }\\n\"\n              \"    else if (std::isalpha(*i) && i != str.end()) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3:27]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test suggested correction doesn't report an error\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    if (i != str.end() && std::isalpha(*i)) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test \"while\" with \"&&\" case\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    while (std::isalpha(*i) && i != str.end()) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    do {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    } while (std::isalpha(*i) && i != str.end());\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5:27]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test \"while\" with \"||\" case\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    while (!(!std::isalpha(*i) || i == str.end())) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:28]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test fix for \"while\" with \"||\" case\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    while (!(i == str.end() || !std::isalpha(*i))) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test \"for\" with \"&&\" case\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    for (; std::isalpha(*i) && i != str.end() ;) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test \"for\" with \"||\" case\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    for (; std::isalpha(*i) || i == str.end() ;) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test that a dereference outside the condition part of a \"for\"\n        // loop does not result in a false positive\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    for (char c = *i; isRunning && i != str.end() ;) {\\n\"\n              \"        std::cout << c;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test that other \"&&\" terms in the condition don't invalidate the check\n        check(\"void foo(char* c, std::string::iterator& i) {\\n\"\n              \"    if (*c && std::isalpha(*i) && i != str.end()) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:28]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test that dereference of different variable doesn't trigger a false positive\n        check(\"void foo(const char* c, std::string::iterator& i) {\\n\"\n              \"    if (std::isalpha(*c) && i != str.end()) {\\n\"\n              \"        std::cout << *c;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Test case involving \"rend()\" instead of \"end()\"\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    while (std::isalpha(*i) && i != str.rend()) {\\n\"\n              \"        std::cout << *i;\\n\"\n              \"        i ++;\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:25]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        // Test that mixed \"&&\" and \"||\" don't result in a false positive\n        check(\"void foo(std::string::iterator& i) {\\n\"\n              \"    if ((i == str.end() || *i) || (isFoo() && i != str.end())) {\\n\"\n              \"        std::cout << \\\"foo\\\";\\n\"\n              \"    }\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector <int> v;\\n\"\n              \"    std::vector <int>::iterator i = v.end();\\n\"\n              \"    *i=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector <int> v;\\n\"\n              \"    std::vector <int>::iterator i = std::end(v);\\n\"\n              \"    *i=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:6]: (error) Dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v) {\\n\"\n              \"    std::vector <int>::iterator i = v.end();\\n\"\n              \"    *i=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:6]: (error) Dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v) {\\n\"\n              \"    std::vector <int>::iterator i = v.end();\\n\"\n              \"    *(i+1)=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (error) Dereference of an invalid iterator: i+1 [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v) {\\n\"\n              \"    std::vector <int>::iterator i = v.end();\\n\"\n              \"    *(i-1)=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector <int> v) {\\n\"\n              \"    std::vector <int>::iterator i = v.begin();\\n\"\n              \"    *(i-1)=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (error) Dereference of an invalid iterator: i-1 [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v) {\\n\"\n              \"    std::vector <int>::iterator i = std::begin(v);\\n\"\n              \"    *(i-1)=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:8]: (error) Dereference of an invalid iterator: i-1 [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v, bool b) {\\n\"\n              \"    std::vector <int>::iterator i = v.begin();\\n\"\n              \"    if (b)\\n\"\n              \"        i = v.end();\\n\"\n              \"    *i=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:6]: (warning) Possible dereference of an invalid iterator: i [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v, bool b) {\\n\"\n              \"    std::vector <int>::iterator i = v.begin();\\n\"\n              \"    if (b)\\n\"\n              \"        i = v.end();\\n\"\n              \"    *(i+1)=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (warning) Possible dereference of an invalid iterator: i+1 [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"void f(std::vector <int> v, bool b) {\\n\"\n              \"    std::vector <int>::iterator i = v.begin();\\n\"\n              \"    if (b)\\n\"\n              \"        i = v.end();\\n\"\n              \"    *(i-1)=0;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5:8]: (warning) Possible dereference of an invalid iterator: i-1 [derefInvalidIterator]\\n\", errout_str());\n\n        check(\"int f(std::vector<int> v, int pos) {\\n\"\n              \"    if (pos >= 0)\\n\"\n              \"        return *(v.begin() + pos);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::vector<int> v, int i) {\\n\"\n              \"    auto it = std::find(v.begin(), v.end(), i);\\n\"\n              \"    if (it != v.end()) {}\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:12] -> [test.cpp:4:13]: (warning) Either the condition 'it!=v.end()' is redundant or there is possible dereference of an invalid iterator: it. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i == v.end() && *(i+1) == *i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:3:27]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\"\n                      \"[test.cpp:3:10] -> [test.cpp:3:35]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n\n        check(\"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i == v.end() && *i == *(i+1)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:3:25]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i. [derefInvalidIteratorRedundantCheck]\\n\"\n                      \"[test.cpp:3:10] -> [test.cpp:3:33]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i != v.end() && *i == *(i+1)) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:3:33]: (warning) Either the condition 'i!=v.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i != v.end()) {\\n\"\n              \"        if (*(i+1) == *i) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:16]: (warning) Either the condition 'i!=v.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i == v.end()) { return; }\\n\"\n              \"    if (*(i+1) == *i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:10] -> [test.cpp:4:12]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i != v.end() && (i+1) != v.end() && *(i+1) == *i) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string s) {\\n\"\n              \"    for (std::string::const_iterator i = s.begin(); i != s.end(); ++i) {\\n\"\n              \"        if (i != s.end() && (i + 1) != s.end() && *(i + 1) == *i) {\\n\"\n              \"            if (!isalpha(*(i + 2))) {\\n\"\n              \"                std::string modifier;\\n\"\n              \"                modifier += *i;\\n\"\n              \"                modifier += *(i + 1);\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:37] -> [test.cpp:4:30]: (warning) Either the condition '(i+1)!=s.end()' is redundant or there is possible dereference of an invalid iterator: i+2. [derefInvalidIteratorRedundantCheck]\\n\", errout_str());\n\n        check(\"void f(int v, std::map<int, int> &items) {\\n\"\n              \"    for (auto it = items.begin(); it != items.end();)\\n\"\n              \"        (it->first == v) ? it = items.erase(it) : ++it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::string s) {\\n\"\n              \"    for (std::string::const_iterator i = s.begin(); i != s.end(); ++i) {\\n\"\n              \"        if (i != s.end() && (i + 1) != s.end() && *(i + 1) == *i) {\\n\"\n              \"            if ((i + 2) != s.end() && !isalpha(*(i + 2))) {\\n\"\n              \"                std::string modifier;\\n\"\n              \"                modifier += *i;\\n\"\n              \"                modifier += *(i + 1);\\n\"\n              \"            }\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::vector<int>::iterator it, const std::vector<int>& vector) {\\n\"\n              \"    if (!(it != vector.end() && it != vector.begin()))\\n\"\n              \"        throw std::out_of_range();\\n\"\n              \"    if (it != vector.end() && *it == 0)\\n\"\n              \"        return -1;\\n\"\n              \"    return *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(std::vector<int> &vect) {\\n\"\n              \"    const int &v = *vect.emplace(vect.end());\\n\"\n              \"    return v;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"extern bool bar(int);\\n\"\n              \"void f(std::vector<int> & v) {\\n\"\n              \"    std::vector<int>::iterator i= v.begin();\\n\"\n              \"    if(i == v.end() && bar(*(i+1)) ) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4:10] -> [test.cpp:4:31]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\",\n            errout_str());\n\n        // #10657\n        check(\"std::list<int> mValues;\\n\"\n              \"typedef std::list<int>::iterator ValueIterator;\\n\"\n              \"void foo(ValueIterator beginValue, ValueIterator endValue) {\\n\"\n              \"    ValueIterator prevValue = beginValue;\\n\"\n              \"    ValueIterator curValue = beginValue;\\n\"\n              \"    for (++curValue; prevValue != endValue && curValue != mValues.end(); ++curValue) {\\n\"\n              \"        a = bar(*curValue);\\n\"\n              \"        prevValue = curValue;\\n\"\n              \"    }\\n\"\n              \"    if (endValue == mValues.end()) {}\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10642\n        check(\"int f(std::vector<int> v) {\\n\"\n              \"    return *(v.begin() + v.size() - 1);\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10716\n        check(\"struct a;\\n\"\n              \"class b {\\n\"\n              \"  void c(std::map<std::string, a *> &);\\n\"\n              \"  std::string d;\\n\"\n              \"  std::map<std::string, std::set<std::string>> e;\\n\"\n              \"};\\n\"\n              \"void b::c(std::map<std::string, a *> &) {\\n\"\n              \"  e.clear();\\n\"\n              \"  auto f = *e[d].begin();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:23]: (error) Out of bounds access in expression 'e[d].begin()' because 'e[d]' is empty. [containerOutOfBounds]\\n\",\n                      errout_str());\n\n        // #10151\n        check(\"std::set<int>::iterator f(std::set<int>& s) {\\n\"\n              \"for (auto it = s.begin(); it != s.end(); ++it)\\n\"\n              \"    if (*it == 42)\\n\"\n              \"        return s.erase(it);\\n\"\n              \"    return s.end();\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:0]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        // #11381\n        check(\"int f(std::map<int, int>& map) {\\n\"\n              \"    auto it = map.find(1);\\n\"\n              \"    if (it == map.end()) {\\n\"\n              \"        bool bInserted;\\n\"\n              \"        std::tie(it, bInserted) = map.emplace(1, 42);\\n\"\n              \"    }\\n\"\n              \"    return debug_valueflow(it)->second;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11557\n        check(\"bool f(const std::vector<int*>& v, std::vector<int*>::iterator it, bool b) {\\n\"\n              \"    if (it == v.end())\\n\"\n              \"        return false;\\n\"\n              \"    if (b && ((it + 1) == v.end() || (*(it + 1)) != nullptr))\\n\"\n              \"        return false;\\n\"\n              \"    return true;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #6925\n        check(\"void f(const std::string& s, std::string::iterator i) {\\n\"\n              \"    if (i != s.end() && *(i + 1) == *i) {\\n\"\n              \"        if (i + 1 != s.end()) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:19] -> [test.cpp:2:29]: (warning) Either the condition 'i+1!=s.end()' is redundant or there is possible dereference of an invalid iterator: i+1. [derefInvalidIteratorRedundantCheck]\\n\",\n                      errout_str());\n\n        check(\"void f(bool b, std::vector<std::string> v) {\\n\" // #12680\n              \"    if (!v.empty()) {\\n\"\n              \"        auto it = v.begin();\\n\"\n              \"        if (b) {\\n\"\n              \"            v.clear();\\n\"\n              \"            it = v.begin();\\n\"\n              \"        }\\n\"\n              \"        for (++it; it != v.end(); ++it) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n\n        check(\"void f(int);\\n\" // #13064\n              \"void g() {\\n\"\n              \"    std::vector<int> v{ 0 };\\n\"\n              \"    auto it = std::find(v.begin(), v.end(), 0);\\n\"\n              \"    if (it == v.end()) {\\n\"\n              \"        f({});\\n\"\n              \"        it = v.begin();\\n\"\n              \"    }\\n\"\n              \"    *it;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g() {\\n\" // #13332\n              \"    const std::vector<int> v = { 1, 2, 3, 4 };\\n\"\n              \"    const std::vector<int>::const_iterator a[2] = { v.begin(), v.end() };\\n\"\n              \"    return *a[0];\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void dereferenceInvalidIterator2() {\n        // Self-implemented iterator class\n        check(\"class iterator {\\n\"\n              \"public:\\n\"\n              \"    CCommitPointer m_ptr;\\n\"\n              \"    iterator() {}\\n\"\n              \"    CCommitPointer& operator*() {\\n\"\n              \"        return m_ptr;\\n\"\n              \"    }\\n\"\n              \"    CCommitPointer* operator->() {\\n\"\n              \"        return &m_ptr;\\n\"\n              \"    }\\n\"\n              \"    iterator& operator++() {\\n\"\n              \"        ++m_ptr.m_place;\\n\"\n              \"        return *this;\\n\"\n              \"    }\\n\"\n              \"    };\\n\"\n              \"    iterator begin() {\\n\"\n              \"    iterator it;\\n\"\n              \"    it->m_place = 0;\\n\"\n              \"    return it;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:18:5]: (error, inconclusive) Invalid iterator 'it' used. [eraseDereference]\\n\", errout_str());\n    }\n\n    void loopAlgoElementAssign() {\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x = 1;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Consider using std::fill algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x = x + 1;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo(int a, int b) {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x = a + b;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Consider using std::fill or std::generate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x += 1;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x = f();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Consider using std::generate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v) {\\n\"\n              \"        f();\\n\"\n              \"        x = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v) {\\n\"\n              \"        x = 1;\\n\"\n              \"        f();\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // There should probably be a message for unconditional break\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v) {\\n\"\n              \"        x = 1;\\n\"\n              \"        break;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x = ++x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void loopAlgoAccumulateAssign() {\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n += x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = n + x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n += 1;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::distance algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = n + 1;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::distance algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool f(int);\\n\"\n              \"void foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        b &= f(x);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int);\\n\"\n              \"void foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        b |= f(x);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int);\\n\"\n              \"void foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        b = b && f(x);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int);\\n\"\n              \"void foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        b = b || f(x);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        n = ++x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::size_t f(const std::map<std::string, std::size_t>& m) {\\n\" // #10412\n              \"    std::size_t t = 0;\\n\"\n              \"    for (std::map<std::string, std::size_t>::const_iterator i = m.begin(); i != m.end(); ++i) {\\n\"\n              \"        t += i->second;\\n\"\n              \"    }\\n\"\n              \"    for (std::map<std::string, std::size_t>::const_iterator i = m.begin(); i != m.end(); i++) {\\n\"\n              \"        t += i->second;\\n\"\n              \"    }\\n\"\n              \"    return t; \\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\"\n                      \"[test.cpp:7:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"int g(const std::vector<int>& v) {\\n\"\n              \"    int t = 0;\\n\"\n              \"    for (auto i = v.begin(); i != v.end(); ++i) {\\n\"\n              \"        t += *i;\\n\"\n              \"    }\\n\"\n              \"    return t;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"auto g(const std::vector<int>& v) {\\n\"\n              \"    std::vector<std::vector<int>::iterator> r;\\n\"\n              \"    for (auto i = v.begin(); i != v.end(); ++i) {\\n\"\n              \"        r.push_back(i);\\n\"\n              \"    }\\n\"\n              \"    return r;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string f(std::vector<std::string> v) {\\n\"\n              \"    std::string ret;\\n\"\n              \"    for (const std::string& s : v)\\n\"\n              \"        ret += s + '\\\\n';\\n\"\n              \"    return ret;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::string f(const std::string& s) {\\n\"\n              \"    std::string ret;\\n\"\n              \"    for (char c : s)\\n\"\n              \"        if (c != ' ')\\n\"\n              \"            ret += i;\\n\"\n              \"    return ret;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\"\n              \"    int sum = 0;\\n\"\n              \"    for (auto it = v.begin(); it != v.end(); it += 2)\\n\"\n              \"        sum += *it;\\n\"\n              \"    return sum;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\" // #12900\n              \"    int x{};\\n\"\n              \"    for (const auto i : v)\\n\"\n              \"        x = dostuff(i);\\n\"\n              \"    return x;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\" // #11493\n              \"    int s = 0;\\n\"\n              \"    for (std::size_t i = 0; i < v.size(); ++i)\\n\"\n              \"        s += v[i];\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"int f(int n) {\\n\"\n              \"    int s = 0;\\n\"\n              \"    for (int i = 0; i < n; ++i)\\n\"\n              \"        s += g(i);\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int g(int);\\n\"\n              \"int f(const std::vector<int>&v, int n) {\\n\"\n              \"    int s = 0;\\n\"\n              \"    for (int i = 0; i < n; ++i) {\\n\"\n              \"        s += g(i) + v[i];\\n\"\n              \"    }\\n\"\n              \"    return s;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void loopAlgoContainerInsert() {\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_back(x);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::copy algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_back(f(x));\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_back(x + 1);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_front(x);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::copy algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_front(f(x));\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_front(x + 1);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_back(v);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        c.push_back(0);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void loopAlgoIncrement() {\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n++;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:9]: (style) Consider using std::distance algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        ++n;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::distance algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        x++;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:9]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    for(int& x:v)\\n\"\n              \"        ++x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:11]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n    }\n\n    void loopAlgoConditional() {\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    for(int& x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            x = 1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (style) Consider using std::replace_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            n += x;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:6:15]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            n += 1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:6:15]: (style) Consider using std::count_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            n++;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:6:13]: (style) Consider using std::count_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    for(int& x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            x = x + 1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:15]: (style) Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            c.push_back(x);\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:6:14]: (style) Consider using std::copy_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"bool foo() {\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            return false;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return true;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:5]: (style) Consider using std::all_of or std::none_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"bool foo() {\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return true;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:22]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void f();\\n\"\n              \"void foo() {\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            f();\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:22]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void f(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            f(x);\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:22]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"bool foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            b = true;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    if(b) {}\\n\"\n              \"    return true;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"bool foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            b |= true;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return true;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"bool foo() {\\n\"\n              \"    bool b = false;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            b &= true;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return true;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"bool foo() {\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            return false;\\n\"\n              \"        }\\n\"\n              \"        return true;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // There is no transform_if\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    std::vector<int> c;\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            c.push_back(x + 1);\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void foo() {\\n\"\n              \"    for(int& x:v) {\\n\"\n              \"        x++;\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            x = 1;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool pred(int x);\\n\"\n              \"void f();\\n\"\n              \"void foo() {\\n\"\n              \"    for(int x:v) {\\n\"\n              \"        if (pred(x)) {\\n\"\n              \"            if(x) { return; }\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(int);\\n\"\n              \"int f(const std::vector<int>& v) {\\n\"\n              \"    int ret = 0;\\n\"\n              \"    for (const auto i : v)\\n\"\n              \"        if (!g(i))\\n\"\n              \"            ret = 1;\\n\"\n              \"    return ret;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\"\n              \"    int ret = 0;\\n\"\n              \"    for (const auto i : v)\\n\"\n              \"        if (i < 5)\\n\"\n              \"            ret = 1;\\n\"\n              \"    return ret;\\n\"\n              \"}\\n\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:5]: (style) Consider using std::any_of, std::all_of, std::none_of algorithm instead of a raw loop.\\n\",\n                           \"\",\n                           errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\"\n              \"    int ret = 0;\\n\"\n              \"    for (const auto i : v)\\n\"\n              \"        if (i < 5) {\\n\"\n              \"            ret = 1;\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    return ret;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:20]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"struct T {\\n\"\n              \"    std::vector<int> v0, v1;\\n\"\n              \"    void g();\\n\"\n              \"};\\n\"\n              \"void T::g() {\\n\"\n              \"    for (std::vector<int>::const_iterator it0 = v0.cbegin(); it0 != v0.cend(); ++it0) {\\n\"\n              \"        std::vector<int>::iterator it1;\\n\"\n              \"        for (it1 = v1.begin(); it1 != v1.end(); ++it1)\\n\"\n              \"            if (*it0 == *it1)\\n\"\n              \"                break;\\n\"\n              \"        if (it1 != v1.end())\\n\"\n              \"            v1.erase(it1);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:9:0]: (style) Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"bool f(const std::set<std::string>& set, const std::string& f) {\\n\" // #11595\n              \"    for (const std::string& s : set) {\\n\"\n              \"        if (f.length() >= s.length() && f.compare(0, s.length(), s) == 0) {\\n\"\n              \"            return true;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"void f() {\\n\" // #12064\n              \"    for (const auto& animal : { \\\"cat\\\", \\\"bat\\\", \\\"tiger\\\", \\\"rat\\\" })\\n\"\n              \"        if (std::strlen(animal) > 4)\\n\"\n              \"            throw 1;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(const std::vector<int>& v, const std::vector<int>& w, int n) {\\n\"\n              \"    for (int i = 0; i < n; ++i)\\n\"\n              \"        if (v[i] == w[i])\\n\"\n              \"            return true;\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f(int n) {\\n\"\n              \"    for (int i = 0; i < n; ++i)\\n\"\n              \"        if (g(i))\\n\"\n              \"            return true;\\n\"\n              \"    return false;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(int);\\n\"\n              \"bool f(const std::vector<int>&v, int n) {\\n\"\n              \"    bool b{};\\n\"\n              \"    for (int i = 0; i < n; ++i) {\\n\"\n              \"        if (v[i] > 0 && g(i)) {\\n\"\n              \"            b = true;\\n\"\n              \"            break;\\n\"\n              \"        }\\n\"\n              \"    }\\n\"\n              \"    return b;\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void loopAlgoMinMax() {\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = x > n ? x : n;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::max_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = x < n ? x : n;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::min_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = x > n ? n : x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::min_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = x < n ? n : x;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::max_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void foo(int m) {\\n\"\n              \"    int n = 0;\\n\"\n              \"    for(int x:v)\\n\"\n              \"        n = x > m ? x : n;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:11]: (style) Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"void f(const std::vector<int>& v) {\\n\" // #9091\n              \"    int maxY = 0;\\n\"\n              \"    for (int y : v) {\\n\"\n              \"        if (y > maxY)\\n\"\n              \"            maxY = y;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:18]: (style) Consider using std::max_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\"\n              \"    int minY = 0;\\n\"\n              \"    for (int y : v) {\\n\"\n              \"        if (y < minY)\\n\"\n              \"            minY = y;\\n\"\n              \"    }\\n\"\n              \"    return minY;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:18]: (style) Consider using std::min_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\"\n              \"    int max = 0;\\n\"\n              \"    for (int i = 0; i < n; ++i)\\n\"\n              \"        max = v[i] > max ? v[i] : max;\\n\"\n              \"    return max;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Consider using std::max_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"int f(const std::vector<int>& v) {\\n\"\n              \"    int min = 0;\\n\"\n              \"    for (int i = 0; i < n; ++i)\\n\"\n              \"        min = v[i] < min ? v[i] : min;\\n\"\n              \"    return min;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:13]: (style) Consider using std::min_element algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n    }\n\n    void loopAlgoMultipleReturn()\n    {\n        check(\"bool f(const std::vector<int>& v) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        if (i < 0)\\n\"\n              \"            continue;\\n\"\n              \"        if (i)\\n\"\n              \"            return true;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"bool g(const std::vector<int>& v) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return true;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            return true;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"bool g(const std::vector<int>& v) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return false;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            return true;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(std::vector<int>& v) {\\n\"\n              \"    for (auto& i : v) {\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return false;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            i++;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(const std::vector<int>& v, int& j) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return false;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            j++;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(const std::vector<int>& v, int& j) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        int& k = j;\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return false;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            k++;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(const std::vector<int>& v, int& j) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        int* k = &j;\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return false;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            (*k)++;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool g(const std::vector<int>& v, int j) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        int k = j;\\n\"\n              \"        if (i % 5 == 0)\\n\"\n              \"            return false;\\n\"\n              \"        if (i % 7 == 0)\\n\"\n              \"            k++;\\n\"\n              \"    }\\n\"\n              \"    return false;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) Consider using std::all_of or std::none_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\",\n                      errout_str());\n\n        check(\"class C {\\n\"\n              \"private:\\n\"\n              \"    QString s;\\n\"\n              \"public:\\n\"\n              \"    C(QString);\\n\"\n              \"private:\\n\"\n              \"    void f() {\\n\"\n              \"        QVERIFY(QDir(s).exists());\\n\"\n              \"    }\\n\"\n              \"    void f(const QStringList& d) {\\n\"\n              \"        for (QString f : d)\\n\"\n              \"          QDir(s);\\n\"\n              \"    }\\n\"\n              \"};\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void invalidContainer() {\n        check(\"void f(std::vector<int> &v) {\\n\"\n              \"    auto v0 = v.begin();\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << *v0 << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:1:27] -> [test.cpp:2:22] -> [test.cpp:3:7] -> [test.cpp:1:26] -> [test.cpp:4:19]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"std::string e();\\n\"\n              \"void a() {\\n\"\n              \"  std::vector<std::string> b;\\n\"\n              \"  for (std::vector<std::string>::const_iterator c; c != b.end(); ++c) {\\n\"\n              \"    std::string f = e();\\n\"\n              \"    std::string::const_iterator d = f.begin();\\n\"\n              \"    if (d != f.end()) {}\\n\"\n              \"  }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int> &v) {\\n\"\n              \"    int *v0 = &v[0];\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << (*v0)[0] << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:1:27] -> [test.cpp:2:15] -> [test.cpp:3:7] -> [test.cpp:1:26] -> [test.cpp:4:20]: (error) Using pointer to local variable 'v' that may be invalid. [invalidContainer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v = {1};\\n\"\n              \"    int &v0 = v.front();\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << v0 << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:3:13] -> [test.cpp:3:17] -> [test.cpp:4:7] -> [test.cpp:5:18]: (error) Reference to v that may be invalid. [invalidContainerReference]\\n\",\n            errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v = {1};\\n\"\n              \"    int &v0 = v[0];\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << v0 << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:13] -> [test.cpp:4:7] -> [test.cpp:5:18]: (error) Reference to v that may be invalid. [invalidContainerReference]\\n\",\n                      errout_str());\n\n        check(\"void f(std::vector<int> &v) {\\n\"\n              \"    int &v0 = v.front();\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << v0 << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:2:13] -> [test.cpp:2:17] -> [test.cpp:1:27] -> [test.cpp:3:7] -> [test.cpp:4:18]: (error) Reference to v that may be invalid. [invalidContainerReference]\\n\",\n            errout_str());\n\n        check(\"void f(std::vector<int> &v) {\\n\"\n              \"    int &v0 = v[0];\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << v0 << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:2:13] -> [test.cpp:1:27] -> [test.cpp:3:7] -> [test.cpp:4:18]: (error) Reference to v that may be invalid. [invalidContainerReference]\\n\",\n            errout_str());\n\n        check(\"void f(std::vector<int> &v) {\\n\"\n              \"    std::vector<int> *v0 = &v;\\n\"\n              \"    v.push_back(123);\\n\"\n              \"    std::cout << (*v0)[0] << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"const std::vector<int> * g(int);\\n\"\n              \"void f() {\\n\"\n              \"    const std::vector<int> *v = g(1);\\n\"\n              \"    if (v && v->size() == 1U) {\\n\"\n              \"        const int &m = v->front();\\n\"\n              \"    }\\n\"\n              \"\\n\"\n              \"    v = g(2);\\n\"\n              \"    if (v && v->size() == 1U) {\\n\"\n              \"        const int &m = v->front();\\n\"\n              \"        if (m == 0) {}\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::vector<std::string> g();\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<std::string> x = g();\\n\"\n              \"    const std::string& y = x[1];\\n\"\n              \"    std::string z;\\n\"\n              \"    z += \\\"\\\";\\n\"\n              \"    z += y;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<char> v)\\n\"\n              \"{\\n\"\n              \"    auto *cur = v.data();\\n\"\n              \"    auto *end = cur + v.size();\\n\"\n              \"    while (cur < end) {\\n\"\n              \"        v.erase(v.begin(), FindNext(v));\\n\"\n              \"        cur = v.data();\\n\"\n              \"        end = cur + v.size();\\n\"\n              \"    }\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9598\n        check(\"void f(std::vector<std::string> v) {\\n\"\n              \"    for (auto it = v.begin(); it != v.end(); it = v.erase(it))\\n\"\n              \"        *it;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9714\n        check(\"void f() {\\n\"\n              \"  auto v = std::vector<std::string>();\\n\"\n              \"  std::string x;\\n\"\n              \"  v.push_back(x.insert(0, \\\"x\\\"));\\n\"\n              \"  v.push_back(\\\"y\\\");\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9783\n        check(\"std::string GetTaskIDPerUUID(int);\\n\"\n              \"void InitializeJumpList(CString s);\\n\"\n              \"void foo() {\\n\"\n              \"    CString sAppID = GetTaskIDPerUUID(123).c_str();\\n\"\n              \"    InitializeJumpList(sAppID);\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n        // #9796\n        check(\"struct A {};\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<A *> v;\\n\"\n              \"    A *a = new A();\\n\"\n              \"    v.push_back(a);\\n\"\n              \"    A *b = v.back();\\n\"\n              \"    v.pop_back();\\n\"\n              \"    delete b;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {};\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<A *, std::allocator<A*>> v;\\n\"\n              \"    A *a = new A();\\n\"\n              \"    v.push_back(a);\\n\"\n              \"    A *b = v.back();\\n\"\n              \"    v.pop_back();\\n\"\n              \"    delete b;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {};\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<std::shared_ptr<A>> v;\\n\"\n              \"    std::shared_ptr<A> a = std::make_shared<A>();\\n\"\n              \"    v.push_back(a);\\n\"\n              \"    std::shared_ptr<A> b = v.back();\\n\"\n              \"    v.pop_back();\\n\"\n              \"    delete b;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9780\n        check(\"int f() {\\n\"\n              \"    std::vector<int> vect;\\n\"\n              \"    MyStruct info{};\\n\"\n              \"    info.vect = &vect;\\n\"\n              \"    vect.push_back(1);\\n\"\n              \"    return info.ret;\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9133\n        check(\"struct Fred {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    void foo();\\n\"\n              \"    void bar();\\n\"\n              \"};\\n\"\n              \"void Fred::foo() {\\n\"\n              \"    std::vector<int>::iterator it = v.begin();\\n\"\n              \"    bar();\\n\"\n              \"    it++;\\n\"\n              \"}\\n\"\n              \"void Fred::bar() {\\n\"\n              \"    v.push_back(0);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:7:44] -> [test.cpp:8:5] -> [test.cpp:12:7] -> [test.cpp:9:5]: (error) Using iterator to member container 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        check(\"void foo(std::vector<int>& v) {\\n\"\n              \"    std::vector<int>::iterator it = v.begin();\\n\"\n              \"    bar(v);\\n\"\n              \"    it++;\\n\"\n              \"}\\n\"\n              \"void bar(std::vector<int>& v) {\\n\"\n              \"    v.push_back(0);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:1:29] -> [test.cpp:2:44] -> [test.cpp:3:5] -> [test.cpp:7:7] -> [test.cpp:1:28] -> [test.cpp:4:5]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        // #10264\n        check(\"void f(std::vector<std::string>& x) {\\n\"\n              \"  struct I {\\n\"\n              \"    std::vector<std::string> *px{};\\n\"\n              \"  };\\n\"\n              \"  I i = { &x };\\n\"\n              \"  x.clear();\\n\"\n              \"  Parse(i);\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"  std::string x;\\n\"\n              \"  struct V {\\n\"\n              \"    std::string* pStr{};\\n\"\n              \"  };\\n\"\n              \"  struct I {\\n\"\n              \"    std::vector<V> v;\\n\"\n              \"  };\\n\"\n              \"  I b[] = {{{{ &x }}}};\\n\"\n              \"  x = \\\"Arial\\\";\\n\"\n              \"  I cb[1];\\n\"\n              \"  for (long i = 0; i < 1; ++i)\\n\"\n              \"    cb[i] = b[i];\\n\"\n              \"}\\n\",dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9836\n        check(\"void f() {\\n\"\n              \"    auto v = std::vector<std::vector<std::string> >{ std::vector<std::string>{ \\\"hello\\\" } };\\n\"\n              \"    auto p = &(v.at(0).at(0));\\n\"\n              \"    v.clear();\\n\"\n              \"    std::cout << *p << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:3:24] -> [test.cpp:3:18] -> [test.cpp:3:14] -> [test.cpp:4:7] -> [test.cpp:2:10] -> [test.cpp:5:19]: (error) Using pointer to local variable 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\"\n              \"    const std::vector<int>* i;\\n\"\n              \"    A(const std::vector<int>& v)\\n\"\n              \"    : i(&v)\\n\"\n              \"    {}\\n\"\n              \"};\\n\"\n              \"int f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    A a{v};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    return a.i->front();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    const std::vector<int>* i;\\n\"\n              \"    A(const std::vector<int>& v)\\n\"\n              \"    : i(&v)\\n\"\n              \"    {}\\n\"\n              \"};\\n\"\n              \"void g(const std::vector<int>& v);\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    A a{v};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    g(a);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #10984\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    auto g = [&v]{};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    g();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    auto g = [&]{ std::cout << *it << std::endl;};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    g();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:2:22] -> [test.cpp:3:33] -> [test.cpp:4:7] -> [test.cpp:1:25] -> [test.cpp:5:5]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    auto g = [=]{ std::cout << *it << std::endl;};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    g();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:2:22] -> [test.cpp:4:7] -> [test.cpp:1:25] -> [test.cpp:5:5]: (error) Using iterator to local container 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int* p;\\n\"\n              \"    void g();\\n\"\n              \"};\\n\"\n              \"void f(std::vector<int> v) {\\n\"\n              \"    auto it = v.begin();\\n\"\n              \"    A a{v.data()};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    a.g();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:7:15] -> [test.cpp:8:7] -> [test.cpp:5:25] -> [test.cpp:9:5]: (error) Using object that points to local variable 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        check(\"struct A {\\n\"\n              \"    int*& p;\\n\"\n              \"    void g();\\n\"\n              \"};\\n\"\n              \"void f(std::vector<int> v) {\\n\"\n              \"    auto* p = v.data();\\n\"\n              \"    A a{p};\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    a.g();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:6:21] -> [test.cpp:7:9] -> [test.cpp:8:7] -> [test.cpp:5:25] -> [test.cpp:9:5]: (error) Using object that points to local variable 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        // #11028\n        check(\"void f(std::vector<int> c) {\\n\"\n              \"    std::vector<int> d(c.begin(), c.end());\\n\"\n              \"    c.erase(c.begin());\\n\"\n              \"    d.push_back(0);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #11147\n        check(\"void f(std::string& s) {\\n\"\n              \"    if (!s.empty()) {\\n\"\n              \"        std::string::iterator it = s.begin();\\n\"\n              \"        s = s.substr(it - s.begin());\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:4:13]: (performance) Ineffective call of function 'substr' because a prefix of the string is assigned to itself. Use resize() or pop_back() instead. [uselessCallsSubstr]\\n\",\n            errout_str());\n\n        // #11630\n        check(\"int main(int argc, const char* argv[]) {\\n\"\n              \"    std::vector<std::string> args(argv + 1, argv + argc);\\n\"\n              \"    args.push_back(\\\"-h\\\");\\n\"\n              \"    args.front();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>& v) {\\n\" // #13108\n              \"    auto it = unknown(v);\\n\"\n              \"    auto w = std::vector<int>{ it, v.end() };\\n\"\n              \"    v.erase(it, v.end());\\n\"\n              \"    for (const auto& i : w) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #13410\n        check(\"int f(std::vector<int>& v) {\\n\"\n              \"    const int* i = &*v.cbegin();\\n\"\n              \"    v.push_back(1);\\n\"\n              \"    return *i;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:1:26] -> [test.cpp:2:30] -> [test.cpp:1:26] -> [test.cpp:2:20] -> [test.cpp:2:20] -> [test.cpp:3:7] -> [test.cpp:1:25] -> [test.cpp:4:13]: (error) Using pointer to local variable 'v' that may be invalid. [invalidContainer]\\n\",\n            errout_str());\n\n        // #9834\n        check(\"struct CJ {\\n\"\n              \"    std::string m_string1 = \\\"hello\\\";\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<CJ> vec1;\\n\"\n              \"    vec1.push_back(CJ());\\n\"\n              \"    auto& a_ref = vec1.at(0).m_string1;\\n\"\n              \"    vec1.clear();\\n\"\n              \"    std::cout << a_ref << std::endl;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:7:17] -> [test.cpp:7:24] -> [test.cpp:8:10] -> [test.cpp:9:18]: (error) Reference to vec1 that may be invalid. [invalidContainerReference]\\n\",\n            errout_str());\n    }\n\n    void invalidContainerLoop() {\n        // #9435\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    for (auto i : v) {\\n\"\n              \"        if (i < 5)\\n\"\n              \"            v.push_back(i * 2);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:2:5] -> [test.cpp:4:15]: (error) Calling 'push_back' while iterating the container is invalid. [invalidContainerLoop]\\n\", errout_str());\n\n        // #9713\n        check(\"void f() {\\n\"\n              \"  std::vector<int> v{1, 2, 3};\\n\"\n              \"  for (int i : v) {\\n\"\n              \"    if (i == 2) {\\n\"\n              \"      v.clear();\\n\"\n              \"      return;\\n\"\n              \"    }\\n\"\n              \"  }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:17]: (style) Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]\\n\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"  std::vector<int> v;\\n\"\n              \"  void add(int i) {\\n\"\n              \"    v.push_back(i);\\n\"\n              \"  } \\n\"\n              \"  void f() {\\n\"\n              \"    for(auto i:v)\\n\"\n              \"      add(i);\\n\"\n              \"  }\\n\"\n              \"};\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\n            \"[test.cpp:4:7] -> [test.cpp:7:5] -> [test.cpp:8:7]: (error) Calling 'add' while iterating the container is invalid. [invalidContainerLoop]\\n\",\n            errout_str());\n\n        check(\"struct S { int i; };\\n\" // #14013\n              \"void f() {\\n\"\n              \"    std::vector<std::unique_ptr<S>> v;\\n\"\n              \"    for (int i = 0; i < 5; ++i) {\\n\"\n              \"        std::unique_ptr<S>& r = v.emplace_back(std::make_unique<S>());\\n\"\n              \"        r->i = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S { int i; };\\n\"\n              \"void f() {\\n\"\n              \"    std::vector<std::unique_ptr<S>> v;\\n\"\n              \"    for (int i = 0; i < 5; ++i) {\\n\"\n              \"        std::unique_ptr<S>& r{ v.emplace_back(std::make_unique<S>()) };\\n\"\n              \"        r->i = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void findInsert() {\n        check(\"void f1(std::set<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f2(std::map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.find(x) == m.end()) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f3(std::map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f4(std::set<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f5(std::map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f6(std::map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f1(std::unordered_set<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f2(std::unordered_map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.find(x) == m.end()) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f3(std::unordered_map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f4(std::unordered_set<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:18]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f5(std::unordered_map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void f6(std::unordered_map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n\n        check(\"void g1(std::map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.find(x) == m.end()) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 2;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g1(std::map<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 2;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(QSet<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(std::multiset<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f2(std::multimap<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.find(x) == m.end()) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f3(std::multimap<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f4(std::multiset<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f5(std::multimap<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f1(std::unordered_multiset<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f2(std::unordered_multimap<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.find(x) == m.end()) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f3(std::unordered_multimap<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f4(std::unordered_multiset<unsigned>& s, unsigned x) {\\n\"\n              \"    if (s.find(x) == s.end()) {\\n\"\n              \"        s.insert(x);\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f5(std::unordered_multimap<unsigned, unsigned>& m, unsigned x) {\\n\"\n              \"    if (m.count(x) == 0) {\\n\"\n              \"        m.emplace(x, 1);\\n\"\n              \"    } else {\\n\"\n              \"        m[x] = 1;\\n\"\n              \"    }\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #9218 - not small type => do not warn if cpp standard is < c++17\n        {\n            const char code[] = \"void f1(std::set<LargeType>& s, const LargeType& x) {\\n\"\n                                \"    if (s.find(x) == s.end()) {\\n\"\n                                \"        s.insert(x);\\n\"\n                                \"    }\\n\"\n                                \"}\\n\";\n            check(code, dinit(CheckOptions, $.inconclusive = true, $.cppstandard = Standards::CPP11));\n            ASSERT_EQUALS(\"\", errout_str());\n            check(code, dinit(CheckOptions, $.inconclusive = true, $.cppstandard = Standards::CPP14));\n            ASSERT_EQUALS(\"\", errout_str());\n            check(code, dinit(CheckOptions, $.inconclusive = true, $.cppstandard = Standards::CPP17));\n            ASSERT_EQUALS(\"[test.cpp:3:18]: (performance) Searching before insertion is not necessary. [stlFindInsert]\\n\", errout_str());\n        }\n\n        { // #10558\n            check(\"void foo() {\\n\"\n                  \"   std::map<int, int> x;\\n\"\n                  \"   int data = 0;\\n\"\n                  \"   for(int i=0; i<10; ++i) {\\n\"\n                  \"      data += 123;\\n\"\n                  \"      if(x.find(5) == x.end())\\n\"\n                  \"         x[5] = data;\\n\"\n                  \"   }\\n\"\n                  \"}\", dinit(CheckOptions, $.cppstandard = Standards::CPP03));\n            ASSERT_EQUALS(\"\", errout_str());\n\n            check(\"void foo() {\\n\"\n                  \"   std::map<int, int> x;\\n\"\n                  \"   int data = 0;\\n\"\n                  \"   for(int i=0; i<10; ++i) {\\n\"\n                  \"      data += 123;\\n\"\n                  \"      if(x.find(5) == x.end())\\n\"\n                  \"         x[5] = data;\\n\"\n                  \"   }\\n\"\n                  \"}\", dinit(CheckOptions, $.cppstandard = Standards::CPP11));\n            ASSERT_EQUALS(\"[test.cpp:7:17]: (performance) Searching before insertion is not necessary. Instead of 'x[5]=data' consider using 'x.emplace(5, data);'. [stlFindInsert]\\n\", errout_str());\n\n            check(\"void foo() {\\n\"\n                  \"   std::map<int, int> x;\\n\"\n                  \"   int data = 0;\\n\"\n                  \"   for(int i=0; i<10; ++i) {\\n\"\n                  \"      data += 123;\\n\"\n                  \"      if(x.find(5) == x.end())\\n\"\n                  \"         x[5] = data;\\n\"\n                  \"   }\\n\"\n                  \"}\");\n            ASSERT_EQUALS(\"[test.cpp:7:17]: (performance) Searching before insertion is not necessary. Instead of 'x[5]=data' consider using 'x.try_emplace(5, data);'. [stlFindInsert]\\n\", errout_str());\n        }\n    }\n\n    void checkKnownEmptyContainer() {\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    for(auto x:v) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Iterating over container 'v' that is always empty. [knownEmptyContainer]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    v.clear();\\n\"\n              \"    for(auto x:v) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Iterating over container 'v' that is always empty. [knownEmptyContainer]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    if (!v.empty()) { return; }\\n\"\n              \"    for(auto x:v) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:16]: (style) Iterating over container 'v' that is always empty. [knownEmptyContainer]\\n\", errout_str());\n\n        check(\"void f(std::vector<int> v) {\\n\"\n              \"    if (v.empty()) { return; }\\n\"\n              \"    for(auto x:v) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    std::sort(v.begin(), v.end());\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (style) Using sort with iterator 'v.begin()' that is always empty. [knownEmptyContainer]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #1201\n              \"    std::vector<int> v1{ 0, 1 };\\n\"\n              \"    std::vector<int> v2;\\n\"\n              \"    std::copy(v1.begin(), v1.end(), v2.begin());\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:45]: (style) Using copy with iterator 'v2.begin()' that is always empty. [knownEmptyContainer]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    v.insert(v.end(), 1);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct A {\\n\"\n              \"    explicit A(std::vector<int>*);\\n\"\n              \"};\\n\"\n              \"A f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    A a(&v);\\n\"\n              \"    for(auto&& x:v) {}\\n\"\n              \"    return a;\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"static void f1(std::list<std::string>& parameters) {\\n\"\n              \"    parameters.push_back(a);\\n\"\n              \"}\\n\"\n              \"int f2(std::list<std::string>& parameters) {\\n\"\n              \"    f1(parameters);\\n\"\n              \"}\\n\"\n              \"void f3() {\\n\"\n              \"    std::list<std::string> parameters;\\n\"\n              \"    int res = ::f2(parameters);\\n\"\n              \"    for (auto param : parameters) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"namespace ns {\\n\"\n              \"    using ArrayType = std::vector<int>;\\n\"\n              \"}\\n\"\n              \"using namespace ns;\\n\"\n              \"static void f() {\\n\"\n              \"    const ArrayType arr;\\n\"\n              \"    for (const auto &a : arr) {}\\n\"\n              \"}\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:7:26]: (style) Iterating over container 'arr' that is always empty. [knownEmptyContainer]\\n\", errout_str());\n\n        check(\"struct S {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"};\\n\"\n              \"void foo(S& s) {\\n\"\n              \"    s.v.clear();\\n\"\n              \"    bar(s);\\n\"\n              \"    std::sort(s.v.begin(), s.v.end());\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(const std::vector<int>& v, int e) {\\n\"\n              \" if (!v.empty()) {\\n\"\n              \"     if (e < 0 || true) {\\n\"\n              \"         if (e < 0)\\n\"\n              \"             return;\\n\"\n              \"     }\\n\"\n              \" }\\n\"\n              \" for (auto i : v) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::vector<int> v;\\n\"\n              \"    auto& rv = v;\\n\"\n              \"    rv.push_back(42);\\n\"\n              \"    for (auto i : v) {}\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"extern void f(std::string&&);\\n\"\n              \"static void func() {\\n\"\n              \"    std::string s;\\n\"\n              \"    const std::string& s_ref = s;\\n\"\n              \"    f(std::move(s));\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct S {\\n\" // #12757\n              \"    template<class T = int>\\n\"\n              \"    void clear() {}\\n\"\n              \"    template<class T = int>\\n\"\n              \"    std::vector<T> get() const { return {}; }\\n\"\n              \"    std::vector<int> m;\\n\"\n              \"};\\n\"\n              \"template<> void S::clear() { m.clear(); }\\n\"\n              \"template<> std::vector<int> S::get() const {\\n\"\n              \"    for (const auto& i : m) {}\\n\"\n              \"    return {};\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(bool b) {\\n\" // #13121\n              \"    static std::string s = {};\\n\"\n              \"    for (auto c : s) {}\\n\"\n              \"    if (b)\\n\"\n              \"        s += \\'a\\';\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(std::vector<int>::iterator it) {\\n\" // #13727\n              \"    std::vector<int> v;\\n\"\n              \"    v.insert<std::vector<int>::iterator>(v.end(), it, it + 1);\\n\"\n              \"    for (auto i : v) {}\\n\"\n              \"}\\n\", dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkMutexes() {\n        check(\"void f() {\\n\"\n              \"    static std::mutex m;\\n\"\n              \"    static std::lock_guard<std::mutex> g(m);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:40]: (warning) Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program. [globalLockGuard]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static std::mutex m;\\n\"\n              \"    std::lock_guard<std::mutex> g(m);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static std::mutex m;\\n\"\n              \"    static std::unique_lock<std::mutex> g(m, std::defer_lock);\\n\"\n              \"    static std::lock(g);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:41]: (warning) Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program. [globalLockGuard]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    static std::mutex m;\\n\"\n              \"    std::unique_lock<std::mutex> g(m, std::defer_lock);\\n\"\n              \"    std::lock(g);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    std::lock_guard<std::mutex> g(m);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:33]: (warning) The lock is ineffective because the mutex is locked at the same scope as the mutex itself. [localMutex]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    std::unique_lock<std::mutex> g(m);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:34]: (warning) The lock is ineffective because the mutex is locked at the same scope as the mutex itself. [localMutex]\\n\", errout_str());\n\n        check(\"void f() {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    std::unique_lock<std::mutex> g(m, std::defer_lock);\\n\"\n              \"    std::lock(g);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:3:34]: (warning) The lock is ineffective because the mutex is locked at the same scope as the mutex itself. [localMutex]\\n\", errout_str());\n\n        check(\"void g();\\n\"\n              \"void f() {\\n\"\n              \"    static std::mutex m;\\n\"\n              \"    m.lock();\\n\"\n              \"    g();\\n\"\n              \"    m.unlock();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g();\\n\"\n              \"void f() {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    m.lock();\\n\"\n              \"    g();\\n\"\n              \"    m.unlock();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:5]: (warning) The lock is ineffective because the mutex is locked at the same scope as the mutex itself. [localMutex]\\n\", errout_str());\n\n        check(\"class A {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    void f() {\\n\"\n              \"        std::lock_guard<std::mutex> g(m);\\n\"\n              \"    }\\n\"\n              \"};\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    void g();\\n\"\n              \"    void f() {\\n\"\n              \"        m.lock();\\n\"\n              \"        g();\\n\"\n              \"        m.unlock();\\n\"\n              \"    }\\n\"\n              \"};\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"class A {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    void f() {\\n\"\n              \"        static std::lock_guard<std::mutex> g(m);\\n\"\n              \"    }\\n\"\n              \"};\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:44]: (warning) Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program. [globalLockGuard]\\n\", errout_str());\n\n        check(\"std::mutex& h();\\n\"\n              \"void f() {\\n\"\n              \"    auto& m = h();\\n\"\n              \"    std::lock_guard<std::mutex> g(m);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void g();\\n\"\n              \"std::mutex& h();\\n\"\n              \"void f() {\\n\"\n              \"    auto& m = h();\\n\"\n              \"    m.lock();\\n\"\n              \"    g();\\n\"\n              \"    m.unlock();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"std::mutex& h();\\n\"\n              \"void f() {\\n\"\n              \"    auto m = h();\\n\"\n              \"    std::lock_guard<std::mutex> g(m);\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:4:33]: (warning) The lock is ineffective because the mutex is locked at the same scope as the mutex itself. [localMutex]\\n\", errout_str());\n\n        check(\"void g();\\n\"\n              \"std::mutex& h();\\n\"\n              \"void f() {\\n\"\n              \"    auto m = h();\\n\"\n              \"    m.lock();\\n\"\n              \"    g();\\n\"\n              \"    m.unlock();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"[test.cpp:5:5]: (warning) The lock is ineffective because the mutex is locked at the same scope as the mutex itself. [localMutex]\\n\", errout_str());\n\n        check(\"void foo();\\n\"\n              \"void bar();\\n\"\n              \"void f() {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    std::thread t([&m](){\\n\"\n              \"        m.lock();\\n\"\n              \"        foo();\\n\"\n              \"        m.unlock();\\n\"\n              \"    });\\n\"\n              \"    m.lock();\\n\"\n              \"    bar();\\n\"\n              \"    m.unlock();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo();\\n\"\n              \"void bar();\\n\"\n              \"void f() {\\n\"\n              \"    std::mutex m;\\n\"\n              \"    std::thread t([&m](){\\n\"\n              \"        std::unique_lock<std::mutex> g{m};\\n\"\n              \"        foo();\\n\"\n              \"    });\\n\"\n              \"    std::unique_lock<std::mutex> g{m};\\n\"\n              \"    bar();\\n\"\n              \"}\\n\",\n              dinit(CheckOptions, $.inconclusive = true));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void foo() { int f = 0; auto g(f); g = g; }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"struct foobar {\\n\"\n              \"    int foo;\\n\"\n              \"    std::shared_mutex foo_mtx;\\n\"\n              \"    int bar;\\n\"\n              \"    std::shared_mutex bar_mtx;\\n\"\n              \"};\\n\"\n              \"void f() {\\n\"\n              \"    foobar xyz;\\n\"\n              \"    {\\n\"\n              \"        std::shared_lock shared_foo_lock(xyz.foo_mtx, std::defer_lock);\\n\"\n              \"        std::shared_lock shared_bar_lock(xyz.bar_mtx, std::defer_lock);\\n\"\n              \"        std::scoped_lock shared_multi_lock(shared_foo_lock, shared_bar_lock);\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestStl)\n"
    }
  ]
}