{
  "name": "checkIntegerOverflow",
  "language": "cpp",
  "description": null,
  "example": null,
  "cwe": null,
  "cwe-description": null,
  "checker-language": "cpp",
  "loc": 40,
  "branches": 14,
  "apis": 23,
  "test": [
    {
      "description": null,
      "expected-problems": 2,
      "expected-linenumbers": [
        275,
        580
      ],
      "code": "\n/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2025 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checktype.h\"\n#include \"errortypes.h\"\n#include \"fixture.h\"\n#include \"helpers.h\"\n#include \"platform.h\"\n#include \"settings.h\"\n#include \"standards.h\"\n\n#include <cstddef>\n#include <string>\n\nclass TestType : public TestFixture {\npublic:\n    TestType() : TestFixture(\"TestType\") {}\n\nprivate:\n\n\n    void run() override {\n        TEST_CASE(checkTooBigShift_Unix32);\n        mNewTemplate = true;\n        TEST_CASE(checkIntegerOverflow);\n        TEST_CASE(signConversion);\n        TEST_CASE(longCastAssign);\n        TEST_CASE(longCastReturn);\n        TEST_CASE(checkFloatToIntegerOverflow);\n        TEST_CASE(integerOverflow); // #11794\n        TEST_CASE(shiftTooManyBits); // #11496\n    }\n\n    struct CheckOptions\n    {\n        CheckOptions() = default;\n        const Settings* settings = nullptr;\n        Standards::cppstd_t standard = Standards::cppstd_t::CPP11;\n    };\n\n#define check(...) check_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void check_(const char* file, int line, const char (&code)[size], const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.settings ? *options.settings : settingsDefault).severity(Severity::warning).severity(Severity::portability).cpp(options.standard).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        runChecks<CheckType>(tokenizer, this);\n    }\n\n    // TODO: get rid of this\n    void check_(const char* file, int line, const std::string& code, const CheckOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.settings ? *options.settings : settingsDefault).severity(Severity::warning).severity(Severity::portability).cpp(options.standard).build();\n\n        // Tokenize..\n        SimpleTokenizer tokenizer(settings1, *this);\n        ASSERT_LOC(tokenizer.tokenize(code), file, line);\n\n        // Check..\n        runChecks<CheckType>(tokenizer, this);\n    }\n\n    struct CheckPOptions\n    {\n        CheckPOptions() = default;\n        const Settings* settings = nullptr;\n        bool cpp = true;\n    };\n\n#define checkP(...) checkP_(__FILE__, __LINE__, __VA_ARGS__)\n    template<size_t size>\n    void checkP_(const char* file, int line, const char (&code)[size], const CheckPOptions& options = make_default_obj()) {\n        const Settings settings1 = settingsBuilder(options.settings ? *options.settings : settingsDefault).severity(Severity::warning).severity(Severity::portability).build();\n\n        SimpleTokenizer2 tokenizer(settings1, *this, code, options.cpp ? \"test.cpp\" : \"test.c\");\n\n        // Tokenizer..\n        ASSERT_LOC(tokenizer.simplifyTokens1(\"\"), file, line);\n\n        // Check..\n        runChecks<CheckType>(tokenizer, this);\n    }\n\n    void checkTooBigShift_Unix32() {\n        const Settings settings = settingsBuilder().platform(Platform::Type::Unix32).build();\n\n        // unsigned types getting promoted to int sizeof(int) = 4 bytes\n        // and unsigned types having already a size of 4 bytes\n        {\n            const std::string types[] = {\"unsigned char\", /*[unsigned]*/ \"char\", \"bool\", \"unsigned short\", \"unsigned int\", \"unsigned long\"};\n            for (const std::string& type : types) {\n                check(type + \" f(\" + type +\" x) { return x << 31; }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"\", errout_str());\n                check(type + \" f(\" + type +\" x) { return x << 33; }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 32-bit value by 33 bits is undefined behaviour\\n\", errout_str());\n                check(type + \" f(int x) { return (x = (\" + type + \")x << 32); }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 32-bit value by 32 bits is undefined behaviour\\n\", errout_str());\n                check(type + \" foo(\" + type + \" x) { return x << 31; }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"\", errout_str());\n            }\n        }\n        // signed types getting promoted to int sizeof(int) = 4 bytes\n        // and signed types having already a size of 4 bytes\n        {\n            const std::string types[] = {\"signed char\", \"signed short\", /*[signed]*/ \"short\", \"wchar_t\", /*[signed]*/ \"int\", \"signed int\", /*[signed]*/ \"long\", \"signed long\"};\n            for (const std::string& type : types) {\n                // c++11\n                check(type + \" f(\" + type +\" x) { return x << 33; }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 32-bit value by 33 bits is undefined behaviour\\n\", errout_str());\n                check(type + \" f(int x) { return (x = (\" + type + \")x << 32); }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 32-bit value by 32 bits is undefined behaviour\\n\", errout_str());\n                check(type + \" foo(\" + type + \" x) { return x << 31; }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting signed 32-bit value by 31 bits is undefined behaviour\\n\", errout_str());\n                check(type + \" foo(\" + type + \" x) { return x << 30; }\", dinit(CheckOptions, $.settings = &settings));\n                ASSERT_EQUALS(\"\", errout_str());\n\n                // c++14\n                check(type + \" foo(\" + type + \" x) { return x << 31; }\", dinit(CheckOptions, $.settings = &settings, $.standard = Standards::CPP14));\n                ASSERT_EQUALS(\"[test.cpp:1]: (portability) Shifting signed 32-bit value by 31 bits is implementation-defined behaviour\\n\", errout_str());\n                check(type + \" f(int x) { return (x = (\" + type + \")x << 32); }\", dinit(CheckOptions, $.settings = &settings, $.standard = Standards::CPP14));\n                ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 32-bit value by 32 bits is undefined behaviour\\n\", errout_str());\n            }\n        }\n        // 64 bit width types\n        {\n            // unsigned long long\n            check(\"unsigned long long foo(unsigned long long x) { return x << 64; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"unsigned long long f(int x) { return (x = (unsigned long long)x << 64); }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"unsigned long long f(unsigned long long x) { return x << 63; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"\", errout_str());\n            // [signed] long long\n            check(\"long long foo(long long x) { return x << 64; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"long long f(int x) { return (x = (long long)x << 64); }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"long long f(long long x) { return x << 63; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting signed 64-bit value by 63 bits is undefined behaviour\\n\", errout_str());\n            check(\"long long f(long long x) { return x << 62; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"\", errout_str());\n            // signed long long\n            check(\"signed long long foo(signed long long x) { return x << 64; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"signed long long f(long long x) { return (x = (signed long long)x << 64); }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"signed long long f(signed long long x) { return x << 63; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting signed 64-bit value by 63 bits is undefined behaviour\\n\", errout_str());\n            check(\"signed long long f(signed long long x) { return x << 62; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"\", errout_str());\n\n            // c++14\n            check(\"signed long long foo(signed long long x) { return x << 64; }\", dinit(CheckOptions, $.settings = &settings, $.standard = Standards::CPP14));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"signed long long f(long long x) { return (x = (signed long long)x << 64); }\", dinit(CheckOptions, $.settings = &settings, $.standard = Standards::CPP14));\n            ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 64-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n            check(\"signed long long f(signed long long x) { return x << 63; }\", dinit(CheckOptions, $.settings = &settings, $.standard = Standards::CPP14));\n            ASSERT_EQUALS(\"[test.cpp:1]: (portability) Shifting signed 64-bit value by 63 bits is implementation-defined behaviour\\n\", errout_str());\n            check(\"signed long long f(signed long long x) { return x << 62; }\",dinit(CheckOptions, $.settings = &settings));\n            ASSERT_EQUALS(\"\", errout_str());\n        }\n\n        check(\"void f() { int x; x = 1 >> 64; }\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:1]: (error) Shifting 32-bit value by 64 bits is undefined behaviour\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"  QList<int> someList;\\n\"\n              \"  someList << 300;\\n\"\n              \"}\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Ticket #6793\n        check(\"template<unsigned int I> int foo(unsigned int x) { return x << I; }\\n\"\n              \"const unsigned int f = foo<31>(0);\\n\"\n              \"const unsigned int g = foo<100>(0);\\n\"\n              \"template<unsigned int I> int hoo(unsigned int x) { return x << 32; }\\n\"\n              \"const unsigned int h = hoo<100>(0);\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:4]: (error) Shifting 32-bit value by 32 bits is undefined behaviour\\n\"\n                      \"[test.cpp:1]: (error) Shifting 32-bit value by 100 bits is undefined behaviour\\n\", errout_str());\n\n        // #7266: C++, shift in macro\n        check(\"void f(unsigned int x) {\\n\"\n              \"    UINFO(x << 1234);\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // #8640\n        check(\"int f (void)\\n\"\n              \"{\\n\"\n              \"    constexpr const int a = 1;\\n\"\n              \"    constexpr const int shift[1] = {32};\\n\"\n              \"    constexpr const int ret = a << shift[0];\\n\" // shift too many bits\n              \"    return ret;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (error) Shifting 32-bit value by 32 bits is undefined behaviour\\n\"\n                      \"[test.cpp:5]: (error) Signed integer overflow for expression 'a<<shift[0]'.\\n\", errout_str());\n\n        // #8885\n        check(\"int f(int k, int rm) {\\n\"\n              \"  if (k == 32)\\n\"\n              \"    return 0;\\n\"\n              \"  if (k > 32)\\n\"\n              \"    return 0;\\n\"\n              \"  return rm>> k;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4] -> [test.cpp:6]: (warning) Shifting signed 32-bit value by 31 bits is undefined behaviour. See condition at line 4.\\n\",\n            errout_str());\n\n        check(\"int f(int k, int rm) {\\n\"\n              \"  if (k == 0 || k == 32)\\n\"\n              \"    return 0;\\n\"\n              \"  else if (k > 32)\\n\"\n              \"    return 0;\\n\"\n              \"  else\\n\"\n              \"    return rm>> k;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4] -> [test.cpp:7]: (warning) Shifting signed 32-bit value by 31 bits is undefined behaviour. See condition at line 4.\\n\",\n            errout_str());\n\n        check(\"int f(int k, int rm) {\\n\"\n              \"  if (k == 0 || k == 32 || k == 31)\\n\"\n              \"    return 0;\\n\"\n              \"  else if (k > 32)\\n\"\n              \"    return 0;\\n\"\n              \"  else\\n\"\n              \"    return rm>> k;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"static long long f(int x, long long y) {\\n\"\n              \"    if (x >= 64)\\n\"\n              \"        return 0;\\n\"\n              \"    return -(y << (x-1));\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"bool f() {\\n\"\n              \"    std::ofstream outfile;\\n\"\n              \"    outfile << vec_points[0](0) << static_cast<int>(d) << ' ';\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"void f(unsigned b, int len, unsigned char rem) {\\n\" // #10773\n              \"    int bits = 0;\\n\"\n              \"    while (len > 8) {\\n\"\n              \"        b = b >> rem;\\n\"\n              \"        bits += 8 - rem;\\n\"\n              \"        if (bits == 512)\\n\"\n              \"            len -= 8;\\n\"\n              \"    }\\n\"\n              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void checkIntegerOverflow() {\n        const Settings settings = settingsBuilder().severity(Severity::warning).platform(Platform::Type::Unix32).build();\n\n        check(\"x = (int)0x10000 * (int)0x10000;\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:1:18]: (error) Signed integer overflow for expression '(int)0x10000*(int)0x10000'. [integerOverflow]\\n\", errout_str());\n\n        check(\"x = (long)0x10000 * (long)0x10000;\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:1:19]: (error) Signed integer overflow for expression '(long)0x10000*(long)0x10000'. [integerOverflow]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int intmax = 0x7fffffff;\\n\"\n              \"    return intmax + 1;\\n\"\n              \"}\",dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:3:19]: (error) Signed integer overflow for expression 'intmax+1'. [integerOverflow]\\n\", errout_str());\n\n        check(\"void foo() {\\n\"\n              \"    int intmax = 0x7fffffff;\\n\"\n              \"    return intmax - 1;\\n\"\n              \"}\",dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int foo(signed int x) {\\n\"\n              \"   if (x==123456) {}\\n\"\n              \"   return x * x;\\n\"\n              \"}\",dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:13]: (warning) Either the condition 'x==123456' is redundant or there is signed integer overflow for expression 'x*x'. [integerOverflowCond]\\n\", errout_str());\n\n        check(\"int foo(signed int x) {\\n\"\n              \"   if (x==123456) {}\\n\"\n              \"   return -123456 * x;\\n\"\n              \"}\",dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:9] -> [test.cpp:3:19]: (warning) Either the condition 'x==123456' is redundant or there is signed integer underflow for expression '-123456*x'. [integerOverflowCond]\\n\", errout_str());\n\n        check(\"int foo(signed int x) {\\n\"\n              \"   if (x==123456) {}\\n\"\n              \"   return 123456U * x;\\n\"\n              \"}\",dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"int f(int i) {\\n\" // #12117\n              \"    return (i == 31) ? 1 << i : 0;\\n\"\n              \"}\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:15] -> [test.cpp:2:26]: (warning) Shifting signed 32-bit value by 31 bits is undefined behaviour. See condition at line 2. [shiftTooManyBitsSigned]\\n\", errout_str());\n\n        check(\"void f() {\\n\" // #13092\n              \"    int n = 0;\\n\"\n              \"    for (int i = 0; i < 10; i++) {\\n\"\n              \"        n = n * 47163 - 57412;\\n\"\n              \"    }\\n\"\n              \"}\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:4:15]: (error) Signed integer underflow for expression 'n*47163'. [integerOverflow]\\n\"\n                      \"[test.cpp:4:23]: (error) Signed integer underflow for expression 'n*47163-57412'. [integerOverflow]\\n\",\n                      errout_str());\n    }\n\n    void signConversion() {\n        const Settings settings = settingsBuilder().platform(Platform::Type::Unix64).build();\n        check(\"x = -4 * (unsigned)y;\");\n        ASSERT_EQUALS(\"[test.cpp:1:6]: (warning) Expression '-4' has a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversion]\\n\", errout_str());\n\n        check(\"x = (unsigned)y * -4;\");\n        ASSERT_EQUALS(\"[test.cpp:1:20]: (warning) Expression '-4' has a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversion]\\n\", errout_str());\n\n        check(\"unsigned int dostuff(int x) {\\n\" // x is signed\n              \"  if (x==0) {}\\n\"\n              \"  return (x-1)*sizeof(int);\\n\"\n              \"}\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:8] -> [test.cpp:3:12]: (warning) Expression 'x-1' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversionCond]\\n\", errout_str());\n\n        check(\"unsigned int f1(signed int x, unsigned int y) {\" // x is signed\n              \"  return x * y;\\n\"\n              \"}\\n\"\n              \"void f2() { f1(-4,4); }\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:57]: (warning) Expression 'x' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversion]\\n\",\n            errout_str());\n\n        check(\"unsigned int f1(int x) {\"\n              \"  return x * 5U;\\n\"\n              \"}\\n\"\n              \"void f2() { f1(-4); }\");\n        ASSERT_EQUALS(\n            \"[test.cpp:1:34]: (warning) Expression 'x' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversion]\\n\",\n            errout_str());\n\n        check(\"unsigned int f1(int x) {\" // #6168: FP for inner calculation\n              \"  return 5U * (1234 - x);\\n\" // <- signed subtraction, x is not sign converted\n              \"}\\n\"\n              \"void f2() { f1(-4); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // Don't warn for + and -\n        check(\"void f1(int x) {\"\n              \"  a = x + 5U;\\n\"\n              \"}\\n\"\n              \"void f2() { f1(-4); }\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"size_t foo(size_t x) {\\n\"\n              \" return -2 * x;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (warning) Expression '-2' has a negative value. That is converted to an unsigned value and used in an unsigned calculation. [signConversion]\\n\", errout_str());\n\n        checkP(\"void f() {\\n\" // #12110 FP signConversion with integer overflow\n               \"    if (LLONG_MIN / (-1)) {}\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void longCastAssign() {\n        const Settings settings = settingsBuilder().severity(Severity::style).platform(Platform::Type::Unix64).build();\n        const Settings settingsWin = settingsBuilder().severity(Severity::style).platform(Platform::Type::Win64).build();\n\n        const char code[] = \"long f(int x, int y) {\\n\"\n                            \"  const long ret = x * y;\\n\"\n                            \"  return ret;\\n\"\n                            \"}\\n\";\n        check(code, dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:18]: (style) int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information. [truncLongCastAssignment]\\n\", errout_str());\n        check(code, dinit(CheckOptions, $.settings = &settingsWin));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"long f(int x, int y) {\\n\"\n              \"  long ret = x * y;\\n\"\n              \"  return ret;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:12]: (style) int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information. [truncLongCastAssignment]\\n\", errout_str());\n\n        check(\"long f() {\\n\"\n              \"  const long long ret = 256 * (1 << 10);\\n\"\n              \"  return ret;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // typedef\n        check(\"long f(int x, int y) {\\n\"\n              \"  const size_t ret = x * y;\\n\"\n              \"  return ret;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        // astIsIntResult\n        check(\"long f(int x, int y) {\\n\"\n              \"  const long ret = (long)x * y;\\n\"\n              \"  return ret;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"double g(float f) {\\n\"\n              \"    return f * f;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:5]: (style) float result is returned as double value. If the return value is double to avoid loss of information, then you have loss of information. [truncLongCastReturn]\\n\",\n                      errout_str());\n\n        check(\"void f(int* p) {\\n\" // #11862\n              \"    long long j = *(p++);\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check(\"template <class T>\\n\" // #12393\n              \"struct S {\\n\"\n              \"    S& operator=(const S&) { return *this; }\\n\"\n              \"    struct U {\\n\"\n              \"        S<T>* p;\\n\"\n              \"    };\\n\"\n              \"    U u;\\n\"\n              \"};\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"\", errout_str()); // don't crash\n\n        check(\"void f(long& r, long i) {\\n\"\n              \"    r = 1 << i;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settingsWin));\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n\n    void longCastReturn() {\n        const Settings settings = settingsBuilder().severity(Severity::style).platform(Platform::Type::Unix64).build();\n        const Settings settingsWin = settingsBuilder().severity(Severity::style).platform(Platform::Type::Win64).build();\n\n        const char code[] = \"long f(int x, int y) {\\n\"\n                            \"  return x * y;\\n\"\n                            \"}\\n\";\n        check(code, dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (style) int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information. [truncLongCastReturn]\\n\", errout_str());\n        check(code, dinit(CheckOptions, $.settings = &settingsWin));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        const char code2[] = \"long long f(int x, int y) {\\n\"\n                             \"  return x * y;\\n\"\n                             \"}\\n\";\n        check(code2, dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (style) int result is returned as long long value. If the return value is long long to avoid loss of information, then you have loss of information. [truncLongCastReturn]\\n\", errout_str());\n        check(code2, dinit(CheckOptions, $.settings = &settingsWin));\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (style) int result is returned as long long value. If the return value is long long to avoid loss of information, then you have loss of information. [truncLongCastReturn]\\n\", errout_str());\n\n        // typedef\n        check(\"size_t f(int x, int y) {\\n\"\n              \"  return x * y;\\n\"\n              \"}\\n\", dinit(CheckOptions, $.settings = &settings));\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (style) int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information. [truncLongCastReturn]\\n\", errout_str());\n    }\n\n    // This function ensure that test works with different compilers. Floats can\n    // be stringified differently.\n    static std::string removeFloat(const std::string& msg) {\n        const std::string::size_type pos1 = msg.find(\"float (\");\n        const std::string::size_type pos2 = msg.find(\") to integer conversion\");\n        if (pos1 == std::string::npos || pos2 == std::string::npos || pos1 > pos2)\n            return msg;\n        return msg.substr(0,pos1+7) + msg.substr(pos2);\n    }\n\n    void checkFloatToIntegerOverflow() {\n        check(\"x = (int)1E100;\");\n        ASSERT_EQUALS(\"[test.cpp:1:5]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check(\"void f(void) {\\n\"\n              \"  return (int)1E100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check(\"void f(void) {\\n\"\n              \"  return (int)-1E100;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check(\"void f(void) {\\n\"\n              \"  return (short)1E6;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check(\"void f(void) {\\n\"\n              \"  return (unsigned char)256.0;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check(\"void f(void) {\\n\"\n              \"  return (unsigned char)255.5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"\", removeFloat(errout_str()));\n\n        check(\"void f(void) {\\n\"\n              \"  char c = 1234.5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:10]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check(\"char f(void) {\\n\"\n              \"  return 1234.5;\\n\"\n              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2:3]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        checkP(\"#define TEST(b, f) b ? 5000 : (unsigned short)f\\n\" // #11685\n               \"void f()\\n\"\n               \"{\\n\"\n               \"    unsigned short u = TEST(true, 75000.0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define TEST(b, f) b ? 5000 : (unsigned short)f\\n\"\n               \"void f()\\n\"\n               \"{\\n\"\n               \"    unsigned short u = TEST(false, 75000.0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:4:24]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check( \"bool f(unsigned short x);\\n\"\n               \"bool g() {\\n\"\n               \"    return false && f((unsigned short)75000.0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check( \"bool f(unsigned short x);\\n\"\n               \"bool g() {\\n\"\n               \"    return true && f((unsigned short)75000.0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:22]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        check( \"bool f(unsigned short x);\\n\"\n               \"bool g() {\\n\"\n               \"    return true || f((unsigned short)75000.0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n\n        check( \"bool f(unsigned short x);\\n\"\n               \"bool g() {\\n\"\n               \"    return false || f((unsigned short)75000.0);\\n\"\n               \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3:23]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n        checkP(\"#define TEST(b, f) b ? 5000 : (unsigned short)f\\n\" // #11685\n               \"void f()\\n\"\n               \"{\\n\"\n               \"    unsigned short u = TEST(true, 75000.0);\\n\"\n               \"}\\n\", dinit(CheckPOptions, $.cpp = false));\n        ASSERT_EQUALS(\"\", errout_str());\n\n        checkP(\"#define TEST(b, f) b ? 5000 : (unsigned short)f\\n\"\n               \"void f()\\n\"\n               \"{\\n\"\n               \"    unsigned short u = TEST(false, 75000.0);\\n\"\n               \"}\\n\", dinit(CheckPOptions, $.cpp = false));\n        ASSERT_EQUALS(\"[test.c:4:24]: (error) Undefined behaviour: float () to integer conversion overflow. [floatConversionOverflow]\\n\", removeFloat(errout_str()));\n\n    }\n\n    void integerOverflow() { // #11794\n        // std.cfg for int32_t\n        // Platform::Unix32 for INT_MIN=-2147483648 and INT32_MAX=2147483647\n        const Settings s = settingsBuilder().library(\"std.cfg\").cpp(Standards::CPP11).platform(Platform::Unix32).build();\n\n        checkP(\"int fun(int x)\\n\"\n               \"{\\n\"\n               \"  if(x < 0) x = -x;\\n\"\n               \"  return x >= 0;\\n\"\n               \"}\\n\"\n               \"int f()\\n\"\n               \"{\\n\"\n               \"    fun(INT_MIN);\\n\"\n               \"}\", dinit(CheckPOptions, $.settings = &s));\n        ASSERT_EQUALS(\"[test.cpp:3:17]: (error) Signed integer overflow for expression '-x'. [integerOverflow]\\n\", errout_str());\n\n        checkP(\"void f() {\\n\" // #8399\n               \"    int32_t i = INT32_MAX;\\n\"\n               \"    i << 1;\\n\"\n               \"    i << 2;\\n\"\n               \"}\", dinit(CheckPOptions, $.settings = &s));\n        ASSERT_EQUALS(\"[test.cpp:4:7]: (error) Signed integer overflow for expression 'i<<2'. [integerOverflow]\\n\", errout_str());\n    }\n\n    void shiftTooManyBits() { // #11496\n        check(\"template<unsigned int width> struct B {\\n\"\n              \"    unsigned long long f(unsigned int n) const {\\n\"\n              \"        if (width == 1)\\n\"\n              \"            return 1ULL << width;\\n\"\n              \"        return 0;\\n\"\n              \"    }\\n\"\n              \"};\\n\"\n              \"static B<64> b;\\n\");\n        ASSERT_EQUALS(\"\", errout_str());\n    }\n};\n\nREGISTER_TEST(TestType)\n"
    }
  ]
}